var LMV;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./extensions/CompGeom/fuzzy-math.js":
/*!*******************************************!*\
  !*** ./extensions/CompGeom/fuzzy-math.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TOL: () => (/* binding */ TOL),
/* harmony export */   isEqual: () => (/* binding */ isEqual),
/* harmony export */   isZero: () => (/* binding */ isZero)
/* harmony export */ });

const TOL = 1e-6;

function isZero(f) {
  return Math.abs(f) < TOL;
}

function isEqual(a, b) {
  return isZero(a - b);
}

/***/ }),

/***/ "./extensions/CompGeom/point-list-3d.js":
/*!**********************************************!*\
  !*** ./extensions/CompGeom/point-list-3d.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UniquePointList3D: () => (/* binding */ UniquePointList3D)
/* harmony export */ });
/* harmony import */ var _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fuzzy-math */ "./extensions/CompGeom/fuzzy-math.js");



const _tmp = {
  x: 0,
  y: 0,
  z: 0
};

class UniquePointList3D {

  constructor(getVertex, bbox, precisionTolerance) {

    this.getVertex = getVertex;
    this.bbox = bbox;
    this.boxSize = this.bbox.getSize().length();

    if (!precisionTolerance) {
      precisionTolerance = _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__.TOL;
    }
    if (precisionTolerance > 0) {
      //Input is in model units, e.g. if model is in feet,
      //precision tolerance has to be in feet
      this.precisionTolerance = precisionTolerance;
      this.scale = 1.0 / this.precisionTolerance;
    } else {
      //If negative, input precision is treated as relative to bounding box size
      this.precisionTolerance = -precisionTolerance * this.boxSize;
      this.scale = 1.0 / this.precisionTolerance;
    }

    this.snapBaseX = this.bbox.min.x; ///- 0.5 * this.precisionTolerance;
    this.snapBaseY = this.bbox.min.y; //- 0.5 * this.precisionTolerance;
    this.snapBaseZ = this.bbox.min.z; //- 0.5 * this.precisionTolerance;

    this.xymap = {};
  }

  findOrAddPoint(px, py, pz, id) {

    //Snap the vertex to our desired granularity
    let x = 0 | /*Math.round*/(px - this.snapBaseX) * this.scale;
    let y = 0 | /*Math.round*/(py - this.snapBaseY) * this.scale;
    let z = 0 | /*Math.round*/(pz - this.snapBaseZ) * this.scale;

    //Find the nearest snapped vertex or create new
    let v;
    let minDist = Infinity;
    //Look in the 27 cube area surrounding the vertex
    for (let i = x - 1; i <= x + 1; i++) {
      let mx = this.xymap[i];
      if (!mx)
      continue;

      for (let j = y - 1; j <= y + 1; j++) {
        let my = mx[j];
        if (!my)
        continue;

        for (let k = z - 1; k <= z + 1; k++) {

          let tmpi = my[k];
          if (tmpi === undefined)
          continue;

          this.getVertex(tmpi, _tmp);
          let tmp = _tmp;
          let dist = (tmp.x - px) * (tmp.x - px) + (tmp.y - py) * (tmp.y - py) + (tmp.z - pz) * (tmp.z - pz);

          if (dist < minDist) {
            v = tmpi;
            minDist = dist;
          }
        }
      }
    }

    if (Math.sqrt(minDist) > this.precisionTolerance)
    v = undefined;

    if (v === undefined) {
      let mx = this.xymap[x];
      if (!mx) {
        mx = this.xymap[x] = {};
      }

      let my = mx[y];
      if (!my) {
        my = mx[y] = {};
      }

      my[z] = id;
      return id;
    } else {
      return v;
    }
  }
}

/***/ }),

/***/ "./src/analytics/index.js":
/*!********************************!*\
  !*** ./src/analytics/index.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   analytics: () => (/* binding */ instance)
/* harmony export */ });
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger/Logger */ "./src/logger/Logger.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interface */ "./src/analytics/interface.js");



class ViewerAnalytics {
  constructor() {
    // map of providerName : class, for e.g., 'mixpanel' : Mixpanel
    this.providerMap = {};
    this.instances = [];
    this.superProps = {}; // properties that are sent with every track request
    this.shouldTrack = true;

    this.trackCache = []; // to store track calls until the first instance is created
    this.oneTimers = {}; // Events that should get tracked only once per viewer session.
  }

  /**
   * Register an analytics provider class
   * @param {object} PClass - Provider class of type AnalyticsProviderInterface
   */
  registerProvider(PClass) {
    if (!PClass) {
      _logger_Logger__WEBPACK_IMPORTED_MODULE_0__.logger.error('Undefined provider');
      return;
    }
    if (!PClass.name) {
      _logger_Logger__WEBPACK_IMPORTED_MODULE_0__.logger.error('missing provider name');
      return;
    }
    const n = PClass.name.toLowerCase();
    if (this.isProviderRegistered(n)) {
      _logger_Logger__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Provider with name ${PClass.name} already registered`);
    } else {
      this.providerMap[n] = PClass;
    }

    // create and initialize default instance
    const defaultInstance = this.createInstance(PClass.name, PClass.defaultOptions);
    this.instances.push(defaultInstance);
    if (this.shouldTrack) {
      this.init(defaultInstance);
    }

    // track data cached before the first instance was created
    if (this.trackCache.length > 0) {
      this.trackCache.forEach((_ref) => {let { event, properties } = _ref;
        this.track(event, properties);
      });
      this.trackCache = []; // clear
    }
  }

  /**
   * Returns if a ProviderClass with its name was already registered.
   * @param {object|string} PClassOrPClassName - ProviderClass object or its name
   * @returns True, if already registered.
   */
  isProviderRegistered(PClassOrPClassName) {var _PClassOrPClassName$n;
    const n = typeof PClassOrPClassName === 'string' ? PClassOrPClassName : (_PClassOrPClassName$n = PClassOrPClassName.name) === null || _PClassOrPClassName$n === void 0 ? void 0 : _PClassOrPClassName$n.toLowerCase();
    return n in this.providerMap;
  }

  init(providerInstance) {
    if (!providerInstance.initialized) {
      providerInstance.init();
      providerInstance.register(this.superProps);
    }
  }

  createInstance(providerName, options) {
    const pname = providerName && providerName.toLowerCase();
    if (!(pname in this.providerMap)) {
      _logger_Logger__WEBPACK_IMPORTED_MODULE_0__.logger.error(`Unknown ${providerName}`);
      return;
    }

    const PClass = this.providerMap[pname];
    const instance = new PClass(options);
    if (!(instance instanceof _interface__WEBPACK_IMPORTED_MODULE_1__.AnalyticsProviderInterface)) {
      throw new Error('not an analytics provider');
    }

    // instance name
    PClass.instanceCount = PClass.instanceCount || 0;
    instance.name = `${pname}-${PClass.instanceCount}`; // for e.g., mixpanel-0
    PClass.instanceCount++;
    return instance;
  }

  optIn(options) {
    this.instances.forEach((i) => this.init(i));
    this._callMethod('optIn', options);
    this.shouldTrack = true;
  }

  optOut(options) {
    this._callMethod('optOut', options);
    this.shouldTrack = false;
  }

  hasOptedOut() {
    return this._callMethod('hasOptedOut');
  }

  getDistinctId() {
    return this._callMethod('getDistinctId');
  }

  track(event, properties, isOneTimer) {
    if (!this.shouldTrack) {
      return;
    }

    // In case this event is a one-timer, make sure to track it only once per viewer session.
    if (isOneTimer) {
      const eventWithProps = { event, properties };

      try {
        const key = JSON.stringify(eventWithProps);

        // Event was already tracked before - skip it.
        if (this.oneTimers[key]) {
          return;
        }

        this.oneTimers[key] = true;
      } catch (_) {


        // Unable to stringify event (probably because of a circular dependency - shouldn't happen anyway).
        // Don't crash because of it - just ignore isOneTimer flag for this one.
      }}
    if (this.instances.length === 0) {
      this.trackCache.push({ event, properties });
    } else {
      this._callMethod('track', event, properties);
    }
  }

  identify(distinctId) {
    this._callMethod('identify', distinctId);
  }

  _callMethod() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
    const methodName = args[0];
    const rest = args.slice(1, args.length);
    return this.instances.map((inst) => ({
      name: inst.name,
      value: inst[methodName](...rest)
    }));
  }
}

const instance = new ViewerAnalytics();


/***/ }),

/***/ "./src/analytics/interface.js":
/*!************************************!*\
  !*** ./src/analytics/interface.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnalyticsProviderInterface: () => (/* binding */ AnalyticsProviderInterface)
/* harmony export */ });
class AnalyticsProviderInterface {
  constructor() {let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.options = options;
  }
  /**
   * Called by ViewerAnalytics to initialize the provider library
   */
  init() {}

  /**
   * Called after init. This could be used to register super properties
   */
  register() {}
  static get name() {return null;} // to be overridden
  static get defaultOptions() {return {};} // to be overridden
  optIn(options) {}
  optOut(options) {}
  hasOptedOut() {}
  getDistinctId() {}
  track(event, properties) {}
  identify(distinctId) {}
}

/***/ }),

/***/ "./src/compat.js":
/*!***********************!*\
  !*** ./src/compat.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectAssign: () => (/* binding */ ObjectAssign),
/* harmony export */   disableDocumentTouchSafari: () => (/* binding */ disableDocumentTouchSafari),
/* harmony export */   enableDocumentTouchSafari: () => (/* binding */ enableDocumentTouchSafari),
/* harmony export */   exitFullscreen: () => (/* binding */ exitFullscreen),
/* harmony export */   fullscreenElement: () => (/* binding */ fullscreenElement),
/* harmony export */   getAndroidVersion: () => (/* binding */ getAndroidVersion),
/* harmony export */   getGlobal: () => (/* reexport safe */ _global__WEBPACK_IMPORTED_MODULE_0__.getGlobal),
/* harmony export */   getIOSVersion: () => (/* binding */ getIOSVersion),
/* harmony export */   inFullscreen: () => (/* binding */ inFullscreen),
/* harmony export */   isAndroidDevice: () => (/* binding */ isAndroidDevice),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   isChrome: () => (/* binding */ isChrome),
/* harmony export */   isFirefox: () => (/* binding */ isFirefox),
/* harmony export */   isFullscreenAvailable: () => (/* binding */ isFullscreenAvailable),
/* harmony export */   isFullscreenEnabled: () => (/* binding */ isFullscreenEnabled),
/* harmony export */   isIE11: () => (/* binding */ isIE11),
/* harmony export */   isIE11Only: () => (/* binding */ isIE11Only),
/* harmony export */   isIOSDevice: () => (/* binding */ isIOSDevice),
/* harmony export */   isMac: () => (/* binding */ isMac),
/* harmony export */   isMobileDevice: () => (/* binding */ isMobileDevice),
/* harmony export */   isNodeJS: () => (/* binding */ isNodeJS),
/* harmony export */   isPhoneFormFactor: () => (/* binding */ isPhoneFormFactor),
/* harmony export */   isSafari: () => (/* binding */ isSafari),
/* harmony export */   isTouchDevice: () => (/* binding */ isTouchDevice),
/* harmony export */   isWindows: () => (/* binding */ isWindows),
/* harmony export */   launchFullscreen: () => (/* binding */ launchFullscreen),
/* harmony export */   touchStartToClick: () => (/* binding */ touchStartToClick)
/* harmony export */ });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global */ "./src/global.js");
var _navigator$platform;


const _window = (0,_global__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
const _document = _window && _window.document;



const isBrowser = typeof navigator !== "undefined";

const isNodeJS = function () {
  return !isBrowser;
};

let isIE11 = isBrowser && !!navigator.userAgent.match(/Edge|Trident\/7\./);

// Although the naming is misleading, isIE11 contains Edge too for some legacy reason.
// For backward compatibility, instead of renaming `isIE11` to `isIEOrEdge`, I just added `isIE11Only`.
let isIE11Only = isBrowser && !!navigator.userAgent.match(/Trident\/7\./);

// fix IE events
if (typeof window !== "undefined" && isIE11) {
  (function () {
    function CustomEvent(event, params) {
      params = params || { bubbles: false, cancelable: false, detail: undefined };
      var evt = _document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    }

    CustomEvent.prototype = _window.CustomEvent.prototype;

    _window.CustomEvent = CustomEvent;
  })();
}

// IE does not implement ArrayBuffer slice. Handy!
if (!ArrayBuffer.prototype.slice) {
  ArrayBuffer.prototype.slice = function (start, end) {
    // Normalize start/end values
    if (!end || end > this.byteLength) {
      end = this.byteLength;
    } else
    if (end < 0) {
      end = this.byteLength + end;
      if (end < 0) end = 0;
    }
    if (start < 0) {
      start = this.byteLength + start;
      if (start < 0) start = 0;
    }

    if (end <= start) {
      return new ArrayBuffer();
    }

    // Bytewise copy- this will not be fast, but what choice do we have?
    var len = end - start;
    var view = new Uint8Array(this, start, len);
    var out = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
      out[i] = view[i];
    }
    return out.buffer;
  };
}

// IE doesn't implement Math.log2
(function () {
  Math.log2 = Math.log2 || function (x) {
    return Math.log(x) / Math.LN2;
  };
})();

//The BlobBuilder object
if (typeof window !== "undefined")
_window.BlobBuilder = _window.BlobBuilder || _window.WebKitBlobBuilder || _window.MozBlobBuilder || _window.MSBlobBuilder;


// Launch full screen on the given element with the available method
function launchFullscreen(element, options) {
  if (element.requestFullscreen) {
    element.requestFullscreen(options);
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen(options);
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen(options);
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen(options);
  }
};

// Exit full screen with the available method
function exitFullscreen(_document) {
  if (!inFullscreen(_document)) {
    return;
  }
  if (_document.exitFullscreen) {
    _document.exitFullscreen();
  } else if (_document.mozCancelFullScreen) {
    _document.mozCancelFullScreen();
  } else if (_document.webkitExitFullscreen) {
    _document.webkitExitFullscreen();
  } else if (_document.msExitFullscreen) {
    _document.msExitFullscreen();
  }
};

// Determines if the browser is in full screen
function inFullscreen(_document) {

  // Special case for Ms-Edge that has webkitIsFullScreen with correct value
  // and fullscreenEnabled with wrong value (thanks MS)

  if ("webkitIsFullScreen" in _document) return !!_document.webkitIsFullScreen;
  if ("fullscreenElement" in _document) return !!_document.fullscreenElement;
  if ("mozFullScreenElement" in _document) return !!_document.mozFullScreenElement;
  if ("msFullscreenElement" in _document) return !!_document.msFullscreenElement;

  return !!_document.querySelector(".viewer-fill-browser"); // Fallback for iPad
};

function fullscreenElement(_document) {
  return _document.fullscreenElement || _document.mozFullScreenElement || _document.webkitFullscreenElement || _document.msFullscreenElement;
};

function isFullscreenAvailable(element) {
  return element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.msRequestFullscreen;
};

/**
 * Returns true if full screen mode is enabled. 
 * @param {Document} _document
 * @return {Boolean} - true if full screen mode is enabled false otherwise.
 */
function isFullscreenEnabled(_document) {
  return (
    _document.fullscreenEnabled ||
    _document.webkitFullscreenEnabled ||
    _document.mozFullScreenEnabled ||
    _document.msFullscreenEnabled);

}

// Get the IOS version through user agent.
// Return the version string of IOS, e.g. 14.1.1, 15.4 ... or empty string if version couldn't be detected
// User agents can be changed and thus might be inaccurate or incompatible at some point, but this pattern
// has been stable at least since IOS 5
function getIOSVersion(ua) {
  ua = ua || navigator.userAgent;
  var match = ua.match(/OS ((\d+)_(\d+)(_(\d+))?) like Mac OS X/);
  if (!match && isIOSDevice()) {
    // On IPadOS Safari requests the desktop version by default with a MacOS user.
    // The major version seems to be reliable, but the minor version might be incorrect.
    match = ua.match(/\/((\d+)\.(\d+)(\.\d)?) Safari\//);
  }

  return match ? match[1].replace('_', '.') : "";
};

// Get the version of the android device through user agent.
// Return the version string of android device, e.g. 4.4, 5.0...
function getAndroidVersion(ua) {
  ua = ua || navigator.userAgent;
  var match = ua.match(/Android\s([0-9\.]*)/);
  return match ? match[1] : false;
};

// Determine if this is a touch or notouch device.
function isTouchDevice() {
  /*
  // Temporarily disable touch support through hammer on Android 5, to debug
  // some specific gesture issue with Chromium WebView when loading viewer3D.js.
  if (parseInt(getAndroidVersion()) == 5) {
      return false;
  }
  */

  return typeof window !== 'undefined' && ('ontouchstart' in window || navigator.maxTouchPoints > 0);
};

// Since iOS 13, the iPad identifies itself as a desktop, so the only way to reliably detect is to search for multitouch capabilities
// (insofar as no other Apple device implements it)
// It also returns different values in a worker so we need to look in the platform as well to distinguish from a regular Mac
const _isIOSDevice = isBrowser && (/ip(ad|hone|od)/.test(navigator.userAgent.toLowerCase()) ||
navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 ||
/^ip(ad|hone|od)$/.test((_navigator$platform = navigator.platform) === null || _navigator$platform === void 0 ? void 0 : _navigator$platform.toLowerCase()));
function isIOSDevice() {
  return _isIOSDevice;
}

const _isAndroidDevice = isBrowser && navigator.userAgent.toLowerCase().indexOf('android') !== -1;
function isAndroidDevice() {
  return _isAndroidDevice;
}

function isMobileDevice() {
  if (!isBrowser) return false;
  return isIOSDevice() || isAndroidDevice();
};

function isPhoneFormFactor() {
  return (
    isMobileDevice() && (
    _window.matchMedia('(max-width: 750px)').matches || _window.matchMedia('(max-height: 750px)').matches));

}

function isSafari() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("safari") !== -1 && _ua.indexOf("chrome") === -1;
};

function isFirefox() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("firefox") !== -1;
};

function isChrome() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("chrome") !== -1;
};

function isMac() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("mac os") !== -1 && !isIOSDevice();
};

function isWindows() {
  if (!isBrowser) return false;
  var _ua = navigator.userAgent.toLowerCase();
  return _ua.indexOf("win32") !== -1 || _ua.indexOf("windows") !== -1;
};

function ObjectAssign(des, src) {
  for (var key in src) {
    if (src.hasOwnProperty(key))
    des[key] = src[key];
  }
  return des;
};

// Hack to work around Safari's use of pinch and pan inside the viewer canvas.
function disableTouchSafari(event) {
  var xOff = _window.hasOwnProperty("pageXOffset") ? _window.pageXOffset : _document.documentElement.scrollLeft;
  var yOff = _window.hasOwnProperty("pageYOffset") ? _window.pageYOffset : _document.documentElement.scrollTop;

  // event.pageX and event.pageY returned undefined through Chrome console device mode
  var pageX = typeof event.pageX === "undefined" ? event.changedTouches[0].pageX : event.pageX;
  var pageY = typeof event.pageY === "undefined" ? event.changedTouches[0].pageY : event.pageY;

  // If we aren't inside the canvas, then allow default propagation of the event
  var element = _document.elementFromPoint(pageX - xOff, pageY - yOff);
  if (!element || element.nodeName !== 'CANVAS')
  return true;
  // If it's a CANVAS, check that it's owned by us
  if (element.getAttribute('data-viewer-canvas') !== 'true')
  return true;
  // Inside the canvas, prevent the event from propagating to Safari'safely
  // standard handlers, which will pan and zoom the page.
  event.preventDefault();
  return false;
}

// Hack to work around Safari's use of pinch and pan inside the viewer canvas.
function disableDocumentTouchSafari() {
  if (isMobileDevice() && isSafari()) {
    // Safari mobile disable default touch handling inside viewer canvas
    // Use capture to make sure Safari doesn't capture the touches and prevent
    // us from disabling them.
    _document.documentElement.addEventListener('touchstart', disableTouchSafari, true);
    _document.documentElement.addEventListener('touchmove', disableTouchSafari, true);
    _document.documentElement.addEventListener('touchcanceled', disableTouchSafari, true);
    _document.documentElement.addEventListener('touchend', disableTouchSafari, true);
  }
};

// Hack to work around Safari's use of pinch and pan inside the viewer canvas.
// This method is not being invoked explicitly.
function enableDocumentTouchSafari() {
  if (isMobileDevice() && isSafari()) {
    // Safari mobile disable default touch handling inside viewer canvas
    // Use capture to make sure Safari doesn't capture the touches and prevent
    // us from disabling them.
    _document.documentElement.removeEventListener('touchstart', disableTouchSafari, true);
    _document.documentElement.removeEventListener('touchmove', disableTouchSafari, true);
    _document.documentElement.removeEventListener('touchcanceled', disableTouchSafari, true);
    _document.documentElement.removeEventListener('touchend', disableTouchSafari, true);
  }
};


// Convert touchstart event to click to remove the delay between the touch and
// the click event which is sent after touchstart with about 300ms deley.
// Should be used in UI elements on touch devices.
function touchStartToClick(e) {
  // Buttons that activate fullscreen are a special case. The HTML5 fullscreen spec
  // requires the original user gesture signal to avoid a security issue.  See LMV-2396 and LMV-2326
  if (e.target.className && (e.target.className.indexOf("fullscreen") > -1 ||
  e.target.className.indexOf("webvr") > -1 ||
  e.target.className.indexOf("webxr") > -1))
  return;
  e.preventDefault(); // Stops the firing of delayed click event.
  e.stopPropagation();
  e.target.click(); // Maps to immediate click.
}

//Safari doesn't have the Performance object
//We only need the now() function, so that's easy to emulate.
(function () {
  var global = (0,_global__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
  if (!global.performance)
  global.performance = Date;
})();

// Polyfill for IE and Safari
// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
Number.isInteger = Number.isInteger || function (value) {
  return typeof value === "number" &&
  isFinite(value) &&
  Math.floor(value) === value;
};

// Polyfill for IE
String.prototype.repeat = String.prototype.repeat || function (count) {
  if (count < 1) return '';
  var result = '',pattern = this.valueOf();
  while (count > 1) {
    if (count & 1) result += pattern;
    count >>= 1, pattern += pattern;
  }
  return result + pattern;
};

// Polyfill for IE
// https://github.com/jonathantneal/array-flat-polyfill/blob/master/src/polyfill-flat.js
if (!Array.prototype.flat) {
  Object.defineProperty(Array.prototype, 'flat', {
    value: function flat() {
      var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);

      return depth ? Array.prototype.reduce.call(this, function (acc, cur) {
        if (Array.isArray(cur)) {
          acc.push.apply(acc, flat.call(cur, depth - 1));
        } else {
          acc.push(cur);
        }

        return acc;
      }, []) : Array.prototype.slice.call(this);
    }
  });
}

// Polyfill for IE
// It doesn't support negative values for start and end; it complicates the code using this function.
if (!Array.prototype.fill) {
  Object.defineProperty(Array.prototype, "fill", {
    enumerable: false,
    value: function (value, start, end) {
      start = start === undefined ? 0 : start;
      end = end === undefined ? this.length : end;
      for (var i = start; i < end; ++i)
      this[i] = value;
    }
  });
}
// Polyfill for IE
Int32Array.prototype.lastIndexOf = Int32Array.prototype.lastIndexOf || function (searchElement, fromIndex) {
  return Array.prototype.lastIndexOf.call(this, searchElement, fromIndex);
};

// Polyfill for IE
// It doesn't support negative values for start and end; it complicates the code using this function.
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, "find", {
    enumerable: false,
    value: function (callback, _this) {
      var len = this.length;
      for (var i = 0; i < len; ++i) {
        var item = this[i];
        if (callback.call(_this, item, i, this))
        return item;
      }
      return undefined;
    }
  });
}

// Polyfill for IE
if (typeof Object.assign != 'function') {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, "assign", {
    value: function assign(target, varArgs) {// .length of function is 2
      'use strict';
      if (target == null) {// TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) {// Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}

// Polyfill for IE and iOS devices
if (typeof window !== "undefined" && (isIE11 || isIOSDevice()) && !HTMLCanvasElement.prototype.toBlob) {
  Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
    value: function (callback, type, quality) {
      var canvas = this;
      setTimeout(function () {

        var binStr = atob(canvas.toDataURL(type, quality).split(',')[1]),
          len = binStr.length,
          arr = new Uint8Array(len);

        for (var i = 0; i < len; i++) {
          arr[i] = binStr.charCodeAt(i);
        }

        callback(new Blob([arr], { type: type || 'image/png' }));

      });
    }
  });
}

// Polyfill for IE (LMV-3823)
if (!Uint8Array.prototype.slice) {

  // This will work for genuine arrays, array-like objects, 
  // NamedNodeMap (attributes, entities, notations),
  // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
  // and will not fail on other DOM objects (as do DOM elements in IE < 9)
  Uint8Array.prototype.slice = function (begin, end) {
    // IE < 9 gets unhappy with an undefined end argument
    end = typeof end !== 'undefined' ? end : this.length;

    // For native Array objects, we use the native slice function
    if (Object.prototype.toString.call(this) === '[object Array]') {
      return _slice.call(this, begin, end);
    }

    // For array like object we handle it ourselves.
    var i,cloned = [],
      size,len = this.length;

    // Handle negative value for "begin"
    var start = begin || 0;
    start = start >= 0 ? start : Math.max(0, len + start);

    // Handle negative value for "end"
    var upTo = typeof end == 'number' ? Math.min(end, len) : len;
    if (end < 0) {
      upTo = len + end;
    }

    // Actual expected size of the slice
    size = upTo - start;

    if (size > 0) {
      cloned = new Array(size);
      if (this.charAt) {
        for (i = 0; i < size; i++) {
          cloned[i] = this.charAt(start + i);
        }
      } else {
        for (i = 0; i < size; i++) {
          cloned[i] = this[start + i];
        }
      }
    }

    return cloned;
  };
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/InputStream.js":
/*!******************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/InputStream.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputStream: () => (/* binding */ InputStream)
/* harmony export */ });
/* harmony import */ var _StringUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StringUtils */ "./src/file-loaders/lmvtk/common/StringUtils.js");


"use strict";

//We will use these shared memory arrays to
//convert from bytes to the desired data type.
var convBuf = new ArrayBuffer(8);
var convUint8 = new Uint8Array(convBuf);
var convUint16 = new Uint16Array(convBuf);
var convInt32 = new Int32Array(convBuf);
var convUint32 = new Uint32Array(convBuf);
var convFloat32 = new Float32Array(convBuf);
var convFloat64 = new Float64Array(convBuf);


/** @constructor */
function InputStream(buf) {
  this.buffer = buf;
  this.offset = 0;
  this.byteLength = buf.length;
}


InputStream.prototype.seek = function (off) {
  this.offset = off;
};

InputStream.prototype.getBytes = function (len) {
  var ret = new Uint8Array(this.buffer.buffer, this.offset, len);
  this.offset += len;
  return ret;
};

InputStream.prototype.getVarints = function () {
  var b;
  var value = 0;
  var shiftBy = 0;
  do {
    b = this.buffer[this.offset++];
    value |= (b & 0x7f) << shiftBy;
    shiftBy += 7;
  } while (b & 0x80);
  return value;
};

InputStream.prototype.getUint8 = function () {
  return this.buffer[this.offset++];
};

InputStream.prototype.getUint16 = function () {
  convUint8[0] = this.buffer[this.offset++];
  convUint8[1] = this.buffer[this.offset++];
  return convUint16[0];
};

InputStream.prototype.getInt16 = function () {
  var tmp = this.getUint16();
  //make negative integer if the ushort is negative
  if (tmp > 0x7fff)
  tmp = tmp | 0xffff0000;
  return tmp;
};

InputStream.prototype.getInt32 = function () {
  var src = this.buffer;
  var dst = convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return convInt32[0];
};

InputStream.prototype.getUint32 = function () {
  var src = this.buffer;
  var dst = convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return convUint32[0];
};

InputStream.prototype.getFloat32 = function () {
  var src = this.buffer;
  var dst = convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return convFloat32[0];
};

//Specialized copy which copies 4 byte integers into 2-byte target.
//Used for downcasting OCTM int32 index buffers to int16 index buffers,
//in cases we know we don't need more (LMVTK guarantees 2 byte indices).
InputStream.prototype.getIndicesArray = function (buffer, offset, numItems) {

  var src = this.buffer;
  var dst = new Uint8Array(buffer, offset, numItems * 2);
  var off = this.offset;

  for (var i = 0, iEnd = numItems * 2; i < iEnd; i += 2) {
    dst[i] = src[off];
    dst[i + 1] = src[off + 1];
    off += 4;
  }

  this.offset = off;
};

InputStream.prototype.getVector3Array = function (arr, numItems, startOffset, stride) {
  var src = this.buffer;
  var off = this.offset;

  //We cannot use Float32Array copying here because the
  //source stream is out of alignment
  var dst = new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);

  if (stride === 3 && startOffset === 0) {
    var len = numItems * 12;
    dst.set(src.subarray(off, off + len));
    this.offset += len;
  } else {

    stride *= 4;
    var aoff = startOffset * 4;
    for (var i = 0; i < numItems; i++) {
      for (var j = 0; j < 12; j++) {
        dst[aoff + j] = src[off++];
      }
      aoff += stride;
    }

    this.offset = off;
  }
};

InputStream.prototype.getVector2Array = function (arr, numItems, startOffset, stride) {
  var src = this.buffer;
  var dst = new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  var off = this.offset;

  stride *= 4;
  var aoff = startOffset * 4;
  for (var i = 0; i < numItems; i++) {
    for (var j = 0; j < 8; j++) {
      dst[aoff + j] = src[off++];
    }
    aoff += stride;
  }

  this.offset = off;
};

InputStream.prototype.getVector4 = function (arr, offset) {
  var src = this.buffer;
  var dst = convUint8;
  var off = this.offset;
  var conv = convFloat32;

  for (var j = 0; j < 4; j++) {
    dst[0] = src[off];
    dst[1] = src[off + 1];
    dst[2] = src[off + 2];
    dst[3] = src[off + 3];
    arr[offset + j] = conv[0];
    off += 4;
  }

  this.offset = off;
};

InputStream.prototype.getFloat64 = function () {
  var src = this.buffer;
  var dst = convUint8;
  var off = this.offset;
  for (var i = 0; i < 8; i++)
  dst[i] = src[off + i];
  this.offset += 8;
  return convFloat64[0];
};



InputStream.prototype.getString = function (len) {
  var res = (0,_StringUtils__WEBPACK_IMPORTED_MODULE_0__.utf8ArrayToString)(this.buffer, this.offset, len);
  this.offset += len;
  return res;
};

InputStream.prototype.reset = function (buf) {
  this.buffer = buf;
  this.offset = 0;
  this.byteLength = buf.length;
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/NamedItemTree.js":
/*!********************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/NamedItemTree.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readNamedItemTree: () => (/* binding */ readNamedItemTree)
/* harmony export */ });


const NodeType = {
  NI_Inner: 0,
  NI_Leaf: 1
};

function readUuid(pfr) {
  let uuid = ''; // uuid should be a 16 bytes long
  for (let i = 0; i < 16; i++) {
    const tempUuid = pfr.readU8();
    uuid = uuid + tempUuid;
  }
  return uuid;
}

function readNamedItemNode(pfr) {

  const name = pfr.readString();
  let uuid = readUuid(pfr);
  const type = pfr.readU8();

  if (type === NodeType.NI_Leaf) {
    const entry = pfr.readVarint();
    return { name: name, entry: entry, uuid };
  } else if (type === NodeType.NI_Inner) {
    const count = pfr.readVarint();
    const children = [];
    for (let i = 0; i < count; i++) {
      const child = readNamedItemNode(pfr);
      children.push(child);
    }
    return { name: name, children: children };
  } else {
    return {};
  }
}

function readNamedItemTree(pfr) {
  if (pfr.seekToEntry) {
    pfr.seekToEntry(0);
  }
  return readNamedItemNode(pfr);
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/OverrideSets.js":
/*!*******************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/OverrideSets.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readOverrideSet: () => (/* binding */ readOverrideSet)
/* harmony export */ });


const OverrideSetParts = {
  OS_DefaultMaterial: 1,
  OS_DefaultFlags: 2,
  OS_MaterialOverrides: 4,
  OS_FlagOverrides: 8
};

function readDbIdSet(pfr, fn) {
  const count = pfr.readVarint();
  let dbId = 0;
  for (let i = 0; i < count; ++i) {
    const delta = pfr.readVarint();
    dbId += delta;
    fn(dbId);
  }
}

function readOverrideSet(pfr, entry) {
  const tse = pfr.seekToEntry(entry);
  if (!tse)
  return null;

  const set = {};
  const parts = pfr.stream.getUint32();

  if (parts & OverrideSetParts.OS_DefaultMaterial) {
    set.defaultMaterialIndex = pfr.readVarint();
    set.defaultMaterialFlags = pfr.readU8();
  }

  if (parts & OverrideSetParts.OS_DefaultFlags) {
    set.defaultFlags = pfr.readVarint();
  }

  if (parts & OverrideSetParts.OS_MaterialOverrides) {
    set.materialOverrides = [];
    const count = pfr.readVarint();
    for (let i = 0; i < count; ++i) {
      let matIdx = pfr.readVarint();
      readDbIdSet(pfr, function (dbId) {
        set.materialOverrides.push({ dbId: dbId, materialIndex: matIdx });
      });
    }
  }

  if (parts & OverrideSetParts.OS_FlagOverrides) {
    set.flagOverrides = [];
    const count = pfr.readVarint();
    for (let i = 0; i < count; ++i) {
      let flags = pfr.readVarint();
      readDbIdSet(pfr, function (dbId) {
        set.flagOverrides.push({ dbId: dbId, flags: flags });
      });
    }
  }

  return set;
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/PackReader.js":
/*!*****************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/PackReader.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PackFileReader: () => (/* binding */ PackFileReader)
/* harmony export */ });
/* harmony import */ var _InputStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InputStream */ "./src/file-loaders/lmvtk/common/InputStream.js");
/* harmony import */ var _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../wgs/scene/LmvMatrix4 */ "./src/wgs/scene/LmvMatrix4.js");




"use strict";

var warnedGzip = false;

/** @constructor */
function PackFileReader(data)
{
  var stream = this.stream = new _InputStream__WEBPACK_IMPORTED_MODULE_0__.InputStream(data);

  var len = stream.getInt32();
  this.type = stream.getString(len);
  this.version = stream.getInt32();

  this.types = null;
  this.entryOffsets = [];

  //read the table of contents
  {
    var offset = stream.offset;

    // Jump to file footer.
    stream.seek(stream.byteLength - 8);

    // Jump to toc.
    var tocOffset = stream.getUint32();
    this.typesOffset = stream.getUint32();

    // Populate type sets.
    stream.seek(this.typesOffset);
    var typesCount = this.readU32V();
    this.types = [];
    for (var i = 0; i < typesCount; ++i)
    this.types.push({
      "entryClass": this.readString(),
      "entryType": this.readString(),
      "version": this.readU32V()
    });

    // Populate data offset list.
    stream.seek(tocOffset);
    var entryCount = this.readU32V();
    var dso = this.entryOffsets;
    for (var i = 0; i < entryCount; ++i)
    dso.push(stream.getUint32());

    // Restore sanity of the world.
    stream.seek(offset);
  }
};

PackFileReader.prototype.readVarint = function () {
  var b;
  var value = 0;
  var shiftBy = 0;
  do {
    b = this.stream.getUint8();
    value |= (b & 0x7f) << shiftBy;
    shiftBy += 7;
  } while (b & 0x80);
  return value;
};
PackFileReader.prototype.readU32V = PackFileReader.prototype.readVarint;

PackFileReader.prototype.readU16 = function () {
  return this.stream.getUint16();
};

PackFileReader.prototype.readU8 = function () {
  return this.stream.getUint8();
};

PackFileReader.prototype.readString = function () {
  return this.stream.getString(this.readU32V());
};

PackFileReader.prototype.readVector3f = function () {
  var s = this.stream;
  return { x: s.getFloat32(), y: s.getFloat32(), z: s.getFloat32() };
};

PackFileReader.prototype.readF32 = function () {
  return this.stream.getFloat32();
};

PackFileReader.prototype.readF64 = function () {
  return this.stream.getFloat64();
};

PackFileReader.prototype.readVector3d = function () {

  var t = { x: 0, y: 0, z: 0 };

  return function () {
    var s = this.stream;
    t.x = s.getFloat64();
    t.y = s.getFloat64();
    t.z = s.getFloat64();

    return t;
  };
}();

PackFileReader.prototype.readQuaternionf = function () {

  var q = { x: 0, y: 0, z: 0, w: 0 };

  return function () {
    var s = this.stream;
    q.x = s.getFloat32();
    q.y = s.getFloat32();
    q.z = s.getFloat32();
    q.w = s.getFloat32();

    return q;
  };

}();

PackFileReader.prototype.readMatrix3f = function () {

  var _m = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_1__.LmvMatrix4();

  return function (dst) {
    if (!dst) dst = _m;

    var s = this.stream;
    dst.identity();
    for (var i = 0; i < 3; ++i)
    for (var j = 0; j < 3; ++j)
    dst.elements[4 * i + j] = s.getFloat32();

    return dst;
  };

}();



PackFileReader.prototype.readTransform = function () {

  var s = { x: 1, y: 1, z: 1 };
  var m = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_1__.LmvMatrix4(true);

  return function (entityIndex, buffer, offset, placementTransform, globalOffset, originalTranslation)
  {
    var stream = this.stream;
    var t, q;

    var transformType = stream.getUint8();

    switch (transformType) {

      case 4 /*TransformType.Identity*/:{
          m.identity();
        }break;
      case 0 /*TransformType.Translation*/:{
          t = this.readVector3d();
          m.makeTranslation(t.x, t.y, t.z);
        }break;
      case 1 /*TransformType.RotationTranslation*/:{
          q = this.readQuaternionf();
          t = this.readVector3d();
          s.x = 1;s.y = 1;s.z = 1;
          m.compose(t, q, s);
        }break;
      case 2 /*TransformType.UniformScaleRotationTranslation*/:{
          var scale = stream.getFloat32();
          q = this.readQuaternionf();
          t = this.readVector3d();
          s.x = scale;s.y = scale;s.z = scale;
          m.compose(t, q, s);
        }break;
      case 3 /*TransformType.AffineMatrix*/:{
          this.readMatrix3f(m);
          t = this.readVector3d();
          m.setPosition(t);
        }break;
      default:
        break; //ERROR
    }

    //Report the original translation term to the caller, if they need it.
    //This is only required when reading fragment bounding boxes, where the translation
    //term of this matrix is subtracted from the bbox terms.
    if (originalTranslation) {
      originalTranslation[0] = m.elements[12];
      originalTranslation[1] = m.elements[13];
      originalTranslation[2] = m.elements[14];
    }

    //Apply any placement transform
    if (placementTransform) {
      m.multiplyMatrices(placementTransform, m);
    }

    //Apply global double precision offset on top
    if (globalOffset) {
      m.elements[12] -= globalOffset.x;
      m.elements[13] -= globalOffset.y;
      m.elements[14] -= globalOffset.z;
    }

    //Store result back into single precision matrix or array
    if (entityIndex !== undefined) {
      var src = m.elements;
      // Sometimes we don't want to keep this data (e.g. when we are probing the fragment list
      // to find the data base id to fragment index mappings used for fragment filtering) so we
      // pass a null buffer and if that is the case, bail out here.
      if (!buffer) return;
      buffer[offset + 0] = src[0];buffer[offset + 1] = src[1];buffer[offset + 2] = src[2];
      buffer[offset + 3] = src[4];buffer[offset + 4] = src[5];buffer[offset + 5] = src[6];
      buffer[offset + 6] = src[8];buffer[offset + 7] = src[9];buffer[offset + 8] = src[10];
      buffer[offset + 9] = src[12];buffer[offset + 10] = src[13];buffer[offset + 11] = src[14];
    } else
    {
      return new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_1__.LmvMatrix4().copy(m);
    }
  };

}();

PackFileReader.prototype.getEntryCounts = function () {
  return this.entryOffsets.length;
};

PackFileReader.prototype.seekToEntry = function (entryIndex) {
  var count = this.getEntryCounts();
  if (entryIndex >= count)
  return null;

  // Read the type index and populate the entry data
  this.stream.seek(this.entryOffsets[entryIndex]);
  var typeIndex = this.stream.getUint32();
  if (typeIndex >= this.types.length)
  return null;

  return this.types[typeIndex];
};


PackFileReader.prototype.readPathID = function () {
  var s = this.stream;

  //Construct a /-delimited string as the path to a node
  //TODO: in case we need a split representation (e.g. to follow paths), then
  //an array of numbers might be better to return from here.
  if (this.version < 2) {
    var pathLength = s.getUint16();
    if (!pathLength)
    return null;

    //The first number in a path ID is always zero (root)
    //so we skip adding it to the path string here.
    //Remove this section if that is not the case in the future.
    s.getUint16();
    if (pathLength == 1)
    return "";

    var path = s.getUint16();
    for (var i = 2; i < pathLength; ++i) {
      path += "/" + s.getUint16();
    }
  } else
  {
    var pathLength = this.readU32V();
    if (!pathLength)
    return null;

    //The first number in a path ID is always zero (root)
    //so we skip adding it to the path string here.
    //Remove this section if that is not the case in the future.
    this.readU32V();
    if (pathLength == 1)
    return "";

    var path = this.readU32V();
    for (var i = 2; i < pathLength; ++i) {
      path += "/" + this.readU32V();
    }
  }
  return path;
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/Propdb.js":
/*!*************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/Propdb.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PropertyDatabase: () => (/* binding */ PropertyDatabase)
/* harmony export */ });
/* harmony import */ var _common_StringUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/StringUtils */ "./src/file-loaders/lmvtk/common/StringUtils.js");
/* harmony import */ var _common_SearchUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/SearchUtils */ "./src/file-loaders/lmvtk/common/SearchUtils.js");
/* harmony import */ var _PropdbEnums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PropdbEnums */ "./src/file-loaders/lmvtk/common/PropdbEnums.js");






//Inlined into enumObjectProperties below
/*
function readVarint(buf, offset) {
    var b;
    var value = 0;
    var shiftBy = 0;
    do {
        b = buf[offset[0]++];
        value |= (b & 0x7f) << shiftBy;
        shiftBy += 7;
    } while (b & 0x80);
    return value;
}
*/

/**
 * The Property Database contains property information for each part of a model.
 * The data is read-only, since it has been packed to optimize memory footprint.
 * It's implemented as an Entity-Atribute-Value (EAV) set of tables.
 * LMV keeps the PropertyDatabase in a browser worker thread to prevent compute-intensive
 * methods to block the main browser UI thread.
 * Words "Attribute" and "Property" are use interchangeably.
 *
 * @param dbjsons
 * @class
 * @class
 */
function PropertyDatabase(dbjsons) {

  "use strict";

  var _this = this;

  var _isV2 = false;
  var _isVarint = false;

  //The property db json arrays.
  //Some of them are held unparsed in blob form
  //with helper arrays containing offsets into the blobs for each value to be parsed on demand
  var _attrs; // Array of arrays. Inner array is in the form [attrName(0), category(1), dataType(2), dataTypeContext(3), description(4), displayName(5), flags(6), precision(7) ] 
  // See struct AttributeDef in https://git.autodesk.com/A360/platform-translation-propertydb/blob/master/propertydb/PropertyDatabase.h 
  var _offsets;
  var _avs;
  var _valuesBlob;
  var _valuesOffsets;
  var _idsBlob;
  var _idsOffsets;

  //Cached ids of commonly used well known attributes (child, parent, name)
  var _childAttrId;
  var _parentAttrId;
  var _nameAttrId;
  var _instanceOfAttrId;
  var _viewableInAttrId;
  var _externalRefAttrId;
  var _nodeFlagsAttrId;
  var _layersAttrId;

  //Transient structures for detecting invalid cycles in buildObjectTree()
  var _processedIds;
  var _cyclesCount;

  // Used for memoizing recursive calls to getNodeNameAndChildren
  let _instanceNodeCache = {};

  //dbjsons is expected to be of the form
  //{ attrs: {filename1:x, filename2:y}, ids: {filename1:x... }, values: {... }, offsets: {... }, avs: {... } }
  //where each of the elements of each array is a pair of the original name and the unzipped *raw* byte
  //array buffer corresponding to the respective property database constituent. In the current implementation
  //each array is expected to only have one name-value element.


  //=========================================================================

  //The attribute definitions blob is considered small enough
  //to parse using regular APIs
  for (var p in dbjsons.attrs) {
    _attrs = (0,_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.blobToJson)(dbjsons.attrs[p]);

    if (_attrs[0] === "pdb version 2")
    _isV2 = true;

    for (var i = 1; i < _attrs.length; i++) {

      var attrName = _attrs[i][0];
      switch (attrName) {
        case "Layer":_layersAttrId = i;break;
        default:break;
      }

      var category = _attrs[i][1];

      switch (category) {
        case "__parent__":_parentAttrId = i;break;
        case "__child__":_childAttrId = i;break;
        case "__name__":_nameAttrId = i;break;
        case "__instanceof__":_instanceOfAttrId = i;break;
        case "__viewable_in__":_viewableInAttrId = i;break;
        case "__externalref__":_externalRefAttrId = i;break;
        case "__node_flags__":_nodeFlagsAttrId = i;break;
        default:break;
      }

      //As of V2, DbKey attribute values are stored directly into the AV array
      if (_isV2 && _attrs[i][2] === _PropdbEnums__WEBPACK_IMPORTED_MODULE_2__.AttributeType.DbKey) {
        _attrs[i][6] = _attrs[i][6] | _PropdbEnums__WEBPACK_IMPORTED_MODULE_2__.AttributeFlags.afDirectStorage;
      }
    }

    break; //currently we can only handle single property file (no chunking)
  }

  //manual parse of the attribute-value index pairs array
  for (let p in dbjsons.avs) {

    let buf = dbjsons.avs[p];

    if (buf[0] === "[".charCodeAt(0)) {
      _avs = (0,_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.parseIntArray)(dbjsons.avs[p], 0);
    } else {
      _avs = buf;
      _isVarint = true;
    }

    delete dbjsons.avs; //don't need this blob anymore

    break; //currently we can only handle single property file (no chunking)

  }


  //manual parse of the offsets array
  for (let p in dbjsons.offsets) {

    let buf = dbjsons.offsets[p];

    if (buf[0] === "[".charCodeAt(0)) {
      _offsets = (0,_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.parseIntArray)(buf, 1); //passing in 1 to reserve a spot for the sentinel value

      //just a sentinel value to make lookups for the last item easier
      _offsets[_offsets.length - 1] = _avs.length / 2;
    } else {
      _offsets = new Int32Array(buf.buffer, buf.byteOffset, buf.byteLength / 4);
    }

    delete dbjsons.offsets; //don't need this

    break; //currently we can only handle single property file (no chunking)

  }

  //Instead of parsing the values and ids arrays, find the
  //offset of each json item in the blob, and then we can
  //pick and parse specific items later on demand, without
  //parsing the potentially large json blob up front.
  for (let p in dbjsons.values) {
    _valuesBlob = dbjsons.values[p];
    _valuesOffsets = (0,_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.findValueOffsets)(_valuesBlob);

    break; //currently we can only handle single property file (no chunking)

  }

  // Get externalIds from data blob. Unlike the other data, this one is optional
  // and may be loaded later or not at all to save memory.
  this.setIdsBlob = function (data) {
    // Just like for _valuesBlob: Find the offset to each value 
    //  but skip the full parse.
    _idsBlob = data;
    _idsOffsets = (0,_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.findValueOffsets)(data);
  };

  //Set ids array (if available). Note that the ids array is
  //optional and LMV does not require them. (Just some extensions might do - like PushPins)
  for (let p in dbjsons.ids) {
    this.setIdsBlob(dbjsons.ids[p]);
    break; //currently we can only handle single property file (no chunking)
  }

  //=========================================================================

  /**
   * Obtains the number of database ids (dbIds) available. 
   * These ids range betwee 1 (inclusive) up to getObjectCount() (exclusive).
   *
   * @returns {number}
   */
  this.getObjectCount = function () {
    return _offsets.length - 1;
  };

  this.getValueAt = function (valId) {
    return (0,_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.subBlobToJson)(_valuesBlob, _valuesOffsets[valId]);
  };

  //faster variant used for traversing the object hierarchy where
  //we know the data type of the value to be an integer
  this.getIntValueAt = function (valId) {
    return (0,_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.subBlobToJsonInt)(_valuesBlob, _valuesOffsets[valId]);
  };


  this.getIdAt = function (entId) {
    return (0,_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.subBlobToJson)(_idsBlob, _idsOffsets[entId]);
  };

  // Loading the (large) externalIDs can be skipped to save memory.
  this.externalIdsLoaded = function () {
    return Boolean(_idsBlob);
  };

  /**
   * Obtains the actual value of a property.
   *
   * @param {number} attrId - The attribute id
   * @param {number} valId - The value id
   * @param {boolean} [integerHint] - If true the return value will be casted to integer.
   *
   * @returns {*} 
   */
  this.getAttrValue = function (attrId, valId, integerHint) {
    var attr = _attrs[attrId];
    if (attr[6] & _PropdbEnums__WEBPACK_IMPORTED_MODULE_2__.AttributeFlags.afDirectStorage) {
      if (attr[2] === _PropdbEnums__WEBPACK_IMPORTED_MODULE_2__.AttributeType.DbKey) {
        //db keys are stored directly in the EAV triplet
        return valId;
      }
    }

    return integerHint ? this.getIntValueAt(valId) : this.getValueAt(valId);
  };

  this._getObjectProperty = function (attrId, valId) {

    var attr = _attrs[attrId];
    var displayName = attr[5] ? attr[5] : attr[0];
    var hidden = this.attributeHidden(attrId);

    // type values match those in PropertyDatabase.h
    // See: https://git.autodesk.com/A360/platform-translation-propertydb/blob/master/propertydb/PropertyDatabase.h#L67
    return {
      displayName: displayName,
      displayValue: _this.getAttrValue(attrId, valId),
      displayCategory: attr[1],
      attributeName: attr[0],
      type: attr[2],
      units: attr[3],
      hidden: hidden,
      precision: attr[7] || 0
    };
  };

  /**
   * Obtains all properties for a given database id.
   *
   * @param {number} dbId - The database id
   * @param {string[]} [propFilter=null] - Array of property names to return values for. Use null for no filtering.
   * @param {boolean} [ignoreHidden=false] - true to ignore hidden properties.
   * @param {string[]} [propIgnored=null] - Array of property names to not include in the return value.
   *
   * @returns {object} consisting of attributes `name`, `dbId`, `properties` and `externalId`.
   */
  this.getObjectProperties = function (dbId, propFilter, ignoreHidden, propIgnored, categoryFilter) {
    var result = {
      "dbId": dbId,
      "properties": []
    };

    var needName = false;

    // Check if externalIds are wanted and available
    var filterContainsId = propFilter && propFilter.indexOf("externalId") !== -1;
    var idsLoaded = this.externalIdsLoaded();

    // If externalIds are explicitly addressed in the filter, we can assume that the caller expects
    // to have them in the result. So we should report an error if they are not loaded.
    if (filterContainsId && !idsLoaded) {
      console.error('Requesting externalID requires loading of the externalID table');
    }

    // We add externalIds to the result if...
    //  1. externalIds are in memory
    //  2. Either the filter includes externalIds or there is no filter
    var addExternalId = idsLoaded && (!propFilter || filterContainsId);
    if (addExternalId) {
      result.externalId = this.getIdAt(dbId);

      // If there are no other properties required, then just return.
      // Useful when we only care about fetching externalId-only data.
      if (propFilter && propFilter.length === 1) {
        return result;
      }
    }

    var parentProps = null;

    //Loop over the attribute index - value index pairs for the objects
    //and for each one look up the attribute and the value in their
    //respective arrays.
    this.enumObjectProperties(dbId, function (attrId, valId) {
      if (attrId == _instanceOfAttrId) {
        //Recursively resolve any common properties from the parent of this instance
        //NOTE: Here we explicitly ignore hidden properties, because we don't 
        //want the parent instance to override parent/child nodes and other structural 
        //attributes. Specifically, Revit extraction has a bug where the model tree parent is 
        //also instance prototype for its children, so we need to prevent the child
        //from gaining all its siblings as children of its own due to this inheritance.
        var res = _this.getObjectProperties(_this.getAttrValue(attrId, valId), propFilter, true /*ignoreHidden*/, propIgnored, categoryFilter);
        if (res && res.properties) {
          parentProps = res;
        }
        return;
      }

      var attr = _attrs[attrId];

      if (propFilter && propFilter.indexOf(attr[0]) === -1 && propFilter.indexOf(attr[5]) === -1)
      return;

      if (categoryFilter && categoryFilter.indexOf(attr[1]) === -1)
      return;

      if (propIgnored && (propIgnored.indexOf(attr[0]) > -1 || propIgnored.indexOf(attr[5]) > -1))
      return;

      if (attrId == _nameAttrId) {
        var val = _this.getAttrValue(attrId, valId);
        needName = true;
        result.name = val;
      } else
      {

        //skip structural attributes, we don't want those to display
        //NOTE: The list of structural attributes that we check explicitly is not marked
        //as hidden in older versions of the property database, so if we ever want to
        //add them to the result list, we have to explicitly set the hidden flag for those.
        var hidden = _this.attributeHidden(attrId);
        if (ignoreHidden && hidden) {
          return;
        }

        var prop = _this._getObjectProperty(attrId, valId);
        result.properties.push(prop);
      }
    });

    //Combine instance properties with any parent object properties
    if (parentProps) {
      var myProps = {};
      var rp = result.properties;
      for (let i = 0; i < rp.length; i++) {
        myProps[rp[i].displayName] = 1;
      }

      if (!result.name)
      result.name = parentProps.name;

      var pp = parentProps.properties;
      for (let i = 0; i < pp.length; i++) {
        if (!Object.prototype.hasOwnProperty.call(myProps, pp[i].displayName)) {
          rp.push(pp[i]);
        }
      }
    }

    if (categoryFilter && !result.properties.length)
    return null;

    if (propFilter && !result.properties.length && !addExternalId && !needName)
    return null;

    return result;
  };

  /**
   * Obtains a map between each database id (dbId) and their corresponding external-id.
   * The external-id is the identifier used by the source file. 
   * Example: A translated Revit file has a wall with dbId=1, but in Revit (desktop application) the identifier of that wall is "Wall-06-some-guid-here".
   *
   * @param {number[]} [extIdFilter] - Limits the result to only contain the ids in this array.
   *
   * @returns {object} map from dbId into external-id.
   */
  this.getExternalIdMapping = function (extIdFilter) {
    var mapping = {};
    if (_idsOffsets && 'length' in _idsOffsets) {// Check that it's an indexable type
      for (var dbId = 1, len = _idsOffsets.length; dbId < len; ++dbId) {
        var externalId = this.getIdAt(dbId);
        if (!extIdFilter || extIdFilter[externalId] === true) {
          mapping[externalId] = dbId;
        }
      }
    }
    return mapping;
  };

  //Heuristically find the root node(s) of a scene
  //A root is a node that has children, has no (or null) parent and has a name.
  //There can be multiple nodes at the top level (e.g. Revit DWF), which is why
  //we should get the scene root with absolute certainty from the SVF instance tree,
  //but we would have to uncompress and parse that in -- something that is
  //not currently done. This is good enough for now (if pretty slow).
  this.findRootNodes = function () {

    var idroots = [];
    var idDetachedNodes = []; // These are nodes without a parent or child

    this.enumObjects(function (id) {
      var hasChild = false;
      var hasParent = false;
      var hasName = false;

      _this.enumObjectProperties(id, function (attrId, valId) {
        if (attrId == _parentAttrId) {
          if (_this.getAttrValue(attrId, valId, true)) //checks for null or zero parent id, in which case it's considered non-parent
            hasParent = true;
        } else if (attrId == _childAttrId) {
          hasChild = true;
        } else
        if (attrId == _nameAttrId) {
          hasName = true;
        }
      });

      if (hasName && !hasParent) {
        hasChild ? idroots.push(id) : idDetachedNodes.push(id);
      }
    });

    // Some dwfx files can have only detached nodes, in which case, we treat them as roots
    return idroots.length > 0 ? idroots : idDetachedNodes;
  };

  // Does the node have atleast one child?
  this.nodeHasChild = function (dbId) {
    let hasChild = false;

    this.enumObjectProperties(dbId, function (attrId) {
      if (attrId === _childAttrId) {
        hasChild = true;
        return true; // break from enumerating
      }
    });

    return hasChild;
  };


  //Gets the immediate children of a node with the given dbId
  this.getNodeNameAndChildren = function (node /* {dbId:X, name:""} */, skipChildren) {

    var id = node.dbId;

    var children;
    var instanceOfValId;

    this.enumObjectProperties(id, function (attrId, valId) {
      var val;

      if (attrId === _parentAttrId) {

        //node.parent = this.getAttrValue(attrId, valId, true); //eventually we will needs this instead of setting parent pointer when creating children below.
      } else if (attrId == _childAttrId && !skipChildren) {val = _this.getAttrValue(attrId, valId, true);

        // avoid parent->child links to the same dbId
        if (val !== node.dbId) {
          var child = { dbId: val, parent: node.dbId };
          if (!children)
          children = [child];else

          children.push(child);
        }

      } else if (attrId === _nameAttrId) {
        node.name = _this.getAttrValue(attrId, valId); //name is necessary for GUI purposes, so add it to the node object explicitly
      } else if (attrId === _nodeFlagsAttrId) {
        node.flags = _this.getAttrValue(attrId, valId, true); //flags are necessary for GUI/selection purposes, so add them to the node object
      } else if (attrId === _instanceOfAttrId) {
        instanceOfValId = valId;
      }
    });

    //If this is an instance of another object,
    //try to get the object name/flags from there.
    //This is not done in the main loop above for performance reasons,
    //we only want to do the expensive thing of going up the object hierarchy
    //if the node does not actually have a name/flags attributes.
    if ((!node.name || !node.flags) && instanceOfValId) {
      const dbIdOfInstance = _this.getAttrValue(_instanceOfAttrId, instanceOfValId, true);

      // Check if the instance node already exists in cache.
      let tmp = _instanceNodeCache[dbIdOfInstance];

      if (!tmp) {
        // Fetch instance node and memoize it.
        _instanceNodeCache[dbIdOfInstance] = tmp = { dbId: dbIdOfInstance, name: null, flags: null };
        _this.getNodeNameAndChildren(tmp, true);
      }

      //Take the name from the prototype object if the instance doesn't have it
      if (tmp.name && !node.name)
      node.name = tmp.name;

      //Take the node flags from the prototype object if the instance doesn't have it
      if (typeof node.flags !== "number" && typeof tmp.flags === "number")
      node.flags = tmp.flags;
    }

    return children;
  };


  /**
   * @param fragToDbId
   * @private
   */
  function buildDbIdToFragMap(fragToDbId) {
    var ret = {};
    for (var i = 0, iEnd = fragToDbId.length; i < iEnd; i++) {

      var dbIds = fragToDbId[i];

      //In 2D drawings, a single fragment (consolidation mesh)
      //can contain multiple objects with different dbIds.
      if (!Array.isArray(dbIds)) {
        dbIds = [dbIds];
      }

      for (var j = 0; j < dbIds.length; j++) {
        var dbId = dbIds[j];
        var frags = ret[dbId];
        if (frags === undefined) {
          //If it's the first fragments for this dbid,
          //store the index directly -- most common case.
          ret[dbId] = i;
        } else
        if (!Array.isArray(frags)) {
          //otherwise put the fragments that
          //reference the dbid into an array
          ret[dbId] = [frags, i];
        } else
        {
          //already is an array
          frags.push(i);
        }
      }
    }

    return ret;
  }

  this.buildDbIdToFragMap = buildDbIdToFragMap;

  //Duplicated from InstanceTree.js
  var NODE_TYPE_ASSEMBLY = 0x0, // Real world object as assembly of sub-objects
    NODE_TYPE_GEOMETRY = 0x6; // Leaf geometry node

  //Builds a tree of nodes according to the parent/child hierarchy
  //stored in the property database, starting at the node with the given dbId
  this.buildObjectTree = function (rootId, //current node dbId
  fragToDbId, //array of fragId->dbId lookup
  maxDepth, /* returns max tree depth */
  nodeStorage)
  {

    //Build reverse lookup for dbId->fragId
    var dbToFragId;
    if (fragToDbId) {
      dbToFragId = buildDbIdToFragMap(fragToDbId);
    }

    _processedIds = {};
    _cyclesCount = 0;

    //Call recursive implementation
    var ret = this.buildObjectTreeRec(rootId, 0, dbToFragId, 0, maxDepth, nodeStorage);
    if (_cyclesCount > 0) {
      console.warn('Property database integrity not guaranteed (' + _cyclesCount + ').');
    }

    _processedIds = null;

    // Clean cache
    _instanceNodeCache = {};

    return ret;
  };

  //Recursive helper for buildObjectTree
  this.buildObjectTreeRec = function (dbId, //current node dbId
  parent, //parent dbId
  dbToFrag, //map of dbId to fragmentIds
  depth, /* start at 0 */
  maxDepth, /* returns max tree depth */
  nodeStorage)
  {

    // Check for cycles in the tree.
    // There shouldn't be any cycles in the tree...
    if (_processedIds[dbId]) {
      _cyclesCount++;
      return 0;
    }

    _processedIds[dbId] = parent || dbId;

    if (depth > maxDepth[0])
    maxDepth[0] = depth;

    var node = { dbId: dbId };
    var children = this.getNodeNameAndChildren(node);

    var childrenIds = [];

    if (children) {
      for (var j = 0; j < children.length; j++) {
        var childHasChildren = this.buildObjectTreeRec(children[j].dbId, dbId, dbToFrag, depth + 1, maxDepth, nodeStorage);

        //For display purposes, prune children that are leafs without graphics
        //and add the rest to the node
        if (childHasChildren)
        childrenIds.push(children[j].dbId);
      }
    }

    var fragIds;

    //leaf node
    if (dbToFrag) {
      var frags = dbToFrag[dbId];
      if (frags !== undefined) {

        //if (childrenIds.length)
        //    console.error("Node that has both node children and fragment children!", node.name, children, childrenIds, frags);

        if (!Array.isArray(frags))
        fragIds = [frags];else

        fragIds = frags;
      }
    }

    //Use default node flags in case none are set
    //This is not the best place to do this, but it's
    //the last place where we can differentiate between "not set" and zero.
    var flags = node.flags || 0;
    if (flags === undefined) {
      if (fragIds && fragIds.length)
      flags = NODE_TYPE_GEOMETRY;else
      if (childrenIds.length)
      flags = NODE_TYPE_ASSEMBLY;else

      flags = 0; //??? Should not happen (those nodes are pruned above)
    }

    // Get child count (nodes + fragments)
    var childCount = childrenIds.length + (fragIds ? fragIds.length : 0);

    // Skip nodes that contain neither children nor any fragments
    if (childCount) {
      nodeStorage.setNode(dbId, parent, node.name, flags, childrenIds, fragIds);
    }

    return childCount;
  };

  /**
   * Given a text string, returns an array of individual words separated by
   * white spaces.
   * Will preserve white spacing within double quotes.
   *
   * @param {string} searchText - Text to search
   */
  this.getSearchTerms = function (searchText) {
    searchText = searchText.toLowerCase();
    //regex preserves double-quote delimited strings as phrases
    var searchTerms = searchText.match(/"[^"]+"|[^\s]+/g) || [];
    var i = searchTerms.length;
    while (i--) {
      searchTerms[i] = searchTerms[i].replace(/"/g, "");
    }
    var searchList = [];
    for (i = 0; i < searchTerms.length; i++) {

      if (searchTerms[i].length > 1)
      searchList.push(searchTerms[i]);
    }
    return searchList;
  };

  /**
   * Searches the property database for a string.
   *
   * @param searchText
   * @param attributeNames
   * @param searchOptions
   * @returns Array of ids.
   * @private
   */
  this.bruteForceSearch = function (searchText, attributeNames, searchOptions) {

    const searchList = this.getSearchTerms(searchText);
    if (searchList.length === 0)
    return [];

    //For each search word, find matching IDs
    var results = [];

    const searchHidden = searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.searchHidden;
    const includeInherited = searchOptions === null || searchOptions === void 0 ? void 0 : searchOptions.includeInherited;
    // { x: [ a, b, c ]}, a,b,c are instances of x
    const inheritanceMap = {};

    for (let k = 0; k < searchList.length; k++) {
      var result = [];

      //Find all values that match the search text
      var matching_vals = [];
      for (var i = 0, iEnd = _valuesOffsets.length; i < iEnd; i++) {
        var val = this.getValueAt(i);
        if (val === null)
        continue;
        if (val.toString().toLowerCase().indexOf(searchList[k]) !== -1)
        matching_vals.push(i);
      }

      if (matching_vals.length === 0) {
        results.push(result);
        continue;
      }

      // values should be sorted at this point, but it doesn't hurt making sure they are.
      matching_vals.sort(function (a, b) {
        return a - b;
      });

      this.enumObjects(function (id) {

        _this.enumObjectProperties(id, function (attrId, valId) {

          if (includeInherited && attrId === _instanceOfAttrId) {
            const pid = parseInt(_this.getAttrValue(attrId, valId));
            inheritanceMap[pid] = inheritanceMap[pid] || [];
            inheritanceMap[pid].push(id);
          }

          if (!searchHidden) {
            // skip hidden attributes
            var isHidden = _this.attributeHidden(attrId);
            if (isHidden) {
              return;
            }
          }

          var iFound = (0,_common_SearchUtils__WEBPACK_IMPORTED_MODULE_1__.binarySearch)(matching_vals, valId);
          if (iFound !== -1) {
            //Check attribute name in case a restriction is passed in
            if (attributeNames && attributeNames.length && attributeNames.indexOf(_attrs[attrId][0]) === -1)
            return;

            result.push(id);
            return true;
          }
        });

      });

      results.push(result);
    }

    const addInheritedIds = (ids, inheritanceMap) => {
      // traverse inheritance and add to ids list
      const seen = new Set(ids);
      for (let i = 0; i < ids.length; ++i) {
        const id = ids[i];
        if (!(id in inheritanceMap)) continue;
        const cids = inheritanceMap[id];
        for (let j = 0; j < cids.length; ++j) {
          const cid = cids[j];
          if (!seen.has(cid)) {
            ids.push(cid);
            seen.add(cid);
          }
        }
      }
    };

    if (results.length === 1) {
      if (includeInherited) {
        addInheritedIds(results[0], inheritanceMap);
      }
      return results[0];
    }

    //If each search term resulted in hits, compute the intersection of the sets
    var map = {};
    var hits = results[0];
    for (let i = 0; i < hits.length; i++)
    map[hits[i]] = 1;


    for (let j = 1; j < results.length; j++) {
      hits = results[j];
      var mapint = {};

      for (let i = 0; i < hits.length; i++) {
        if (map[hits[i]] === 1)
        mapint[hits[i]] = 1;
      }

      map = mapint;
    }

    result = [];
    for (let k in map) {
      result.push(parseInt(k));
    }

    if (includeInherited) {
      addInheritedIds(result, inheritanceMap);
    }

    return result;
  };


  /**
   * Given a property name, it returns an array of ids that contain it.
   *
   * @param {string} propertyName - Property name
   */
  this.bruteForceFind = function (propertyName) {

    var results = [];
    this.enumObjects(function (id) {

      var idContainsProperty = false;
      _this.enumObjectProperties(id, function (attrId) {

        var attr = _attrs[attrId];
        var propName = attr[0];
        var displayName = attr[5];

        if (propName === propertyName || displayName === propertyName) {
          idContainsProperty = true;
          return true;
        }
      });

      if (idContainsProperty) {
        results.push(id);
      }

    });

    return results;
  };

  /**
   * Specialized function that returns:
   * {
   *    'layer-name-1': [id1, id2, ..., idN],
   *    'layer-name-2': [idX, idY, ..., idZ],
   *    ...
   * }
   */
  this.getLayerToNodeIdMapping = function () {

    var results = {};
    this.enumObjects(function (id) {

      _this.enumObjectProperties(id, function (attrId, valId) {

        if (attrId != _layersAttrId)
        return;

        var val = _this.getAttrValue(attrId, valId);
        if (!Array.isArray(results[val])) {
          results[val] = [];
        }
        results[val].push(id);
        return true;
      });

    });

    return results;
  };

  /**
   * Unpacks an attribute value into all available components.
   *
   * @param {number} attrId - The attribute id.
   *
   * @returns {object} containing `name`, `category`, `dataType`, `dataTypeContext`, `description`, `displayName` and `flags`.
   */
  this.getAttributeDef = function (attrId) {
    var _raw = _attrs[attrId];
    return {
      //attrName(0), category(1), dataType(2), dataTypeContext(3), description(4), displayName(5), flags(6), precision(7)
      name: _raw[0],
      category: _raw[1],
      dataType: _raw[2],
      dataTypeContext: _raw[3],
      description: _raw[4],
      displayName: _raw[5],
      flags: _raw[6],
      precision: _raw.length > 7 ? _raw[7] : 0
    };
  };

  /**
   * Invokes a callback function for each attribute-id in the model.
   *
   * @example
   *      pdb.enumAttributes(function(attrId, attrDef) {
   *           // attrDef is an object
   *           if (attrDef.name === 'name') {
   *               return true; // return true to stop iteration.
   *           }
   *      })
   * 
   * @param {Function} cb - Callback invoked
   */
  this.enumAttributes = function (cb) {
    for (var i = 1; i < _attrs.length; i++) {
      if (cb(i, this.getAttributeDef(i), _attrs[i]))
      break;
    }
  };


  //See API doc for this.enumObjectProperties below
  /**
   * @param dbId
   * @param cb
   * @private
   */
  function enumObjectPropertiesV1(dbId, cb) {
    //Start offset of this object's properties in the Attribute-Values table
    let propStart = 2 * _offsets[dbId];

    //End offset of this object's properties in the Attribute-Values table
    let propEnd = 2 * _offsets[dbId + 1];

    //Loop over the attribute index - value index pairs for the objects
    //and for each one look up the attribute and the value in their
    //respective arrays.
    for (let i = propStart; i < propEnd; i += 2) {
      let attrId = _avs[i];
      let valId = _avs[i + 1];

      if (cb(attrId, valId))
      break;
    }
  }

  //See API doc for this.enumObjectProperties below
  /**
   * @param dbId
   * @param cb
   * @private
   */
  function enumObjectPropertiesV2(dbId, cb) {
    //v2 variable length encoding. Offsets point into delta+varint encoded a-v pairs per object
    let offset = _offsets[dbId];
    let propEnd = _offsets[dbId + 1];
    let buf = _avs;

    let a = 0;
    while (offset < propEnd) {

      //Inlined version of readVarint
      let b = buf[offset++];
      let value = b & 0x7f;
      let shiftBy = 7;
      while (b & 0x80) {
        b = buf[offset++];
        value |= (b & 0x7f) << shiftBy;
        shiftBy += 7;
      }

      //attribute ID is delta encoded from the previously seen attribute ID, add that back in
      a += value;

      //Inlined version of readVarint
      b = buf[offset++];
      value = b & 0x7f;
      shiftBy = 7;
      while (b & 0x80) {
        b = buf[offset++];
        value |= (b & 0x7f) << shiftBy;
        shiftBy += 7;
      }

      if (cb(a, value))
      break;
    }
  }

  /**
   * Iterates over all properties for a given database id and invokes the supplied callback function.
   *
   * @param {number} dbId - The attribute id.
   * @param {Function} cb - callback function, that receives 2 arguments: attribute-id (`attrId`) and value-id (`valId`). Have the function return `true` to abort iteration.
   *
   */
  this.enumObjectProperties = _isVarint ? enumObjectPropertiesV2 : enumObjectPropertiesV1;


  let _instanceOfCache = {};

  //See API documentation in this.getPropertiesSubsetWithInheritance below
  /**
   * @param dbId
   * @param desiredAttrIds
   * @param dstValIds
   * @private
   */
  function getPropertiesSubsetWithInheritanceV1(dbId, desiredAttrIds, dstValIds) {

    //Start offset of this object's properties in the Attribute-Values table
    let propStart = 2 * _offsets[dbId];

    //End offset of this object's properties in the Attribute-Values table
    let propEnd = 2 * _offsets[dbId + 1];

    let res = [];
    let instanceOfVals = [];
    dstValIds = dstValIds || {};

    //Loop over the attribute index - value index pairs for the objects
    //and for each one look up the attribute and the value in their
    //respective arrays.
    for (let i = propStart; i < propEnd; i += 2) {
      let a = _avs[i];
      let value = _avs[i + 1];

      if (a === _instanceOfAttrId) {
        //remember instanceof inheritance for later
        let iofDbId = _this.getAttrValue(a, value);
        instanceOfVals.push(iofDbId);
      } else {
        if (!desiredAttrIds || desiredAttrIds[a]) {
          dstValIds[a] = value;
          res.push(a);
          res.push(value);
        }
      }
    }

    //Really, we only expect one instanceof inheritance, but
    //it's theoretically possible to have several
    for (let i = 0; i < instanceOfVals.length; i++) {

      let iofDbId = instanceOfVals[i];

      let cached = _instanceOfCache[iofDbId];
      if (!cached) {
        _instanceOfCache[iofDbId] = cached = getPropertiesSubsetWithInheritanceV2(iofDbId);
      }

      for (let j = 0; j < cached.length; j += 2) {
        let a = cached[j];
        let v = cached[j + 1];

        if (desiredAttrIds && !desiredAttrIds[a]) {
          continue;
        }

        if (!dstValIds[a] && !_this.attributeHidden(a)) {
          dstValIds[a] = v;
          res.push(a);
          res.push(v);
        }
      }
    }

    return res;
  }

  //See API documentation in this.getPropertiesSubsetWithInheritance below
  /**
   * @param dbId
   * @param desiredAttrIds
   * @param dstValIds
   * @private
   */
  function getPropertiesSubsetWithInheritanceV2(dbId, desiredAttrIds, dstValIds) {

    //v2 variable length encoding. Offsets point into delta+varint encoded a-v pairs per object
    let offset = _offsets[dbId];
    let propEnd = _offsets[dbId + 1];
    let buf = _avs;

    let res = [];
    let instanceOfVals = [];
    dstValIds = dstValIds || {};

    let a = 0;
    while (offset < propEnd) {

      let b = buf[offset++];
      let value = b & 0x7f;
      let shiftBy = 7;
      while (b & 0x80) {
        b = buf[offset++];
        value |= (b & 0x7f) << shiftBy;
        shiftBy += 7;
      }

      //attribute ID is delta encoded from the previously seen attribute ID, add that back in
      a += value;

      b = buf[offset++];
      value = b & 0x7f;
      shiftBy = 7;
      while (b & 0x80) {
        b = buf[offset++];
        value |= (b & 0x7f) << shiftBy;
        shiftBy += 7;
      }

      if (a === _instanceOfAttrId) {
        //remember instanceof inheritance for later
        let iofDbId = _this.getAttrValue(a, value);
        instanceOfVals.push(iofDbId);
      } else {
        if (!desiredAttrIds || desiredAttrIds[a]) {
          dstValIds[a] = value;
          res.push(a);
          res.push(value);
        }
      }
    }

    //Really, we only expect one instanceof inheritance, but
    //it's theoretically possible to have several
    for (let i = 0; i < instanceOfVals.length; i++) {

      let iofDbId = instanceOfVals[i];

      let cached = _instanceOfCache[iofDbId];
      if (!cached) {
        _instanceOfCache[iofDbId] = cached = getPropertiesSubsetWithInheritanceV2(iofDbId);
      }

      for (let j = 0; j < cached.length; j += 2) {
        let a = cached[j];
        let v = cached[j + 1];

        if (desiredAttrIds && !desiredAttrIds[a]) {
          continue;
        }

        if (!dstValIds[a] && !_this.attributeHidden(a)) {
          dstValIds[a] = v;
          res.push(a);
          res.push(v);
        }
      }
    }

    return res;
  }

  /**
   * Given an object ID, returns the corresponding value IDs for the given list of attribute Ids.
   * Takes into account instance_of inheritance of properties.
   *
   * @param {number} dbId - Integer input object ID
   * @param {object} desiredAttrIds - An optional map of the requested attribute Ids, where desiredAttrIds[attrId] is "truthy".
   *                                  If not provided, all properties will be returned.
   * @param {object} dstValIds - A storage target map, such that dstValIds[attrId] will be the resulting value ID.
   *                             It is the responsibility of the caller to zero initialize this map.
   *
   * @returns {number[]} - A flat list of integers attributeId - valueId pairs. This is in addition to the dstValIds, for cases
   *                        where the object has mutliple properties of the same type, e.g. children, __viewable_in__, etc.
   */
  this.getPropertiesSubsetWithInheritance = _isVarint ? getPropertiesSubsetWithInheritanceV2 : getPropertiesSubsetWithInheritanceV1;

  /**
   * Iterates over the property database and finds all layers.
   *
   * @returns {object}
   */
  this.findLayers = function () {

    // Same format as F2d.js::createLayerGroups()
    var ret = { name: 'root', id: 1, index: 1, children: [], isLayer: false, childCount: 0 };

    // Return early when no Layer attribute is present
    if (_layersAttrId === undefined) {
      return ret;
    }

    // Grab all Layer names
    var layers = [];
    var scope = this;
    this.enumObjects(function (dbId) {
      scope.enumObjectProperties(dbId, function (attrId, valId) {
        if (attrId === _layersAttrId) {
          var layerName = scope.getValueAt(valId);
          if (layers.indexOf(layerName) === -1) {
            layers.push(layerName);
          }
          // We found what we wanted => skip remaining attribs for this object
          return true;
        }
      });
    });

    layers.sort(function (a, b) {
      return a.localeCompare(b, undefined, { sensitivity: 'base', numeric: true });
    });

    // Format output to match F2d.js::createLayerGroups()
    ret.childCount = layers.length;
    ret.children = layers.map(function (layerName, index) {
      return {
        name: layerName,
        index: index + 1,
        id: index + 1,
        isLayer: true
      };
    });

    return ret;
  };

  /**
   * Iterates over all database ids and invokes a callback function.
   *
   * @param {Function} cb - callback function. Receives a single parameter: the database-id. Have the function return true to abort iteration.
   * @param {number} fromId - starting id (inclusive)
   * @param {number} toId - end id (exclusive)
   *
   */
  this.enumObjects = function (cb, fromId, toId) {

    // For a given id, the range in _avs is specified by [offsets[id], _offsets[id+1]].
    // The last element in _offsets is just the range end of the final range.
    var idCount = _offsets.length - 1; //== this.getObjectCount()

    if (typeof fromId === "number") {
      fromId = Math.max(fromId, 1);
    } else {
      fromId = 1;
    }

    if (typeof toId === "number") {
      toId = Math.min(idCount, toId);
    } else {
      toId = idCount;
    }

    for (var id = fromId; id < toId; id++) {
      if (cb(id))
      break;
    }
  };

  this.getAttrChild = function () {
    return _childAttrId;
  };

  this.getAttrParent = function () {
    return _parentAttrId;
  };

  this.getAttrName = function () {
    return _nameAttrId;
  };

  this.getAttrLayers = function () {
    return _layersAttrId;
  };

  this.getAttrInstanceOf = function () {
    return _instanceOfAttrId;
  };

  this.getAttrViewableIn = function () {
    return _viewableInAttrId;
  };

  this.getAttrXref = function () {
    return _externalRefAttrId;
  };

  this.getAttrNodeFlags = function () {
    return _nodeFlagsAttrId;
  };

  /**
   * Checks whether an attribute is hidden or not.
   *
   * @param {number} attrId - The attribute id.
   *
   * @returns {boolean} - true if the attribute is a hidden one.
   */
  this.attributeHidden = function (attrId) {
    var _raw = _attrs[attrId];
    var flags = _raw[6];

    return flags & 1 /*afHidden*/ ||
    attrId == _parentAttrId ||
    attrId == _childAttrId ||
    attrId == _viewableInAttrId ||
    attrId == _externalRefAttrId;
  };

  this._attributeIsBlacklisted = function (attrId) {
    var _raw = _attrs[attrId];
    var name = _raw[0];
    var category = _raw[1];

    // IFC/NWD files contains a Source File property which is typically
    // different between the two versions and cause DiffTool to return noisy diff.
    // Ignore it for diff calculation. 
    if (_PropdbEnums__WEBPACK_IMPORTED_MODULE_2__.IFC_NWD_ITEM_PROPS_BLACKLISTED.hasOwnProperty(category) && _PropdbEnums__WEBPACK_IMPORTED_MODULE_2__.IFC_NWD_ITEM_PROPS_BLACKLISTED[category].indexOf(name) !== -1)
    return true;

    //Dimension properties were added at a later time, so
    //some diffs will fail when comparing a file with vs. file without those.
    //Anyway, it's beter to skip those for diff purposes, since they can have numeric
    //noise and result in spurious diffs.
    //See also: https://git.autodesk.com/fluent/modeldb/commit/584d39d5f85a8d2954da557859bb52c224c402af
    if (_PropdbEnums__WEBPACK_IMPORTED_MODULE_2__.RVT_DIM_PROPS_BLACKLISTED.hasOwnProperty(category) && _PropdbEnums__WEBPACK_IMPORTED_MODULE_2__.RVT_DIM_PROPS_BLACKLISTED[category].indexOf(name) !== -1)
    return true;

    return false;
  };

  /**
   * Checks whether an attribute must be excluded from Diff comparison.
   * @param {Object} propertyFilter - A key-value pair of category and property names to ignore from Diff
   * @param {number} attrId - The attribute id.
   */
  this._ignoreAttribute = function (propertyFilter, attrId) {
    var _raw = _attrs[attrId];
    var name = _raw[0];
    var category = _raw[1];

    return propertyFilter[category] && propertyFilter[category].has(name);
  };

  // Returns parent id of dbId or null if there is none. 
  this.findParent = function (dbId) {

    let parent = null;
    _this.enumObjectProperties(dbId, function (attrId, valId) {
      if (attrId === _parentAttrId) {
        parent = _this.getAttrValue(attrId, valId, true);
      }
    });
    return parent;
  };

  // Helper function for _findDifferences.
  // Finds all attributeIds and valueIds - including inherited ones.
  // Results are pushed to 'result' array as objects { attrId, valId }.
  // Hidden attributes are excluded.
  this._getAttributeAndValueIds = function (dbId, result, propertyFilter) {

    let avList = this.getPropertiesSubsetWithInheritance(dbId);
    let ignorePropertyFlag = propertyFilter && Object.keys(propertyFilter).length >= 1;

    //Convert result to array and sort by attrId so diff can work.
    for (let i = 0; i < avList.length; i += 2) {
      let a = avList[i];

      if (this._attributeIsBlacklisted(a) || this.attributeHidden(a))
      continue;

      // Exclude user-specified properties from diff
      if (ignorePropertyFlag && this._ignoreAttribute(propertyFilter, a))
      continue;

      result.push({
        attrId: a,
        valId: avList[i + 1]
      });
    }

    result.sort(function byIncAtribId(a, b) {
      return a.attrId - b.attrId;
    });
  };

  /* Finds all common dbIds of this and another db for which the properties are not identical.
   * Hidden attributes are excluded.
   *  @param {PropertyDatabase} dbToCompare
   *  @param {Object} [DiffOptions] diffOptions 
   *  @param {function(number)} [onProgress] gets progress values in percent
   *  @returns {Object} 
   * See PropDbLoader.diffProperties for details about diffOptions and return value.
   *
   * NOTE: Current implementation only supports Otg models.
   *
   * @private
   */
  this.findDifferences = function (dbToCompare, diffOptions, onProgress) {

    var result = {
      changedIds: []
    };

    // Optional: Restrict search to the given ids
    var dbIds = diffOptions && diffOptions.dbIds;

    // Optional: Collect details about which props have changed
    var listPropChanges = diffOptions && diffOptions.listPropChanges;
    if (listPropChanges) {
      result.propChanges = [];
    }

    //Optional : Collect user-specified properties to ignore for diff
    let propertyFilter = diffOptions && diffOptions.propertyFilter || {};

    var db1 = this;
    var db2 = dbToCompare;

    // Reused array of { attrId, valId } pairs.
    var propIds1 = [];
    var propIds2 = [];

    // To support instanceOf attributes, we need to recursively check parent attributes/values too. (see getAttributesAndValues)
    // Since the parent of subsequent dbId is often the same, we cache the parent attribs/values that we got from last call.
    // This avoids to do the same check several times and can make diff significantly faster.
    var cachedParentAttribs1 = { result: [], dbId: -1 };
    var cachedParentAttribs2 = { result: [], dbId: -1 };

    var diffObject = function (dbId) {

      // get sorted array of {attrIds, valIds} pairs for both objects
      var i1 = 0;
      var i2 = 0;
      propIds1.length = 0;
      propIds2.length = 0;

      db1._getAttributeAndValueIds(dbId, propIds1, propertyFilter, true, cachedParentAttribs1);
      db2._getAttributeAndValueIds(dbId, propIds2, propertyFilter, true, cachedParentAttribs2);

      if (!propIds1.length || !propIds2.length) {
        // If an array is empty, this dbId does only exist
        // in one of the two dbs, i.e, the whole object was added or removed.
        // We are only interested in prop changes of matching objects.
        return;
      }

      var changeFound = false;

      // array of prop changes for current dbId
      var propChanges = undefined;

      while (i1 < propIds1.length && i2 < propIds2.length) {

        // Note that some values may be undefined if one of the arrays ended.
        var elem1 = propIds1[i1];
        var elem2 = propIds2[i2];
        var a1 = elem1 && elem1.attrId;
        var v1 = elem1 && elem1.valId;
        var a2 = elem2 && elem2.attrId;
        var v2 = elem2 && elem2.valId;

        // If everything is equal, we are done with this attribute
        if (a1 === a2 && v1 === v2) {
          i1++;
          i2++;
          continue;
        }

        // If we get here, the current attribute has changed
        changeFound = true;

        // If no details are requested, we are done with this dbId
        if (!listPropChanges) {
          break;
        }

        // We exploit here that attributeIds in OTG are always sorted in ascending order
        // Therefore, if a1 > a2, we can safely assume that a1 does not exist in iterator2,
        // but possibly vice versa.
        var prop1Missing = a1 === undefined || a1 > a2;
        var prop2Missing = a2 === undefined || a2 > a1;

        var change = undefined;

        // Handle case that property has been added or removed
        if (prop1Missing) {

          // property was added in db2
          change = db2._getObjectProperty(a2, v2);
          change.displayValueB = change.displayValue;
          change.displayValue = undefined;

          // a2 has been detected as added. Skip it and continue.
          i2++;
        } else if (prop2Missing) {

          // property was removed in db2
          change = db1._getObjectProperty(a1, v1);
          change.displayValueB = undefined;

          // a1 has been detected as removed. Skip it and continue.
          i1++;
        } else {
          // attrib exists in both, but value has changed
          change = db1._getObjectProperty(a1, v1);
          change.displayValueB = _this.getAttrValue(a2, v2);

          i1++;
          i2++;
        }

        // If this is the first prop that change, alloc array for it
        if (!propChanges) {
          propChanges = [];
        }

        propChanges.push(change);
      }

      // Collect dbId of modified object
      if (changeFound) {
        result.changedIds.push(dbId);

        // collect correspondign prop change details
        if (listPropChanges) {
          result.propChanges.push(propChanges);
        }
      }
    };

    // Track progress
    var lastPercent = -1;
    var trackProgress = function (idsDone, idsTotal) {
      // Limit calls to 100 - otherwise it would slow-down everything.
      var percent = Math.floor(100 * idsDone / idsTotal);
      if (percent != lastPercent) {
        onProgress && onProgress(percent);
        lastPercent = percent;
      }
    };

    if (dbIds) {
      // diff selected set of Ids
      for (var i = 0; i < dbIds.length; i++) {
        let dbId = dbIds[i];
        diffObject(dbId);
        trackProgress(i, dbIds.length);
      }
    } else {
      // diff all objects
      // Note: We are only searching for common objects that changed. Therefore, the loop
      //       runs only over dbIds that are within the valid range for both.
      var dbIdEnd = Math.min(db1.getObjectCount(), this.getObjectCount());
      for (let dbId = 1; dbId < dbIdEnd; dbId++) {
        diffObject(dbId);
        trackProgress(dbId, dbIdEnd);
      }
    }

    return result;
  };

  this.dtor = function () {
    _attrs = null;
    _offsets = null;
    _avs = null;
    _valuesBlob = null;
    _valuesOffsets = null;
    _idsBlob = null;
    _idsOffsets = null;

    _childAttrId = 0;
    _parentAttrId = 0;
    _nameAttrId = 0;
    _instanceOfAttrId = 0;
    _viewableInAttrId = 0;
    _externalRefAttrId = 0;
    _nodeFlagsAttrId = 0;
  };
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/PropdbEnums.js":
/*!******************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/PropdbEnums.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttributeFlags: () => (/* binding */ AttributeFlags),
/* harmony export */   AttributeType: () => (/* binding */ AttributeType),
/* harmony export */   IFC_NWD_ITEM_PROPS_BLACKLISTED: () => (/* binding */ IFC_NWD_ITEM_PROPS_BLACKLISTED),
/* harmony export */   RVT_DIM_PROPS_BLACKLISTED: () => (/* binding */ RVT_DIM_PROPS_BLACKLISTED),
/* harmony export */   isNumericProperty: () => (/* binding */ isNumericProperty)
/* harmony export */ });
/**
 * Numeric values and their meanings associated to {@link PropertyResult|PropertyResult.type}.
 *
 * @readonly
 * @alias AttributeType
 * @default
 */
var AttributeType =
{
  //Numeric types
  Unknown: 0,
  Boolean: 1,
  Integer: 2,
  Double: 3,
  Float: 4,

  //Special types
  BLOB: 10,
  DbKey: 11, /* represents a link to another object in the database, using database internal ID */

  //String types 
  String: 20,
  LocalizableString: 21,
  DateTime: 22, /* ISO 8601 date */
  GeoLocation: 23, /* LatLonHeight - ISO6709 Annex H string, e.g: "+27.5916+086.5640+8850/" for Mount Everest */
  Position: 24 /* "x y z w" space separated string representing vector with 2,3 or 4 elements*/

  //TODO: Do we need explicit logical types for any others?
};

//Bitmask values for boolean attribute options
var AttributeFlags =
{
  afHidden: 1 << 0, /* Attribute will not be displayed in default GUI property views. */
  afDontIndex: 1 << 1, /* Attribute will not be indexed by the search service. */
  afDirectStorage: 1 << 2, /* Attribute is not worth de-duplicating (e.g. vertex data or dbId reference) */
  afReadOnly: 1 << 3 /* Attribute is read-only (used when writing back to the design model, in e.g. Revit) */
};

//Used by property diff
var RVT_DIM_PROPS_BLACKLISTED = {
  "Dimensions": [
  "Perimeter",
  "Volume",
  "Area",
  "Length",
  "Width",
  "Height"]

};

var IFC_NWD_ITEM_PROPS_BLACKLISTED = {
  "Item": [
  "Source File"]

};


/**
 * Determines if the property types is numeric
 * @param {AttributeType} propertyType 
 * @returns {boolean}
 */
const isNumericProperty = (propertyType) => {
  return [AttributeType.Integer, AttributeType.Double, AttributeType.Float].includes(propertyType);
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/SearchUtils.js":
/*!******************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/SearchUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   binarySearch: () => (/* binding */ binarySearch)
/* harmony export */ });


/**
 * Finds the index of a number in a sorted Array or numbers. 
 * 
 * @param sortedArray Array of sorted numbers to search in.
 * @param key number value to find.
 * @returns index of the value in the array, or -1 if not found.  
 */
function binarySearch(sortedArray, key) {

  let start = 0;
  let end = sortedArray.length - 1;
  let mid;

  while (start <= end)
  {
    mid = (start + end) / 2 | 0;
    if (key === sortedArray[mid])
    return mid;else
    if (key < sortedArray[mid])
    end = mid - 1;else
    start = mid + 1;
  }
  return -1;
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/StringUtils.js":
/*!******************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/StringUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blobToJson: () => (/* binding */ blobToJson),
/* harmony export */   findValueOffsets: () => (/* binding */ findValueOffsets),
/* harmony export */   parseIntArray: () => (/* binding */ parseIntArray),
/* harmony export */   safeUtf8BlobToStr: () => (/* binding */ safeUtf8BlobToStr),
/* harmony export */   subBlobToJson: () => (/* binding */ subBlobToJson),
/* harmony export */   subBlobToJsonInt: () => (/* binding */ subBlobToJsonInt),
/* harmony export */   utf16to8: () => (/* binding */ utf16to8),
/* harmony export */   utf8ArrayToString: () => (/* binding */ utf8ArrayToString),
/* harmony export */   utf8BlobToStr: () => (/* binding */ utf8BlobToStr)
/* harmony export */ });


// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
/* utf.js - UTF-8 <=> UTF-16 convertion
 *
 * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0
 * LastModified: Dec 25 1999
 * This library is free.  You can redistribute it and/or modify it.
 */
function utf8BlobToStr(array, start, length) {
  var out, i, len, c;
  var char2, char3;

  out = '';
  len = length;
  i = 0;
  while (i < len) {
    c = array[start + i++];
    switch (c >> 4) {

      case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:
        // 0xxxxxxx
        out += String.fromCharCode(c);
        break;
      case 12:case 13:
        // 110x xxxx   10xx xxxx
        char2 = array[start + i++];
        out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
        break;
      case 14:
        // 1110 xxxx  10xx xxxx  10xx xxxx
        char2 = array[start + i++];
        char3 = array[start + i++];
        out += String.fromCharCode((c & 0x0F) << 12 |
        (char2 & 0x3F) << 6 |
        (char3 & 0x3F) << 0);
        break;
    }
  }

  return out;
}

/**
 * Safe version of utf8BlobToStr(), where Arrays are used to concatenate chars via join().
 * This function exists because string::operator += crashes on Chrome with large inputs.
 */
function safeUtf8BlobToStr(array, start, length) {
  var out, i, len, c, outArray, count;
  var char2, char3;

  var STR_CVT_LIMIT = 32 * 1024;
  out = '';
  outArray = [];
  len = length;
  count = 0;
  i = 0;
  while (i < len) {
    c = array[start + i++];
    switch (c >> 4) {

      case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:
        // 0xxxxxxx
        outArray.push(String.fromCharCode(c));
        break;
      case 12:case 13:
        // 110x xxxx   10xx xxxx
        char2 = array[start + i++];
        outArray.push(String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F));
        break;
      case 14:
        // 1110 xxxx  10xx xxxx  10xx xxxx
        char2 = array[start + i++];
        char3 = array[start + i++];
        outArray.push(String.fromCharCode((c & 0x0F) << 12 |
        (char2 & 0x3F) << 6 |
        (char3 & 0x3F) << 0));
        break;
    }
    if (++count >= STR_CVT_LIMIT || i >= len) {
      out += outArray.join("");
      outArray.length = 0;
      count = 0;
    }
  }

  return out;
}


function utf16to8(str, array, start) {
  var i, len, c;

  var j = start || 0;
  len = str.length;

  if (array) {
    for (i = 0; i < len; i++) {
      c = str.charCodeAt(i);
      if (c >= 0x0001 && c <= 0x007F) {
        array[j++] = c;
      } else if (c > 0x07FF) {
        array[j++] = 0xE0 | c >> 12 & 0x0F;
        array[j++] = 0x80 | c >> 6 & 0x3F;
        array[j++] = 0x80 | c >> 0 & 0x3F;
      } else {
        array[j++] = 0xC0 | c >> 6 & 0x1F;
        array[j++] = 0x80 | c >> 0 & 0x3F;
      }
    }
  } else {
    //If no output buffer is passed in, estimate the required
    //buffer size and return that.
    for (i = 0; i < len; i++) {
      c = str.charCodeAt(i);
      if (c >= 0x0001 && c <= 0x007F) {
        j++;
      } else if (c > 0x07FF) {
        j += 3;
      } else {
        j += 2;
      }
    }
  }

  return j - (start || 0);
}


var USE_MANUAL_UTF8 = true;
var SAFE_UTF_LENGTH = 1024 * 1024;

function utf8ArrayToString(array, start, length) {

  if (start === undefined)
  start = 0;
  if (length === undefined)
  length = array.length;

  if (USE_MANUAL_UTF8) {
    if (length > SAFE_UTF_LENGTH) {
      return safeUtf8BlobToStr(array, start, length);
    }
    return utf8BlobToStr(array, start, length);
  } else {
    var encodedString = "";
    for (var i = start, iEnd = start + length; i < iEnd; i++)
    encodedString += String.fromCharCode(array[i]);

    return decodeURIComponent(escape(encodedString));
  }
}

function blobToJson(blob) {

  var decodedString = utf8ArrayToString(blob, 0, blob.length);

  const regex = /\u000e/gi;
  // LMV-6005 Some blobs contained a Shift Out unicode character that could not be parsed by JSON.parse
  // This caused the property data base to not load.
  decodedString = decodedString.replace(regex, '');

  return JSON.parse(decodedString);
}

//parses a piece of json from a given blob (representing an array of json values)
//up to the next comma+newline combo (i.e. array delimiter).
function subBlobToJson(blob, startIndex) {
  if (startIndex === undefined) {
    return '';
  }

  var i = startIndex;

  while (i < blob.length - 1) {
    var c = blob[i];
    if (c == 44 && (blob[i + 1] == 10 || blob[i + 1] == 13)) //comma followed by newline?
      break;
    if (c == 10 || c == 13) //detect newline or line feed
      break;
    i++;
  }

  var decodedString = utf8ArrayToString(blob, startIndex, i - startIndex);
  try {
    return JSON.parse(decodedString);
  } catch (e) {
    console.error("Error parsing property blob to JSON : " + decodedString);
    return decodedString;
  }
}

function subBlobToJsonInt(blob, startIndex) {
  var val = 0;
  var i = startIndex;

  //Check for integers that were serialized as strings.
  //This should not happen, ever, but hey, it does.
  if (blob[i] == 34)
  i++;

  while (i < blob.length - 1) {
    var c = blob[i];
    if (c == 44 && (blob[i + 1] == 10 || blob[i + 1] == 13))
    break;
    if (c == 10 || c == 13 || c == 34)
    break;
    if (c >= 48 && c <= 57)
    val = val * 10 + (c - 48);

    i++;
  }

  return val;
}

//Simple integer array parse -- expects the array in property database
//format, where the array is packed with possibly newline separator,
//but no other white space. Does not do extensive error checking
function parseIntArray(blob, wantSentinel) {

  //find out how many items we have
  var count = 0;
  for (var i = 0, iEnd = blob.length; i < iEnd; i++)
  if (blob[i] == 44) //44 = ','
    count++;

  count++; //last item has no comma after it

  var items = new Uint32Array(count + (wantSentinel ? 1 : 0));

  i = 0;
  var end = blob.length;

  while (blob[i] != 91 && i < end) //91 = '['
  i++;

  if (i == blob.length)
  return null;

  i++;

  var seenDigit = false;
  count = 0;
  var curInt = 0;
  while (i < end) {
    var c = blob[i];
    if (c >= 48 && c <= 57) {//digit
      curInt = 10 * curInt + (c - 48);
      seenDigit = true;
    } else
    if (c == 44 || c == 93) {//',' or ']'
      if (seenDigit) {
        items[count++] = curInt;
        seenDigit = false;
        curInt = 0;
      }
    } else {
      seenDigit = false; //most likely a newline (the only other thing we have in our arrays
      curInt = 0;
    }
    i++;
  }

  return items;
}

//Scans an array of json values (strings, integers, doubles) and finds the
//offset of each value in the array, so that we can later pick off that
//specific value, without parsing the whole (potentially huge) json array up front.
//This expects the input blob to be in the form serialized by the property database
//C++ component -- one value per line. A more sophisticated parser would be needed
//in case the format changes and this assumption is not true anymore.
function findValueOffsets(blob) {

  //first, count how many items we have
  var count = 0;
  var end = blob.length - 1;

  for (var i = 0; i < end; i++) {
    if (blob[i] == 44 && (blob[i + 1] == 10 || blob[i + 1] == 13)) // ',' + newline is the item delimiter
      count++;
  }

  if (!count)
  return null;

  count++; //one for the last item

  var items = new Uint32Array(count);

  i = 0;
  count = 0;

  //find opening [
  while (blob[i] != 91 && i < end) //91 = '['
  i++;

  i++;

  items[count++] = i;
  var seenEol = false;
  while (i < end) {
    if (blob[i] == 10 || blob[i] == 13)
    seenEol = true;else
    if (seenEol) {
      seenEol = false;
      items[count++] = i;
    }

    i++;
  }

  return items;
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/SvfPlacementUtils.js":
/*!************************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/SvfPlacementUtils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculatePlacementWithOffset: () => (/* binding */ calculatePlacementWithOffset),
/* harmony export */   derivePlacementTransform: () => (/* binding */ derivePlacementTransform),
/* harmony export */   initPlacement: () => (/* binding */ initPlacement),
/* harmony export */   transformAnimations: () => (/* binding */ transformAnimations),
/* harmony export */   transformCameraData: () => (/* binding */ transformCameraData)
/* harmony export */ });
/* harmony import */ var _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../wgs/scene/LmvVector3 */ "./src/wgs/scene/LmvVector3.js");
/* harmony import */ var _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../wgs/scene/LmvBox3 */ "./src/wgs/scene/LmvBox3.js");
/* harmony import */ var _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../wgs/scene/LmvMatrix4 */ "./src/wgs/scene/LmvMatrix4.js");





function getUnitScale(unit) {
  //Why are translators not using standard strings for those?!?!?!?
  switch (unit) {
    case 'meter':
    case 'meters':
    case 'm':return 1.0;
    case 'feet and inches':
    case 'foot':
    case 'feet':
    case 'ft':return 0.3048;
    case 'inch':
    case 'inches':
    case 'in':return 0.0254;
    case 'centimeter':
    case 'centimeters':
    case 'cm':return 0.01;
    case 'millimeter':
    case 'millimeters':
    case 'mm':return 0.001;
    default:return 1.0;
  }
}


function isIdentity(mtx) {
  var e = mtx.elements;
  for (var i = 0; i < 4; i++) {
    for (var j = 0; j < 4; j++) {
      if (i === j) {
        if (e[i * 4 + j] !== 1)
        return false;
      } else {
        if (e[i * 4 + j] !== 0)
        return false;
      }
    }
  }

  return true;
}


function derivePlacementTransform(svf, loadContext) {

  // We now will apply overall model transforms, following the following logic:
  //    1) placementTransform = options.placementTransform);
  //    2) placementTransform = placementTransform.multiply(scalingTransform);
  //    3) placementTransform = placementTransform.multiply(refPointTransform);
  // This is for aggregation scenarios, where multiple models are loaded into the scene
  // In such scenarios the client will most probably manually override the model units


  //First, take the input placement transform as is (could be null).
  svf.placementTransform = loadContext.placementTransform;

  // If requested in the load options, apply scaling from optional 'from' to 'to' units.
  // If unpecified, then units will be read from the models metadata.
  // * usage overloads
  //      options.appyScaling: { from: 'ft', to: 'm' }
  //      options.appyScaling: 'm'   ( equivalent to { to: 'm' })
  // * this is aimed at multiple 3D model situations where models potentialy have different units, but
  //   one  doesn't up-front know what these units are.It also allows overriding of such units.
  // * Model methods: getUnitString , getUnitScale &  getDisplayUnit will be automatically return corrected values
  //   as long as there are no additional options.placementTransform scalings applied.
  if (loadContext.applyScaling) {

    // default 'from' & 'to'  units are from metadata, or 'm' not present
    var scalingFromUnit = 'm';
    if (svf.metadata["distance unit"]) {
      scalingFromUnit = svf.metadata["distance unit"]["value"];
    }
    svf.scalingUnit = scalingFromUnit;

    if ('object' === typeof loadContext.applyScaling) {
      if (loadContext.applyScaling.from) {
        scalingFromUnit = loadContext.applyScaling.from;
      }
      if (loadContext.applyScaling.to) {
        svf.scalingUnit = loadContext.applyScaling.to;
      }
    } else {
      svf.scalingUnit = loadContext.applyScaling;
    }


    // Work out overall desired scaling factor.
    var scalingFactor = getUnitScale(scalingFromUnit) / getUnitScale(svf.scalingUnit);

    if (1 != scalingFactor) {

      var placementS = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4(true);

      var scalingTransform = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4(true);
      scalingTransform.elements[0] = scalingFactor;
      scalingTransform.elements[5] = scalingFactor;
      scalingTransform.elements[10] = scalingFactor;

      if (loadContext.placementTransform) {
        // There may well already be a placementTransform from previous options/operations.
        placementS.copy(loadContext.placementTransform);

      }

      // Combine (optional) placementTransform with scaling
      if (loadContext.applyPlacementInModelUnits) {
        // Apply placementMatrix first, then scale to viewer world units. In this way,
        // the placementMatrix is handled in the same way as a refPointTransform.
        loadContext.placementTransform = scalingTransform.multiply(placementS);
      } else {
        // Apply unitScaling first, then placementTransform
        loadContext.placementTransform = placementS.multiply(scalingTransform);
      }
      svf.placementTransform = loadContext.placementTransform;

      // Store scalingFactor, so that we know which unitScaling was applied to this model.
      // Multiplying with this factor converts model file units to viewer world units.
      svf.scalingFactor = scalingFactor;
    }
  }


  var custom_values = svf.metadata["custom values"];

  if (custom_values && custom_values.refPointTransform) {

    svf.refPointTransform = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4(true);
    var e = svf.refPointTransform.elements;
    var src = custom_values.refPointTransform;

    e[0] = src[0];
    e[1] = src[1];
    e[2] = src[2];

    e[4] = src[3];
    e[5] = src[4];
    e[6] = src[5];

    e[8] = src[6];
    e[9] = src[7];
    e[10] = src[8];

    e[12] = src[9];
    e[13] = src[10];
    e[14] = src[11];

  } else {
    //Is there an extra offset specified in the georeference?
    //This is important when aggregating Revit models from the same Revit
    //project into the same scene, because Revit SVFs use RVT internal coordinates, which
    //need extra offset to get into the world space.
    var georeference = svf.metadata["georeference"];
    var refPointLMV = georeference && georeference["refPointLMV"];

    var angle = 0;
    if (custom_values && custom_values.hasOwnProperty("angleToTrueNorth")) {
      angle = Math.PI / 180.0 * custom_values["angleToTrueNorth"];
    }

    if (refPointLMV || angle) {

      var rotation = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4(true);
      var m = rotation.elements;
      m[0] = m[5] = Math.cos(angle);
      m[1] = -Math.sin(angle);
      m[4] = Math.sin(angle);

      //refPointLMV is given in model local coordinates, hence the negation needed
      //to make the translation go from local to shared coordinates.
      var offset = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4(true);
      m = offset.elements;
      if (refPointLMV) {
        m[12] = -refPointLMV[0];
        m[13] = -refPointLMV[1];
        m[14] = -refPointLMV[2];
      }

      //Compose the rotation and offset.
      svf.refPointTransform = rotation.multiply(offset);
    }
  }

  //If request in the load options, apply the reference point transform when loading the model
  if (loadContext.applyRefPoint && svf.refPointTransform) {

    var placement = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4(true);

    //Normally we expect the input placement transform to come in as identity in case
    //we have it specified in the georef here, but, whatever, let's be thorough for once.
    if (loadContext.placementTransform)
    placement.copy(loadContext.placementTransform);

    placement.multiply(svf.refPointTransform);

    svf.placementTransform = loadContext.placementTransform = placement;

  } else if (!loadContext.applyRefPoint && loadContext.placementTransform) {

    //In case we are given a placement transform that overrides the icoming refPointTransform

    svf.placementTransform = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4(true).copy(loadContext.placementTransform);

  }

  if (svf.placementTransform && isIdentity(svf.placementTransform))
  svf.placementTransform = null;

  return svf.placementTransform;
}

function calculatePlacementWithOffset(svf, pt) {
  var go = svf.globalOffset;
  if (go.x || go.y || go.z) {
    if (!pt) {
      pt = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4(true);
      pt.makeTranslation(-go.x, -go.y, -go.z);
    } else {
      var pt2 = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4(true);
      pt2.copy(pt);
      pt = pt2;
      pt.elements[12] -= go.x;
      pt.elements[13] -= go.y;
      pt.elements[14] -= go.z;
    }

    svf.placementWithOffset = pt;
  } else {
    svf.placementWithOffset = pt;
  }
}

function initPlacement(svf, loadContext) {

  if (!svf.metadata)
  return;

  //Retrieve world bounding box
  var bbox = svf.metadata["world bounding box"];
  var min = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(bbox.minXYZ[0], bbox.minXYZ[1], bbox.minXYZ[2]);
  var max = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(bbox.maxXYZ[0], bbox.maxXYZ[1], bbox.maxXYZ[2]);
  svf.bbox = new _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_1__.LmvBox3(min, max);
  svf.modelSpaceBBox = svf.bbox.clone();

  var pt = derivePlacementTransform(svf, loadContext);
  if (pt && !svf.bbox.isEmpty()) {
    svf.bbox.applyMatrix4(pt);
  }

  //Global offset is used to avoid floating point precision issues for models
  //located enormous distances from the origin. The default is to move the model to the origin
  //but it can be overridden in case of model aggregation scenarios, where multiple
  //models are loaded into the scene and a common offset is needed for all.
  if (loadContext.globalOffset) {
    // Apply user-defined globalOffset
    svf.globalOffset = loadContext.globalOffset;
  } else {
    // Choose global offset automatically at the center of the placmenent transformed model. 
    svf.globalOffset = svf.bbox.getCenter(new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3());
  }

  calculatePlacementWithOffset(svf, pt);

  // The model boundingBox must finally be in viewer-coords, just like everything else. I.e. with subtracted offset.
  // Therefore, we have to subtract the globaloffset from bbox as well.
  if (!svf.bbox.isEmpty()) {
    svf.bbox.min.sub(svf.globalOffset);
    svf.bbox.max.sub(svf.globalOffset);
  }

  if (svf.metadata.hasOwnProperty("double sided geometry") &&
  svf.metadata["double sided geometry"]["value"]) //TODO: do we want to check the global flag or drop that and rely on material only?
    {
      svf.doubleSided = true;
    }

}

function applyOffset(a, offset) {
  a[0] -= offset.x;
  a[1] -= offset.y;
  a[2] -= offset.z;
}


function transformAnimations(svf) {

  if (!svf.animations)
  return;

  // apply global offset to animations
  var animations = svf.animations["animations"];
  if (animations) {
    var globalOffset = svf.globalOffset;
    var t = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4().makeTranslation(globalOffset.x, globalOffset.y, globalOffset.z);
    var tinv = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4().makeTranslation(-globalOffset.x, -globalOffset.y, -globalOffset.z);
    var r = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4();
    var m = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_2__.LmvMatrix4();
    for (var a = 0; a < animations.length; a++) {
      var anim = animations[a];
      if (anim.hierarchy) {
        for (var h = 0; h < anim.hierarchy.length; h++) {
          var keys = anim.hierarchy[h].keys;
          if (keys) {
            for (var k = 0; k < keys.length; k++) {
              var pos = keys[k].pos;
              if (pos) {
                var offset = globalOffset;
                var rot = keys[k].rot;
                if (rot) {
                  r.makeRotationFromQuaternion({ x: rot[0], y: rot[1], z: rot[2], w: rot[3] });
                  m.multiplyMatrices(t, r).multiply(tinv);
                  offset = { x: m.elements[12], y: m.elements[13], z: m.elements[14] };
                }
                applyOffset(pos, offset);
              }
              var target = keys[k].target;
              if (target) {
                applyOffset(target, globalOffset);
              }
              var points = keys[k].points;
              if (points) {
                for (var p = 0; p < points.length; p++) {
                  applyOffset(points[p], globalOffset);
                }
              }
            }
          }
        }
      }
    }
  }
}

// Apply transform (if any) to given camera data with { position, target, up, orthoScale }
function transformCameraData(cam, transform) {

  if (!transform) {
    return;
  }

  transform.transformPoint(cam.position);
  transform.transformPoint(cam.target);
  transform.transformDirection(cam.up);

  // If the placement includes scaling (either by unit scaling or manually included 
  // in the placement transform), orthoScale values need to be scaled as well.
  //
  // Note: We don't support non-uniform scaling well. However, home-views cannot be recovered
  //       anyway if the model is distorted with non-uniform transforms.
  if (isFinite(cam.orthoScale)) {
    const scale = transform.getMaxScaleOnAxis();
    cam.orthoScale *= scale;
  }
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/VbUtils.js":
/*!**************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/VbUtils.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VBUtils: () => (/* binding */ VBUtils)
/* harmony export */ });



const VBUtils = {


  deduceUVRepetition: function (mesh) {

    for (var p in mesh.vblayout) {

      if (p.indexOf("uv") != 0 || p.indexOf("uvw") == 0)
      continue;

      var baseOffset = mesh.vblayout[p].offset;
      var floatStride = mesh.vbstride;
      var vbf = mesh.vb;
      var vcount = mesh.vb.length / floatStride;

      for (var i = 0, offset = baseOffset; i < vcount; i++, offset += floatStride)
      {
        var u = vbf[offset];
        var v = vbf[offset + 1];
        if (u > 2 || u < 0 || v > 2 || v < 0) {
          mesh.vblayout[p].isPattern = true;
          break;
        }
      }
    }
  },


  //Calculate the 3D bounding box and bounding sphere
  //of a mesh containing an interleaved vertex buffer
  computeBounds3D: function (mesh) {

    var minx = Infinity,miny = Infinity,minz = Infinity;
    var maxx = -Infinity,maxy = -Infinity,maxz = -Infinity;
    var i, offset, x, y, z;

    var floatStride = mesh.vbstride;
    var baseOffset = mesh.vblayout.position.offset;
    var vbf = mesh.vb;
    var vcount = mesh.vb.length / floatStride;

    for (i = 0, offset = baseOffset; i < vcount; i++, offset += floatStride)
    {
      x = vbf[offset];
      y = vbf[offset + 1];
      z = vbf[offset + 2];

      if (minx > x) minx = x;
      if (miny > y) miny = y;
      if (minz > z) minz = z;

      if (maxx < x) maxx = x;
      if (maxy < y) maxy = y;
      if (maxz < z) maxz = z;
    }

    var bb = mesh.boundingBox = {
      min: { x: minx, y: miny, z: minz },
      max: { x: maxx, y: maxy, z: maxz }
    };

    var cx = 0.5 * (minx + maxx),cy = 0.5 * (miny + maxy),cz = 0.5 * (minz + maxz);

    var bs = mesh.boundingSphere = {};
    bs.center = { x: cx, y: cy, z: cz };

    var maxRadiusSq = 0;
    for (i = 0, offset = baseOffset; i < vcount; i++, offset += floatStride) {

      x = vbf[offset];
      y = vbf[offset + 1];
      z = vbf[offset + 2];

      var dx = x - cx;
      var dy = y - cy;
      var dz = z - cz;
      var distsq = dx * dx + dy * dy + dz * dz;
      if (distsq > maxRadiusSq)
      maxRadiusSq = distsq;
    }

    bs.radius = Math.sqrt(maxRadiusSq);

  },

  bboxUnion: function (bdst, bsrc) {
    if (bsrc.min.x < bdst.min.x)
    bdst.min.x = bsrc.min.x;
    if (bsrc.min.y < bdst.min.y)
    bdst.min.y = bsrc.min.y;
    if (bsrc.min.z < bdst.min.z)
    bdst.min.z = bsrc.min.z;

    if (bsrc.max.x > bdst.max.x)
    bdst.max.x = bsrc.max.x;
    if (bsrc.max.y > bdst.max.y)
    bdst.max.y = bsrc.max.y;
    if (bsrc.max.z > bdst.max.z)
    bdst.max.z = bsrc.max.z;
  }

};

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/VertexBufferBuilder.js":
/*!**************************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/VertexBufferBuilder.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VertexBufferBuilder: () => (/* binding */ VertexBufferBuilder)
/* harmony export */ });



var TAU = Math.PI * 2;

var VBB_GT_TRIANGLE_INDEXED = 0,
  VBB_GT_LINE_SEGMENT = 1,
  VBB_GT_ARC_CIRCULAR = 2,
  VBB_GT_ARC_ELLIPTICAL = 3,
  VBB_GT_TEX_QUAD = 4,
  VBB_GT_ONE_TRIANGLE = 5,
  VBB_GT_MSDF_TRIANGLE_INDEXED = 6,
  VBB_GT_TEX_TRIANGLE_INDEXED = 7,
  VBB_GT_LINE_SEGMENT_CAPPED = 8,
  VBB_GT_LINE_SEGMENT_CAPPED_START = 9,
  VBB_GT_LINE_SEGMENT_CAPPED_END = 10,
  VBB_GT_LINE_SEGMENT_MITER = 11;

var VBB_INSTANCED_FLAG = 0, // this is intentionally 0 for the instancing case!
  VBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!
  VBB_SEG_START_LEFT = 1,
  VBB_SEG_END_RIGHT = 2,
  VBB_SEG_END_LEFT = 3;

var VBB_COLOR_OFFSET = 6,
  VBB_DBID_OFFSET = 7,
  VBB_FLAGS_OFFSET = 8,
  VBB_LAYER_VP_OFFSET = 9;

var QUAD_TRIANGLE_INDICES = [0, 1, 3, 0, 3, 2];

// align changes here with the uniforms in LineShaderSS.js!!!
var VBB_MITER_SEGMENT_SCALE_FACTOR = 1023.0;
var VBB_MITER_SEGMENT_CP = 65536.0;

// VBB_MITER_SEGMENT_SCALE_FACTOR * VBB_MITER_SEGMENT_MAX < VBB_MITER_SEGMENT_CP
var VBB_MITER_SEGMENT_MAX = 64.0;

function VertexBufferBuilder(useInstancing, allocSize, fullCount, useCompactBuffers)
{
  var MAX_VCOUNT = allocSize || 65536;
  this.FULL_COUNT = (fullCount || 32767) | 0;

  this.useInstancing = useInstancing;
  this.useCompactBuffers = useCompactBuffers;

  this.stride = 10;
  this.allocVcount = 4 * (this.useInstancing ? MAX_VCOUNT / 4 : MAX_VCOUNT);

  this.vb = new ArrayBuffer(this.stride * this.allocVcount);
  this.vbf = new Float32Array(this.vb);
  this.vbi = new Int32Array(this.vb);
  this.ib = this.useInstancing ? null : new Uint16Array(MAX_VCOUNT);
  this.minLineWidth = Number.MAX_VALUE;
  this.reset(0);

}

VertexBufferBuilder.prototype.reset = function (vcount) {
  // This is used to restore the vcount when restoring stream state as well as at init time.
  this.vcount = vcount;

  this.icount = 0;

  this.minx = this.miny = Infinity;
  this.maxx = this.maxy = -Infinity;

  //Keeps track of objectIds referenced by geometry in the VB
  this.dbIds = {};
  this.lastDbId = null;

  //Keep track of unique colors used by this VB
  this.colors = {};

  this.numEllipticals = 0;
  this.numCirculars = 0;
  this.numTriangleGeoms = 0;
  this.numMiterLines = 0;

  // If false, all lines are of type 0 (solid), so that we don't need line-pattern support.
  this.hasLineStyles = false;

  //Certain fields can be invariant over large numbers of primitives.
  //We keep track of those in order to optimize the vertex layout by
  //pulling invariants into shader uniforms.
  this.changeTracking = {};

  this.stride = 10;
};

VertexBufferBuilder.prototype.expandStride = function ()
{
  //Currently hardcoded to expand by 4 floats.
  var expandBy = 2;

  var stride = this.stride;

  if (stride >= 12)
  return;

  var nstride = this.stride + expandBy;

  var nvb = new ArrayBuffer(nstride * this.allocVcount);

  var src = new Uint8Array(this.vb);
  var dst = new Uint8Array(nvb);

  for (var i = 0, iEnd = this.vcount; i < iEnd; i++) {
    var os = i * stride * 4;
    var od = i * nstride * 4;

    for (var j = 0; j < stride * 4; j++)
    dst[od + j] = src[os + j];
  }

  this.vb = nvb;
  this.vbf = new Float32Array(nvb);
  this.vbi = new Int32Array(nvb);
  this.stride = nstride;

};

VertexBufferBuilder.prototype.addToBounds = function (x, y)
{
  if (x < this.minx) this.minx = x;
  if (x > this.maxx) this.maxx = x;
  if (y < this.miny) this.miny = y;
  if (y > this.maxy) this.maxy = y;
};

var _toInt32 = new Int32Array(1);
function toInt32(c) {
  _toInt32[0] = c;
  return _toInt32[0];
}

VertexBufferBuilder.prototype.trackChanges = function (geomType, color, dbId, layerId, vpId, linePattern) {

  if (dbId !== this.lastDbId) {
    this.dbIds[toInt32(dbId)] = 1;
    this.lastDbId = dbId;
  }

  if (linePattern) {
    this.hasLineStyles = true;
  }

  if (!this.useCompactBuffers)
  return;

  var ct = this.changeTracking;

  function checkOne(whichAttr, val) {
    if (ct[whichAttr] === undefined)
    ct[whichAttr] = geomType;else
    if (ct[whichAttr] === val)
    ct[whichAttr + "Varies"] = true;
  }

  checkOne("geomType", geomType);
  checkOne("color", color);
  checkOne("dbId", dbId);
  checkOne("layerId", layerId);
  checkOne("viewportId", vpId);
  checkOne("linePattern", linePattern);

  this.colors[toInt32(color)] = 1;
};


VertexBufferBuilder.prototype.setCommonVertexAttribs = function (offset, vertexId, geomType, color, dbId, layerId, vpId, linePattern)
{
  this.trackChanges(geomType, color, dbId, layerId, vpId, linePattern);

  // align changes here with the "decodeCommonAttribs()" function in LineShader.js and VertexBufferReader.js!!!
  vertexId = vertexId & 0xff; //  8 bit
  geomType = geomType & 0xff; //  8 bit
  linePattern = linePattern & 0xff; //  8 bit
  layerId = layerId & 0xffff; // 16 bit
  vpId = vpId & 0xffff; // 16 bit

  this.vbi[offset + VBB_FLAGS_OFFSET] = vertexId | geomType << 8 | linePattern << 16; // vertexId: int8; geomType: int8; linePattern: int8; ghostingFlag: int8
  this.vbi[offset + VBB_COLOR_OFFSET] = color;
  this.vbi[offset + VBB_DBID_OFFSET] = dbId;
  this.vbi[offset + VBB_LAYER_VP_OFFSET] = layerId | vpId << 16; // layerId: int16; vpId: int16
};

//Creates a non-indexed triangle geometry vertex (triangle vertex coords stored in single vertex structure)
VertexBufferBuilder.prototype.addVertexTriangleGeom = function (x1, y1, x2, y2, x3, y3, color, dbId, layerId, vpId)
{
  var vi = this.vcount;
  var vbf = this.vbf;

  var repeat = this.useInstancing ? 1 : 4;
  for (var i = 0; i < repeat; i++) {
    var offset = (vi + i) * this.stride;

    // align changes here with the "decodeTriangleData()" function in LineShader.js!!!
    vbf[offset] = x1;
    vbf[offset + 1] = y1;
    vbf[offset + 2] = x2;

    vbf[offset + 3] = y2;
    vbf[offset + 4] = x3;
    vbf[offset + 5] = y3;

    this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, VBB_GT_ONE_TRIANGLE, color, dbId, layerId, vpId, /*linePattern*/0);
    this.vcount++;
  }

  return vi;
};


VertexBufferBuilder.prototype.addVertexLine = function (x, y, angle, distanceAlong, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType, buttCapStart, buttCapEnd)
{
  var vi = this.vcount;
  var vbf = this.vbf;

  if (dbId >= 0 && lineWidth > 0 && distanceAlong > 0) {
    this.minLineWidth = Math.min(this.minLineWidth, lineWidth);
  }

  var geomType = VBB_GT_LINE_SEGMENT;
  if (buttCapStart && buttCapEnd) {
    geomType = VBB_GT_LINE_SEGMENT_CAPPED;
  } else
  if (buttCapStart) {
    geomType = VBB_GT_LINE_SEGMENT_CAPPED_START;
  } else
  if (buttCapEnd) {
    geomType = VBB_GT_LINE_SEGMENT_CAPPED_END;
  }

  var repeat = this.useInstancing ? 1 : 4;
  for (var i = 0; i < repeat; i++) {
    var offset = (vi + i) * this.stride;

    // align changes here with the "decodeSegmentData()" function in LineShader.js and VertexBufferReader!!!
    vbf[offset] = x;
    vbf[offset + 1] = y;
    vbf[offset + 2] = (angle + Math.PI) / TAU;

    vbf[offset + 3] = distanceAlong;
    vbf[offset + 4] = lineWidth * 0.5; // we are storing only the half width (i.e., the radius)
    vbf[offset + 5] = totalDistance;

    this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, geomType, color, dbId, layerId, vpId, lineType);
    this.vcount++;
  }

  return vi;
};

VertexBufferBuilder.prototype.addVertexMiterLine = function (x, y, angle, anglePrev, angleNext, distanceAlong, distanceAlongPN, lineWidth, color, dbId, layerId, vpId, lineType)
{
  var vi = this.vcount;
  var vbf = this.vbf;

  if (dbId >= 0 && lineWidth > 0) {
    this.minLineWidth = Math.min(this.minLineWidth, lineWidth);
  }

  var repeat = this.useInstancing ? 1 : 4;
  for (var i = 0; i < repeat; i++) {
    var offset = (vi + i) * this.stride;

    // align changes here with the "decodeMiterSegment()" function in LineShaderSS.js!!!
    vbf[offset] = x;
    vbf[offset + 1] = y;
    vbf[offset + 2] = (angle + Math.PI) / TAU;

    vbf[offset + 3] = distanceAlong;
    vbf[offset + 4] = lineWidth * 0.5; // we are storing only the half width (i.e., the radius)
    vbf[offset + 5] = (anglePrev + Math.PI) / TAU;

    vbf[offset + 10] = (angleNext + Math.PI) / TAU;
    vbf[offset + 11] = distanceAlongPN;

    this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, VBB_GT_LINE_SEGMENT_MITER, color, dbId, layerId, vpId, lineType);
    this.vcount++;
  }

  return vi;
};

VertexBufferBuilder.prototype.addVertexTexQuad = function (centerX, centerY, width, height, rotation, color, dbId, layerId, vpId)
{
  var vi = this.vcount;
  var vbf = this.vbf;

  var repeat = this.useInstancing ? 1 : 4;
  for (var i = 0; i < repeat; i++) {
    var offset = (vi + i) * this.stride;

    // align changes here with the "decodeTexQuadData()" function in LineShader.js!!!
    vbf[offset] = centerX;
    vbf[offset + 1] = centerY;
    vbf[offset + 2] = rotation / TAU;

    vbf[offset + 3] = width;
    vbf[offset + 4] = height;

    this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, VBB_GT_TEX_QUAD, color, dbId, layerId, vpId, /*linePattern*/0);
    this.vcount++;
  }

  return vi;
};


VertexBufferBuilder.prototype.addVertexArc = function (x, y, startAngle, endAngle, major, minor, tilt, lineWidth, color, dbId, layerId, vpId)
{
  var vi = this.vcount;
  var vbf = this.vbf;

  var geomType = major == minor ? VBB_GT_ARC_CIRCULAR : VBB_GT_ARC_ELLIPTICAL;

  var repeat = this.useInstancing ? 1 : 4;
  for (var i = 0; i < repeat; i++) {
    var offset = (vi + i) * this.stride;

    // align changes here with the "decodeArcData()" function in LineShader.js!!!
    vbf[offset] = x;
    vbf[offset + 1] = y;
    vbf[offset + 2] = startAngle / TAU;

    vbf[offset + 3] = endAngle / TAU;
    vbf[offset + 4] = lineWidth * 0.5; // we are storing only the half width (i.e., the radius)
    vbf[offset + 5] = major; // = radius for circular arcs

    if (geomType === VBB_GT_ARC_ELLIPTICAL) {
      vbf[offset + 10] = minor;
      vbf[offset + 11] = tilt;
    }

    this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, geomType, color, dbId, layerId, vpId, /*linePattern*/0);
    this.vcount++;
  }

  return vi;
};




//====================================================================================================
//====================================================================================================
// Indexed triangle code path can only be used when hardware instancing is not in use.
// Otherwise, the addTriangleGeom operation should be used to add simple triangles to the buffer.
//====================================================================================================
//====================================================================================================

VertexBufferBuilder.prototype.addVertex = function (x, y, color, dbId, layerId, vpId)
{let flag = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : VBB_GT_TRIANGLE_INDEXED;
  if (this.useInstancing)
  return; //not supported if instancing is used.

  var vi = this.vcount;
  var offset = this.stride * vi;
  var vbf = this.vbf;

  // align changes here with the "decodeTriangleData()" function in LineShader.js!!!
  vbf[offset] = x;
  vbf[offset + 1] = y;

  this.setCommonVertexAttribs(offset, /*vertexId*/0, flag, color, dbId, layerId, vpId, /*linePattern*/0);
  this.vcount++;

  return vi;
};


VertexBufferBuilder.prototype.addVertexPolytriangle = function (x, y, color, dbId, layerId, vpId)
{
  if (this.useInstancing)
  return; //not supported if instancing is used.

  this.addVertex(x, y, color, dbId, layerId, vpId);

  this.addToBounds(x, y);
};

VertexBufferBuilder.prototype.addVertexMSDFPolytriangle = function (x, y, u, v, color, dbId, layerId, vpId)
{
  this.addVertexTexPolytriangle(x, y, u, v, color, dbId, layerId, vpId, VBB_GT_MSDF_TRIANGLE_INDEXED);
};

VertexBufferBuilder.prototype.addIndices = function (indices, vindex) {

  if (this.useInstancing)
  return; //not supported if instancing is used.

  var ib = this.ib;
  var ii = this.icount;

  if (ii + indices.length >= ib.length) {
    var ibnew = new Uint16Array(Math.max(indices.length, ib.length) * 2);
    for (var i = 0; i < ii; ++i) {
      ibnew[i] = ib[i];
    }
    this.ib = ib = ibnew;
  }

  for (var i = 0; i < indices.length; ++i) {
    ib[ii + i] = vindex + indices[i];
  }

  this.icount += indices.length;
};

//====================================================================================================
//====================================================================================================
// End indexed triangle code path.
//====================================================================================================
//====================================================================================================


VertexBufferBuilder.prototype.finalizeQuad = function (vindex)
{
  if (!this.useInstancing) {
    this.addIndices(QUAD_TRIANGLE_INDICES, vindex);
  }
};


VertexBufferBuilder.prototype.addSegment = function (x1, y1, x2, y2, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType, buttCapStart, buttCapEnd)
{
  var dx = x2 - x1;
  var dy = y2 - y1;
  var angle = dx || dy ? Math.atan2(dy, dx) : 0.0;
  var segLen = dx || dy ? Math.sqrt(dx * dx + dy * dy) : 0.0;

  //Add four vertices for the bbox of this line segment
  //This call sets the stuff that's common for all four
  var v = this.addVertexLine(x1, y1, angle, segLen, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType, buttCapStart, buttCapEnd);

  this.finalizeQuad(v);
  this.addToBounds(x1, y1);
  this.addToBounds(x2, y2);
};

VertexBufferBuilder.prototype.addMiterSegment = function (x1, y1, x2, y2, x3, y3, x4, y4, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType, buttCapStart, buttCapEnd)
{
  if (this.useCompactBuffers) {
    this.addSegment(x2, y2, x3, y3, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType, buttCapStart, buttCapEnd);
    return;
  }

  this.numMiterLines++;

  //Miter segments need large vertex layout
  this.expandStride();

  //Primary segment to be drawn
  var dx2 = x3 - x2;
  var dy2 = y3 - y2;
  var angle = dx2 || dy2 ? Math.atan2(dy2, dx2) : 0.0;
  var segLen = dx2 || dy2 ? Math.sqrt(dx2 * dx2 + dy2 * dy2) : 0.0;

  //Supporting segments (previous + next) to calculate miter joints
  var dx = x2 - x1;
  var dy = y2 - y1;
  var anglePrev = dx || dy ? Math.atan2(dy, dx) : angle;
  var segLenPrev = dx || dy ? Math.sqrt(dx * dx + dy * dy) : 1.0;

  var dx3 = x4 - x3;
  var dy3 = y4 - y3;
  var angleNext = dx3 || dy3 ? Math.atan2(dy3, dx3) : angle;
  var segLenNext = dx3 || dy3 ? Math.sqrt(dx3 * dx3 + dy3 * dy3) : 1.0;

  // Compress previous and next seg length to fit into one float, loses precision.
  var prev = Math.floor(Math.min(VBB_MITER_SEGMENT_MAX, segLenPrev) * VBB_MITER_SEGMENT_SCALE_FACTOR);
  var next = Math.floor(Math.min(VBB_MITER_SEGMENT_MAX, segLenNext) * VBB_MITER_SEGMENT_SCALE_FACTOR);
  var segLenPN = next * VBB_MITER_SEGMENT_CP + prev;

  //Add four vertices for the bbox of this line segment
  //This call sets the stuff that's common for all four
  var v = this.addVertexMiterLine(x2, y2, angle, anglePrev, angleNext, segLen, segLenPN, lineWidth, color, dbId, layerId, vpId, lineType);

  this.finalizeQuad(v);
  this.addToBounds(x2, y2);
  this.addToBounds(x3, y3);
};


//Creates a non-indexed triangle geometry (triangle vertex coords stored in single vertex structure)
VertexBufferBuilder.prototype.addTriangleGeom = function (x1, y1, x2, y2, x3, y3, color, dbId, layerId, vpId)
{
  this.numTriangleGeoms++;

  var v = this.addVertexTriangleGeom(x1, y1, x2, y2, x3, y3, color, dbId, layerId, vpId);

  this.finalizeQuad(v);
  this.addToBounds(x1, y1);
  this.addToBounds(x2, y2);
  this.addToBounds(x3, y3);
};

VertexBufferBuilder.prototype.addArc = function (cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layerId, vpId)
{
  if (major == minor) {
    this.numCirculars++;
  } else {
    this.numEllipticals++;

    //Ellipticals need large vertex layout
    this.expandStride();
  }

  // This is a workaround, when the circular arc has rotation, the extractor cannot handle it.
  // After the fix is deployed in extractor, this can be removed.
  var result = fixUglyArc(start, end);
  start = result.start;
  end = result.end;

  //If both start and end angles are exactly 0, it's a complete ellipse/circle
  //This is working around a bug in the F2D writer, where an fmod operation will potentially.
  //convert 2pi to 0.
  if (start == 0 && end == 0)
  end = TAU;

  //Add two zero length segments as round caps at the end points
  {
    //If it's a full ellipse, then we don't need caps
    var range = Math.abs(start - end);
    if (range > 0.0001 && Math.abs(range - TAU) > 0.0001)
    {
      var sx = cx + major * Math.cos(start);
      var sy = cy + minor * Math.sin(start);
      this.addSegment(sx, sy, sx, sy, 0, lineWidth, color, dbId, layerId, vpId);

      var ex = cx + major * Math.cos(end);
      var ey = cy + minor * Math.sin(end);
      this.addSegment(ex, ey, ex, ey, 0, lineWidth, color, dbId, layerId, vpId);

      //TODO: also must add all the vertices at all multiples of PI/2 in the start-end range to get exact bounds
    } else

    {
      this.addToBounds(cx - major, cy - minor);
      this.addToBounds(cx + major, cy + minor);
    }

    // Add the center of the circle / ellipse as a single transparent dot - So it wil be snappable.
    const hiddenColor = 0x01ffffff; // Note that lineShader discards fully transparent fragments. Therefore, we use a white here with very small, but nonzero alpha.
    var c = this.addVertexLine(cx, cy, 0, 0.0001, 0, 0, hiddenColor, dbId, layerId, vpId);
    this.finalizeQuad(c);
  }

  var v = this.addVertexArc(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layerId, vpId);

  this.finalizeQuad(v);

  //Testing caps
  if (false) { var ey, ex, sy, sx, range; }
};


VertexBufferBuilder.prototype.addTexturedQuad = function (centerX, centerY, width, height, rotation, color, dbId, layerId, vpId)
{
  //Height is specified using the line weight field.
  //This will result in height being clamped to at least one pixel
  //but that's ok (zero height for an image would be rare).
  var v = this.addVertexTexQuad(centerX, centerY, width, height, rotation, color, dbId, layerId, vpId);

  this.finalizeQuad(v);

  var cos = 0.5 * Math.cos(rotation);
  var sin = 0.5 * Math.sin(rotation);
  var w = Math.abs(width * cos) + Math.abs(height * sin);
  var h = Math.abs(width * sin) + Math.abs(height * cos);
  this.addToBounds(centerX - w, centerY - h);
  this.addToBounds(centerX + w, centerY + h);
};

VertexBufferBuilder.prototype.addVertexImagePolytriangle = function (x, y, u, v, color, dbId, layerId, vpId) {
  return this.addVertexTexPolytriangle(x, y, u, v, color, dbId, layerId, vpId, VBB_GT_TEX_TRIANGLE_INDEXED);
};

VertexBufferBuilder.prototype.addVertexTexPolytriangle = function (x, y, u, v, color, dbId, layerId, vpId, type) {
  if (this.useInstancing)
  return; //not supported if instancing is used.

  let vi = this.vcount;
  let vbf = this.vbf;
  this.addVertex(x, y, color, dbId, layerId, vpId, type);

  // put the UV data into the fields2 attribute
  vbf[vi * this.stride + 2] = u;
  vbf[vi * this.stride + 3] = v;

  this.addToBounds(x, y);
};


VertexBufferBuilder.prototype.isFull = function (addCount)
{
  addCount = addCount || 3;
  var mult = this.useInstancing ? 4 : 1;

  return this.vcount * mult + addCount > this.FULL_COUNT;
};

/**
 * Determines if there are invariant memebers in the vertex layout,
 * which can be moved out to shader uniforms to save space.
 * Determines if uint16 can be used to store positions data
 * @returns {MeshData}
 */
VertexBufferBuilder.prototype.makeCompactVertexLayout = function () {

  var colorKeys = Object.keys(this.colors);
  var dbIdsKeys = Object.keys(this.dbIds);

  // if (this.changeTracking.geomType === VBB_GT_LINE_SEGMENT && !this.changeTracking.geomTypeVaries) {
  //   console.log("Vertex buffer only has lines");
  // }

  // if (this.changeTracking.color === VBB_GT_LINE_SEGMENT && !this.changeTracking.colorVaries) {
  //     console.log("Vertex buffer has invariant color");
  // } else {
  //     console.log("Num colors:", colorKeys.length);
  // }

  // if (!this.changeTracking.viewportIdVaries) {
  //     console.log("Vertex buffer has invariant viewportId");
  // }

  // if (!this.changeTracking.layerIdVaries) {
  //     console.log("Vertex buffer has invariant layerId");
  // }

  // if (!this.changeTracking.dbIdVaries) {
  //     console.log("Vertex buffer has invariant dbId");
  // } else {
  //     console.log("Num dbIds:", dbIdsKeys.length);
  // }

  if (this.stride !== 10)
  return null;

  //create the color/dbId index texture
  var texLen = colorKeys.length + dbIdsKeys.length;

  if (colorKeys.length + dbIdsKeys.length > 65536)
  return null;

  var texData = new Int32Array(texLen + 1);
  texData[0] = 0;
  var count = 1;
  for (var i = 0; i < colorKeys.length; i++, count++) {
    texData[count] = parseInt(colorKeys[i]);
    this.colors[colorKeys[i]] = count;
  }
  for (var i = 0; i < dbIdsKeys.length; i++, count++) {
    texData[count] = parseInt(dbIdsKeys[i]);
    this.dbIds[dbIdsKeys[i]] = count;
  }

  var compactStride = 6;

  var vb = new ArrayBuffer(compactStride * 4 * this.vcount);
  var vbi = new Int32Array(vb);
  var vbs = new Uint16Array(vb);

  var sx = this.maxx - this.minx || 1;
  var sy = this.maxy - this.miny || 1;
  var ox = this.minx;
  var oy = this.miny;
  var ss = Math.max(sx, sy);

  function tx(x) {
    return 0 | Math.round((x - ox) / sx * 65535);
  }

  function ty(y) {
    return 0 | Math.round((y - oy) / sy * 65535);
  }

  function ts(x) {
    return 0 | Math.round(x / ss * 65535);
  }

  function unit(x) {
    return 0 | x * 65535;
  }

  function lineWeight(x) {
    if (x < 0) {
      return 32768 + Math.min(1.0, -x / 1024) * 32767;
    } else {
      // Don't allow non-zero line weights to become 0 because
      // of the compact buffer format.
      return x ? 0 | Math.round(x / ss * 32767) || 1 : x;
    }
  }

  for (var i = 0; i < this.vcount; i++) {

    var srcOffset = this.stride * i;
    var dstOffset = compactStride * i;
    var ushortOffset = dstOffset * 2;

    var gt = this.vbi[srcOffset + VBB_FLAGS_OFFSET] >> 8 & 0xff;

    //Handle data that varies per geometry type and needs scaling
    //to uint16 packing, e.g. positions and angles
    switch (gt) {
      case VBB_GT_TRIANGLE_INDEXED:
        vbs[ushortOffset] = tx(this.vbf[srcOffset]);
        vbs[ushortOffset + 1] = ty(this.vbf[srcOffset + 1]);
        break;

      case VBB_GT_LINE_SEGMENT:
      case VBB_GT_LINE_SEGMENT_CAPPED:
      case VBB_GT_LINE_SEGMENT_CAPPED_START:
      case VBB_GT_LINE_SEGMENT_CAPPED_END:
        vbs[ushortOffset] = tx(this.vbf[srcOffset]);
        vbs[ushortOffset + 1] = ty(this.vbf[srcOffset + 1]);
        vbs[ushortOffset + 2] = unit(this.vbf[srcOffset + 2]);
        vbs[ushortOffset + 3] = ts(this.vbf[srcOffset + 3]);
        vbs[ushortOffset + 4] = lineWeight(this.vbf[srcOffset + 4]);
        break;

      case VBB_GT_ARC_CIRCULAR:
        vbs[ushortOffset] = tx(this.vbf[srcOffset]);
        vbs[ushortOffset + 1] = ty(this.vbf[srcOffset + 1]);
        vbs[ushortOffset + 2] = unit(this.vbf[srcOffset + 2]);
        vbs[ushortOffset + 3] = unit(this.vbf[srcOffset + 3]);
        vbs[ushortOffset + 4] = lineWeight(this.vbf[srcOffset + 4]);
        vbs[ushortOffset + 5] = ts(this.vbf[srcOffset + 5]);
        break;

      case VBB_GT_ARC_ELLIPTICAL:
      case VBB_GT_LINE_SEGMENT_MITER:
        //will not happen
        break;

      case VBB_GT_TEX_QUAD:
        vbs[ushortOffset] = tx(this.vbf[srcOffset]);
        vbs[ushortOffset + 1] = ty(this.vbf[srcOffset + 1]);
        vbs[ushortOffset + 2] = unit(this.vbf[srcOffset + 2]);
        vbs[ushortOffset + 3] = ts(this.vbf[srcOffset + 3]);
        vbs[ushortOffset + 4] = ts(this.vbf[srcOffset + 4]);
        break;

      case VBB_GT_ONE_TRIANGLE:
        vbs[ushortOffset] = tx(this.vbf[srcOffset]);
        vbs[ushortOffset + 1] = ty(this.vbf[srcOffset + 1]);
        vbs[ushortOffset + 2] = tx(this.vbf[srcOffset + 2]);
        vbs[ushortOffset + 3] = ty(this.vbf[srcOffset + 3]);
        vbs[ushortOffset + 4] = tx(this.vbf[srcOffset + 4]);
        vbs[ushortOffset + 5] = ty(this.vbf[srcOffset + 5]);
        break;

      default:console.error("Unknown geometry type");break;
    }

    //Copy the common data to the new offset
    vbs[ushortOffset + 6] = this.colors[this.vbi[srcOffset + VBB_COLOR_OFFSET]] || 0;
    vbs[ushortOffset + 7] = this.dbIds[this.vbi[srcOffset + VBB_DBID_OFFSET]] || 0;

    vbi[dstOffset + 4] = this.vbi[srcOffset + VBB_FLAGS_OFFSET];
    vbi[dstOffset + 5] = this.vbi[srcOffset + VBB_LAYER_VP_OFFSET];
  }

  var mesh = {};

  mesh.vb = new Float32Array(vb);
  mesh.vbstride = compactStride;

  var d = this.useInstancing ? 1 : 0;

  mesh.vblayout = {
    "fields1": { offset: 0, itemSize: 2, bytesPerItem: 2, divisor: d, normalized: true },
    "fields2": { offset: 1, itemSize: 4, bytesPerItem: 2, divisor: d, normalized: true },
    "uvIdColor": { offset: 3, itemSize: 2, bytesPerItem: 2, divisor: d, normalized: false },
    "flags4b": { offset: 4, itemSize: 4, bytesPerItem: 1, divisor: d, normalized: false },
    "layerVp4b": { offset: 5, itemSize: 4, bytesPerItem: 1, divisor: d, normalized: false }
  };

  mesh.unpackXform = { x: sx, y: sy, z: ox, w: oy };
  mesh.texData = texData;

  return mesh;
};

VertexBufferBuilder.prototype.makeWideVertexLayout = function () {
  var mesh = {};

  mesh.vb = new Float32Array(this.vb.slice(0, this.vcount * this.stride * 4));
  mesh.vbstride = this.stride;

  var d = this.useInstancing ? 1 : 0;

  mesh.vblayout = {
    "fields1": { offset: 0, itemSize: 2, bytesPerItem: 4, divisor: d, normalized: false },
    "fields2": { offset: 2, itemSize: 4, bytesPerItem: 4, divisor: d, normalized: false },
    "color4b": { offset: VBB_COLOR_OFFSET, itemSize: 4, bytesPerItem: 1, divisor: d, normalized: true },
    "dbId4b": { offset: VBB_DBID_OFFSET, itemSize: 4, bytesPerItem: 1, divisor: d, normalized: false },
    "flags4b": { offset: VBB_FLAGS_OFFSET, itemSize: 4, bytesPerItem: 1, divisor: d, normalized: false },
    "layerVp4b": { offset: VBB_LAYER_VP_OFFSET, itemSize: 4, bytesPerItem: 1, divisor: d, normalized: false }
  };

  //Set the expanded vertex layout to use the last two floats in the buffer. If the
  //were allocated then it is good. If they weren't it overlaps the flags4b and layerVp4b
  //channels, but since the extraParams won't be used in the shader it won't matter.
  //Doing this lets the shader connect to something and prevents crashes on iOS.
  mesh.vblayout["extraParams"] = { offset: this.stride - 2, itemSize: 2, bytesPerItem: 4, divisor: d, normalized: false };
  return mesh;
};

VertexBufferBuilder.prototype.toMesh = function ()
{
  var mesh = null;

  if (this.useCompactBuffers)
  mesh = this.makeCompactVertexLayout();

  if (!mesh)
  mesh = this.makeWideVertexLayout();

  if (this.useInstancing) {
    mesh.numInstances = this.vcount;

    //Set up trivial vertexId and index attributes

    var instFlags = new Int32Array([VBB_SEG_START_RIGHT, VBB_SEG_START_LEFT, VBB_SEG_END_RIGHT, VBB_SEG_END_LEFT]);
    mesh.vblayout.instFlags4b = { offset: 0, itemSize: 4, bytesPerItem: 1, divisor: 0, normalized: false };
    mesh.vblayout.instFlags4b.array = instFlags.buffer;

    var idx = mesh.indices = new Uint16Array(QUAD_TRIANGLE_INDICES);
  } else {
    mesh.indices = new Uint16Array(this.ib.buffer.slice(0, 2 * this.icount));
  }

  mesh.dbIds = this.dbIds;

  var w = this.maxx - this.minx;
  var h = this.maxy - this.miny;
  var sz = Math.max(w, h);

  mesh.boundingBox = {
    min: { x: this.minx, y: this.miny, z: -sz * 1e-3 },
    max: { x: this.maxx, y: this.maxy, z: sz * 1e-3 }
  };

  //Also compute a rough bounding sphere
  var bs = mesh.boundingSphere = {
    center: {
      x: 0.5 * (this.minx + this.maxx),
      y: 0.5 * (this.miny + this.maxy),
      z: 0.0
    },
    radius: 0.5 * Math.sqrt(w * w + h * h)
  };

  return mesh;
};

// The following logic attempts to "fix" imprecisions in arc definitions introduced
// by Heidi's fixed point math, in case that the extractor doesn't handle it correctly.

var fixUglyArc = function (start, end)
{
  //Snap critical angles exactly
  function snapCritical() {
    function fuzzyEquals(a, b) {return Math.abs(a - b) < 1e-3;}

    if (fuzzyEquals(start, 0)) start = 0.0;
    if (fuzzyEquals(end, 0)) end = 0.0;
    if (fuzzyEquals(start, TAU)) start = TAU;
    if (fuzzyEquals(end, TAU)) end = TAU;
  }

  snapCritical();

  //OK, in some cases the angles are both over-rotated...
  if (start > end) {
    while (start > TAU) {
      start -= TAU;
      end -= TAU;
    }
  } else {
    while (end > TAU) {
      start -= TAU;
      end -= TAU;
    }
  }

  //Snap critical angles exactly -- again
  snapCritical();

  //If the arc crosses the x axis, we have to make it clockwise...
  //This is a side effect of bringing over-rotated arcs in range above.
  //For example start = 5.0, end = 7.0 will result in start < 0 and end > 0,
  //so we have to make start > end in order to indicate we are crossing angle = 0.
  if (start < 0 && end > 0) {
    start += TAU;
  }

  return { start: start, end: end };
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/common/Viewpoints.js":
/*!*****************************************************!*\
  !*** ./src/file-loaders/lmvtk/common/Viewpoints.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readViewpointDefinition: () => (/* binding */ readViewpointDefinition)
/* harmony export */ });
/* harmony import */ var _svf_Cameras__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../svf/Cameras */ "./src/file-loaders/lmvtk/svf/Cameras.js");
/* harmony import */ var _SvfPlacementUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SvfPlacementUtils */ "./src/file-loaders/lmvtk/common/SvfPlacementUtils.js");


"use strict";

const ViewpointParts = {
  VP_Camera: 1,
  VP_CameraTransform: 2,
  VP_RenderMode: 4,
  VP_PrimitiveDisplayFlags: 8,
  VP_ClipPlanes: 16,
  VP_OverrideSet: 32
};

let Sections = [];

function readViewpointDefinition(pfr, camPfr, entry) {
  const tse = pfr.seekToEntry(entry);
  if (!tse)
  return null;

  const def = {};
  const parts = pfr.readVarint();

  if (parts & ViewpointParts.VP_Camera) {
    def.cameraEntry = pfr.readVarint();
    const inst = { definition: def.cameraEntry };
    def.camera = (0,_svf_Cameras__WEBPACK_IMPORTED_MODULE_0__.readCameraDefinition)(camPfr, inst);
  }

  if (parts & ViewpointParts.VP_CameraTransform) {
    def.cameraTransform = pfr.readTransform();
    if (def.camera && def.cameraTransform) {
      (0,_SvfPlacementUtils__WEBPACK_IMPORTED_MODULE_1__.transformCameraData)(def.camera, def.cameraTransform);
    }
  }

  if (parts & ViewpointParts.VP_RenderMode) {
    def.renderMode = pfr.readU8();
  }

  if (parts & ViewpointParts.VP_PrimitiveDisplayFlags) {
    def.primitiveDisplayFlags = pfr.readU8();
  }

  if (parts & ViewpointParts.VP_OverrideSet) {
    def.overrideSet = pfr.readVarint();
  }

  if (parts & ViewpointParts.VP_ClipPlanes) {
    def.clipPlaneMode = pfr.readU8();
    if (def.clipPlaneMode === 0) {// Planes
      def.sectionCount = pfr.readU8();
      def.clipData = {};
      def.sectionPlane = [];
      for (let i = 0; i < def.sectionCount; i++) {
        const normal = Object.assign({}, pfr.readVector3f());
        const distance = pfr.readF64();
        def.sectionPlane.push(-normal.x, -normal.y, -normal.z, distance);
      }
    } else {// Box
      def.clipData = {};
      const min = Object.assign({}, pfr.readVector3d());
      const max = Object.assign({}, pfr.readVector3d());
      const rotationQuat = Object.assign({}, pfr.readQuaternionf());
      def.sectionBox = { min, max };
      def.sectionBoxTransform = rotationQuat;
      def.isFromViewpoint = true;
    }
  }

  return def;
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/f2d/CheckedInputStream.js":
/*!**********************************************************!*\
  !*** ./src/file-loaders/lmvtk/f2d/CheckedInputStream.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckedInputStream: () => (/* binding */ CheckedInputStream)
/* harmony export */ });



// Similar as InputStream but with bounds checking.
// Throw exception when out of bounds access is / to be made.
function CheckedInputStream(buf) {
  this.buffer = buf;
  this.offset = 0;
  this.byteLength = buf.length;

  //We will use these shared memory arrays to
  //convert from bytes to the desired data type.
  this.convBuf = new ArrayBuffer(8);
  this.convUint8 = new Uint8Array(this.convBuf);
  this.convUint16 = new Uint16Array(this.convBuf);
  this.convInt32 = new Int32Array(this.convBuf);
  this.convUint32 = new Uint32Array(this.convBuf);
}

function OutOfBoundsBufferAccessException(offset) {
  this.offset = offset;
  this.message = "try to access an offset that is out of bounds: " + this.offset;
  this.toString = function () {
    return this.message;
  };
}

CheckedInputStream.prototype.boundsCheck = function (offset) {
  if (offset >= this.byteLength) {
    throw new OutOfBoundsBufferAccessException(offset);
  }
};

CheckedInputStream.prototype.seek = function (off) {
  this.boundsCheck(off);
  this.offset = off;
};

CheckedInputStream.prototype.getBytes = function (len) {
  this.boundsCheck(this.offset + len);
  var ret = new Uint8Array(this.buffer.buffer, this.offset, len);
  this.offset += len;
  return ret;
};

CheckedInputStream.prototype.skipBytes = function (len) {
  this.boundsCheck(this.offset + len);
  this.offset += len;
};


CheckedInputStream.prototype.getVarints = function () {
  var b;
  var value = 0;
  var shiftBy = 0;
  do {
    this.boundsCheck(this.offset);
    b = this.buffer[this.offset++];
    value |= (b & 0x7f) << shiftBy;
    shiftBy += 7;
  } while (b & 0x80);
  return value;
};

CheckedInputStream.prototype.getUint8 = function () {
  this.boundsCheck(this.offset + 1);
  return this.buffer[this.offset++];
};

CheckedInputStream.prototype.getUint16 = function () {
  this.boundsCheck(this.offset + 2);
  this.convUint8[0] = this.buffer[this.offset++];
  this.convUint8[1] = this.buffer[this.offset++];
  return this.convUint16[0];
};

CheckedInputStream.prototype.getInt16 = function () {
  var tmp = this.getUint16();
  //make negative integer if the ushort is negative
  if (tmp > 0x7fff)
  tmp = tmp | 0xffff0000;
  return tmp;
};

CheckedInputStream.prototype.getInt32 = function () {
  this.boundsCheck(this.offset + 4);
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return this.convInt32[0];
};

CheckedInputStream.prototype.getUint32 = function () {
  this.boundsCheck(this.offset + 4);
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return this.convUint32[0];
};

CheckedInputStream.prototype.skipUint32 = function () {
  this.boundsCheck(this.offset + 4);
  this.offset += 4;
};

CheckedInputStream.prototype.getFloat32 = function () {
  this.boundsCheck(this.offset + 4);
  this.offset += 4;
  return 0;
};

CheckedInputStream.prototype.getFloat64 = function () {
  this.boundsCheck(this.offset + 8);
  this.offset += 8;
  return 0;
};

CheckedInputStream.prototype.skipFloat64 = function () {
  this.boundsCheck(this.offset + 8);
  this.offset += 8;
};

CheckedInputStream.prototype.reset = function (buf) {
  this.buffer = buf;
  this.offset = 0;
  this.byteLength = buf.length;
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/f2d/F2d.js":
/*!*******************************************!*\
  !*** ./src/file-loaders/lmvtk/f2d/F2d.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F2D: () => (/* binding */ F2D),
/* harmony export */   F2dDataType: () => (/* binding */ F2dDataType),
/* harmony export */   F2dSemanticType: () => (/* binding */ F2dSemanticType),
/* harmony export */   F2dShadowRatio: () => (/* binding */ F2dShadowRatio),
/* harmony export */   restoreSignBitFromLSB: () => (/* binding */ restoreSignBitFromLSB)
/* harmony export */ });
/* harmony import */ var _common_VertexBufferBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/VertexBufferBuilder */ "./src/file-loaders/lmvtk/common/VertexBufferBuilder.js");
/* harmony import */ var _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../wgs/scene/LmvBox3 */ "./src/wgs/scene/LmvBox3.js");
/* harmony import */ var _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../wgs/scene/LmvVector3 */ "./src/wgs/scene/LmvVector3.js");
/* harmony import */ var _common_VbUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/VbUtils */ "./src/file-loaders/lmvtk/common/VbUtils.js");
/* harmony import */ var _common_InputStream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/InputStream */ "./src/file-loaders/lmvtk/common/InputStream.js");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../logger/Logger */ "./src/logger/Logger.js");
/* harmony import */ var _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../net/ErrorCodes */ "./src/file-loaders/net/ErrorCodes.js");










var MOBILE_MAX_VCOUNT = 16383;

var F2dDataType = {
  //Fixed size types
  dt_object: 0,
  dt_void: 1,
  dt_byte: 2,
  dt_int: 3,
  dt_float: 4,
  dt_double: 5,
  dt_varint: 6,
  dt_point_varint: 7,

  //Variable size types
  //Data bytes are prefixed by an integer
  //representing the number of elements in the array.
  dt_byte_array: 32,
  dt_int_array: 33,
  dt_float_array: 34,
  dt_double_array: 35,
  dt_varint_array: 36,
  //Special variable int encoding for point data
  dt_point_varint_array: 37,

  //Well-known data types that help reduce output size for commonly
  //encountered simple geometries
  dt_arc: 38,
  dt_circle: 39,
  dt_circular_arc: 40,

  dt_string: 63,
  //do not want to go into varint range
  dt_last_data_type: 127
};

var F2dSemanticType = {
  //For objects with fixed serialization (arc, raster) we don't bother having dedicated semantic for each member
  //and assume the parsing application knows the order they appear. There is still an end-object tag of course
  //which shows where the object ends.
  st_object_member: 0,

  //Simple / fixed size attributes
  st_fill: 1,
  st_fill_off: 2,
  st_clip_off: 3,
  st_layer: 4,
  st_link: 5,
  st_line_weight: 6,
  st_miter_angle: 7,
  st_miter_length: 8,
  st_line_pattern_ref: 9,
  st_back_color: 10,
  st_color: 11,
  st_markup: 12,
  st_object_id: 13,
  st_markup_id: 14,
  st_reset_rel_offset: 15,
  st_font_ref: 16,

  //Compound object opcodes

  //Begin a generic object opcode
  st_begin_object: 32,

  //Style attribute related opcodes. Those are compound objects
  st_clip: 33,
  st_line_caps: 34,
  st_line_join: 35,
  st_line_pattern_def: 36,
  st_font_def: 37,
  st_viewport: 38,

  //Drawables are all objects-typed bounded by begin/end object opcodes

  //Root level document begin
  st_sheet: 42,
  //Circle, Ellipse, Arcs
  st_arc: 43,
  //The grandfather of them all
  st_polyline: 44,
  st_raster: 45,
  st_text: 46,
  st_polytriangle: 47,
  st_dot: 48,
  //end object -- could be ending a generic object or drawable, etc.
  st_end_object: 63,

  st_last_semantic_type: 127
};

// F2D shadow ratio, relative to paper width.
const F2dShadowRatio = 0.0075;


//Initializes a structure of counters used for statistical purposes and sheet content hash
function initGeomMetrics() {
  return {
    "arcs": 0,
    "circles": 0,
    "circ_arcs": 0,
    "viewports": 0,
    "clips": 0,
    "colors": 0,
    "db_ids": 0,
    "dots": 0,
    "fills": 0,
    "layers": 0,
    "line_caps": 0,
    "line_joins": 0,
    "line_patterns": 0,
    "line_pat_refs": 0,
    "plines": 0,
    "pline_points": 0,
    "line_weights": 0,
    "links": 0,
    "miters": 0,
    "ptris": 0,
    "ptri_indices": 0,
    "ptri_points": 0,
    "rasters": 0,
    "texts": 0,
    "strings": []
  };
}


// Restore sign bit from LSB of an encoded integer which has the sign bit
// moved from MSB to LSB.
// The decoding process is the reverse by restoring the sign bit from LSB to MSB.
function restoreSignBitFromLSB(integer) {
  return integer & 1 ? -(integer >>> 1) : integer >>> 1;
};

function F2D(metadata, manifest, basePath) {let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  this.metadata = metadata;
  this.scaleX = 1;
  this.scaleY = 1;
  this.bbox = { min: { x: 0, y: 0, z: 0 }, max: { x: 0, y: 0, z: 0 } };
  this.is2d = true;
  this.layersMap = {};
  this.fontDefs = {};
  this.fontCount = 0;
  this.fontId = 0;
  this.manifestAvailable = false;
  this.geomMetricsSum = 0;
  this.objectMemberQueue = [];

  this.propertydb = {
    attrs: [],
    avs: [],
    ids: [],
    values: [],
    offsets: [],
    viewables: []
  };

  if (metadata) {

    var dims = metadata.page_dimensions;

    this.paperWidth = dims.page_width;
    this.paperHeight = dims.page_height;

    // TODO: scale parsing.
    this.scaleX = this.paperWidth / dims.plot_width;
    this.scaleY = this.paperHeight / dims.plot_height;

    this.hidePaper = dims.hide_paper;

    var pw = this.paperWidth;
    var ph = this.paperHeight;
    this.bbox.max.x = pw;
    this.bbox.max.y = ph;

    var dim = metadata.page_dimensions || {};
    // If the paper is rotated or offset, include that in the bbox
    if (isFinite(dim.paper_rotation) && dim.paper_rotation !== 0) {
      var angle = dim.paper_rotation * Math.PI / 180;
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var dwx;
      var dwx = pw * cos;
      var dwy = pw * sin;
      var dhx = -ph * sin;
      var dhy = ph * cos;
      this.bbox.min.x = Math.min(0, dwx, dhx, dwx + dhx);
      this.bbox.max.x = Math.max(0, dwx, dhx, dwx + dhx);
      this.bbox.min.y = Math.min(0, dwy, dhy, dwy + dhy);
      this.bbox.max.y = Math.max(0, dwy, dhy, dwy + dhy);
    }
    if (isFinite(dim.paper_offset_x) && dim.paper_offset_x !== 0) {
      this.bbox.min.x += dim.paper_offset_x;
      this.bbox.max.x += dim.paper_offset_x;
    }
    if (isFinite(dim.paper_offset_y) && dim.paper_offset_y !== 0) {
      this.bbox.min.y += dim.paper_offset_y;
      this.bbox.max.y += dim.paper_offset_y;
    }

    //Initialize mapping between layer index -> layer number to be used for rendering
    var count = 0;
    //Some geometry comes on null layer, and we reserve a spot for that one.
    //For example, Revit plots have no layers at all.
    this.layersMap[0] = count++;

    for (var l in metadata.layers) {

      var index = parseInt(l);

      //We store in a map in order to allow non-consecutive layer numbers,
      //which does happen.
      this.layersMap[index] = count++;
    }

    this.layerCount = count;

    //Create a layers tree to be used by the UI -- this splits AutoCAD style
    //layer groups (specified using | character) into a tree of layers.
    this.createLayerGroups(metadata.layers);

    if (metadata.geom_metrics) {
      var values = Object.keys(metadata.geom_metrics).map(function (key) {
        return metadata.geom_metrics[key];
      });
      this.geomMetricsSum = values.reduce((acc, cur) => acc + cur);
    }
  }

  this.hidePaper = this.hidePaper || options.modelSpace;
  this.noShadow = !!options.noShadow; // The request to not draw a shadow

  this.hasPageShadow = false; // Will be true only if the shadow was actually created

  // For debugging only. Could be removed.
  this.opCount = 0;

  this.excludeTextGeometry = options.excludeTextGeometry;
  //provides additional parameters for precise text search and highlight
  this.extendStringsFetching = options.extendStringsFetching;

  this.fontFaces = [];
  this.fontFamilies = [];

  this.viewports = [{}]; // make viewport index start at 1, 0 as paper is used in LineShader
  this.currentVpId = 0; // current viewport index
  this.viewports[0].geom_metrics = this.currentGeomMetrics = initGeomMetrics();

  this.clips = [0]; // make clip index start at 1, matched with viewport index

  this.strings = [];
  this.stringDbIds = [];
  this.stringBoxes = [];
  if (this.extendStringsFetching) {
    this.stringCharWidths = [];
    this.stringAngles = [];
    this.stringPositions = [];
    this.stringHeights = [];
  }
  this.currentStringNumber = -1;
  this.currentStringBox = new _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_1__.LmvBox3();

  this.linkBoxes = [];
  this.currentLinkBox = new _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_1__.LmvBox3();

  this.objectNumber = 0;
  this.currentFakeId = -2; //We tag certain objects that we care about (like strings) that have no ID with fake negative IDs instead of giving them default ID of 0.
  this.imageNumber = 0;
  this.linkNumber = 0;
  this.maxObjectNumber = 0;

  this.objectStack = [];
  this.objectNameStack = [];
  this.parseObjState = {
    polyTriangle: {},
    viewport: {},
    clip: {},
    raster: {},
    text: {},
    fontDef: {},
    uknown: {}
  };

  this.layer = 0;

  this.bgColor = typeof options.bgColor === "number" ? options.bgColor : 0xffffffff;

  //NOTE: Use of contrast color is turned off in mapColor() until UX makes up their mind
  //one way or another.
  this.contrastColor = this.color = this.fillColor = 0xff000000;
  if (this.hidePaper)
  this.contrastColor = 0xffffff00;

  this.isMobile = options && !!options.isMobile;

  // https://git.autodesk.com/A360/firefly.js/pull/3884
  // We spotted multiple devices that doesn't play nice with 2dInstancing and compactBuffers.
  // After some testing, we found out that using WebGL2 fixes the performance issues for these devices.
  // For browsers that don't support WebGL2 (Safari), we want to still use these optimisations,
  // only if the number of geometries is large (more than 10 million) - this is when the memory optimisation
  // is really important and we can't risk on not using it.
  var isWebGL2 = options && !!options.isWebGL2;
  var useMobileOptimizations = this.isMobile && (isWebGL2 || this.geomMetricsSum > 1e7);
  var useInstancing = useMobileOptimizations && options && !!options.supportsInstancing;
  var useCompactBuffers = useMobileOptimizations;

  this.max_vcount = this.isMobile ? MOBILE_MAX_VCOUNT : undefined;

  this.currentVbb = new _common_VertexBufferBuilder__WEBPACK_IMPORTED_MODULE_0__.VertexBufferBuilder(useInstancing, undefined, this.max_vcount, useCompactBuffers);
  this.meshes = [];

  this.numCircles = this.numEllipses = this.numPolylines = this.numLineSegs = 0;
  this.numPolytriangles = this.numTriangles = 0;

  // Newly added f2d pasing stuff.
  this.error = false;

  // Last absolute positions of point parsed so far.
  // Used to decode relative positions parsed from points array.
  this.offsetX = 0;
  this.offsetY = 0;

  // Parse manifest, do stuff.
  // 1. Build image id to raster URI map used to assign values to texture path.
  // 2. Acquire names of property database json streams.
  if (manifest) {
    this.manifestAvailable = true;
    this.imageId2URI = {};
    var assets = manifest.assets;
    for (var i = 0, e = assets.length; i < e; ++i) {
      var entry = assets[i];
      var mime = entry.mime;
      if (mime.indexOf('image/') !== -1) {
        var id = entry.id;
        id = id.substr(0, id.indexOf('.'));
        this.imageId2URI[id] = basePath + entry.URI;
      }

      if (entry.type === "Autodesk.CloudPlatform.PropertyAttributes")
      this.propertydb.attrs.push({ path: entry.URI });
      if (entry.type === "Autodesk.CloudPlatform.PropertyValues")
      this.propertydb.values.push({ path: entry.URI });
      if (entry.type === "Autodesk.CloudPlatform.PropertyIDs")
      this.propertydb.ids.push({ path: entry.URI });
      if (entry.type === "Autodesk.CloudPlatform.PropertyViewables")
      this.propertydb.viewables.push({ path: entry.URI });
      if (entry.type === "Autodesk.CloudPlatform.PropertyOffsets") {
        // rcv and rcv_offsets are not used any longer
        if (entry.id.indexOf('rcv') === -1)
        this.propertydb.offsets.push({ path: entry.URI });
      }
      if (entry.type === "Autodesk.CloudPlatform.PropertyAVs")
      this.propertydb.avs.push({ path: entry.URI });
    }

  }
}

F2D.prototype.load = function (loadContext, fydoPack) {

  if (!(fydoPack instanceof Uint8Array))
  fydoPack = new Uint8Array(fydoPack);
  this.data = fydoPack;
  this.parse();

  if (this.stringBoxes.length) {
    var fbuf = new Float32Array(this.stringBoxes.length);
    fbuf.set(this.stringBoxes);
    this.stringBoxes = fbuf;
  }

  loadContext.loadDoneCB(true);
};

F2D.prototype.loadFrames = function (loadContext) {

  this.loadContext = loadContext;

  var data = loadContext.data;

  if (data) {
    if (!(data instanceof Uint8Array))
    data = new Uint8Array(data);
    this.data = data;
  } else if (loadContext.finalFrame) {
    this.data = null;

    if (this.stringBoxes.length) {
      var fbuf = new Float32Array(this.stringBoxes.length);
      fbuf.set(this.stringBoxes);
      this.stringBoxes = fbuf;
    }
  }

  this.parseFrames(loadContext.finalFrame);

  loadContext.loadDoneCB(true);
};


F2D.prototype.pushMesh = function (mesh) {
  this.meshes.push(mesh);


  mesh.material = {
    skipEllipticals: !this.currentVbb.numEllipticals,
    skipCircles: !this.currentVbb.numCirculars,
    skipTriangleGeoms: !this.currentVbb.numTriangleGeoms,
    skipMiterLines: !this.currentVbb.numMiterLines,
    useInstancing: this.currentVbb.useInstancing,
    unpackPositions: !!mesh.unpackXform
  };

  if (this.currentImage) {
    mesh.material.image = this.currentImage;
    mesh.material.image.name = this.imageNumber++;
    this.currentImage = null;
  }
};

F2D.prototype.flushBuffer = function (addCount, finalFlush)
{
  if (!this.currentVbb.vcount && !finalFlush)
  {
    return;
  }

  var flush = finalFlush;
  flush = flush || this.currentVbb.isFull(addCount);

  if (flush) {
    if (this.currentVbb.vcount) {
      var mesh = this.currentVbb.toMesh();
      _common_VbUtils__WEBPACK_IMPORTED_MODULE_3__.VBUtils.bboxUnion(this.bbox, mesh.boundingBox);

      this.pushMesh(mesh);
      this.currentVbb.reset(0);
    }

    if (this.loadContext)
    this.loadContext.loadDoneCB(true, finalFlush);
  }


};

F2D.prototype.tx = function (x) {
  return this.sx(x);
};

F2D.prototype.ty = function (y) {
  return this.sy(y);
};

F2D.prototype.sx = function (x) {
  //TODO: The hardcoded scale is used to get the integer coords from FYDO
  //into something normal and close to page coordinates
  return x * this.scaleX;
};

F2D.prototype.sy = function (y) {
  //TODO: The hardcoded scale is used to get the integer coords from FYDO
  //into something normal and close to page coordinates
  return y * this.scaleY;
};

F2D.prototype.invertColor = function (c) {
  var a = c >> 24 & 0xff;
  var b = c >> 16 & 0xff;
  var g = c >> 8 & 0xff;
  var r = c & 0xff;

  b = 255 - b;
  g = 255 - g;
  r = 255 - r;

  return a << 24 | b << 16 | g << 8 | r;
};

F2D.prototype.mapColor = function (c, isFill) {

  if (!this.hidePaper || this.bgColor !== 0)
  return c;

  //Color substitution in cases when we want to interleave the 2D drawing
  //into a 3D scene (when bgColor is explicitly specified as transparent black (0)
  //and hidePaper is set to true.

  var r = c & 0xff;
  var g = (c & 0xff00) >> 8;
  var b = (c & 0xff0000) >> 16;

  var isGrey = r === g && r === b;

  if (r < 0x7f) {

    //c = this.contrastColor;
  } else if (isGrey && isFill) {c = c & 0x55ffffff;
  }

  return c;
};

// ====================== F2D Parser ================================= //


// Convert relative positions to absolute positions, and update global offsets.
F2D.prototype.parsePointPositions = function () {
  var x = this.stream.getVarints();
  var y = this.stream.getVarints();

  x = restoreSignBitFromLSB(x);
  y = restoreSignBitFromLSB(y);

  x += this.offsetX;
  y += this.offsetY;

  this.offsetX = x;
  this.offsetY = y;

  return [this.tx(x), this.ty(y)];
};

F2D.prototype.parserAssert = function (actualType, expectedType, functionName) {
  if (actualType != expectedType) {
    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Expect " + expectedType + "; actual type is " +
    actualType + "; in function " + functionName);
    this.error = true;
    return true;
  } else {
    return false;
  }
};

F2D.prototype.unhandledTypeWarning = function (inFunction, semanticType) {
  _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Unhandled semantic type : " + semanticType + " in function " + inFunction);
};

F2D.prototype.parseObject = function () {
  var semantic_type = this.stream.getVarints();
  this.objectStack.push(semantic_type);
  //debug(semantic_type);
  switch (semantic_type) {
    case F2dSemanticType.st_sheet:
      this.objectNameStack.push("sheet");
      this.objectMemberQueue.unshift("paperColor");
      break;
    case F2dSemanticType.st_viewport:
      this.objectNameStack.push("viewport");
      this.objectMemberQueue.unshift("units", "transform");
      break;
    case F2dSemanticType.st_clip:
      this.objectNameStack.push("clip");
      this.objectMemberQueue.unshift("contourCounts", "points", "indices");
      break;
    case F2dSemanticType.st_polytriangle:
      this.objectNameStack.push("polyTriangle");
      this.objectMemberQueue.unshift("points", "indices", "colors");
      break;
    case F2dSemanticType.st_raster:
      this.objectNameStack.push("raster");
      this.objectMemberQueue.unshift("position", "width", "height", "imageId");
      break;
    case F2dSemanticType.st_text:
      this.currentStringNumber = this.strings.length;
      if (this.objectNumber === 0)
      this.objectNumber = this.currentFakeId--;
      this.currentStringBox.makeEmpty();
      this.objectNameStack.push("text");
      this.objectMemberQueue.unshift("string", "position", "height", "widthScale", "rotation", "oblique", "charWidths");
      break;
    case F2dSemanticType.st_font_def:
      this.objectNameStack.push("fontDef");
      this.objectMemberQueue.unshift("name", "fullName", "flags", "spacing", "panose");
      break;
    case F2dSemanticType.st_end_object:{
        this.objectStack.pop(); //pop the end_object we pushed at the beginning of the function

        if (!this.objectStack.length)
        this.parserAssert(0, 1, "parseEndObject (Stack Empty)");else
        {
          //Do any end-of-object post processing depending on object type
          var objType = this.objectStack.pop(); //pop the start object

          switch (objType) {
            case F2dSemanticType.st_polytriangle:this.actOnPolyTriangle();break;
            case F2dSemanticType.st_viewport:this.actOnViewport();break;
            case F2dSemanticType.st_clip:this.actOnClip();break;
            case F2dSemanticType.st_raster:this.actOnRaster();break;
            case F2dSemanticType.st_text:this.actOnText();break;
            case F2dSemanticType.st_font_def:this.actOnFontDef();break;
          }

          //Zero out the state of the object we just finished processing
          var name = this.objectNameStack.pop();
          var state = this.parseObjState[name];
          for (var p in state)
          state[p] = null;
        }

        this.objectMemberQueue.length = 0;
      }
      break;
    default:
      this.objectNameStack.push("unknown");
      this.error = true;
      this.unhandledTypeWarning('parseObject', semantic_type);
      break;
  }
};


F2D.prototype.initSheet = function (paperColor) {
  if (this.hidePaper)
  return;

  this.bgColor = paperColor;

  if (this.metadata) {
    var pw = this.paperWidth;
    var ph = this.paperHeight;

    var o = { x: 0, y: 0 }; // origin
    var dw = { x: pw, y: 0 }; // paper width direction
    var dh = { x: 0, y: ph }; // paper height direction

    // If the metadata has a non-zero rotation, then use it
    var dim = this.metadata.page_dimensions || {};
    if (isFinite(dim.paper_rotation) && dim.paper_rotation !== 0) {
      var angle = dim.paper_rotation * Math.PI / 180;
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      dw.y = pw * sin;
      dw.x = pw * cos;
      dh.x = -ph * sin;
      dh.y = ph * cos;
    }
    // If the metadata has a non-zero offset, then use them
    if (isFinite(dim.paper_offset_x) && dim.paper_offset_x !== 0) {
      o.x = dim.paper_offset_x;
    }
    if (isFinite(dim.paper_offset_y) && dim.paper_offset_y !== 0) {
      o.y = dim.paper_offset_y;
    }

    var vbb = this.currentVbb;

    var points = [o.x, o.y, o.x + dw.x, o.y + dw.y, o.x + dw.x + dh.x, o.y + dw.y + dh.y, o.x + dh.x, o.y + dh.y];
    var colors = [paperColor, paperColor, paperColor, paperColor];
    var indices = [0, 1, 2, 0, 2, 3];

    if (!this.noShadow) {
      var ss = pw * F2dShadowRatio;
      var ssw = { x: dw.x * ss / pw, y: dw.y * ss / pw }; // shadow offset in width direction
      var ssh = { x: dh.x * ss / ph, y: dh.y * ss / ph }; // shadow offset in height direction
      var ssb = { x: o.x + ssw.x, y: o.y + ssw.y }; // bottom shadow origin
      var ssr = { x: o.x + dw.x, y: o.y + dw.y }; // right shadow origin
      var shadowColor = 0xff555555;

      points = points.concat([ssb.x - ssh.x, ssb.y - ssh.y, ssb.x - ssh.x + dw.x, ssb.y - ssh.y + dw.y, ssb.x + dw.x, ssb.y + dw.y, ssb.x, ssb.y,
      ssr.x, ssr.y, ssr.x + ssw.x, ssr.y + ssw.y, ssr.x + ssw.x - ssh.x + dh.x, ssr.y + ssw.y - ssh.y + dh.y, ssr.x - ssh.x + dh.x, ssr.y - ssh.y + dh.y]);
      colors = colors.concat([shadowColor, shadowColor, shadowColor, shadowColor,
      shadowColor, shadowColor, shadowColor, shadowColor]);
      indices = indices.concat([4, 5, 6, 4, 6, 7,
      8, 9, 10, 8, 10, 11]);

      this.hasPageShadow = true;
    }

    var paperLayer = 0; //Put the paper the null layer so it won't get turned off.
    var paperDbId = -1;

    this.addPolyTriangle(points, colors, indices, 0xffffffff, paperDbId, paperLayer, false);

    //Page outline
    vbb.addSegment(o.x, o.y, o.x + dw.x, o.y + dw.y, 0, 1e-6, 0xff000000, paperDbId, paperLayer, this.currentVpId);
    vbb.addSegment(o.x + dw.x, o.y + dw.y, o.x + dw.x + dh.x, o.y + dw.y + dh.y, 0, 1e-6, 0xff000000, paperDbId, paperLayer, this.currentVpId);
    vbb.addSegment(o.x + dw.x + dh.x, o.y + dw.y + dh.y, o.x + dh.x, o.y + dh.y, 0, 1e-6, 0xff000000, paperDbId, paperLayer, this.currentVpId);
    vbb.addSegment(o.x + dh.x, o.y + dh.y, o.x, o.y, 0, 1e-6, 0xff000000, paperDbId, paperLayer, this.currentVpId);


    //Test pattern for line styles.
    //for (var i=0; i<39; i++) {
    //    vbb.addSegment(0, ph + i * 0.25 + 1, 12, 12 + ph + i * 0.25 + 1, 0, -1 /* device space pixel width */, 0xff000000, 0xffffffff, 0, 0, i);
    //}

    //Test pattern for line styles.
    //for (var i=0; i<39; i++) {
    //    vbb.addSegment(0, ph + (i+39) * 0.25 + 1, 12, 12 + ph + (i+39) * 0.25 + 1, 0, (1.0 / 25.4) /*1mm width*/, 0xff000000, 0xffffffff, 0, 0, i);
    //}

  }
};

F2D.prototype.setObjectMember = function (val) {
  if (!this.objectMemberQueue.length) {
    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Unexpected object member. " + val + " on object " + this.objectNameStack[this.objectNameStack.length - 1]);
    return false;
  }

  var propName = this.objectMemberQueue.shift();
  var curObjName = this.objectNameStack[this.objectNameStack.length - 1];

  //The paper color needs to be processed as soon as it comes in
  //because we want to initialize the page geometry first, before
  //adding any other geometry
  if (curObjName == "sheet" && propName == "paperColor") {
    this.initSheet(val);
    return true;
  } else
  if (curObjName) {
    this.parseObjState[curObjName][propName] = val;
    return true;
  }

  return false;
};


F2D.prototype.parseString = function () {
  var s = this.stream;
  var sema = s.getVarints();

  var len = s.getVarints();
  var ret = s.getString(len);

  switch (sema) {
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(ret))
      return;
      break;
    default:_logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.info("Unexpected opcode semantic type for string.");break;
  }

  return ret;
};


F2D.prototype.actOnFontDef = function () {
  var fontDef = this.parseObjState.fontDef;
  this.fontDefs[++this.fontCount] = fontDef;
  this.fontId = this.fontCount;
};


F2D.prototype.parsePoint = function () {
  var s = this.stream;
  var sema = s.getVarints(); //skip past the semantics
  var ret = this.parsePointPositions();

  switch (sema) {
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(ret))
      return;
      break;
    default:_logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.info("Unexpected opcode semantic type for point.");break;
  }

  return ret;
};


F2D.prototype.parsePointsArray = function () {

  var s = this.stream;

  var sema = s.getVarints();

  var count = s.getVarints(); // number of coordinates * 2
  if (!count) return;
  count = count / 2;

  var ret = [];
  var position;

  for (var i = 0; i < count; ++i) {
    position = this.parsePointPositions();
    ret.push(position[0]);
    ret.push(position[1]);
  }

  switch (sema) {
    case F2dSemanticType.st_polyline:
      this.actOnPolylinePointsArray(ret);
      return;
    case F2dSemanticType.st_dot:
      this.actOnDot(ret);
      return;
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(ret))
      return;
      break;
    default:_logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.info("Unexpected opcode semantic type for points array.");break;
  }

  return ret;
};

F2D.prototype.parseIntArray = function () {
  var s = this.stream;
  var sema = s.getVarints();
  var count = s.getVarints(); // total number of elements in integer array.
  var retVal = [];
  for (var i = 0; i < count; ++i) {
    retVal.push(s.getUint32());
  }

  switch (sema) {
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(retVal))
      return;
      break;
    default:
      this.unhandledTypeWarning('parseIntArray', sema);
      break;
  }

  return retVal;
};

F2D.prototype.parseDoubleArray = function () {
  var s = this.stream;
  var sema = s.getVarints();
  var count = s.getVarints(); // total number of elements in integer array.
  var retVal = [];
  for (var i = 0; i < count; ++i) {
    retVal.push(s.getFloat64());
  }

  switch (sema) {
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(retVal))
      return;
      break;
    default:
      this.unhandledTypeWarning('parseDoubleArray', sema);
      break;
  }

  return retVal;
};

F2D.prototype.parseByteArray = function () {
  var s = this.stream;
  var sema = s.getVarints();
  var count = s.getVarints(); // total number of elements in byte array.
  var retVal = [];
  for (var i = 0; i < count; ++i) {
    retVal.push(s.getUint8());
  }

  switch (sema) {
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(retVal))
      return;
      break;
    default:
      this.unhandledTypeWarning('parseByteArray', sema);
      break;
  }

  return retVal;
};


F2D.prototype.parseVarintArray = function () {
  var s = this.stream;
  var sema = s.getVarints();

  var ret = [];

  // Total number of integers in array, not the total number of bytes.
  var count = s.getVarints();

  for (var i = 0; i < count; ++i) {
    ret.push(s.getVarints());
  }

  switch (sema) {
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(ret))
      return;
      break;
    default:
      this.unhandledTypeWarning('parseVarIntArray', sema);
      break;
  }

  return ret;
};


F2D.prototype.parseInt = function () {
  var s = this.stream;
  var sema = s.getVarints();
  var val = s.getUint32();

  switch (sema) {
    case F2dSemanticType.st_color:
      this.color = this.mapColor(val, false);
      this.currentGeomMetrics.colors++;
      break;
    case F2dSemanticType.st_fill:
      this.fill = true;
      this.fillColor = this.mapColor(val, true);
      this.currentGeomMetrics.fills++;
      break;
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(val))
      return;
    default:
      this.unhandledTypeWarning('parseInt', sema);
      break;
  }

  return val;
};

F2D.prototype.parseVoid = function () {
  var sema = this.stream.getVarints();
  switch (sema) {
    case F2dSemanticType.st_fill_off:
      this.fill = false;
      this.currentGeomMetrics.fills++;
      break;
    default:
      this.unhandledTypeWarning('parseVoid', sema);
      break;
  }
};

F2D.prototype.parseVarint = function () {
  var s = this.stream;
  var semantic_type = s.getVarints();
  var val = s.getVarints();

  switch (semantic_type) {
    case F2dSemanticType.st_line_weight:
      this.lineWeight = this.tx(val);
      this.currentGeomMetrics.line_weights++;
      break;
    case F2dSemanticType.st_line_caps:
      this.currentGeomMetrics.line_caps++;
      break;
    case F2dSemanticType.st_line_join:
      this.currentGeomMetrics.line_joins++;
      break;
    case F2dSemanticType.st_object_id:
    case F2dSemanticType.st_markup_id:
      this.objectNumber = val;
      this.maxObjectNumber = Math.max(this.maxObjectNumber, val);
      this.currentGeomMetrics.db_ids++;
      break;
    case F2dSemanticType.st_link:
      if (this.linkNumber) {
        this.linkBoxes[this.linkNumber] = this.currentLinkBox.clone();
        this.currentLinkBox.makeEmpty();
      }
      this.linkNumber = val;
      break;
    case F2dSemanticType.st_layer:
      this.currentGeomMetrics.layers++;
      this.layer = this.layersMap[val];
      break;
    case F2dSemanticType.st_font_ref:
      this.fontId = val;
      break;
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(val))
      return;
      break;
    default:
      break;
  }

  return val;
};

F2D.prototype.parseFloat = function () {
  var s = this.stream;
  var semantic_type = s.getVarints();
  var val = s.getFloat32();

  switch (semantic_type) {
    case F2dSemanticType.st_miter_angle:
      break;
    case F2dSemanticType.st_miter_length:
      break;
    case F2dSemanticType.st_object_member:
      if (this.setObjectMember(val)) {
        return;
      }
      break;
    default:
      break;
  }

  return val;
};

F2D.prototype.parseCircularArc = function () {
  var s = this.stream;
  var sema = s.getVarints();
  if (this.parserAssert(sema, F2dSemanticType.st_arc, 'parseCircularArc')) return;

  var point = this.parsePointPositions();
  var major = s.getVarints(), /*rotation = s.getFloat32(),*/start = s.getFloat32(),end = s.getFloat32();

  this.actOnCircularArc(point[0], point[1], start, end, this.sx(major));
};

F2D.prototype.parseCircle = function () {
  var s = this.stream;
  var sema = s.getVarints();
  if (this.parserAssert(sema, F2dSemanticType.st_arc, 'parseCircle')) return;

  var point = this.parsePointPositions();
  var major = s.getVarints();

  this.actOnCompleteCircle(point[0], point[1], this.sx(major));
};

F2D.prototype.parseArc = function () {
  var s = this.stream;
  var sema = s.getVarints();
  if (this.parserAssert(sema, F2dSemanticType.st_arc, 'parseArc')) return;

  // Relative positions.
  var point = this.parsePointPositions();

  var major = s.getVarints();
  var minor = s.getVarints();

  var rotation = s.getFloat32();
  var start = s.getFloat32();
  var end = s.getFloat32();

  this.actOnArc(point[0], point[1], start, end, this.sx(major), this.sy(minor), rotation);
};

F2D.prototype.parseDataType = function () {
  var data_type = this.stream.getVarints();

  switch (data_type) {
    case F2dDataType.dt_void:
      this.parseVoid();
      break;
    case F2dDataType.dt_int:
      this.parseInt();
      break;
    case F2dDataType.dt_object:
      this.parseObject();
      break;
    case F2dDataType.dt_varint:
      this.parseVarint();
      break;
    case F2dDataType.dt_point_varint:
      this.parsePoint();
      break;
    case F2dDataType.dt_float:
      this.parseFloat();
      break;
    case F2dDataType.dt_point_varint_array:
      this.parsePointsArray();
      break;
    case F2dDataType.dt_circular_arc:
      this.parseCircularArc();
      break;
    case F2dDataType.dt_circle:
      this.parseCircle();
      break;
    case F2dDataType.dt_arc:
      this.parseArc();
      break;
    case F2dDataType.dt_int_array:
      this.parseIntArray();
      break;
    case F2dDataType.dt_varint_array:
      this.parseVarintArray();
      break;
    case F2dDataType.dt_byte_array:
      this.parseByteArray();
      break;
    case F2dDataType.dt_string:
      this.parseString();
      break;
    case F2dDataType.dt_double_array:
      this.parseDoubleArray();
      break;
    default:
      this.error = true;
      _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.info("Data type not supported yet: " + data_type);
      break;
  }
};

F2D.prototype.readHeader = function () {
  var stream = this.stream = new _common_InputStream__WEBPACK_IMPORTED_MODULE_4__.InputStream(this.data);

  // "F2D"
  var header = stream.getString(3);

  if (header !== "F2D") {
    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.error("Invalid F2D header : " + header, (0,_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_6__.errorCodeString)(_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_6__.ErrorCodes.BAD_DATA));
    return false;
  }

  var versionMajor = stream.getString(2);
  if (versionMajor !== "01") {
    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.error("Only support f2d major version 1; actual version is : " + versionMajor, (0,_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_6__.errorCodeString)(_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_6__.ErrorCodes.BAD_DATA));
    return false;
  }

  var dot = stream.getString(1);
  if (dot !== ".") {
    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.error("Invalid version delimiter.", (0,_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_6__.errorCodeString)(_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_6__.ErrorCodes.BAD_DATA));
    return false;
  }

  var versionMinor = stream.getString(2);
  return true;
};

F2D.prototype.parse = function () {
  // Read and check header
  if (!this.readHeader())
  return;

  var stream = this.stream;
  while (stream.offset < stream.byteLength) {
    this.parseDataType();
    if (this.error)
    break;
    this.opCount++;
  }

  if (this.linkNumber) {
    this.linkBoxes[this.linkNumber] = this.currentLinkBox.clone();
    this.currentLinkBox.makeEmpty();
  }

  this.flushBuffer(0, true);
  this.currentVbb = null;

  this.stream = null;
  this.data = null;

  _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.info("F2d parse: data types count : " + this.opCount);
};

F2D.prototype.parseFrames = function (flush) {

  if (this.data) {
    var stream = this.stream = new _common_InputStream__WEBPACK_IMPORTED_MODULE_4__.InputStream(this.data);
    while (stream.offset < stream.byteLength) {
      this.parseDataType();
      if (this.error)
      break;
      this.opCount++;
    }
  } else if (!flush) {
    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Unexpected F2D parse state: If there is no data, we only expect a flush command, but flush was false.");
  }

  if (flush) {
    this.flushBuffer(0, true);
  }

  this.stream = null;
  this.data = null;
};

// ================= Semantic Analysis Pass ======================//

F2D.prototype.actOnPolylinePointsArray = function (points) {

  this.flushBuffer();

  // For now only consider this.fill == false case.
  // TODO: handle fill case.

  var count = points.length / 2;

  var totalLen = 0;
  var x0 = points[0];
  var y0 = points[1];
  for (var i = 1; i < count; ++i) {
    var x1 = points[2 * i];
    var y1 = points[2 * i + 1];

    // TODO: make sure this function can be reused as is.
    this.currentVbb.addSegment(x0, y0, x1, y1, totalLen, this.lineWeight, this.color, this.objectNumber, this.layer, this.currentVpId);

    totalLen += Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));

    x0 = x1;
    y0 = y1;
  }

  this.numPolylines++;
  this.numLineSegs += count - 1;

  this.currentGeomMetrics.plines++;
  this.currentGeomMetrics.pline_points += count - 1;
};

F2D.prototype.actOnDot = function (points) {

  this.currentGeomMetrics.dots++;

  var x0 = points[0];
  var y0 = points[1];

  this.actOnCompleteCircle(x0, y0, this.sx(1), true);
};


F2D.prototype.actOnCompleteCircle = function (cx, cy, radius, skipCount) {
  // Relative positions.
  this.flushBuffer();
  this.numCircles++;

  if (!skipCount)
  this.currentGeomMetrics.circles++;

  if (this.fill) {
    //A simple filled circle can be handled
    //as degenerate thick line segment -- lots of these
    //in line style grass clippings
    this.currentVbb.addSegment(cx, cy, cx, cy, 0, 2 * radius, this.color, this.objectNumber,
    this.layer, this.currentVpId);
  } else {
    this.currentVbb.addArc(cx, cy, 0, 2 * Math.PI, /*major*/radius, /*minor*/radius, /*tilt*/0.0,
    this.lineWeight, this.color, this.objectNumber, this.layer, this.currentVpId);
  }
};

F2D.prototype.actOnCircularArc = function (cx, cy, start, end, radius) {
  this.numCircles++;
  this.currentGeomMetrics.circ_arcs++;
  this.flushBuffer();

  //    debug("circle " + start + " " + end + " c " + this.color.toString(16));

  this.currentVbb.addArc(cx, cy, start, end, /*major*/radius, /*minor*/radius, /*tilt*/0.0,
  this.lineWeight, this.color, this.objectNumber, this.layer, this.currentVpId);
};

F2D.prototype.actOnArc = function (cx, cy, start, end, major, minor, rotation) {
  this.numEllipses++;
  this.currentGeomMetrics.arcs++;
  // TODO: need this?
  this.flushBuffer();
  this.currentVbb.addArc(cx, cy, start, end, major, minor, rotation,
  this.lineWeight, this.color, this.objectNumber, this.layer, this.currentVpId);
};

F2D.prototype.actOnRaster = function () {

  if (!this.manifestAvailable)
  return;

  this.flushBuffer(4, true);

  var ps = this.parseObjState.raster;

  var position = ps.position,
    imageId = ps.imageId,
    imageUri = this.imageId2URI[imageId];

  var width = this.sx(ps.width),
    height = this.sy(ps.height);

  var centerX = position[0] + 0.5 * width,
    centerY = position[1] - 0.5 * height;

  this.currentVbb.addTexturedQuad(centerX, centerY, width, height, /*rotation*/0, 0xff00ffff, this.objectNumber, this.layer, this.currentVpId);
  this.currentImage = { dataURI: imageUri };

  //We can do one image per Vertex Buffer, so flush the quad
  this.flushBuffer(0, true);

  //TODO: we need to compare the contents of the raster also.
  this.currentGeomMetrics.rasters++;
};

F2D.prototype.actOnClip = function () {

  var v = this.parseObjState.clip;
  this.parseObjState.clip = {};

  this.clips.push(v);

  this.currentGeomMetrics.clips++;
};

F2D.prototype.actOnText = function () {
  //TODO: text not currently used for rendering,
  //but we collect the strings for search/lookup purposes
  this.strings[this.currentStringNumber] = this.parseObjState.text.string;

  this.currentGeomMetrics.texts++;
  this.currentGeomMetrics.strings.push(this.parseObjState.text.string);

  this.stringDbIds[this.currentStringNumber] = this.objectNumber;
  this.stringBoxes.push(this.currentStringBox.min.x, this.currentStringBox.min.y, this.currentStringBox.max.x, this.currentStringBox.max.y);
  if (this.extendStringsFetching) {
    this.stringCharWidths.push(this.parseObjState.text.charWidths);
    this.stringAngles.push(this.parseObjState.text.rotation);
    this.stringPositions.push(this.parseObjState.text.position);
    this.stringHeights.push(this.parseObjState.text.height);
  }
  this.currentStringBox.makeEmpty();
  this.currentStringNumber = -1;
  if (this.objectNumber < -1)
  this.objectNumber = 0; //reset the current object ID in case we were using a fake one for the text object
};


var _tmpVector = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__.LmvVector3();

//Polytriangle processing differs depending on whether
//we want edge antialiasing and whether the renderer is using
//hardware instancing or not, so it require a lot more
//work than other geometries before sending raw primitives to the
//vertex buffer.
F2D.prototype.addPolyTriangle = function (points, colors, inds, color, dbId, layer, antialiasEdges) {
  var me = this;
  var edgeMap = null;

  //For non-text geometry we get good looking results with
  //1 pixel outlines. For text, which is generally small and highly detailed,
  //a 0.5 pixel AA outline does better.
  var aaLineWeight = -1.0; //negative = in pixel units
  if (this.objectStack[this.objectStack.length - 1] == F2dSemanticType.st_text)
  aaLineWeight = -0.5;


  function processEdge(iFrom, iTo) {
    if (iFrom > iTo) {
      var tmp = iFrom;
      iFrom = iTo;
      iTo = tmp;
    }

    if (!edgeMap[iFrom])
    edgeMap[iFrom] = [iTo];else
    {
      var adjacentVerts = edgeMap[iFrom];
      var idx = adjacentVerts.lastIndexOf(iTo);
      if (idx == -1)
      adjacentVerts.push(iTo); //first time we see this edge, so remember it as exterior edge
      else
      adjacentVerts[idx] = -1; //the second time we see an edge mark it as interior edge
    }
  }


  function addAllAntialiasEdges() {

    for (var i = 0, iEnd = edgeMap.length; i < iEnd; i++) {

      var adjacentVerts = edgeMap[i];
      if (!adjacentVerts)
      continue;

      for (var j = 0; j < adjacentVerts.length; j++) {
        var iTo = adjacentVerts[j];
        if (iTo == -1)
        continue; //an interior edge was here -- skip
        else {
          //exterior edge -- add an antialiasing line for it
          me.flushBuffer(4);
          me.currentVbb.addSegment(points[2 * i], points[2 * i + 1],
          points[2 * iTo], points[2 * iTo + 1],
          0,
          aaLineWeight,
          me.mapColor(colors ? colors[i] : color, true),
          dbId, layer, me.currentVpId);
          {
            if (colors && colors[i] != colors[iTo])
            _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Gouraud triangle encountered. Will have incorrect antialiasing.");}
        }
      }
    }
  }

  function antialiasOneEdge(iFrom, iTo) {
    if (iFrom > iTo) {
      var tmp = iFrom;
      iFrom = iTo;
      iTo = tmp;
    }

    var adjacentVerts = edgeMap[iFrom];
    if (!adjacentVerts)
    return;

    var idx = adjacentVerts.indexOf(iTo);
    if (idx != -1) {
      //exterior edge -- add an antialiasing line for it
      me.flushBuffer(4);
      me.currentVbb.addSegment(points[2 * iFrom], points[2 * iFrom + 1],
      points[2 * iTo], points[2 * iTo + 1],
      0,
      aaLineWeight,
      me.mapColor(colors ? colors[iFrom] : color, true),
      dbId, layer, me.currentVpId);

      if (colors && colors[iFrom] != colors[iTo])
      _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Gouraud triangle encountered. Will have incorrect antialiasing.");
    }
  }

  if (antialiasEdges) {
    edgeMap = new Array(points.length / 2);

    for (var i = 0, iEnd = inds.length; i < iEnd; i += 3) {
      var i0 = inds[i];
      var i1 = inds[i + 1];
      var i2 = inds[i + 2];

      processEdge(i0, i1);
      processEdge(i1, i2);
      processEdge(i2, i0);
    }
  }

  //If the polytriangle is part of tesselated text or hyperlink, add it to the current
  //text object bounding box
  if (this.currentStringNumber !== -1 || this.linkNumber) {
    var count = points.length / 2; // number of vertices
    for (var i = 0; i < count; ++i) {
      _tmpVector.set(points[2 * i], points[2 * i + 1], 0);

      if (this.currentStringNumber !== -1)
      this.currentStringBox.expandByPoint(_tmpVector);

      if (this.linkNumber)
      this.currentLinkBox.expandByPoint(_tmpVector);
    }
  }

  if (this.currentVbb.useInstancing) {
    var count = inds.length;
    for (var i = 0; i < count; i += 3) {
      var i0 = inds[i];
      var i1 = inds[i + 1];
      var i2 = inds[i + 2];

      this.flushBuffer(4);

      this.currentVbb.addTriangleGeom(points[2 * i0], points[2 * i0 + 1],
      points[2 * i1], points[2 * i1 + 1],
      points[2 * i2], points[2 * i2 + 1],
      this.mapColor(colors ? colors[i0] : color, true), dbId, layer, this.currentVpId);

      if (antialiasEdges) {
        antialiasOneEdge(i0, i1);
        antialiasOneEdge(i1, i2);
        antialiasOneEdge(i2, i0);
      }
    }
  } else
  {
    var count = points.length / 2; // number of vertices

    this.flushBuffer(count);
    var vbb = this.currentVbb;
    var vbase = vbb.vcount;

    for (var i = 0; i < count; ++i) {
      var x = points[2 * i];
      var y = points[2 * i + 1];
      vbb.addVertexPolytriangle(x, y, this.mapColor(colors ? colors[i] : color, true), dbId, layer, this.currentVpId);
    }

    vbb.addIndices(inds, vbase);

    if (antialiasEdges) {
      addAllAntialiasEdges();
    }

  }
};

F2D.prototype.actOnPolyTriangle = function () {

  var ptri = this.parseObjState.polyTriangle;
  this.parseObjState.polyTriangle = {};

  var points = ptri.points;
  var inds = ptri.indices;
  var colors = ptri.colors;

  if (!points || !inds) {
    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Malformed polytriangle.");
    return;
  }

  //Skip polytriangles that belong to text strings from the geometry stats
  //as they are not relevant to the sheet signature computation
  if (this.objectStack[this.objectStack.length - 1] == F2dSemanticType.st_text) {
    if (this.excludeTextGeometry) {
      return;
    }
  } else {
    this.currentGeomMetrics.ptris++;
    this.currentGeomMetrics.ptri_points += points.length / 2;
    this.currentGeomMetrics.ptri_indices += inds.length;
  }

  this.numPolytriangles++;
  this.numTriangles += inds.length / 3;

  this.addPolyTriangle(points, colors, inds, this.color, this.objectNumber, this.layer, true);
};

F2D.prototype.actOnViewport = function () {

  var v = this.parseObjState.viewport;
  this.parseObjState.viewport = {};

  v.geom_metrics = this.currentGeomMetrics = initGeomMetrics();

  this.viewports.push(v);
  this.currentVpId = this.viewports.length - 1;
};

F2D.prototype.createLayerGroups = function (layers) {

  // Temporary: build the layers tree. Eventually the extractor
  // should be the one doing this; we're incompletely faking it
  // by looking at the layer names.
  //
  var layersRoot = this.layersRoot = { name: 'root', id: 'root', childrenByName: {}, isLayer: false };
  var groupId = 0,layerId = 0;

  for (var l in layers) {

    var index = parseInt(l);
    var layerDef = layers[l];

    var name = typeof layerDef === "string" ? layerDef : layerDef.name;

    if (!name)
    name = l; //won't get here...

    var path = name.split('|');
    var parent = layersRoot;

    if (path.length > 1) {
      for (var i = 0; i < path.length - 1; ++i) {
        var pathComponent = path[i];
        var item = parent.childrenByName[pathComponent];
        if (!item) {
          item = {
            name: pathComponent,
            id: 'group-' + groupId++,
            childrenByName: {},
            isLayer: false
          };
          parent.childrenByName[pathComponent] = item;
        }
        parent = item;
      }
    }

    parent.childrenByName[name] = {
      name: name,
      index: index,
      id: layerId++,
      childrenByName: {},
      isLayer: true
    };
  }

  function sortLayers(parent) {
    var children = Object.keys(parent.childrenByName).map(function (k) {return parent.childrenByName[k];});
    delete parent.childrenByName;

    if (children.length) {
      parent.children = children;

      parent.childCount = 0;

      for (var i = 0; i < children.length; ++i) {
        parent.childCount += sortLayers(children[i]);
      }

      children.sort(function (a, b) {
        if (a.isLayer && !b.isLayer) {
          return -1; // Layers before groups
        } else if (!a.isLayer && b.isLayer) {
          return 1;
        }
        return a.name.localeCompare(b.name, undefined, { sensitivity: 'base', numeric: true }); // Sort layers and groups by name
      });
    }

    return parent.isLayer ? 1 : parent.childCount;
  }
  sortLayers(this.layersRoot);
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/f2d/F2dGeometry.js":
/*!***************************************************!*\
  !*** ./src/file-loaders/lmvtk/f2d/F2dGeometry.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F2DGeometry: () => (/* binding */ F2DGeometry)
/* harmony export */ });
/* harmony import */ var _GeometryBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeometryBuilder */ "./src/file-loaders/lmvtk/f2d/GeometryBuilder.js");
/* harmony import */ var _common_InputStream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/InputStream */ "./src/file-loaders/lmvtk/common/InputStream.js");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../logger/Logger */ "./src/logger/Logger.js");
/* harmony import */ var _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../net/ErrorCodes */ "./src/file-loaders/net/ErrorCodes.js");
/* harmony import */ var _F2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./F2d */ "./src/file-loaders/lmvtk/f2d/F2d.js");






class F2DGeometry {
  constructor(metadata, options) {
    this.metadata = metadata;
    this.scaleX = 1;
    this.scaleY = 1;
    this.bbox = { min: { x: 0, y: 0, z: 0 }, max: { x: 0, y: 0, z: 0 } };
    this.fillColor = null;
    if (metadata) {
      const dimensions = metadata.page_dimensions;
      this.setScale(dimensions);
    }

    this.excludeTextGeometry = options.excludeTextGeometry || true;

    this.dbId = 0;
    this.maxDbId = 0;

    this.geometry = new _GeometryBuilder__WEBPACK_IMPORTED_MODULE_0__.GeometryBuilder();

    // Newly added f2d pasing stuff.
    this.error = false;

    // Last absolute positions of point parsed so far.
    // Used to decode relative positions parsed from points array.
    this.offsetX = 0;
    this.offsetY = 0;
  }

  setScale(dims) {
    this.paperWidth = dims.page_width;
    this.paperHeight = dims.page_height;

    // TODO: scale parsing.
    this.scaleX = this.paperWidth / dims.plot_width;
    this.scaleY = this.paperHeight / dims.plot_height;
  }

  load(loadContext, fydoPack) {
    if (!(fydoPack instanceof Uint8Array)) fydoPack = new Uint8Array(fydoPack);
    this.data = fydoPack;
    this.parse();

    loadContext.loadDoneCB(true);
  }

  loadFrames(loadContext) {
    this.loadContext = loadContext;

    let data = loadContext.data;

    if (data) {
      if (!(data instanceof Uint8Array)) data = new Uint8Array(data);
      this.data = data;
    } else if (loadContext.finalFrame) {
      this.data = null;
    }

    this.probeFrames(loadContext.finalFrame);

    loadContext.loadDoneCB(true);
  }

  sx(x) {
    //TODO: The hardcoded scale is used to get the integer coords from FYDO
    //into something normal and close to page coordinates
    return x * this.scaleX;
  }

  sy(y) {
    //TODO: The hardcoded scale is used to get the integer coords from FYDO
    //into something normal and close to page coordinates
    return y * this.scaleY;
  }

  // ====================== F2D Parser ================================= //

  parserAssert(actualType, expectedType, functionName) {
    if (actualType != expectedType) {
      _logger_Logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn(
        "Expect " +
        expectedType +
        "; actual type is " +
        actualType +
        "; in function " +
        functionName
      );
      this.error = true;
      return true;
    } else {
      return false;
    }
  }

  parseDataType() {
    const data_type = this.stream.getVarints();
    switch (data_type) {
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_void:
        this.parseVoid();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_int:
        this.parseInt();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_object:
        this.parseObject();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_varint:
        this.parseVarint();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_point_varint:
        this.parsePoint();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_float:
        this.parseFloat();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_point_varint_array:
        this.parsePointsArray();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_circular_arc:
        this.parseCircularArc();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_circle:
        this.parseCircle();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_arc:
        this.parseArc();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_int_array:
        this.parseIntArray();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_varint_array:
        this.parseVarintArray();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_byte_array:
        this.parseByteArray();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_string:
        this.parseString();
        break;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dDataType.dt_double_array:
        this.parseDoubleArray();
        break;
      default:
        this.error = true;
        _logger_Logger__WEBPACK_IMPORTED_MODULE_2__.logger.info("Data type not supported yet: " + data_type);
        break;
    }
  }

  readHeader() {
    const stream = this.stream = new _common_InputStream__WEBPACK_IMPORTED_MODULE_1__.InputStream(this.data);

    // "F2D"
    const header = stream.getString(3);

    if (header !== "F2D") {
      _logger_Logger__WEBPACK_IMPORTED_MODULE_2__.logger.error(
        "Invalid F2D header : " + header,
        (0,_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__.errorCodeString)(_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__.ErrorCodes.BAD_DATA)
      );
      return false;
    }

    const versionMajor = stream.getString(2);
    if (versionMajor !== "01") {
      _logger_Logger__WEBPACK_IMPORTED_MODULE_2__.logger.error(
        "Only support f2d major version 1; actual version is : " + versionMajor,
        (0,_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__.errorCodeString)(_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__.ErrorCodes.BAD_DATA)
      );
      return false;
    }

    const dot = stream.getString(1);
    if (dot !== ".") {
      _logger_Logger__WEBPACK_IMPORTED_MODULE_2__.logger.error(
        "Invalid version delimiter.",
        (0,_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__.errorCodeString)(_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__.ErrorCodes.BAD_DATA)
      );
      return false;
    }

    const versionMinor = stream.getString(2);
    return true;
  }

  probe() {
    const stream = this.stream;
    this.error = false;

    try {
      while (stream.offset < stream.byteLength) {
        this.parseDataType();
        if (this.error) {
          break;
        }
      }
    } catch (exc) {
      // Typically caused by out of bounds access of data.
      const message = exc.toString();
      const stack = exc.stack ? exc.stack.toString() : "...";

      // Don't panic with this - we are supposed to hit out of bounds a couple of times when probing.
      _logger_Logger__WEBPACK_IMPORTED_MODULE_2__.logger.error(
        "Error in F2DProbe.prototype.probe : " +
        message +
        " with stack : " +
        stack
      );
    }
  }

  parse() {
    // Read and check header
    if (!this.readHeader()) return;
    this.probe();
  }

  parseFrames() {
    if (this.data) {
      this.stream = new _common_InputStream__WEBPACK_IMPORTED_MODULE_1__.InputStream(this.data);
      this.probe();
    }

    this.stream = null;
    this.data = null;
  }

  // === Parse Geometry === //

  parsePointPositions() {
    let x = this.stream.getVarints();
    let y = this.stream.getVarints();

    x = (0,_F2d__WEBPACK_IMPORTED_MODULE_4__.restoreSignBitFromLSB)(x);
    y = (0,_F2d__WEBPACK_IMPORTED_MODULE_4__.restoreSignBitFromLSB)(y);

    x += this.offsetX;
    y += this.offsetY;

    this.offsetX = x;
    this.offsetY = y;

    return [this.sx(x), this.sy(y)];
  }

  parseObject() {
    this.stream.getVarints();
  }

  parseString() {
    const s = this.stream;
    s.getVarints(); //skip past the semantics

    const len = s.getVarints();
    return s.getString(len);
  }

  parsePoint() {
    const s = this.stream;
    s.getVarints(); //skip past the semantics
    this.parsePointPositions();
  }

  parsePointsArray() {
    const s = this.stream;
    const sema = s.getVarints();

    let count = s.getVarints(); // number of coordinates * 2
    if (!count) return;
    count = count / 2;

    const ret = [];
    let position;

    for (let i = 0; i < count; ++i) {
      position = this.parsePointPositions();
      ret.push(position[0]);
      ret.push(position[1]);
    }

    switch (sema) {
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dSemanticType.st_polyline:
        this.actOnPolylinePointsArray(ret);
        return;
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dSemanticType.st_dot:
        this.actOnDot(ret[0], ret[1]);
        return;
      default:
        _logger_Logger__WEBPACK_IMPORTED_MODULE_2__.logger.info("Unexpected opcode semantic type for points array.");
        break;
    }
  }

  parseArray(getFunction) {
    const s = this.stream;
    s.getVarints();
    const count = s.getVarints(); // total number of elements in integer array.

    for (let i = 0; i < count; ++i) {
      getFunction();
    }
  }

  parseIntArray() {
    const s = this.stream;
    this.parseArray(s.getUint32.bind(s));
  }

  parseDoubleArray() {
    const s = this.stream;
    this.parseArray(s.getFloat64.bind(s));
  }

  parseByteArray() {
    const s = this.stream;
    this.parseArray(s.getUint8.bind(s));
  }

  parseVarintArray() {
    const s = this.stream;
    this.parseArray(s.getVarints.bind(s));
  }

  parseInt() {
    const sema = this.stream.getVarints();
    const val = this.stream.getUint32();
    switch (sema) {
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dSemanticType.st_fill:
        this.fillColor = val;
        break;
    }

    return val;
  }

  parseFloat() {
    this.stream.getVarints();
    this.stream.getFloat32();
  }

  parseVoid() {
    var sema = this.stream.getVarints();
    switch (sema) {
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dSemanticType.st_fill_off:
        this.fillColor = null;
        break;
    }
  }

  parseVarint() {
    const s = this.stream;
    const semantic_type = s.getVarints();
    const val = s.getVarints();

    switch (semantic_type) {
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dSemanticType.st_object_id:
      case _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dSemanticType.st_markup_id:
        this.dbId = val;
        this.maxDbId = Math.max(this.maxDbId, val);
        break;
      default:
        break;
    }
  }

  parseCircularArc() {
    const s = this.stream;
    const sema = s.getVarints();
    if (this.parserAssert(sema, _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dSemanticType.st_arc, "parseCircularArc"))
    return;

    const point = this.parsePointPositions();
    const major = s.getVarints();
    const start = s.getFloat32();
    const end = s.getFloat32();

    this.actOnCircularArc(point[0], point[1], start, end, this.sx(major));
  }

  parseCircle() {
    const s = this.stream;
    const sema = s.getVarints();
    if (this.parserAssert(sema, _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dSemanticType.st_arc, "parseCircle")) return;

    const point = this.parsePointPositions();
    const major = s.getVarints();

    this.actOnCompleteCircle(point[0], point[1], this.sx(major));
  }

  parseArc() {
    const s = this.stream;
    const sema = s.getVarints();
    if (this.parserAssert(sema, _F2d__WEBPACK_IMPORTED_MODULE_4__.F2dSemanticType.st_arc, "parseArc")) return;

    // Relative positions.
    const point = this.parsePointPositions();

    const major = s.getVarints();
    const minor = s.getVarints();

    const rotation = s.getFloat32();
    const start = s.getFloat32();
    const end = s.getFloat32();

    this.actOnArc(
      point[0],
      point[1],
      start,
      end,
      this.sx(major),
      this.sy(minor),
      rotation
    );
  }

  // ================= Semantic Analysis Pass ======================//
  actOnPolylinePointsArray(points) {
    this.geometry.addPolyLine(points, this.fillColor, this.dbId);
  }

  actOnDot(x, y) {
    this.actOnCompleteCircle(x, y, this.sx(1));
  }

  actOnCompleteCircle(cx, cy, radius) {
    // Relative positions.
    this.geometry.addCircularArc(
      cx,
      cy,
      /*major*/radius,
      0,
      2 * Math.PI,
      this.dbId
    );
  }

  actOnCircularArc(cx, cy, start, end, radius) {
    this.geometry.addCircularArc(
      cx,
      cy,
      /*major*/radius,
      start,
      end,
      this.dbId
    );
  }

  actOnArc(cx, cy, start, end, major, minor) {
    this.geometry.addEllipticalArc(cx, cy, start, end, major, minor, this.dbId);
  }

  actOnPolyTriangle() {
    _logger_Logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("Polytriangles not currently supported.");
    return;
  }
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/f2d/F2dProbe.js":
/*!************************************************!*\
  !*** ./src/file-loaders/lmvtk/f2d/F2dProbe.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F2DProbe: () => (/* binding */ F2DProbe)
/* harmony export */ });
/* harmony import */ var _CheckedInputStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CheckedInputStream */ "./src/file-loaders/lmvtk/f2d/CheckedInputStream.js");
/* harmony import */ var _F2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./F2d */ "./src/file-loaders/lmvtk/f2d/F2d.js");
/* harmony import */ var _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../net/ErrorCodes */ "./src/file-loaders/net/ErrorCodes.js");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../logger/Logger */ "./src/logger/Logger.js");








function F2DProbe() {
  this.data = null;
  this.frameStart = 0;
  this.frameEnd = 0;
  this.stream = null;
  this.opCount = 0;
  this.marker = { frameStart: this.frameStart,
    frameEnd: this.frameEnd };
}

F2DProbe.prototype.load = function (data) {
  this.data = data;
  this.frameStart = 0;

  if (!this.stream) {
    this.stream = new _CheckedInputStream__WEBPACK_IMPORTED_MODULE_0__.CheckedInputStream(this.data);
    // Skip headers.
    this.stream.seek(8);
    this.frameStart = 8;
    this.frameEnd = 8;
  } else
  {
    this.stream.reset(this.data);
    this.stream.seek(0);
    this.frameEnd = 0;
  }

  this.probe();
  this.marker.frameStart = this.frameStart;
  this.marker.frameEnd = this.frameEnd;
  return this.marker;
};

var F2dProbeDataType = _F2d__WEBPACK_IMPORTED_MODULE_1__.F2dDataType;
var F2dProbeSemanticType = _F2d__WEBPACK_IMPORTED_MODULE_1__.F2dSemanticType;

F2DProbe.prototype.readColor = function () {
  var s = this.stream;
  s.getVarints(); // data type : dt_int 3
  s.getVarints(); // semantic type : st_object_member 0
  s.skipUint32(); // color
};

F2DProbe.prototype.parsePointPositions = function () {
  this.stream.getVarints();
  this.stream.getVarints();
};

F2DProbe.prototype.unhandledTypeWarning = function (inFunction, semanticType) {
  _logger_Logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("Unhandled semantic type when probing F2d : " + semanticType + " in function " + inFunction);
};

F2DProbe.prototype.parseObject = function () {
  /*var semantic_type =*/this.stream.getVarints();
  //debug("object parsing : type" + semantic_type);
};


F2DProbe.prototype.parseString = function () {
  var s = this.stream;
  s.getVarints();
  var len = s.getVarints();
  s.skipBytes(len);
};

F2DProbe.prototype.parsePoint = function () {
  this.stream.getVarints();
  this.parsePointPositions();
};

F2DProbe.prototype.parseVarintArray = function () {
  var s = this.stream;
  s.getVarints();

  var count = s.getVarints();
  for (var i = 0; i < count; ++i)
  s.getVarints();
};

F2DProbe.prototype.parseByteArray = function () {
  var s = this.stream;
  s.getVarints();
  var count = s.getVarints();
  s.skipBytes(count);
};

F2DProbe.prototype.parseEndOfObject = function () {
  var s = this.stream;
  s.getVarints();
  s.getVarints();
};

F2DProbe.prototype.parsePointsArray = function (context) {
  var s = this.stream;
  var sema = s.getVarints();
  var count = s.getVarints(); // number of coordinates * 2
  if (!count) return;
  count = count / 2;
  for (var i = 0; i < count; ++i)
  this.parsePointPositions();
};

F2DProbe.prototype.parsePoint = function (context) {
  var s = this.stream;
  var sema = s.getVarints();
  this.parsePointPositions();
};

F2DProbe.prototype.parseInt = function () {
  var s = this.stream;
  var sema = s.getVarints();

  switch (sema) {
    case F2dProbeSemanticType.st_color:
      s.skipUint32();
      break;
    case F2dProbeSemanticType.st_fill:{
        s.skipUint32();
        break;
      }
    default:
      s.skipUint32();
      this.unhandledTypeWarning('parseInt', sema);
      break;
  }
};

F2DProbe.prototype.parseVoid = function () {
  var sema = this.stream.getVarints();
  switch (sema) {
    case F2dProbeSemanticType.st_fill_off:
      break;
    default:
      this.unhandledTypeWarning('parseVoid', sema);
      break;
  }
};

F2DProbe.prototype.parseVarint = function () {
  this.stream.getVarints();
  this.stream.getVarints();
};

F2DProbe.prototype.parseIntArray = function () {
  var s = this.stream;
  s.getVarints();
  var count = s.getVarints();
  for (var i = 0; i < count; ++i)
  s.skipUint32();
};

F2DProbe.prototype.parseFloat = function () {
  var s = this.stream;
  s.getVarints();
  s.getFloat32();
};

F2DProbe.prototype.parseDoubleArray = function () {
  var s = this.stream;
  s.getVarints();
  var count = s.getVarints();
  for (var i = 0; i < count; ++i)
  s.skipFloat64();
};

F2DProbe.prototype.parseCircularArc = function () {
  var s = this.stream;
  s.getVarints();
  this.parsePointPositions();
  s.getVarints();
  s.getFloat32();
  s.getFloat32();
};

F2DProbe.prototype.parseCircle = function () {
  var s = this.stream;
  s.getVarints();
  this.parsePointPositions();
  s.getVarints();
};

F2DProbe.prototype.parseArc = function () {
  var s = this.stream;
  s.getVarints();
  this.parsePointPositions();
  s.getVarints();
  s.getVarints();
  s.getFloat32();
  s.getFloat32();
  s.getFloat32();
};

F2DProbe.prototype.parseDataType = function () {
  var data_type = this.stream.getVarints();

  switch (data_type) {
    case F2dProbeDataType.dt_void:
      this.parseVoid();
      break;
    case F2dProbeDataType.dt_int:
      this.parseInt();
      break;
    case F2dProbeDataType.dt_object:
      this.parseObject();
      break;
    case F2dProbeDataType.dt_varint:
      this.parseVarint();
      break;
    case F2dProbeDataType.dt_float:
      this.parseFloat();
      break;
    case F2dProbeDataType.dt_point_varint:
      this.parsePoint();
      break;
    case F2dProbeDataType.dt_point_varint_array:
      this.parsePointsArray();
      break;
    case F2dProbeDataType.dt_circular_arc:
      this.parseCircularArc();
      break;
    case F2dProbeDataType.dt_circle:
      this.parseCircle();
      break;
    case F2dProbeDataType.dt_arc:
      this.parseArc();
      break;
    case F2dProbeDataType.dt_varint_array:
      this.parseVarintArray();
      break;
    case F2dProbeDataType.dt_int_array:
      this.parseIntArray();
      break;
    case F2dProbeDataType.dt_byte_array:
      this.parseByteArray();
      break;
    case F2dProbeDataType.dt_string:
      this.parseString();
      break;
    case F2dProbeDataType.dt_double_array:
      this.parseDoubleArray();
      break;
    default:
      this.error = true;
      _logger_Logger__WEBPACK_IMPORTED_MODULE_3__.logger.error("Bad op code encountered : " + data_type + " , bail out.", (0,_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__.errorCodeString)(_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__.ErrorCodes.BAD_DATA));
      break;
  }

  if (!this.error)
  this.frameEnd = this.stream.offset;
};

F2DProbe.prototype.probe = function () {
  var stream = this.stream;
  var error = false;

  try {
    while (stream.offset < stream.byteLength) {
      this.parseDataType();
      if (this.error) {
        break;
      }
      this.opCount++;
    }
  } catch (exc) {
    // Typically caused by out of bounds access of data.
    var message = exc.toString();
    var stack = exc.stack ? exc.stack.toString() : "...";

    // Don't panic with this - we are supposed to hit out of bounds a couple of times when probing.
    //debug("Error in F2DProbe.prototype.probe : " + message + " with stack : " + stack);
  }
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/f2d/GeometryBuilder.js":
/*!*******************************************************!*\
  !*** ./src/file-loaders/lmvtk/f2d/GeometryBuilder.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeometryBuilder: () => (/* binding */ GeometryBuilder)
/* harmony export */ });
const createEllipticalCurveData = (
center,
majorAxis,
minorAxis,
tiltInRadians,
startInRadians,
endInRadians,
dbId) => (
{
  ellipse: {
    center,
    majorAxis,
    minorAxis,
    tiltInRadians
  },
  startInRadians,
  endInRadians,
  dbId
});

const createCircularCurveData = (
center,
radius,
startInRadians,
endInRadians,
dbId) => (
{
  type: "circularCurve",
  circle: {
    center,
    radius
  },
  startInRadians,
  endInRadians,
  dbId
});

const createPolyLineData = (vertices, fillColor, dbId) => ({
  type: "polyLine",
  vertices,
  fillColor,
  dbId
});

const createTriangleData = (_ref, dbId) => {let [point1, point2, point3] = _ref;return {
    type: "triangle",
    point1,
    point2,
    point3,
    dbId
  };};

const createLineSegmentData = (from, to, dbId) => ({
  type: "lineSegment",
  from,
  to,
  dbId
});

class GeometryBuilder {
  constructor() {
    this.numPolyLine = 0;
    this.numEllipticals = 0;
    this.numCirculars = 0;
    this.numSegments = 0;
    this.geometries = [];
  }

  addPolyLine(flatPoints, fillColor, dbId) {

    this.numPolyLine++;
    const count = flatPoints.length / 2;
    const points = [];
    for (let i = 0; i < count; i++) {
      points.push({ x: flatPoints[2 * i], y: flatPoints[2 * i + 1] });
    }
    const polyLine = createPolyLineData(points, fillColor, dbId);
    this.geometries.push(polyLine);
  }

  addSegment(to, from, dbId) {
    this.numSegments++;
    const lineSegment = createLineSegmentData(to, from, dbId);
    this.geometries.push(lineSegment);
  }

  addCircularArc(cx, cy, radius, start, end, dbId) {
    this.numCirculars++;

    const circularArc = createCircularCurveData(
      [cx, cy],
      radius,
      start,
      end,
      dbId
    );
    this.geometries.push(circularArc);
  }

  addEllipticalArc(cx, cy, start, end, majorRadius, minorRadius, dbId) {
    this.numEllipticals++;
    const circularArc = createEllipticalCurveData(
      [cx, cy],
      majorRadius,
      minorRadius,
      start,
      end,
      dbId
    );
    this.geometries.push(circularArc);
  }
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/otg/HashStrings.js":
/*!***************************************************!*\
  !*** ./src/file-loaders/lmvtk/otg/HashStrings.js ***!
  \***************************************************/
/***/ ((module) => {

var TO_HEX = new Array(256);
for (var i = 0; i < 256; i++) {
  var s = i.toString(16);
  if (s.length === 1)
  s = "0" + s;
  TO_HEX[i] = s;
}

//Most common case is for SHA1 hashes, which are 20 bytes
var tmpArr20 = new Array(20);

function getHexString(buffer, offset, length) {
  var res = length === 20 ? tmpArr20 : [];

  for (var i = 0; i < length; i++) {
    var b = buffer[offset + i];
    var s = TO_HEX[b];
    res[i] = s;
  }

  return res.join("");
}

var tmpArr10 = new Array(10);

//Converts the input byte array into a string of half the length
//by packing two bytes into each string character (JS strings are two bytes per char)
function getHexStringPacked(buffer, offset, length) {
  var res = length === 20 ? tmpArr10 : [];

  for (var i = 0; i < length; i += 2) {
    var b0 = buffer[offset + i];
    var b1 = buffer[offset + i + 1];
    res[i / 2] = b1 << 8 | b0;
  }

  return String.fromCharCode.apply(null, res);
}

//Converts from UCS16 packed string (two bytes per character) to
//regular ASCII string of 4x the length
function unpackHexString(s) {
  var res = s.length === 10 ? tmpArr20 : [];

  for (var i = 0; i < s.length; i++) {
    var bytes = s.charCodeAt(i);
    res[2 * i] = TO_HEX[bytes & 0xff];
    res[2 * i + 1] = TO_HEX[bytes >> 8 & 0xff];
  }

  return res.join("");
}


function hexToDec(code) {
  //0-9
  if (code >= 48 && code <= 57) {
    return code - 48;
  }
  //A-F
  if (code >= 65 && code <= 70) {
    return code - 55;
  }
  //a-f
  if (code >= 97 && code <= 102) {
    return code - 87;
  }

  return 0;
}

//Convert string in hex format, e.g. "3498572abc" to binary
function hexToBin(str, buf, offset) {

  // Go directly from packed to bin
  if (str.length === 10) {
    unpackToBin(str, buf, offset);
    return;
  }

  let j = offset;
  for (let i = 0; i < s.length; i += 2) {
    let d1 = hexToDec(s.charCodeAt(i));
    let d2 = hexToDec(s.charCodeAt(i + 1));
    buf[j++] = d1 << 4 | d2;
  }
}

function unpackToBin(s, buf, offset) {
  let j = offset;
  for (var i = 0; i < s.length; i++) {
    var bytes = s.charCodeAt(i);
    let h1 = TO_HEX[bytes & 0xff]; // char 1
    let h2 = TO_HEX[bytes >> 8 & 0xff]; // char 2

    let d1 = hexToDec(h1.charCodeAt(0));
    let d2 = hexToDec(h1.charCodeAt(1));
    buf[j++] = d1 << 4 | d2;

    d1 = hexToDec(h2.charCodeAt(0));
    d2 = hexToDec(h2.charCodeAt(1));
    buf[j++] = d1 << 4 | d2;
  }
}

module.exports = {
  //getHexString,
  getHexStringPacked,
  unpackHexString,
  hexToBin
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/otg/LocalDbCache.js":
/*!****************************************************!*\
  !*** ./src/file-loaders/lmvtk/otg/LocalDbCache.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LocalDbCache: () => (/* binding */ LocalDbCache)
/* harmony export */ });
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../compat */ "./src/compat.js");




//All object stores go into this database
const DB_NAME = "otg";

const CONTENT_STORE = "otg-content";
const CONTENT_STORE_LRU = "otg-lru";


class LocalDbCache {

  constructor(forceDisabled, isInlineWorker) {
    this.db = null;
    this.readTransaction = null;
    this.loaded = false;
    this.opening = false;

    this.dbDisabled = this._isDbDisabled(forceDisabled, isInlineWorker);

    if (!(0,_compat__WEBPACK_IMPORTED_MODULE_0__.isNodeJS)() && this.dbDisabled) {
      console.log("IndexedDb disabled");
    }

    this.storeName = CONTENT_STORE;
    this.storeNameTimestamp = CONTENT_STORE_LRU;
    this.bothStoreNames = [this.storeName, this.storeNameTimestamp];

    this.useCompression = true;
    this.pendingTimestampUpdates = {};
    this.pendingTimestampCount = 0;

    this.pendingStores = [];

    this._pendingCallbacks = [];
  }

  // Disable on Safari until we figure out why performance is terrible.
  // Disable on Node.js because we don't need to cache locally on the server side
  // Disable on Mobile until we decide if we want the performance hit there.
  // Disable IE11 & Edge if worker created from a Blob URL. IndexedDB is not supported in that case.
  _isDbDisabled(forceDisabled, isInlineWorker) {
    return (
      forceDisabled ||
      (0,_compat__WEBPACK_IMPORTED_MODULE_0__.isNodeJS)() ||
      (0,_compat__WEBPACK_IMPORTED_MODULE_0__.isSafari)() ||
      (0,_compat__WEBPACK_IMPORTED_MODULE_0__.isMobileDevice)() ||
      _compat__WEBPACK_IMPORTED_MODULE_0__.isIE11 && isInlineWorker ||
      typeof indexedDB === "undefined");

  }

  notifyPendingCallbacks(error) {
    this._pendingCallbacks.forEach((cb) => cb(error, this.db));
    this._pendingCallbacks = [];
  }

  open(cb) {

    if (this.dbDisabled) {
      cb && cb();
      return;
    }

    //Call back immediately if we are already open
    if (this.loaded) {
      cb && cb(null, this.db);
      return;
    }

    //Delay callback if we are still waiting to open.
    if (this.opening) {
      cb && this._pendingCallbacks.push(cb);
      return;
    }

    this.opening = true;

    //Open the IndexedDb database connection
    let request = indexedDB.open(DB_NAME, 1);

    request.onerror = (event) => {
      console.error("Failed to open or create cache database.");
      this.dbDisabled = true;
      this.notifyPendingCallbacks(event);
    };
    request.onsuccess = (event) => {

      this.opening = false;
      this.db = event.target.result;

      this.db.onerror = function (event) {
        console.error("Database error", event);
      };

      this.loaded = true;
      this.notifyPendingCallbacks();

      /*
      this.size((err, data) => {
          console.log(data);
      });
      */
    };

    request.onupgradeneeded = (event) => {

      console.log("Db upgrade", this.storeName);

      // Save the IDBDatabase interface
      let db = event.target.result;

      // Create the database schema
      db.createObjectStore(CONTENT_STORE);
      let os = db.createObjectStore(CONTENT_STORE_LRU);
      os.createIndex(CONTENT_STORE_LRU + "-index", "t", { unique: false });
    };
  }


  deleteOld(callback) {

    if (!this.db) {
      callback();
      return;
    }

    if (this.deleteInProgress)
    return;

    this.deleteInProgress = true;

    let howMany = 200;

    //Avoid deleting stuff that was last used a short while ago, by using a range query
    let upperBoundOpenKeyRange = IDBKeyRange.upperBound(Date.now() - 300 * 1000, true);

    let hashes = [];

    let objectStore = this.db.transaction([this.storeNameTimestamp] /*, "readwrite"*/).objectStore(this.storeNameTimestamp);

    let index = objectStore.index(this.storeNameTimestamp + "-index");

    index.openCursor(upperBoundOpenKeyRange).onsuccess = (event) => {
      let cursor = event.target.result;
      if (cursor && hashes.length < howMany) {
        hashes.push(cursor.primaryKey);
        cursor.continue();
        return;
      }

      if (hashes.length) {

        console.log("Deleting old objects.", hashes.length);

        let transaction = this.db.transaction(this.bothStoreNames, "readwrite");

        transaction.oncomplete = (event) => {
          this.deleteInProgress = false;
          console.log("Delete done");
          callback && callback();
        };

        transaction.onerror = (event) => {
          this.deleteInProgress = false;
          console.error("Transaction error.", event);
        };

        transaction.onabort = (event) => {
          this.deleteInProgress = false;
          let error = event.target.error; // DOMError
          console.log("Failed to delete cached objects", error);
        };

        let objectStoreMain = transaction.objectStore(this.storeName);
        let objectStoreTimestamp = transaction.objectStore(this.storeNameTimestamp);

        for (let i = 0; i < hashes.length; i++) {
          objectStoreMain.delete(hashes[i]);
          objectStoreTimestamp.delete(hashes[i]);
        }

      }
    };



  }


  flush(cb) {

    if (!this.pendingStores.length) {
      cb && cb();
      return;
    }

    if (!this.writeTransaction) {

      let transaction = this.db.transaction(this.bothStoreNames, "readwrite");

      if (cb) {
        transaction.oncomplete = (event) => {
          //console.log("Transaction complete");
          cb();
        };
      }

      transaction.onerror = (event) => {
        console.error("Transaction error.", event);
        cb && cb(event.target.error);
      };

      transaction.onabort = (event) => {
        let error = event.target.error; // DOMError
        if (error.name === 'QuotaExceededError') {
          //console.log("Quota exceeded");
          this.deleteOld(() => {});

        }
        cb && cb(event.target.error);
      };

      this.writeTransaction = transaction;
    }

    for (var i = 0; i < this.pendingStores.length; i += 2) {

      var hash = this.pendingStores[i];
      var data = this.pendingStores[i + 1];

      let objectStore = this.writeTransaction.objectStore(this.storeName);

      let storeBlob = objectStore.put(data, hash);

      storeBlob.onerror = (event) => {
        console.error("Object store error.", event);
      };

      let timestampStore = this.writeTransaction.objectStore(this.storeNameTimestamp);
      timestampStore.put({ t: Date.now() }, hash);

    }

    this.pendingStores = [];

    //TODO: reuse this transaction for longer
    this.writeTransaction = null;
  }


  store(hash, data, cb) {

    if (!this.db) {
      cb && cb();
      return;
    }

    // Most of the time (i.e. always) we're given a TypedArray that's a view on a larger ArrayBuffer:
    // The geoms/materials came through a websocket and the ArrayBuffer contains the whole message.
    // Even geoms that did not arrive in a batch contain a header that's not geometry data.
    // To prevent the entire ArrayBuffer being serialized into the cache, create a copy with just the part we're interested in.
    // This also keeps the data alive while the original ArrayBuffer might become unusable (see transferList in OtgLoadWorker)
    data = data.slice();

    this.pendingStores.push(hash);
    this.pendingStores.push(data);

    if (this.pendingStores.length < 200 || this.deleteInProgress) {
      cb && cb();
      return;
    }

    this.flush(cb);
  }


  flushTimestamps(cb) {

    let transaction = this.db.transaction([this.storeNameTimestamp], "readwrite");

    if (cb) {
      transaction.oncomplete = (event) => {
        //console.log("Transaction complete");
        cb();
      };
    }

    transaction.onerror = (event) => {
      console.error("Transaction error.", event);
      cb && cb(event.target.error);
    };

    transaction.onabort = (event) => {
      let error = event.target.error; // DOMError
      if (error.name === 'QuotaExceededError') {
        console.log("Quota exceeded");
        this.deleteOld(() => {});
      }
      cb && cb(event.target.error);
    };


    let timestampStore = transaction.objectStore(this.storeNameTimestamp);

    for (let hash in this.pendingTimestampUpdates) {
      timestampStore.put({ t: this.pendingTimestampUpdates[hash] }, hash);
    }

    this.pendingTimestampUpdates = {};
    this.pendingTimestampCount = 0;
  }

  _createReadTransaction() {
    //We try to keep the read transaction alive by reusing it
    //for all new requests. If they come fast enough, the transaction
    //will stay alive. If it completes, we will create a new one.
    let transaction = this.readTransaction = this.db.transaction(this.storeName);

    transaction.oncomplete = (event) => {
      this.readTransaction = null;
    };
    transaction.onerror = (event) => {
      console.error("Transaction error.", event);
      this.readTransaction = null;
    };
    transaction.onabort = (event) => {
      console.warn("Transaction abort", event);
      this.readTransaction = null;
    };
  }

  get(hash, cb) {

    if (this.opening) {
      console.error("Tried to get IndexedDb resource while database was still opening");
      cb(-1, null);
      return;
    }

    if (!this.db) {
      cb(-1, null);
      return;
    }

    //We try to reuse the same read transaction for as long as it will let us
    if (!this.readTransaction) {
      this._createReadTransaction();
    }

    let req;
    //This can fail if the transaction has gone inactive
    try {
      req = this.readTransaction.objectStore(this.storeName).get(hash);
    } catch (e) {
      this._createReadTransaction();
      req = this.readTransaction.objectStore(this.storeName).get(hash);
    }

    req.onsuccess = (event) => {

      //Somehow we sometimes end up getting null for an existing key
      //so we force reload
      if (!event.target.result) {
        cb(-1, null);
        return;
      }


      let data = event.target.result;

      cb(null, data);

      //Remember the new timestamp for this hash, but don't update
      //it in the mru table immediately, to avoid slowing down model load
      //with a write transaction.
      this.pendingTimestampUpdates[hash] = Date.now();
      this.pendingTimestampCount++;
    };

    req.onerror = (event) => {
      cb(event.target.errorCode);
    };

  }


  flushStoresAndTimestamps() {

    if (!this.db)
    return;

    this.flush((err) => {
      //console.log("Updating all timestamps");

      if (err) {
        return;
      }

      this.flushTimestamps();

    });

  }

  size(callback) {
    if (!this.db) {
      callback();
      return;
    }

    let size = 0;
    let items = 0;

    let transaction = this.db.transaction([this.storeName]).
    objectStore(this.storeName).
    openCursor();

    transaction.onsuccess = (event) => {
      let cursor = event.target.result;
      if (cursor) {
        let storedObject = cursor.value;
        size += storedObject.length;
        items++;
        cursor.continue();
      } else
      {
        callback(null, { size: size, items: items });
      }
    };

    transaction.onerror = function (err) {
      callback(err);
    };
  }

  estimateCachedHashCount(cb) {
    if (this.opening) {
      console.error("Tried to get IndexedDb resource while database was still opening");
      cb(undefined);
      return;
    }

    if (!this.db) {
      cb(undefined);
      return;
    }

    let transaction = this.db.transaction(this.storeNameTimestamp);
    let req;
    try {
      req = transaction.objectStore(this.storeNameTimestamp).openKeyCursor();
    } catch (e) {
      cb(undefined);
      return;
    }

    let count = 2;
    const probePosition = 1000;
    req.onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        if (--count > 0) {
          // first call: advance to a specific position in the sorted order of hashes
          cursor.advance(probePosition - 1);
        } else {
          // second call: check key and estimate total hash count
          // the estimation assumes uniform hash distribution (md5() is used to calculate the hash from some block of data)
          // and sorted access through IndexDb
          // it takes the first two bytes of the hash at position `probePosition` and extrapolates the position for 65536 as the first two bytes 
          const firstWord = cursor.key.charCodeAt(0);
          const estimatedCount = probePosition * 65536 / firstWord;
          cb(estimatedCount);

          // no need to do anything else
          transaction.abort();
        }
      } else {
        // an immediately undefined cursor means an empty cache
        // an undefined cursor after advancing to `probePosition` means less than probePosition entries
        cb(count == 2 ? 0 : count == 1 ? probePosition : undefined);
      }
    };

    req.onerror = (event) => {
      cb(undefined);
    };
  }

  readAllCachedHashes(cb) {
    if (this.opening) {
      console.error("Tried to get IndexedDb resource while database was still opening");
      cb([]);
      return;
    }

    if (!this.db) {
      cb([]);
      return;
    }

    // reading all hashes from the timestamp store is faster than from the content store
    let transaction = this.db.transaction(this.storeNameTimestamp);
    let req;
    try {
      req = transaction.objectStore(this.storeNameTimestamp).getAllKeys();
    } catch (e) {
      cb([]);
      return;
    }

    req.onsuccess = (event) => {
      cb(event.target.result);
    };

    req.onerror = (event) => {
      cb([]);
    };
  }
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/otg/OtgFragInfo.js":
/*!***************************************************!*\
  !*** ./src/file-loaders/lmvtk/otg/OtgFragInfo.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OtgFragInfo: () => (/* binding */ OtgFragInfo)
/* harmony export */ });
/* harmony import */ var _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../wgs/scene/LmvBox3 */ "./src/wgs/scene/LmvBox3.js");


function setFromArray(array, offset) {

  this.min.x = array[offset];
  this.min.y = array[offset + 1];
  this.min.z = array[offset + 2];

  this.max.x = array[offset + 3];
  this.max.y = array[offset + 4];
  this.max.z = array[offset + 5];
}

function copyToArray(array, offset) {

  array[offset] = this.min.x;
  array[offset + 1] = this.min.y;
  array[offset + 2] = this.min.z;

  array[offset + 3] = this.max.x;
  array[offset + 4] = this.max.y;
  array[offset + 5] = this.max.z;
}

//Overload of the default FragInfo, used with OTG-specific fragments_extra data file
//to initialize the BVH spatial index.
function OtgFragInfo(data, loadContext) {

  var byteStride = data[1] << 8 | data[0];
  //var version = data[3] << 8 | data[2];

  if (!byteStride)
  byteStride = 7 * 4;

  this.boxStride = byteStride / 4;
  this.count = data.byteLength / byteStride - 1;

  //Global offset set by the viewer loader client
  let globalOffset = loadContext.globalOffset || { x: 0, y: 0, z: 0 };

  //Internal double precision offset used in the OTG file format (always set as of November 2018)
  let fo = loadContext.fragmentTransformsOffset || { x: 0, y: 0, z: 0 };

  if (this.count) {
    //make views directly into the first data record (skipping the header record)
    this.boxes = new Float32Array(data.buffer, byteStride);
    this.flags = new Int32Array(data.buffer, byteStride);

    //apply placement transform if given
    var boxes = this.boxes;

    if (loadContext.placementTransform) {
      var tmpBox = new _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_0__.LmvBox3();
      var offset = 0;
      for (var i = 0; i < this.count; i++, offset += this.boxStride) {

        setFromArray.call(tmpBox, boxes, offset);

        //Add back the built-in OTG offset
        tmpBox.min.x += fo.x;
        tmpBox.min.y += fo.y;
        tmpBox.min.z += fo.z;
        tmpBox.max.x += fo.x;
        tmpBox.max.y += fo.y;
        tmpBox.max.z += fo.z;


        tmpBox.applyMatrix4(loadContext.placementWithOffset); //this will apply both placement and global offset at once

        copyToArray.call(tmpBox, boxes, offset);
      }
    } else {

      var ox = fo.x - globalOffset.x;
      var oy = fo.y - globalOffset.y;
      var oz = fo.z - globalOffset.z;

      //Faster code path when we only have global offset and no placement transform
      for (var i = 0, offset = 0; i < this.count; i++, offset += this.boxStride) {

        boxes[offset] += ox;
        boxes[offset + 1] += oy;
        boxes[offset + 2] += oz;

        boxes[offset + 3] += ox;
        boxes[offset + 4] += oy;
        boxes[offset + 5] += oz;
      }
    }
  }

  this.hasPolygonCounts = true;
  this.wantSort = false;
}

OtgFragInfo.prototype.getCount = function () {
  return this.count;
};

OtgFragInfo.prototype.isTransparent = function (i) {
  var flags = this.flags[i * this.boxStride + 6];
  return !!(flags & 0x01000000);
};

OtgFragInfo.prototype.getPolygonCount = function (i) {
  var flags = this.flags[i * this.boxStride + 6];
  return flags & 0xffffff;
};

/***/ }),

/***/ "./src/file-loaders/lmvtk/otg/OtgGeomCodec.js":
/*!****************************************************!*\
  !*** ./src/file-loaders/lmvtk/otg/OtgGeomCodec.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readLmvBufferGeom: () => (/* binding */ readLmvBufferGeom),
/* harmony export */   serializeLmvBufferGeom: () => (/* binding */ serializeLmvBufferGeom)
/* harmony export */ });
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../compat */ "./src/compat.js");
/* harmony import */ var _common_InputStream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/InputStream */ "./src/file-loaders/lmvtk/common/InputStream.js");
/* harmony import */ var _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../wgs/scene/LmvBox3 */ "./src/wgs/scene/LmvBox3.js");
/* harmony import */ var _wgs_scene_BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../wgs/scene/BufferGeometryUtils */ "./src/wgs/scene/BufferGeometryUtils.js");






/*
Integers encoded in *little endian*

Magic header: LMV0 (4 bytes)
Flags: 2 bytes (isLine, isPoint, isWideLine, etc.)
Num buffers: 1 byte
Num attributes: 1 byte (attributes are fixed size)
Buf Offsets (from beginning of data block, first buffer is always at 0, so is skipped): 4 bytes each
Attributes: {
	Name: 1 byte enum (Index, IndexEdges, Position, Normal, TextureUV, Color)
	itemSize: 1/2 byte low nibble (must be 1,2,3 or 4)
	itemType: 1/2 byte hi nibble (BYTE, SHORT, UBYTE, USHORT, FLOAT ...)
	itemOffset: 1 byte (in bytes)
	itemStride: 1 byte (stride in bytes)
	buffer Idx: 1 bytes
} (5 bytes each)

(padding bytes to make data stream offset a multiple of 4)

Data: binary, concatenated vertex and index streams
*/

const AttributeName = {
  Index: 0,
  IndexEdges: 1,
  Position: 2,
  Normal: 3,
  TextureUV: 4,
  Color: 5
};

const AttributeType = {
  BYTE: 0,
  SHORT: 1,
  UBYTE: 2,
  USHORT: 3,

  BYTE_NORM: 4,
  SHORT_NORM: 5,
  UBYTE_NORM: 6,
  USHORT_NORM: 7,

  FLOAT: 8,
  INT: 9,
  UINT: 10
  //DOUBLE: 11
};


const MeshFlags = {
  //NOTE: Lower two bits are NOT A BITMASK!!!
  TRIANGLES: 0,
  LINES: 1,
  POINTS: 2,
  WIDE_LINES: 3


};


const LMV2OTGAttr = {
  "position": AttributeName.Position,
  "normal": AttributeName.Normal,
  "index": AttributeName.Index,
  "indexlines": AttributeName.IndexEdges,
  "color": AttributeName.Color
};

const OTG2LMVAttr = {};
OTG2LMVAttr[AttributeName.Position] = "position";
OTG2LMVAttr[AttributeName.Normal] = "normal";
OTG2LMVAttr[AttributeName.Index] = "index";
OTG2LMVAttr[AttributeName.IndexEdges] = "indexlines";
OTG2LMVAttr[AttributeName.Color] = "color";
OTG2LMVAttr[AttributeName.TextureUV] = "uv";


const AttributeTypeToSize = {};
AttributeTypeToSize[AttributeType.BYTE] = 1;
AttributeTypeToSize[AttributeType.SHORT] = 2;
AttributeTypeToSize[AttributeType.UBYTE] = 1;
AttributeTypeToSize[AttributeType.USHORT] = 2;
AttributeTypeToSize[AttributeType.BYTE_NORM] = 1;
AttributeTypeToSize[AttributeType.SHORT_NORM] = 2;
AttributeTypeToSize[AttributeType.UBYTE_NORM] = 1;
AttributeTypeToSize[AttributeType.USHORT_NORM] = 2;
AttributeTypeToSize[AttributeType.FLOAT] = 4;
AttributeTypeToSize[AttributeType.INT] = 4;
AttributeTypeToSize[AttributeType.UINT] = 4;
//DOUBLE: 11



function rotate(tri) {
  var tmp = tri[0];
  tri[0] = tri[1];
  tri[1] = tri[2];
  tri[2] = tmp;
}

function deltaEncodeIndexBuffer3(ib) {

  var triangles = [];

  for (var i = 0; i < ib.length; i += 3) {
    triangles.push(
      [ib[i], ib[i + 1], ib[i + 2]]
    );
  }

  //Sort the indices for each triangle so that
  //the first one is smallest
  for (var i = 0; i < triangles.length; i++) {
    var t = triangles[i];

    while (t[0] > t[1] || t[0] > t[2]) {
      rotate(t);
    }
  }

  //Sort triangles by ascending first index
  triangles.sort(function (a, b) {
    return a[0] - b[0];
  });

  //Delta encode the indices
  var t = triangles[0];
  var j = 0;
  ib[j] = t[0];
  ib[j + 1] = t[1] - t[0];
  ib[j + 2] = t[2] - t[0];
  j += 3;

  for (var i = 1; i < triangles.length; i++, j += 3) {
    t = triangles[i];

    ib[j] = t[0] - triangles[i - 1][0];
    ib[j + 1] = t[1] - t[0];
    ib[j + 2] = t[2] - t[0];
  }

}

function deltaEncodeIndexBuffer2(ib) {

  var lines = [];

  for (var i = 0; i < ib.length; i += 2) {
    lines.push(
      [ib[i], ib[i + 1]]
    );
  }

  //Sort the indices for each triangle so that
  //the first one is smallest
  for (var i = 0; i < lines.length; i++) {
    var t = lines[i];

    if (t[0] > t[1]) {
      var tmp = t[0];
      t[0] = t[1];
      t[1] = tmp;
    }
  }

  //Sort lines by ascending first index
  lines.sort(function (a, b) {
    return a[0] - b[0];
  });

  //Delta encode the indices
  var t = lines[0];
  var j = 0;
  ib[j] = t[0];
  ib[j + 1] = t[1] - t[0];
  j += 2;

  for (var i = 1; i < lines.length; i++, j += 2) {
    t = lines[i];

    ib[j] = t[0] - lines[i - 1][0];
    ib[j + 1] = t[1] - t[0];
  }

}


function deltaDecodeIndexBuffer3(ib) {

  if (!ib.length)
  return;

  ib[1] += ib[0];
  ib[2] += ib[0];

  for (var i = 3; i < ib.length; i += 3) {
    ib[i] += ib[i - 3];
    ib[i + 1] += ib[i];
    ib[i + 2] += ib[i];
  }
}

function deltaDecodeIndexBuffer2(ib) {

  if (!ib.length)
  return;

  ib[1] += ib[0];

  for (var i = 2; i < ib.length; i += 2) {
    ib[i] += ib[i - 2];
    ib[i + 1] += ib[i];
  }
}

function attrNameMapper(attributeName) {

  var name = LMV2OTGAttr[attributeName];
  if (typeof name !== "undefined")
  return name;

  if (attributeName.indexOf("uv") === 0) {
    return AttributeName.TextureUV;
  }

  console.warn("Unknown attribute name");
  return AttributeName.TextureUV;
}


function attrNameToLMV(attrName) {

  var lmvAttr = OTG2LMVAttr[attrName];
  if (lmvAttr)
  return lmvAttr;

  console.error("Unknown vertex attribute");
  return AttributeName.TextureUV;
}


function attrTypeMapper(attr) {

  var type = AttributeType.FLOAT;

  var itemWidth = attr.bytesPerItem || 4;
  if (itemWidth === 1) {
    type = attr.normalized ? AttributeType.UBYTE_NORM : AttributeType.UBYTE;
  } else if (itemWidth === 2) {
    type = attr.normalized ? AttributeType.USHORT_NORM : AttributeType.USHORT;
  }

  return type << 4 | attr.itemSize & 0xf;
}

function indexTypeMapper(attr) {
  var type = AttributeType.USHORT;

  var itemWidth = attr.bytesPerItem || 2;
  if (itemWidth === 1) {
    type = AttributeType.UBYTE;
  } else if (itemWidth === 2) {
    type = AttributeType.USHORT;
  } else if (itemWidth === 4) {
    type = AttributeType.UINT;
  }

  return type << 4 | attr.itemSize & 0xf;
}


function OtgGeomEncoder() {
}


OtgGeomEncoder.prototype.beginHeader = function (meshFlag, numAttributes, dataStreamLengths) {
  var headerSize = 8;

  var numBuffers = dataStreamLengths.length;
  headerSize += (numBuffers - 1) * 4;

  headerSize += numAttributes * 5;

  while (headerSize % 4 !== 0) {
    headerSize++;
  }

  var totalDataSize = 0;
  for (var i = 0; i < dataStreamLengths.length; i++)
  totalDataSize += dataStreamLengths[i];

  this.buffer = Buffer.alloc(headerSize + totalDataSize);
  this.writeOffset = 0;

  //Write the 4 byte magic prefix
  const MAGIC = "OTG0";
  for (var i = 0; i < 4; i++) {
    this.writeOffset = this.buffer.writeUInt8(MAGIC.charCodeAt(i), this.writeOffset);
  }

  //TODO: line width if wide lines and pointSize if points

  this.writeOffset = this.buffer.writeUInt16LE(meshFlag, this.writeOffset);

  this.writeOffset = this.buffer.writeUInt8(numBuffers, this.writeOffset);

  this.writeOffset = this.buffer.writeUInt8(numAttributes, this.writeOffset);

  //write buffer offsets from the beginning of the binary data block
  //Skip the first buffer as its at offset zero
  var offset = dataStreamLengths[0];
  for (var i = 1; i < dataStreamLengths.length; i++) {
    this.writeOffset = this.buffer.writeUInt32LE(offset, this.writeOffset);
    offset += dataStreamLengths[i];
  }
};

OtgGeomEncoder.prototype.addAttribute = function (attrName, attr, stride, bufferIndex) {
  this.writeOffset = this.buffer.writeUInt8(attrName, this.writeOffset);

  if (attrName === AttributeName.Index || attrName === AttributeName.IndexEdges) {

    this.writeOffset = this.buffer.writeUInt8(indexTypeMapper(attr), this.writeOffset);

    this.writeOffset = this.buffer.writeUInt8((attr.itemOffset || 0) * 4, this.writeOffset); //itemOffset
    this.writeOffset = this.buffer.writeUInt8((stride || 0) * 4, this.writeOffset); //itemStride

    this.writeOffset = this.buffer.writeUInt8(bufferIndex, this.writeOffset); //buffer index
  } else {
    this.writeOffset = this.buffer.writeUInt8(attrTypeMapper(attr), this.writeOffset);

    this.writeOffset = this.buffer.writeUInt8((attr.itemOffset || 0) * 4, this.writeOffset); //itemOffset (LMV stores in multiples of 4)
    this.writeOffset = this.buffer.writeUInt8((stride || 0) * 4, this.writeOffset); //itemStride (LMV stores in multiples of 4)

    this.writeOffset = this.buffer.writeUInt8(bufferIndex, this.writeOffset); //buffer index
  }
};


OtgGeomEncoder.prototype.endHeader = function () {
  //Padding so that buffers are written at multiple of 4
  while (this.writeOffset % 4 !== 0) {
    this.writeOffset = this.buffer.writeUInt8(0, this.writeOffset);
  }
};

OtgGeomEncoder.prototype.addBuffer = function (buffer) {
  buffer.copy(this.buffer, this.writeOffset);
  this.writeOffset += buffer.length;
};


OtgGeomEncoder.prototype.end = function () {
  if (this.writeOffset !== this.buffer.length) {
    console.error("Incorrect encoding buffer size");
  }

  return this.buffer;
};



function OtgGeomDecoder(buf) {

  this.buffer = buf;
  this.readOffset = 0;

  this.meshFlag = 0;
  this.numBuffers = 0;
  this.numAttributes = 0;
  this.bufferOffsets = [];
  this.attributes = [];
  this.buffers = [];
}


OtgGeomDecoder.prototype.readNodeJS = function () {

  var magic = this.buffer.toString("ascii", 0, 4);
  if (magic !== "OTG0") {
    console.error("Invalid OTG header");
    return false;
  }

  this.readOffset = 4;

  this.meshFlag = this.buffer.readUInt16LE(this.readOffset);
  this.readOffset += 2;

  this.numBuffers = this.buffer.readUInt8(this.readOffset);
  this.readOffset++;

  this.numAttributes = this.buffer.readUInt8(this.readOffset);
  this.readOffset++;

  if (this.numBuffers) {
    this.bufferOffsets.push(0);

    for (var i = 1; i < this.numBuffers; i++) {
      var boff = this.buffer.readUInt32LE(this.readOffset);
      this.readOffset += 4;
      this.bufferOffsets.push(boff);
    }
  }

  for (var i = 0; i < this.numAttributes; i++) {
    var attr = {};

    attr.name = this.buffer.readUInt8(this.readOffset);
    this.readOffset++;

    var type = this.buffer.readUInt8(this.readOffset);
    this.readOffset++;

    attr.itemSize = type & 0xf;
    attr.type = type >> 4;

    attr.bytesPerItem = AttributeTypeToSize[attr.type];

    attr.normalized = attr.type === AttributeType.BYTE_NORM ||
    attr.type === AttributeType.SHORT_NORM ||
    attr.type === AttributeType.UBYTE_NORM ||
    attr.type === AttributeType.USHORT_NORM;


    attr.itemOffset = this.buffer.readUInt8(this.readOffset) / 4;
    this.readOffset++;

    attr.itemStride = this.buffer.readUInt8(this.readOffset) / 4;
    this.readOffset++;

    attr.bufferIndex = this.buffer.readUInt8(this.readOffset);
    this.readOffset++;

    this.attributes.push(attr);
  }

  //seek to the beginning of the buffer data
  while (this.readOffset % 4 !== 0)
  this.readOffset++;

  for (var i = 0; i < this.bufferOffsets.length; i++) {

    var startOffset = this.readOffset + this.bufferOffsets[i];
    var endOffset;

    if (i < this.bufferOffsets.length - 1) {
      endOffset = this.readOffset + this.bufferOffsets[i + 1];
    } else {
      endOffset = this.buffer.length;
    }

    this.buffers.push(this.buffer.slice(startOffset, endOffset));
  }

  return true;
};


OtgGeomDecoder.prototype.readWeb = function () {

  var stream = new _common_InputStream__WEBPACK_IMPORTED_MODULE_1__.InputStream(this.buffer);

  var magic = stream.getString(4);
  if (magic !== "OTG0") {
    console.error("Invalid OTG header");
    return false;
  }


  this.meshFlag = stream.getUint16();
  this.numBuffers = stream.getUint8();
  this.numAttributes = stream.getUint8();

  if (this.numBuffers) {
    this.bufferOffsets.push(0);

    for (var i = 1; i < this.numBuffers; i++) {
      var boff = stream.getUint32();
      this.bufferOffsets.push(boff);
    }
  }

  for (var i = 0; i < this.numAttributes; i++) {
    var attr = {};

    attr.name = stream.getUint8();

    var type = stream.getUint8();

    attr.itemSize = type & 0xf;
    attr.type = type >> 4;

    attr.bytesPerItem = AttributeTypeToSize[attr.type];

    attr.normalized = attr.type === AttributeType.BYTE_NORM ||
    attr.type === AttributeType.SHORT_NORM ||
    attr.type === AttributeType.UBYTE_NORM ||
    attr.type === AttributeType.USHORT_NORM;


    attr.itemOffset = stream.getUint8() / 4;

    attr.itemStride = stream.getUint8() / 4;

    attr.bufferIndex = stream.getUint8();

    this.attributes.push(attr);
  }

  //seek to the beginning of the buffer data
  while (stream.offset % 4 !== 0)
  stream.offset++;

  for (var i = 0; i < this.bufferOffsets.length; i++) {

    var startOffset = stream.offset + this.bufferOffsets[i];
    var endOffset;

    if (i < this.bufferOffsets.length - 1) {
      endOffset = stream.offset + this.bufferOffsets[i + 1];
    } else {
      endOffset = stream.byteLength;
    }

    this.buffers.push(this.buffer.subarray(startOffset, endOffset));
  }

  return true;
};


OtgGeomDecoder.prototype.read = function () {

  if ((0,_compat__WEBPACK_IMPORTED_MODULE_0__.isNodeJS)() && this.buffer instanceof Buffer) {
    return this.readNodeJS();
  } else {
    return this.readWeb();
  }
};


/**
 * @param {BufferGeometry} geom
 * @returns {Buffer}
 */
function serializeLmvBufferGeom(geom) {

  var otgEncoder = new OtgGeomEncoder();

  //Check for interleaved buffer. For now
  //this is the only one we support
  var bufSizes = [];
  let vbstride, vb, ib, iblines;
  if (!(0,_wgs_scene_BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_3__.isInterleavedGeometry)(geom)) {
    console.error("Unexpected non-interleaved vertex buffer");
    return null;
  } else {

    vb = geom.vb;
    vbstride = geom.vbstride;





    ib = (0,_wgs_scene_BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_3__.getIndexBufferArray)(geom);
    iblines = (0,_wgs_scene_BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_3__.getLineIndexBufferArray)(geom);

    bufSizes = [vb.byteLength, ib.byteLength];

    if (iblines) {
      bufSizes.push(iblines.byteLength);
    }
  }

  var attrKeys = Object.keys(geom.attributes);

  var meshFlag = 0;
  if (geom.isLines)
  meshFlag = meshFlag | MeshFlags.LINES;
  if (geom.isWideLines)
  meshFlag = meshFlag | MeshFlags.WIDE_LINES;
  if (geom.isPoints)
  meshFlag = meshFlag | MeshFlags.POINTS;

  otgEncoder.beginHeader(meshFlag, attrKeys.length, bufSizes);

  //Write the attributes
  for (var i = 0; i < attrKeys.length; i++) {
    var attr = geom.attributes[attrKeys[i]];
    var attrName = attrNameMapper(attrKeys[i]);

    if (attrKeys[i] === "index") {
      otgEncoder.addAttribute(attrName, attr, 0, 1);
    } else if (attrKeys[i] === "indexlines") {
      otgEncoder.addAttribute(attrName, attr, 0, 2);
    } else {
      otgEncoder.addAttribute(attrName, attr, vbstride, 0);
    }

  }

  otgEncoder.endHeader();

  //Write the buffers

  //Buffer 0
  var tmp = Buffer.from(vb.buffer, vb.byteOffset, vb.byteLength);
  otgEncoder.addBuffer(tmp);

  //Buffer 1
  if (geom.isLines)
  deltaEncodeIndexBuffer2(ib);else

  deltaEncodeIndexBuffer3(ib);

  tmp = Buffer.from(ib.buffer, ib.byteOffset, ib.byteLength);
  otgEncoder.addBuffer(tmp);

  //Buffer 2
  if (iblines) {
    deltaEncodeIndexBuffer2(iblines);

    tmp = Buffer.from(iblines.buffer, iblines.byteOffset, iblines.byteLength);
    otgEncoder.addBuffer(tmp);
  }

  var buf = otgEncoder.end();

  return buf;
}



var unitBox = new _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_2__.LmvBox3();
unitBox.min.x = -0.5;
unitBox.min.y = -0.5;
unitBox.min.z = -0.5;
unitBox.max.x = 0.5;
unitBox.max.y = 0.5;
unitBox.max.z = 0.5;

//var unitSphere = new THREE.Sphere();
//unitSphere.radius = Math.sqrt(0.5 * 0.5 * 3);
var unitSphere = {
  center: { x: 0, y: 0, z: 0 },
  radius: Math.sqrt(0.5 * 0.5 * 3)
};

function readLmvBufferGeom(buffer, skipEdges) {

  var dec = new OtgGeomDecoder(buffer);

  if (!dec.read()) {
    console.error("Failed to parse OTG geometry");
    return null;
  }

  //Assumes the interleaved buffer serialization we use by default
  //Maps the decoded data to the mdata/vblayout structures produced by
  //the LMV loader worker threads. It's slightly different from the LmvBufferGeometry fields
  var mesh = {
    vblayout: {},
    vb: new Float32Array(dec.buffers[0].buffer, dec.buffers[0].byteOffset, dec.buffers[0].byteLength / 4),
    isLines: (dec.meshFlag & 0x3) === MeshFlags.LINES,
    isWideLines: (dec.meshFlag & 0x3) === MeshFlags.WIDE_LINES,
    isPoints: (dec.meshFlag & 0x3) === MeshFlags.POINTS,
    boundingBox: unitBox,
    boundingSphere: unitSphere
  };

  //TODO: line width
  let uvCount = 0;

  for (var i = 0; i < dec.attributes.length; i++) {
    var attr = dec.attributes[i];

    if (attr.name === AttributeName.Index) {
      var ib = dec.buffers[1];
      if (attr.bytesPerItem === 1) {
        mesh.indices = ib;
      } else if (attr.bytesPerItem === 2) {
        mesh.indices = new Uint16Array(ib.buffer, ib.byteOffset, ib.byteLength / attr.bytesPerItem);
      } else if (attr.bytesPerItem === 4) {
        mesh.indices = new Uint32Array(ib.buffer, ib.byteOffset, ib.byteLength / attr.bytesPerItem);
      }

      if (mesh.isLines)
      deltaDecodeIndexBuffer2(mesh.indices);else

      deltaDecodeIndexBuffer3(mesh.indices);
    } else if (attr.name === AttributeName.IndexEdges) {
      if (!skipEdges) {
        var iblines = dec.buffers[2];
        if (attr.bytesPerItem === 1) {
          mesh.iblines = iblines;
        } else if (attr.bytesPerItem === 2) {
          mesh.iblines = new Uint16Array(iblines.buffer, iblines.byteOffset, iblines.byteLength / attr.bytesPerItem);
        } else if (attr.bytesPerItem === 4) {
          mesh.iblines = new Uint32Array(iblines.buffer, iblines.byteOffset, iblines.byteLength / attr.bytesPerItem);
        }

        deltaDecodeIndexBuffer2(mesh.iblines);
      }
    } else {
      var lmvAttr = attrNameToLMV(attr.name);

      if (lmvAttr === "uv") {
        uvCount++;
        if (uvCount > 1) {
          lmvAttr += uvCount.toString();
        }
      }

      if (!mesh.vbstride)
      mesh.vbstride = attr.itemStride;else
      {
        //We expect all vertex attributes to be packed into one VB
        if (mesh.vbstride !== attr.itemStride)
        console.error("Unexpected vertex buffer stride mismatch.");
      }

      if (attr.itemOffset >= attr.itemStride) {




        //Some old (pre- October 2018) meshes have an extra UV attribute defined even though
        //it's not physically in the vertex buffer data. We skip it here.
        //If the attribute offset is out of bounds, we just ignore it.
        //console.warn("Buggy OTG mesh. Ignoring out of bounds attribute");
      } else {mesh.vblayout[lmvAttr] = { bytesPerItem: attr.bytesPerItem, offset: attr.itemOffset, normalized: attr.normalized,
          itemSize: attr.itemSize
        };
      }
    }

  }

  var mdata = {
    mesh: mesh,
    packId: 0,
    meshIndex: 0
  };

  return mdata;

}

/***/ }),

/***/ "./src/file-loaders/lmvtk/otg/OtgWebSocket.js":
/*!****************************************************!*\
  !*** ./src/file-loaders/lmvtk/otg/OtgWebSocket.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { WebSocketBase, STATE } = __webpack_require__(/*! ./WebSocketBase */ "./src/file-loaders/lmvtk/otg/WebSocketBase.js");
const hexToBin = (__webpack_require__(/*! ./HashStrings */ "./src/file-loaders/lmvtk/otg/HashStrings.js").hexToBin);
const getHexStringPacked = (__webpack_require__(/*! ./HashStrings */ "./src/file-loaders/lmvtk/otg/HashStrings.js").getHexStringPacked);

//OTG web socket protocol.
class OtgWs extends WebSocketBase {

  //Packed message format, where the response from the server may contain multiple items in the same
  //buffer.
  /*
      The format is as follows:
       Bytes      Meaning
      ------------------------------
      0-3        Magic number. The bytes 'OPK1'
      4-7        Currently unused flags + resource type (ASCII 'm' or 'g') in byte 0 of this integer.
      8-11       Number of items in the message stream. Little endian.
      12-15      Offset of the first item in the data buffer (first item is implicitly at offset 0, so this is always zero)
      16-19      Offset of the second item in the data buffer
      20-...     etc... subsequent offsets, one per item
      ...
      Remaining bytes: all items combined into single buffer
  */

  _decodeMessage(buffer) {
    const prefixLength = 12;

    const headerInt = new Int32Array(buffer, 0, prefixLength / 4);

    if (headerInt[0] !== 0x314B504F) {
      console.error("Invalid message format", headerInt[0].toString(16), headerInt[1], buffer);
      return;
    }

    const resourceType = String.fromCharCode(headerInt[1] & 0xff);

    const numItems = headerInt[2];
    const offsets = new Int32Array(buffer, prefixLength, numItems);

    const baseOffset = prefixLength + numItems * 4;
    const items = new Uint8Array(buffer, baseOffset);

    const hashes = [];
    const arrays = [];

    for (let i = 0; i < offsets.length; i++) {
      const start = offsets[i];
      const end = i < offsets.length - 1 ? offsets[i + 1] : items.byteLength;

      const hash = getHexStringPacked(items, start, 20);
      const data = items.subarray(start + 20, end);

      this.numRequestsReceived++;
      if (resourceType === "e") {
        // The first four bytes are a HTTP-statuscode-like error code. It doesn't add anything to the message so we ignore it.
        // See https://git.autodesk.com/A360/platform-ds-ss/blob/6c439e82f3138eed3935b68096d2d980ffe95616/src/ws-server/ws-server.js#L310
        let errorMessage = new TextDecoder().decode(data.subarray(4));
        errorMessage = "The service returned the following message: " + errorMessage;
        let actualResourceType = this.inFlightRequests.get(hash).type;
        this.inFlightRequests.delete(hash);
        this.onResourceFailed(hash, actualResourceType, errorMessage);
        continue;
      }
      hashes.push(hash);
      arrays.push(data);
      this.inFlightRequests.delete(hash);
    }
    this.onResourcesReceived(hashes, arrays, resourceType);
  }


  _flushSendQueue() {var _this$ws;
    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) !== STATE.OPEN) {
      return;
    }

    for (const [accountId, pendingsSendsOfAccount] of this._pendingSends) {

      // Set accountId for the following messages
      if (this.accountIdSent !== accountId) {
        this.ws.send("/account_id/" + accountId);
        this.accountIdSent = accountId;
      }

      for (const [type, msgs] of pendingsSendsOfAccount) {
        if (!msgs.length)
        continue;

        this.numRequestsSent += msgs.length;

        //Send all hashes collected in requestResource in a single shot websocket message

        //Enlarge the accumulation buffer if needed
        const len = 1 + msgs.length * 20;
        if (this.msgBuffer.length < len) {
          this.msgBuffer = new Uint8Array(len);
        }

        this.msgBuffer[0] = type.charCodeAt(0);
        for (let i = 0; i < msgs.length; i++) {
          hexToBin(msgs[i], this.msgBuffer, 1 + i * 20);
        }
        this.ws.send(new Uint8Array(this.msgBuffer.buffer, 0, len));
      }
    }
    this._pendingSends.clear();
    this._numPendingSends = 0;
  }

  // @param {string}   url - request url
  // @param {string}   hash - corresponding hash
  // @param {string}   type - "m" or "g" (material or geometry)
  // @param {any}      queryParams - additional data passed back into onConnectionFailed (currently only used for the HTTP fallback)
  requestResource(url, hash, type, queryParams) {
    if (this.hasPermanentError) {
      console.error("requestResource called on unusable WebSocket");
      return;
    }

    const wspath = url.slice(url.indexOf("/cdn/") + 5);
    const accountId = wspath.split("/")[1];

    if (!this._pendingSends.has(accountId)) {
      this._pendingSends.set(accountId, new Map([
      ["g", []],
      ["m", []]]
      ));
    }
    this._pendingSends.get(accountId).get(type).push(hash);
    this._numPendingSends++;
    this.inFlightRequests.set(hash, { url: url, type: type, queryParams: queryParams });
  }
}

module.exports.OtgWs = OtgWs;

/***/ }),

/***/ "./src/file-loaders/lmvtk/otg/WebSocketBase.js":
/*!*****************************************************!*\
  !*** ./src/file-loaders/lmvtk/otg/WebSocketBase.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const WebSocket = __webpack_require__(/*! isomorphic-ws */ "./node_modules/isomorphic-ws/browser.js");

//Copied from compat.js to avoid importing ES6 exports from plain node.js forge-tools.
const isBrowser = typeof navigator !== "undefined";
const isNodeJS = function () {
  return !isBrowser;
};

// https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
const STATE = Object.freeze({
  CONNECTING: 0,
  OPEN: 1,
  CLOSING: 2,
  CLOSED: 3
});

/** A base class for web socket based resource loading.
 * 
 * Since this class has a history of race conditions and multiple attempts to fix them, here are some notes.
 * 
 * States a WebSocketBase can be in:
 * ws === null: Constructor OR closeWebSocket called, but not _openWebSocket
 * ws.readyState === CONNECTING: _openWebSocket called, but not onopen.
 * ws.readyState === OPEN: onopen called, but not closeWebSocket or onclose. 
 * ws.readyState === CLOSING: server/browser initiated a close, but onclose was not called yet. This is unexpected and will go to one of the error states.
 * ws.readyState === CLOSED && retryEvent: there was an unexpected error, and _openWebSocket will be called again shortly.
 * hasPermanentError: there was an unrecoverable error. Either WebSockets are not supported, or all retries to open one have failed.
 * 
 * Apart from OtgLoadWorker calling any of the API methods at any point, be aware of the following events:
 * * retryEvent firing
 * * The browser closes the WebSocket because the internet connection broke down. (code: 1006)
 * * The server closes the WebSocket after one minute without requests. (code: 1000, reason: 'Idle timeout')
 *     * When using on-demand loading, this is not an error. The WebSocket must be reopened when requestResource is called again.
 * * The server closes the WebSocket if a resource was requested that was not authorized. (code: 1007, reason: '401 (Unauthorized)')
 * * Any other internal server error.
 * * Also, be aware that closeWebSocket might never be called when on-demand loading is active.
 * 
 * When the WebSocket is closing, one task switches it to CLOSING without calling any handler, and another one later switches
 * it to CLOSED and calls the close handler, see https://websockets.spec.whatwg.org/#feedback-from-the-protocol.
 * Since this is done in a task, the state cannot suddenly change while any of our code is running.
 * It's ok that there's no onclosing handler: the CLOSING state will make every send() a noop, and our close/error handler will re-issue all requests.
 */
class WebSocketBase {

  constructor(url, queryParams, headers, onResourcesReceived, onResourceFailed, onConnectionFailed) {

    this.ws = null;
    this.url = url;
    this.queryParams = queryParams;
    this.headers = headers;
    this.numRequestsSent = 0;
    this.numRequestsReceived = 0;
    this.authorizeUrns = new Set();
    this._retriedOpen = 0;
    this.retryEvent = null;
    this.hasPermanentError = typeof WebSocket === "undefined" || !this.url;
    this.onResourcesReceived = onResourcesReceived;
    this.onResourceFailed = onResourceFailed;
    this.onConnectionFailed = onConnectionFailed;

    this._pendingSends = new Map();
    this._numPendingSends = 0;
    this.inFlightRequests = new Map();

    this.msgBuffer = new Uint8Array(201);
  }

  addAuthorizeUrn(authorizeUrn) {var _this$ws;
    if (this.authorizeUrns.has(authorizeUrn) || this.hasPermanentError) {
      return;
    }
    // Since this is also called on every requestResource, it's not strictly necessary here.
    // This is a performance optimization, to start opening the web socket as early as possible.
    this._openWebSocket();

    if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === STATE.OPEN) {
      // Since we won't go through the onOpen handler anymore, authorize the new urns directly.
      this.ws.send("/auth/" + authorizeUrn);
    }

    this.authorizeUrns.add(authorizeUrn);
  }

  _openWebSocket() {
    if (this.ws || this.hasPermanentError) {
      return;
    }

    //http and 7124->7125 are here to support local debugging, when the endpoints are overridden to
    //point directly to local node.js process(es).
    let url = this.url.replace("https:", "wss:").replace("http:", "ws:").replace(":7124", ":7125");

    if (this.queryParams) {
      url += "?" + this.queryParams;
    }

    this.ws = new WebSocket(url, undefined, isNodeJS() ? { headers: this.headers } : {});

    this.ws.onopen = () => {
      this.accountIdSent = null;
      this.ws.binaryType = "arraybuffer";

      //On web clients that do not use the cookie approach, the headers
      //will not get sent (unlike on node.js WebSocket implementation
      //so we send the Authorization first thing after open
      if (!isNodeJS()) {
        this.ws.send("/headers/" + JSON.stringify(this.headers));
      }

      //Tell the server that we expect batched responses
      this.ws.send("/options/" + JSON.stringify({ batch_responses: true, report_errors: true }));

      //Tell the server to authorize the web socket
      //for the URNs that we will be loading
      for (const urn of this.authorizeUrns) {
        this.ws.send("/auth/" + urn);
      }
    };

    this.ws.onmessage = (event) => this._decodeMessage(event.data);

    // We do not set onerror, since every error event is followed by a close event, so onclose is enough.
    // This will only be run for unexpected close events, because we reset the close event handler before closing the web socket intentionally 
    this.ws.onclose = (event) => {

      // Close code 1000 means NORMAL_CLOSURE, currently only used by the server on idle timeout. 
      // This is not an error and we don't wan't to retry in this case.
      if (event.code === 1000 && this.inFlightRequests.size === 0) {
        this.closeWebSocket(); // It's already closed, but we want to also reset the state.
        return;
      }

      console.warn(
        "Abnormal socket close.",
        "pending sends:", this._numPendingSends,
        "in flight", this.inFlightRequests.size,
        "event:", event
      );

      this._pendingSends = new Map();
      this._numPendingSends = 0;

      // try again opening later or give up
      if (this._retriedOpen < 3) {
        console.warn("Retrying");
        this._retriedOpen++;
        this.retryEvent = setTimeout(() => {
          this.retryEvent = null;
          this.ws = null;
          this._openWebSocket();
        }, 2000);
      } else {
        console.error("Too many WebSocket failures. Giving up.");
        this.hasPermanentError = true;
      }

      this.onConnectionFailed(this.inFlightRequests);
      this.inFlightRequests.clear();
    };
  }

  /** This should be called when no new requests are expected. */
  closeWebSocket() {
    if (!this.ws) {
      return;
    }
    // Violating this assert won't break something here, but in-flight requests will be lost
    // and pending requests will be issued on next _openWebSocket, which is probably not intended
    console.assert(this.inFlightRequests.size === 0, "closeWebSocket called even though there are requests in flight");

    if (this.retryEvent) {
      clearTimeout(this.retryEvent);
      this.retryEvent = null;
    }

    // We don't care if anything goes wrong past this point.
    // By unsetting this on regular close, any call to our onclose handler is unexpected and is an error.
    // This seemed more robust than checking for our closing message in the close handler.
    this.ws.onclose = null;

    const ws = this.ws;
    if (this.ws.readyState === STATE.CONNECTING) {
      // We could just close the connection right away, which is allowed by the spec.
      // However, browsers will print a warning which is not nice, in particular for small cached models that load
      // faster than the WS open, this would mean a fair bit of console spam. So we wait for the WS to open first.
      this.ws.onopen = () => ws.close(1000, "no more work expected"); // close code 1000 means normal closure
    } else {
      // If this.ws is CLOSING or CLOSED, close() is a NOOP.
      this.ws.close(1000, "no more work expected");
    }
    this.ws = null;
  }

  _decodeMessage(buffer) {
    throw new Error('Implement!');
  }

  _flushSendQueue() {
    throw new Error('Implement!');
  }

  /** This must not be called before a corresponding call to addAuthorizeUrn, otherwise the server will close the WebSocket
   *  and the WebSocketBase will go into the error state after retrying. */
  requestResource() {
    throw new Error('Implement!');
  }
}

module.exports.WebSocketBase = WebSocketBase;
module.exports.STATE = STATE;

/***/ }),

/***/ "./src/file-loaders/lmvtk/svf/Cameras.js":
/*!***********************************************!*\
  !*** ./src/file-loaders/lmvtk/svf/Cameras.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readCameraDefinition: () => (/* binding */ readCameraDefinition)
/* harmony export */ });


function readCameraDefinition(pfr, inst) {
  var entry = inst.definition;
  var tse = pfr.seekToEntry(entry);
  if (!tse)
  return null;
  if (tse.version > 2 /*Constants::CameraDefinitionVersion*/)
  return null;

  var s = pfr.stream;
  var cam = {
    isPerspective: !s.getUint8(), /* 0 = perspective, 1 = ortho */
    position: pfr.readVector3f(),
    target: pfr.readVector3f(),
    up: pfr.readVector3f(),
    aspect: s.getFloat32(),
    fov: s.getFloat32() * (180 / Math.PI)
  };
  if (tse.version < 2) {
    // Skip the clip planes for old files.
    s.getFloat32();
    s.getFloat32();
  }

  cam.orthoScale = s.getFloat32();

  return cam;
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/svf/Fragments.js":
/*!*************************************************!*\
  !*** ./src/file-loaders/lmvtk/svf/Fragments.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FragList: () => (/* binding */ FragList),
/* harmony export */   filterFragments: () => (/* binding */ filterFragments),
/* harmony export */   readFragments: () => (/* binding */ readFragments),
/* harmony export */   readGeometryMetadata: () => (/* binding */ readGeometryMetadata),
/* harmony export */   readGeometryMetadataIntoFragments: () => (/* binding */ readGeometryMetadataIntoFragments)
/* harmony export */ });
/* harmony import */ var _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../wgs/scene/LmvBox3 */ "./src/wgs/scene/LmvBox3.js");
/* harmony import */ var _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../wgs/scene/LmvMatrix4 */ "./src/wgs/scene/LmvMatrix4.js");
/* harmony import */ var _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../wgs/scene/LmvVector3 */ "./src/wgs/scene/LmvVector3.js");
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../compat */ "./src/compat.js");
/* harmony import */ var _wgs_scene_MeshFlags__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../wgs/scene/MeshFlags */ "./src/wgs/scene/MeshFlags.js");






//FragList represents an array of fragments, stored in Structure of Arrays form
//which allows us to free some parts easily and transfer the fragment information in large chunks.
var NUM_FRAGMENT_LIMITS = (0,_compat__WEBPACK_IMPORTED_MODULE_3__.isMobileDevice)() ? null : null;
var MAX_BBOX_RATIO = 100;

/** @constructor */
// note: update transferable var list in SvfWorker.ts if you add a new field
function FragList() {
  this.length = 0;
  this.numLoaded = 0;

  this.boxes = null;
  this.transforms = null;
  this.materials = null;

  this.packIds = null;
  this.entityIndexes = null;

  this.fragId2dbId = null;

  this.topoIndexes = null;

  this.visibilityFlags = null;
}

function readGeometryMetadataIntoFragments(pfr, fragments) {
  var length = fragments.geomDataIndexes.length;
  var stream = pfr.stream;
  var primsCount = 0;

  // Read from cache if the same entry has been reading from stream.
  var entryCache = {};
  var mesh2frag = fragments.mesh2frag = {};
  fragments.polygonCounts = fragments.geomDataIndexes;
  for (var g = 0; g < length; g++) {
    var entry = fragments.geomDataIndexes[g];

    if (entryCache[entry]) {
      var i = entryCache[entry];
      fragments.polygonCounts[g] = fragments.polygonCounts[i];
      fragments.packIds[g] = fragments.packIds[i];
      fragments.entityIndexes[g] = fragments.entityIndexes[i];
      primsCount += fragments.polygonCounts[g];
    } else
    {
      var tse = pfr.seekToEntry(entry);
      if (!tse)
      return;

      // Frag type, seems no use any more.
      stream.getUint8();
      //skip past object space bbox -- we don't use that
      stream.seek(stream.offset + 24);

      fragments.polygonCounts[g] = stream.getUint16();
      fragments.packIds[g] = parseInt(pfr.readString());
      fragments.entityIndexes[g] = pfr.readU32V();
      primsCount += fragments.polygonCounts[g];

      entryCache[entry] = g;
    }

    // Construct mesh2frag here directly
    var meshid = fragments.packIds[g] + ":" + fragments.entityIndexes[g];
    var meshRefs = mesh2frag[meshid];
    if (meshRefs === undefined) {
      //If it's the first fragments for this mesh,
      //store the index directly -- most common case.
      mesh2frag[meshid] = g;
    } else
    if (!Array.isArray(meshRefs)) {
      //otherwise put the fragments that
      //reference the mesh into an array
      mesh2frag[meshid] = [meshRefs, g];
    } else
    {
      //already is an array
      meshRefs.push(g);
    }

  }
  fragments.geomDataIndexes = null;
  entryCache = null;

  return primsCount;
}

function readGeometryMetadata(pfr, geoms)
{
  var numGeoms = pfr.getEntryCounts();
  var stream = pfr.stream;

  geoms.length = numGeoms;
  var fragTypes = geoms.fragTypes = new Uint8Array(numGeoms);
  var primCounts = geoms.primCounts = new Uint16Array(numGeoms);
  var packIds = geoms.packIds = new Int32Array(numGeoms);
  var entityIndexes = geoms.entityIndexes = new Int32Array(numGeoms);
  // Holds the indexes to the topology data.
  var topoIndexes;

  for (var g = 0, gEnd = numGeoms; g < gEnd; g++) {
    var tse = pfr.seekToEntry(g);
    if (!tse)
    return;

    fragTypes[g] = stream.getUint8();
    //skip past object space bbox -- we don't use that
    stream.seek(stream.offset + 24);
    primCounts[g] = stream.getUint16();
    packIds[g] = parseInt(pfr.readString());
    entityIndexes[g] = pfr.readU32V();

    if (tse.version > 2) {
      var topoIndex = stream.getInt32();
      if (topoIndex != -1 && topoIndexes === undefined) {
        topoIndexes = geoms.topoIndexes = new Int32Array(numGeoms);
        // Fill in the first entries to indicate
        for (var i = 0; i < g; i++)
        topoIndexes[i] = -1;
      }

      if (topoIndexes != undefined)
      topoIndexes[g] = topoIndex;
    }

  }
}

// Convert a list of object id (dbid) to a list of integers where each integer is an index of the fragment
// in fragment list that associated with the object id.
function objectIds2FragmentIndices(pfr, ids) {
  var ret = [];

  if (!ids) {
    return ret;
  }

  var counts = pfr.getEntryCounts();
  var stream = pfr.stream;
  for (var entry = 0; entry < counts; entry++) {
    var tse = pfr.seekToEntry(entry);
    if (!tse)
    return;
    if (tse.version > 5)
    return;

    // Keep reading fragment fields as usual, but does not store anything as we only
    // interested in the data base id / object id field at the very end.
    if (tse.version > 4) {
      // Flag byte.
      pfr.readU8();
    }
    // Material index
    pfr.readU32V();
    if (tse.version > 2) {
      // Geometry metadata reference
      pfr.readU32V();
    } else {
      // Pack file reference
      pfr.readString();
      pfr.readU32V();
    }

    // Transform
    pfr.readTransform(entry, null, 12 * entry);

    // Bounding box
    for (var i = 0; i < 6; i++) {
      stream.getFloat32();
    }

    if (tse.version > 1) {
      var dbid = pfr.readU32V();
      if (ids.indexOf(dbid) >= 0) {
        ret.push(entry);
      }
    }
  }

  return ret;
}

var _tmpVector = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__.LmvVector3();

// globalOffset:        GlobalOffset as specified by loadOptions (may be undefined)
// defaultGlobalOffset: GlobalOffset as initially chosen by SvfPlacementUtil.initPlacement
function readFragments(pfr, frags, globalOffset, placementTransform, fragmentTransformsDouble, ids, bbox, defaultGlobalOffset) {
  var filteredIndices = objectIds2FragmentIndices(pfr, ids);

  //Initialize all the fragments structures
  //once we know how many fragments we have.
  var numFrags = filteredIndices.length ? filteredIndices.length : pfr.getEntryCounts();
  var stream = pfr.stream;

  if (NUM_FRAGMENT_LIMITS && numFrags > NUM_FRAGMENT_LIMITS) {
    numFrags = NUM_FRAGMENT_LIMITS;
  }

  // Recored the total length of the fragments
  frags.totalLength = pfr.getEntryCounts();
  frags.length = numFrags;
  frags.numLoaded = 0;

  //Allocate flat array per fragment property
  var fragBoxes = frags.boxes = fragmentTransformsDouble ? new Float64Array(6 * numFrags) : new Float32Array(6 * numFrags);
  var transforms = frags.transforms = fragmentTransformsDouble ? new Float64Array(12 * numFrags) : new Float32Array(12 * numFrags);
  var materials = frags.materials = new Int32Array(numFrags);
  var packIds = frags.packIds = new Int32Array(numFrags);
  var entityIndexes = frags.entityIndexes = new Int32Array(numFrags);
  var geomDataIndexes = frags.geomDataIndexes = new Int32Array(numFrags);
  var fragId2dbId = frags.fragId2dbId = new Int32Array(numFrags); //NOTE: this potentially truncates IDs bigger than 4 billion -- can be converted to array if needed.
  var visibilityFlags = frags.visibilityFlags = new Uint16Array(numFrags);

  var tmpBox;
  var tmpMat;
  var boxTranslation = [0, 0, 0];
  if (placementTransform) {
    tmpBox = new _wgs_scene_LmvBox3__WEBPACK_IMPORTED_MODULE_0__.LmvBox3();
    tmpMat = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_1__.LmvMatrix4(true).fromArray(placementTransform.elements);
  }

  var calculateOffset = !globalOffset && bbox;
  var dpTranslations = transforms;
  // Normally the translations component of transforms is 12 entries for each
  // transform and then offset by 9 in the transform.
  var translationSize = 12;
  var translationOff = 9;
  if (calculateOffset) {
    // A global offset wasn't specified in the load context, so we will calculate one
    // here. We normally use the center of the bbox, but if the bbox is signficantly
    // larger than the objects in the model, then we make the global offset the
    // average of the centers of the fragment bounding boxes, which will push
    // offset toward places where there are more fragments.
    if (!fragmentTransformsDouble) {
      // We need to keep bboxes and transform translations in double precision
      // to guarantee precision in large bbox cases
      fragBoxes = new Float64Array(6 * numFrags);
      dpTranslations = new Float64Array(3 * numFrags);
      // In this case the translations are 3 entries offset by 0
      translationSize = 3;
      translationOff = 0;
    }
  }

  //Helper functions used by the main fragment read loop.

  function applyPlacement(index) {
    if (placementTransform) {
      var offset = index * 6;
      tmpBox.setFromArray(fragBoxes, offset);
      tmpBox.applyMatrix4(tmpMat);
      tmpBox.copyToArray(fragBoxes, offset);
    }
  }

  function readBoundingBox(entry) {
    var offset = entry * 6;
    for (var i = 0; i < 6; i++)
    fragBoxes[offset++] = stream.getFloat32();
  }

  function readBoundingBoxOffset(entry, boxTranslation) {
    var offset = entry * 6;
    for (var i = 0; i < 6; i++)
    fragBoxes[offset++] = stream.getFloat32() + boxTranslation[i % 3];
  }

  //Spin through all the fragments now
  for (var entry = 0, eEnd = frags.length; entry < eEnd; entry++) {
    var tse = filteredIndices.length ? pfr.seekToEntry(filteredIndices[entry]) : pfr.seekToEntry(entry);

    if (!tse)
    return;
    if (tse.version > 5)
    return;

    var isVisible = true;
    if (tse.version > 4) {
      // Fragments v5+ include a flag byte, the LSB of which denotes
      // visibility
      var flags = pfr.readU8();
      isVisible = (flags & 0x01) != 0;
    }
    visibilityFlags[entry] = isVisible ? _wgs_scene_MeshFlags__WEBPACK_IMPORTED_MODULE_4__.MeshFlags.MESH_VISIBLE : 0;

    materials[entry] = pfr.readU32V();

    if (tse.version > 2) {
      //In case it's new style fragment that
      //points to a geometry metadata entry
      geomDataIndexes[entry] = pfr.readU32V();
    } else
    {
      //Old style fragment, pack reference is directly
      //encoded in the fragment entry
      packIds[entry] = parseInt(pfr.readString());
      entityIndexes[entry] = pfr.readU32V();
    }

    pfr.readTransform(entry, transforms, 12 * entry, placementTransform, globalOffset, boxTranslation);
    if (calculateOffset && dpTranslations !== transforms) {
      dpTranslations.set(boxTranslation, entry * translationSize + translationOff);
    }

    if (tse.version > 3) {
      // With this version the transform's (double precision) translation is subtracted from the BB,
      // so we have to add it back
      readBoundingBoxOffset(entry, boxTranslation);
    } else
    {
      readBoundingBox(entry);
    }

    //Apply the placement transform to the world space bbox
    applyPlacement(entry);

    //Apply any global offset to the world space bbox
    if (globalOffset) {
      var offset = entry * 6;
      fragBoxes[offset++] -= globalOffset.x;
      fragBoxes[offset++] -= globalOffset.y;
      fragBoxes[offset++] -= globalOffset.z;
      fragBoxes[offset++] -= globalOffset.x;
      fragBoxes[offset++] -= globalOffset.y;
      fragBoxes[offset++] -= globalOffset.z;
    }

    if (tse.version > 1) {
      fragId2dbId[entry] = pfr.readU32V();
    }
    // Skip reading path ID which is not in use now.
    // pfr.readPathID();
  }

  if (calculateOffset) {
    // We compare the size of the bbox against the size of the largest
    // max size of the bounding boxes in the model to see decide
    // what to use as the globalOffset.

    // First calculate the max of object box sizes
    var maxX = -1,maxY = -1,maxZ = -1;
    var boxEnd = fragBoxes.length;
    // Effectively this calculates the average of the centers of the fragment bboxes
    for (var i = 0; i < boxEnd; i += 6) {
      maxX = Math.max(maxX, fragBoxes[i + 3] - fragBoxes[i]);
      maxY = Math.max(maxY, fragBoxes[i + 4] - fragBoxes[i + 1]);
      maxZ = Math.max(maxZ, fragBoxes[i + 5] - fragBoxes[i + 2]);
    }

    var size = bbox.getSize(_tmpVector);
    if (size.x > maxX * MAX_BBOX_RATIO || size.y > maxY * MAX_BBOX_RATIO || size.z > maxZ * MAX_BBOX_RATIO) {
      // Now calculate the weighted offset. The weighted globalOffset is
      // weighted to be close to places with more fragments.
      var offsetX = 0,offsetY = 0,offsetZ = 0;
      // Effectively this calculates the average of the centers of the fragment bboxes
      for (var i = 0; i < boxEnd; i += 3) {
        offsetX += fragBoxes[i];
        offsetY += fragBoxes[i + 1];
        offsetZ += fragBoxes[i + 2];
      }
      globalOffset = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__.LmvVector3(offsetX * 3 / boxEnd, offsetY * 3 / boxEnd, offsetZ * 3 / boxEnd);
    } else {
      globalOffset = defaultGlobalOffset;
    }

    // Need to addjust the bounding boxes, using the globalOffset
    var outBoxes = frags.boxes;
    for (i = 0; i < boxEnd; i += 3) {
      outBoxes[i] = fragBoxes[i] - globalOffset.x;
      outBoxes[i + 1] = fragBoxes[i + 1] - globalOffset.y;
      outBoxes[i + 2] = fragBoxes[i + 2] - globalOffset.z;
    }

    if (placementTransform && dpTranslations !== transforms) {
      var tmpVec = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__.LmvVector3();
      // And adjust the transforms, too
      for (entry = 0; entry < eEnd; ++entry) {
        const from = entry * translationSize + translationOff;
        tmpVec.fromArray(dpTranslations, from).applyMatrix4(tmpMat).toArray(dpTranslations, from);
      }
    }

    // And adjust the transforms, too
    for (entry = 0; entry < eEnd; ++entry) {
      var to = entry * 12 + 9;
      var from = entry * translationSize + translationOff;
      transforms[to] = dpTranslations[from] - globalOffset.x;
      transforms[to + 1] = dpTranslations[from + 1] - globalOffset.y;
      transforms[to + 2] = dpTranslations[from + 2] - globalOffset.z;
    }
  }

  frags.finishLoading = true;

  return globalOffset;
}

// Filter fragments based on specified object id list, by picking
// up fragment whose id is in the specified id list, and dropping others.
// This is used to produce a list of fragments that matches a search hit.
function filterFragments(frags, ids) {
  frags.length = ids.length;
  frags.numLoaded = 0;
  let numFrags = frags.length;
  let bb = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];

  let fragBoxes = new Float32Array(6 * numFrags);
  let transforms = new Float32Array(12 * numFrags);
  let materials = new Int32Array(numFrags);
  let packIds = new Int32Array(numFrags);
  let entityIndexes = new Int32Array(numFrags);
  let visibilityFlags = new Uint16Array(numFrags);
  let fragId2DbId = new Int32Array(numFrags);
  let polygonCounts = new Int32Array(numFrags);
  let geomDataIndexes = frags.geomDataIndexes ? new Int32Array(numFrags) : null;
  let topoIndexes = frags.topoIndexes ? new Int32Array(numFrags) : null;

  var mesh2frag = {};

  for (let i = 0; i < ids.length; ++i) {
    let index = ids[i];

    let idxOld = index * 6;
    let idxNew = i * 6;
    for (let j = 0; j < 6; ++j)
    fragBoxes[idxNew++] = frags.boxes[idxOld++];

    idxOld = index * 12;
    idxNew = i * 12;
    for (let j = 0; j < 12; ++j)
    transforms[idxNew++] = frags.transforms[idxOld++];

    materials[i] = frags.materials[index];
    packIds[i] = frags.packIds[index];
    entityIndexes[i] = frags.entityIndexes[index];
    visibilityFlags[i] = frags.visibilityFlags[index];
    fragId2DbId[i] = frags.fragId2dbId[index];
    polygonCounts[i] = frags.polygonCounts[index];
    if (geomDataIndexes) {
      geomDataIndexes[i] = frags.geomDataIndexes[index];
    }
    if (topoIndexes) {
      topoIndexes[i] = frags.topoIndexes[index];
    }

    // TODO: consolidate this with addToMeshMap.
    let meshID = frags.packIds[index] + ":" + frags.entityIndexes[index];
    let meshRefs = mesh2frag[meshID];
    if (meshRefs == undefined) {
      mesh2frag[meshID] = i;
    } else
    if (!Array.isArray(meshRefs)) {
      mesh2frag[meshID] = [meshRefs, i];
    } else
    {
      meshRefs.push(i);
    }

    let bbIndex = i * 6;
    for (let j = 0; j < 3; ++j)
    if (fragBoxes[bbIndex + j] < bb[j])
    bb[j] = fragBoxes[bbIndex + j];
    for (let j = 3; j < 6; ++j)
    if (fragBoxes[bbIndex + j] > bb[j])
    bb[j] = fragBoxes[bbIndex + j];
  }

  frags.boxes = fragBoxes;
  frags.transforms = transforms;
  frags.materials = materials;
  frags.packIds = packIds;
  frags.entityIndexes = entityIndexes;
  frags.mesh2frag = mesh2frag;
  frags.visibilityFlags = visibilityFlags;
  frags.fragId2dbId = fragId2DbId;
  frags.polygonCounts = polygonCounts;
  frags.geomDataIndexes = geomDataIndexes;
  frags.topoIndexes = topoIndexes;

  frags.totalLength = numFrags;

  return bb;
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/svf/Geoms.js":
/*!*********************************************!*\
  !*** ./src/file-loaders/lmvtk/svf/Geoms.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readGeometry: () => (/* binding */ readGeometry)
/* harmony export */ });
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../compat */ "./src/compat.js");
/* harmony import */ var _common_VbUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/VbUtils */ "./src/file-loaders/lmvtk/common/VbUtils.js");



"use strict";

//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================

var ntmp = new Float32Array(3);

var INV_PI = 1.0 / Math.PI;

var atan2 = Math.atan2;
if (!(0,_compat__WEBPACK_IMPORTED_MODULE_0__.isNodeJS)()) {
  //Faster approximation to atan2
  //http://math.stackexchange.com/questions/1098487/atan2-faster-approximation
  //The algorithm does not deal with special cases such as x=0,y=0x=0,y=0,
  //nor does it consider special IEEE-754 floating-point operands such as infinities and NaN.
  atan2 = function (y, x) {
    var ax = Math.abs(x);
    var ay = Math.abs(y);
    //var a = (ax > ay) ? ay / ax : ax / ay;
    var a = Math.min(ax, ay) / Math.max(ax, ay);
    var s = a * a;
    var r = ((-0.0464964749 * s + 0.15931422) * s - 0.327622764) * s * a + a;
    if (ay > ax)
    r = 1.57079637 - r;
    if (x < 0)
    r = 3.14159274 - r;
    if (y < 0)
    r = -r;
    return r;
  };
}

function readOpenCTM_RAW(stream, mesh, dstBuffer, startOffset, estimateSizeOnly) {

  var readOpenCTMString = function () {
    return stream.getString(stream.getInt32());
  };

  //Now do the data reads
  var name = stream.getString(4);
  if (name != "INDX") return null;

  var vcount = mesh.vertexCount;
  var tcount = mesh.triangleCount;
  var stride = mesh.vbstride;

  //We will create a single ArrayBuffer to back both the vertex and index buffers
  //The indices will be places after the vertex information, because we need alignment
  //of 4 bytes
  var vbSizeFloat = vcount * stride;
  var totalSizeInFloats = vbSizeFloat + (tcount * 3 * 2 + 3) / 4 | 0;

  mesh.sharedBufferBytes = totalSizeInFloats * 4;

  if (estimateSizeOnly) {
    return;
  }

  var vbf;
  if (!dstBuffer) {
    dstBuffer = new ArrayBuffer(totalSizeInFloats * 4);
    startOffset = 0;
  }

  vbf = mesh.vb = new Float32Array(dstBuffer, startOffset, vbSizeFloat);
  mesh.indices = new Uint16Array(dstBuffer, startOffset + vbSizeFloat * 4, tcount * 3);
  stream.getIndicesArray(vbf.buffer, startOffset + vbSizeFloat * 4, tcount * 3);

  name = stream.getString(4);
  if (name != "VERT") return null;

  var vbi;
  //See if we want to pack the normals into two shorts
  if (mesh.vblayout.normal && mesh.vblayout.normal.itemSize === 2)
  vbi = new Uint16Array(vbf.buffer, vbf.byteOffset, vbf.byteLength / 2);

  //Read positions
  stream.getVector3Array(vbf, vcount, mesh.vblayout['position'].offset, stride);

  //Read normals
  var i, t, offset;
  if (mesh.flags & 1) {
    name = stream.getString(4);
    if (name != "NORM") return null;

    if (vbi) {
      if (ntmp.length < vcount * 3)
      ntmp = new Float32Array(vcount * 3);
      stream.getVector3Array(ntmp, vcount, 0, 3);

      for (i = 0, offset = mesh.vblayout['normal'].offset;
      i < vcount;
      i++, offset += stride)
      {
        var pnx = (atan2(ntmp[i * 3 + 1], ntmp[i * 3]) * INV_PI + 1.0) * 0.5;
        var pny = (ntmp[i * 3 + 2] + 1.0) * 0.5;

        vbi[offset * 2] = pnx * 65535 | 0;
        vbi[offset * 2 + 1] = pny * 65535 | 0;
      }
    } else {
      stream.getVector3Array(vbf, vcount, mesh.vblayout['normal'].offset, stride);
    }

  }

  //Read uv layers
  for (t = 0; t < mesh.texMapCount; t++) {
    name = stream.getString(4);
    if (name != "TEXC") return null;

    var uv = {
      name: readOpenCTMString(),
      file: readOpenCTMString()
    };
    mesh.uvs.push(uv);

    var uvname = "uv";
    if (t)
    uvname += (t + 1).toString();

    stream.getVector2Array(vbf, vcount, mesh.vblayout[uvname].offset, stride);
  }

  var attributeOffset = stride - (mesh.attribMapCount || 0) * 3;

  //Read vertex colors and uvw (and skip any other attributes that we don't know)
  for (t = 0; t < mesh.attribMapCount; t++) {
    name = stream.getString(4);
    if (name != "ATTR") return null;

    var attr = {
      name: readOpenCTMString()
    };

    // console.log("attribute", attr.name);

    var attrname;
    if (attr.name.indexOf("Color") != -1) //Special case of vertex colors
      attrname = 'color';else
    if (attr.name.indexOf("UVW") != -1) //Only used by prism 3d wood.
      attrname = 'uvw';else
    {
      //Other attributes, though we don't know what to do with those
      mesh.attrs.push(attr);
      stream.getBytes(vcount * 16); //skip past
      continue;
    }

    mesh.vblayout[attrname] = { offset: attributeOffset, itemSize: 3 };

    var v4 = [0, 0, 0, 0];
    for (i = 0, offset = attributeOffset;
    i < vcount;
    i++, offset += stride) {
      stream.getVector4(v4, 0);
      vbf[offset] = v4[0];
      vbf[offset + 1] = v4[1];
      vbf[offset + 2] = v4[2];
      //Ignoring the alpha term. For color attribute, we can actually pack it in a 4-byte attribute,
      //but we do not know in advance (when we allocate the target buffer) if the OCTM attribute is UVW or color
    }
    attributeOffset += 3;
  }

}

// Helper function for calculating new vertex for wide lines
var getLineSplitVertex = function (stride, vbf, neighbourhoods, a, b) {
  // New vertex position
  var pos = {
    x: vbf[stride * a],
    y: vbf[stride * a + 1],
    z: vbf[stride * a + 2]
  };
  // Direction to the next vertex for segment (must be valid always)
  var next = {
    x: pos.x - vbf[stride * b],
    y: pos.y - vbf[stride * b + 1],
    z: pos.z - vbf[stride * b + 2]
  };

  // Index of previous point
  var prev_ind = neighbourhoods[a].next == b ? neighbourhoods[a].prev : neighbourhoods[a].next;

  // Direction to previous point
  var prev;
  // If does not exist
  if (prev_ind < 0) {
    // mirror next direction
    prev = {
      x: next.x,
      y: next.y,
      z: next.z
    };
  } else {
    // else - set directly
    prev = {
      x: vbf[stride * prev_ind] - pos.x,
      y: vbf[stride * prev_ind + 1] - pos.y,
      z: vbf[stride * prev_ind + 2] - pos.z
    };
  }

  return {
    pos: pos,
    next: next,
    prev: prev
  };
};

// convert a line mesh into specially organised triangles, which will be drawn
// as lines with a specific width
var convertToWideLines = function (mesh, stride, vbf, indexPairs, offset) {

  var numCoords = 3;

  // add some extra vertex data to the mesh
  // prev & next are directions specific vertex positions, which are used to specify
  // the offset direction in the shader
  // side is the directed line width used for the magnitude of the offset in the shader
  offset = mesh.vbstride;
  mesh.vblayout['prev'] = { offset: offset, itemSize: numCoords };
  offset += numCoords;
  mesh.vblayout['next'] = { offset: offset, itemSize: numCoords };
  offset += numCoords;
  mesh.vblayout['side'] = { offset: offset, itemSize: 1 };

  mesh.vbstride += 7;

  // Count of shared vertexes
  var connections = 0;

  // Build neighbourhoods of each vertex
  var neighbourhoods = new Array(mesh.vertexCount);
  var i, j, n, a, b;
  for (i = 0; i < mesh.vertexCount; ++i) {
    neighbourhoods[i] = {
      prev: -1, // index of previous vertex
      next: -1, // index of next vertex
      prev_seg: -1 // index of previous segment
    };
  }

  for (j = 0; j < indexPairs; ++j) {
    n = j * 2;
    a = mesh.indices[n];
    b = mesh.indices[n + 1];
    neighbourhoods[a].next = b;
    if (neighbourhoods[a].prev >= 0) {
      ++connections;
    }

    neighbourhoods[b].prev = a;
    neighbourhoods[b].prev_seg = j;
    if (neighbourhoods[b].next >= 0) {
      ++connections;
    }
  }

  // Each segment will have its own vertexes
  var newBaseVertexCount = indexPairs * 2;
  var newBaseVertexies = new Array(newBaseVertexCount);

  // Indexes contains line segments and additional connection for shared vertexes
  var newIndices = new Uint16Array(2 * numCoords * (indexPairs + connections));
  var meshIndex = 0;

  // Split all vertexes and build indexes of all triangles
  for (j = 0; j < indexPairs; ++j) {
    n = j * 2;
    a = mesh.indices[n];
    b = mesh.indices[n + 1];
    // New vertexes with calculated next and previous points
    newBaseVertexies[n] = getLineSplitVertex(stride, vbf, neighbourhoods, a, b);
    newBaseVertexies[n + 1] = getLineSplitVertex(stride, vbf, neighbourhoods, b, a);

    // Segment triangles
    a = n;
    b = n + 1;
    // First two coordinates form line segment are used in ray casting
    newIndices[meshIndex++] = 2 * a + 1;
    newIndices[meshIndex++] = 2 * b;
    newIndices[meshIndex++] = 2 * a;
    newIndices[meshIndex++] = 2 * b;
    newIndices[meshIndex++] = 2 * b + 1;
    newIndices[meshIndex++] = 2 * a;

    // Connection triangles for shared vertexes, if exist
    a = mesh.indices[n];
    if (neighbourhoods[a].prev >= 0) {
      b = neighbourhoods[a].prev_seg * 2 + 1;
      a = n;

      newIndices[meshIndex++] = 2 * b;
      newIndices[meshIndex++] = 2 * a;
      newIndices[meshIndex++] = 2 * b + 1;
      newIndices[meshIndex++] = 2 * a + 1;
      newIndices[meshIndex++] = 2 * a;
      newIndices[meshIndex++] = 2 * b;
    }
  }
  mesh.indices = newIndices;

  // Finally, fill vertex buffer with new data
  var newVertexCount = newBaseVertexCount * 2;
  mesh.vb = new Float32Array(newVertexCount * mesh.vbstride);

  offset = mesh.vblayout['position'].offset;
  for (var c = 0; c < newBaseVertexCount; ++c) {
    // Duplicate every vertex for each side
    for (var side = 0; side < 2; ++side) {
      // Vertex position
      mesh.vb[offset] = newBaseVertexies[c].pos.x;
      mesh.vb[offset + 1] = newBaseVertexies[c].pos.y;
      mesh.vb[offset + 2] = newBaseVertexies[c].pos.z;
      offset += stride;

      // Previous vertex direction
      mesh.vb[offset] = newBaseVertexies[c].prev.x;
      mesh.vb[offset + 1] = newBaseVertexies[c].prev.y;
      mesh.vb[offset + 2] = newBaseVertexies[c].prev.z;
      offset += numCoords;

      // Next vertex direction
      mesh.vb[offset] = newBaseVertexies[c].next.x;
      mesh.vb[offset + 1] = newBaseVertexies[c].next.y;
      mesh.vb[offset + 2] = newBaseVertexies[c].next.z;
      offset += numCoords;

      // Side (offset direction)
      mesh.vb[offset] = side ? -1 : 1;
      offset += 1;
    }
  }

  mesh.vertexCount = newVertexCount;

  // flag to mark this mesh as special
  mesh.isWideLines = true;
};

//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================


var readOpenCTM = function (stream, dstBuffer, startOffset, estimateSizeOnly, packNormals) {

  var readOpenCTMString = function () {
    return stream.getString(stream.getInt32());
  };

  var fourcc = stream.getString(4);
  if (fourcc != "OCTM") return null;

  var version = stream.getInt32();
  if (version != 5) return null;

  var method = stream.getString(3);
  stream.getUint8(); //read the last 0 char of the RAW or MG2 fourCC.

  var mesh = {
    stream: null,
    vertices: null,
    indices: null,
    normals: null,
    colors: null,
    uvs: [],
    attrs: []
  };

  mesh.vertexCount = stream.getInt32();
  mesh.triangleCount = stream.getInt32();
  mesh.texMapCount = stream.getInt32();
  mesh.attribMapCount = stream.getInt32();
  mesh.flags = stream.getInt32();
  mesh.comment = readOpenCTMString();

  var usePackedNormals = packNormals;


  //Calculate stride of the interleaved buffer we need
  mesh.vbstride = 3; //position is always there
  if (mesh.flags & 1)
  mesh.vbstride += usePackedNormals ? 1 : 3; //normal
  mesh.vbstride += 2 * (mesh.texMapCount || 0); //texture coords
  mesh.vbstride += 3 * (mesh.attribMapCount || 0); //we now support color and uvw. Both of them use three floats.

  mesh.vblayout = {};
  var offset = 0;

  mesh.vblayout['position'] = { offset: offset, itemSize: 3 };

  offset += 3;
  if (mesh.flags & 1) {
    mesh.vblayout['normal'] = { offset: offset,
      itemSize: usePackedNormals ? 2 : 3,
      bytesPerItem: usePackedNormals ? 2 : 4,
      normalized: usePackedNormals };

    offset += usePackedNormals ? 1 : 3; //offset is counted in units of 4 bytes
  }
  if (mesh.texMapCount) {
    for (var i = 0; i < mesh.texMapCount; i++) {
      var uvname = "uv";
      if (i)
      uvname += (i + 1).toString();

      mesh.vblayout[uvname] = { offset: offset, itemSize: 2 };
      offset += 2;
    }
  }

  //Now read and populate the mesh data
  if (method == "RAW") {
    readOpenCTM_RAW(stream, mesh, dstBuffer, startOffset, estimateSizeOnly);
    if (!estimateSizeOnly) {
      _common_VbUtils__WEBPACK_IMPORTED_MODULE_1__.VBUtils.deduceUVRepetition(mesh);
      _common_VbUtils__WEBPACK_IMPORTED_MODULE_1__.VBUtils.computeBounds3D(mesh);
    }
    return mesh;
  } else
  if (method == "MG2") {
    //This code path is never used, since MG2 compression is disabled at the LMVTK C++ level
    console.assert(false, "readOpenCTM_MG2(stream, mesh, dstBuffer, startOffset, estimateSizeOnly) not supported");
  }
  return null;
};


var readLinesOrPoints = function (pfr, tse, estimateSizeOnly, lines) {

  //TODO: Line geometry does not go into shared buffers yet
  if (estimateSizeOnly)
  return null;

  // Initialize mesh
  var mesh = {
    vertices: null,
    indices: null,
    colors: null,
    normals: null,
    uvs: [],
    attrs: [],
    lineWidth: 1.0
  };

  // Read vertex count, index count, polyline bound count
  var indexCount;
  if (lines) {
    // Read vertex count, index count, polyline bound count
    var polyLineBoundCount;
    if (tse.version > 1) {
      mesh.vertexCount = pfr.readU16();
      indexCount = pfr.readU16();
      polyLineBoundCount = pfr.readU16();

      if (tse.version > 2) {
        mesh.lineWidth = pfr.readF32();
      }
    } else {
      mesh.vertexCount = pfr.readU32V();
      indexCount = pfr.readU32V();
      polyLineBoundCount = pfr.readU32V();
    }
    mesh.isLines = true;
  } else {
    // Read vertex count, index count, point size
    mesh.vertexCount = pfr.readU16();
    indexCount = pfr.readU16();
    mesh.pointSize = pfr.readF32();
    mesh.isPoints = true;
  }

  // Determine if color is defined
  var hasColor = pfr.stream.getUint8() != 0;


  //Calculate stride of the interleaved buffer we need
  mesh.vbstride = 3; //position is always there
  if (hasColor)
  mesh.vbstride += 3; //we only interleave the color attribute, and we reduce that to RGB from ARGB.

  mesh.vblayout = {};
  var offset = 0;

  mesh.vblayout['position'] = { offset: offset, itemSize: 3 };

  offset += 3;
  if (hasColor) {
    mesh.vblayout['color'] = { offset: offset, itemSize: 3 };
  }

  mesh.vb = new Float32Array(mesh.vertexCount * mesh.vbstride);


  // Read vertices
  var vbf = mesh.vb;
  var stride = mesh.vbstride;
  var stream = pfr.stream;

  stream.getVector3Array(vbf, mesh.vertexCount, mesh.vblayout['position'].offset, stride);

  // Determine color if specified
  var c, cEnd;
  if (hasColor) {
    for (c = 0, offset = mesh.vblayout['color'].offset, cEnd = mesh.vertexCount;
    c < cEnd;
    c++, offset += stride)
    {
      vbf[offset] = stream.getFloat32();
      vbf[offset + 1] = stream.getFloat32();
      vbf[offset + 2] = stream.getFloat32();
      stream.getFloat32(); //skip alpha -- TODO: convert color to ARGB 32 bit integer in the vertex layout and shader
    }
  }

  // Copies bytes from buffer
  var forceCopy = function (b) {
    return b.buffer.slice(b.byteOffset, b.byteOffset + b.length);
  };

  // Read indices and polyline bound buffer
  if (lines) {
    var indices;
    var polyLineBoundBuffer;
    if (tse.version > 1) {
      // 16 bit format
      indices = new Uint16Array(forceCopy(stream.getBytes(indexCount * 2)));
      polyLineBoundBuffer = new Uint16Array(forceCopy(stream.getBytes(polyLineBoundCount * 2)));
    } else
    {
      // 32 bit format
      indices = new Int32Array(forceCopy(stream.getBytes(indexCount * 4)));
      polyLineBoundBuffer = new Int32Array(forceCopy(stream.getBytes(polyLineBoundCount * 4)));
    }

    // three.js uses GL-style index pairs in its index buffer. We need one pair
    // per segment in each polyline
    var indexPairs = polyLineBoundBuffer[polyLineBoundCount - 1] - polyLineBoundCount + 1;

    mesh.indices = new Uint16Array(2 * indexPairs);

    // Extract the individual line segment index pairs
    var meshIndex = 0;
    for (var i = 0; i + 1 < polyLineBoundCount; i++) {
      for (var j = polyLineBoundBuffer[i]; j + 1 < polyLineBoundBuffer[i + 1]; j++) {
        mesh.indices[meshIndex++] = indices[j];
        mesh.indices[meshIndex++] = indices[j + 1];
      }
    }
  } else {
    mesh.indices = new Uint16Array(forceCopy(stream.getBytes(indexCount * 2)));
  }

  if (mesh.lineWidth != 1.0) {
    convertToWideLines(mesh, stride, vbf, indexPairs, offset);
  }

  _common_VbUtils__WEBPACK_IMPORTED_MODULE_1__.VBUtils.computeBounds3D(mesh);

  return mesh;
};

var readLines = function (pfr, tse, estimateSizeOnly) {
  return readLinesOrPoints(pfr, tse, estimateSizeOnly, true);
};

var readPoints = function (pfr, tse, estimateSizeOnly) {
  return readLinesOrPoints(pfr, tse, estimateSizeOnly, false);
};

function readGeometry(pfr, entry, options) {
  var tse = pfr.seekToEntry(entry);
  if (!tse)
  return null;

  if (tse.entryType == "Autodesk.CloudPlatform.OpenCTM") {
    return readOpenCTM(pfr.stream, options.dstBuffer, options.startOffset, options.estimateSizeOnly, options.packNormals);
  } else
  if (tse.entryType == "Autodesk.CloudPlatform.Lines") {
    return readLines(pfr, tse, options.estimateSizeOnly);
  } else
  if (tse.entryType == "Autodesk.CloudPlatform.Points") {
    return readPoints(pfr, tse, options.estimateSizeOnly);
  }

  return null;
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/svf/Instances.js":
/*!*************************************************!*\
  !*** ./src/file-loaders/lmvtk/svf/Instances.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readInstance: () => (/* binding */ readInstance),
/* harmony export */   readInstanceTree: () => (/* binding */ readInstanceTree)
/* harmony export */ });


function readInstance(pfr, entry, placementTransform, globalOffset) {
  var tse = pfr.seekToEntry(entry);
  if (!tse)
  return null;
  if (tse.version > 2 /*Constants::InstanceVersion*/)
  return null;

  var isVisible = true;
  if (tse.version > 1) {
    // Instances v2+ include a flag byte, the LSB of which denotes visibility
    var flags = pfr.readU8();
    isVisible = (flags & 0x01) != 0;
  }

  return {
    definition: pfr.stream.getUint32(),
    transform: pfr.readTransform(undefined, undefined, undefined, placementTransform, globalOffset),
    instanceNodePath: pfr.readPathID()
  };
}



var NodeType = {
  NT_Inner: 0,
  NT_Geometry: 1,
  NT_Camera: 2,
  NT_Light: 3
};

function readInstanceTree(pfr, version) {

  var transforms = [];
  var dbIds = [];
  var fragIds = [];
  var childCounts = [];
  var nodeIndex = 0;
  var s = pfr.stream;

  while (s.offset < s.byteLength - 8 - 1) {

    pfr.readTransform(nodeIndex, transforms, nodeIndex * 12, undefined, undefined, undefined);

    // Version 1-4 had optional "shared nodes" that were never used in practice. If found, consume and ignore.
    if (version < 5) {
      var hasSharedNode = s.getUint8();
      if (hasSharedNode) {
        s.getUint32();
      }
    }

    var nodeType = s.getUint8();

    // Version 5 introduced a flags byte and the visibility flag.
    if (version >= 5) {
      var flags = s.getUint8();
      var visible = !!(flags & 1);
    }

    // Version 3 introduced the database ID
    if (version >= 3) {
      dbIds[nodeIndex] = s.getVarints();
    }

    if (nodeIndex) {
      // Not a root, behavior depends on type
      // Leaf, instantiate and add fragment references before returning
      switch (nodeType) {

        case NodeType.NT_Inner:
          break;
        case NodeType.NT_Geometry:{
            if (version < 2) {
              var fragCount = s.getUint16();
              if (fragCount === 1) {
                fragIds[nodeIndex] = s.getUint32();
              } else if (fragCount > 0) {
                var flist = [];
                for (var i = 0; i < fragCount; i++)
                flist.push(s.getUint32());
                fragIds[nodeIndex] = flist;
              }
            } else {
              var fragCount = s.getVarints();
              if (fragCount === 1) {
                fragIds[nodeIndex] = s.getVarints();
              } else if (fragCount > 0) {
                var flist = [];
                for (var i = 0; i < fragCount; i++)
                flist.push(s.getVarints());
                fragIds[nodeIndex] = flist;
              }
            }
          }
          break;
        case NodeType.NT_Camera:
        case NodeType.NT_Light:{
            var hasInstanceEntryId = s.getUint8();
            if (hasInstanceEntryId) {
              s.getUint32();
            }
          }
          break;
        default:
          debug("Unrecognized instance tree node type.");
          break;
      }
    }

    var childCount = 0;
    if (nodeType === NodeType.NT_Inner) {
      if (version < 2) {
        childCount = s.getUint16();
      } else {
        childCount = s.getVarints();
      }
    }
    childCounts[nodeIndex] = childCount;

    nodeIndex++;
  }

  var dbIdBuffer = new Uint32Array(dbIds.length);
  dbIdBuffer.set(dbIds);

  var xformBuffer = new Float32Array(transforms.length);
  xformBuffer.set(transforms);

  var childCountsBuffer = new Uint32Array(childCounts.length);
  childCountsBuffer.set(childCounts);

  return { dbIds: dbIdBuffer, fragIds: fragIds, transforms: xformBuffer, childCounts: childCountsBuffer };
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/svf/Lights.js":
/*!**********************************************!*\
  !*** ./src/file-loaders/lmvtk/svf/Lights.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readLightDefinition: () => (/* binding */ readLightDefinition)
/* harmony export */ });



function readLightDefinition(pfr, entry) {
  var tse = pfr.seekToEntry(entry);
  if (!tse)
  return null;
  if (tse.version > 1 /*Constants::LightDefinitionVersion*/)
  return null;

  var s = pfr.stream;

  var light = {
    position: pfr.readVector3f(),
    dir: pfr.readVector3f(),
    r: s.getFloat32(),
    g: s.getFloat32(),
    b: s.getFloat32(),
    intensity: s.getFloat32(),
    spotAngle: s.getFloat32(),
    size: s.getFloat32(),
    type: s.getUint8()
  };

  return light;
}

/***/ }),

/***/ "./src/file-loaders/lmvtk/svf/Package.js":
/*!***********************************************!*\
  !*** ./src/file-loaders/lmvtk/svf/Package.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Package: () => (/* binding */ Package)
/* harmony export */ });
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../compat */ "./src/compat.js");
/* harmony import */ var _wgs_scene_BVHBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../wgs/scene/BVHBuilder */ "./src/wgs/scene/BVHBuilder.js");
/* harmony import */ var _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../wgs/scene/LmvVector3 */ "./src/wgs/scene/LmvVector3.js");
/* harmony import */ var _net_Xhr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../net/Xhr */ "./src/file-loaders/net/Xhr.js");
/* harmony import */ var _common_InputStream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/InputStream */ "./src/file-loaders/lmvtk/common/InputStream.js");
/* harmony import */ var _common_PackReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/PackReader */ "./src/file-loaders/lmvtk/common/PackReader.js");
/* harmony import */ var _Fragments__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Fragments */ "./src/file-loaders/lmvtk/svf/Fragments.js");
/* harmony import */ var _Instances__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Instances */ "./src/file-loaders/lmvtk/svf/Instances.js");
/* harmony import */ var _common_SvfPlacementUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/SvfPlacementUtils */ "./src/file-loaders/lmvtk/common/SvfPlacementUtils.js");
/* harmony import */ var _Cameras__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Cameras */ "./src/file-loaders/lmvtk/svf/Cameras.js");
/* harmony import */ var _Lights__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Lights */ "./src/file-loaders/lmvtk/svf/Lights.js");
/* harmony import */ var _common_NamedItemTree__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../common/NamedItemTree */ "./src/file-loaders/lmvtk/common/NamedItemTree.js");
/* harmony import */ var _common_Viewpoints__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../common/Viewpoints */ "./src/file-loaders/lmvtk/common/Viewpoints.js");
/* harmony import */ var _common_OverrideSets__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../common/OverrideSets */ "./src/file-loaders/lmvtk/common/OverrideSets.js");
/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! fflate */ "./node_modules/fflate/esm/browser.js");

















function getSingleFileFromZip(zip, filename) {
  const unzipped = (0,fflate__WEBPACK_IMPORTED_MODULE_14__.unzipSync)(zip, { filter: (fileinfo) => fileinfo.name === filename })[filename];
  if (!unzipped) {
    throw new Error("Error while extracting " + filename);
  }
  return unzipped;
}

/** @constructor */
function Package(zipPack) {

  this.zipPack = zipPack;

  this.manifest = null;

  this.materials = null; //The materials json as it came from the SVF

  this.metadata = null; //metadata json

  this.fragments = null; //will be a FragList

  this.geompacks = [];

  //TODO:
  //Those will not be parsed immediately
  //but we will remember the raw arrays
  //and fire off async workers to parse
  //them later, once we are loading geometry packs
  this.instances = [];

  this.cameras = [];
  this.lights = [];
  this.viewpoints = [];
  this.overrideSets = [];

  this.propertydb = {
    attrs: [],
    avs: [],
    ids: [],
    values: [],
    offsets: []
  };

  this.bbox = null; //Overall scene bounds

  this.animations = null; // animations json

  this.pendingRequests = 0;

  this.globalOffset = { x: 0, y: 0, z: 0 };

  this.topologyPath = null; // string path to the topology file

}



Package.prototype.loadAsyncResource = function (loadContext, resourcePath, contents, callback) {

  //Data is immediately available from the SVF zip
  if (contents) {
    callback(contents);
    return;
  }

  //Launch an XHR to load the data from external file
  var svf = this;

  this.pendingRequests++;

  function xhrCB(responseData) {
    svf.pendingRequests--;

    callback(responseData);

    if (svf.pendingRequests == 0)
    svf.postLoad(loadContext);
  }

  _net_Xhr__WEBPACK_IMPORTED_MODULE_3__.ViewingService.getItem(loadContext, loadContext.basePath + resourcePath,
  xhrCB,
  loadContext.onFailureCallback
  );

};

/**
 * Extracts `manifest.json` file from the geometry pack file.
 * 
 * @param {object} loadContext The loading context object passed in by an 
 * SvfLoader object as it successfully downloaded a geometry pack file. The 
 * load context is not used in this function.
 * 
 * @throws {Error} `manifest.json` cannot be found within the package.
 */
Package.prototype.loadManifest = function (loadContext) {
  // yes, LoadContext is passed in, but is not used.
  const manifestJson = getSingleFileFromZip(this.zipPack, "manifest.json");
  const jdr = new _common_InputStream__WEBPACK_IMPORTED_MODULE_4__.InputStream(manifestJson);
  this.manifest = JSON.parse(jdr.getString(manifestJson.byteLength));
};

// Replace default globalOffset from SvfPlacementOffset by a recomputed one computed based on Fragment bboxes.
Package.prototype.applyLargeBoxOffset = function (offset) {
  if (offset && (
  offset.x !== this.globalOffset.x ||
  offset.y !== this.globalOffset.y ||
  offset.z !== this.globalOffset.z))
  {
    // So far, bbox was in viewer-coords, assuming the default globalOffset. Since we modified the offset,
    // we have to adjust the bbox now.
    if (!this.bbox.isEmpty()) {
      this.bbox.translate({
        x: this.globalOffset.x - offset.x,
        y: this.globalOffset.y - offset.y,
        z: this.globalOffset.z - offset.z
      });
    }

    // self.globalOffset may not be an LMVVector3, but in that case
    // offset should be self.GlobalOffset, so this should be OK
    this.verylargebbox = true;
    this.globalOffset.copy(offset);
    (0,_common_SvfPlacementUtils__WEBPACK_IMPORTED_MODULE_8__.calculatePlacementWithOffset)(this, this.placementTransform);
  }
};

Package.prototype.parseFragmentList = function (asset, loadContext, path, contents) {

  var self = this;
  this.loadAsyncResource(loadContext, path, contents, function (data) {
    var pfr = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);

    //Use a single large blocks to store all fragment elements
    //TODO: perhaps have a FragList per pack file to keep block size down?
    var frags = self.fragments = new _Fragments__WEBPACK_IMPORTED_MODULE_6__.FragList();
    var offset = (0,_Fragments__WEBPACK_IMPORTED_MODULE_6__.readFragments)(pfr, frags, loadContext.globalOffset, loadContext.placementTransform,
    loadContext.fragmentTransformsDouble, undefined, self.bbox, self.globalOffset);
    pfr = null;

    self.applyLargeBoxOffset(offset);
  });
};

Package.prototype.parseGeometryMetadata = function (asset, loadContext, path, contents) {
  var self = this;
  this.loadAsyncResource(loadContext, path, contents, function (data) {
    var pfr = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);

    self.geomMetadata = {};
    (0,_Fragments__WEBPACK_IMPORTED_MODULE_6__.readGeometryMetadata)(pfr, self.geomMetadata);
    self.numGeoms = self.geomMetadata.primCounts.length;
  });
};


Package.prototype.parseInstanceTree = function (loadContext, path, contents, version) {

  var that = this;

  this.loadAsyncResource(loadContext, path, contents, function (data) {
    var pfr = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);
    that.instanceTransforms = (0,_Instances__WEBPACK_IMPORTED_MODULE_7__.readInstanceTree)(pfr, version);
  });

};


Package.prototype.loadRemainingSvf = function (loadContext) {
  var svf = this;

  this.manifest = loadContext.manifest;
  var manifest = this.manifest;

  var assets = manifest["assets"];

  const metadataJson = getSingleFileFromZip(this.zipPack, "metadata.json");
  var jdr = new _common_InputStream__WEBPACK_IMPORTED_MODULE_4__.InputStream(metadataJson);

  // Test to see if this is json (not a binary header)
  // Done by verifying that there is no 0 (Hence ASCII)
  if (metadataJson.byteLength > 3 && metadataJson[3] !== 0) {
    this.metadata = JSON.parse(jdr.getString(metadataJson.byteLength)).metadata;

    (0,_common_SvfPlacementUtils__WEBPACK_IMPORTED_MODULE_8__.initPlacement)(this, loadContext);
  }

  //Version strings seem to be variable at the moment.
  //var manifestVersion = manifest["manifestversion"];
  //if (   manifest["name"] != "LMV Manifest"
  //    || manifest["manifestversion"] != 1)
  //    return false;

  this.packFileTotalSize = 0;
  this.primitiveCount = 0;

  var typesetsList = manifest["typesets"];
  var typesets = {};
  for (var i = 0; i < typesetsList.length; i++) {
    var ts = typesetsList[i];
    typesets[ts['id']] = ts['types'];
  }

  //Loop through the assets, and schedule non-embedded
  //ones for later loading.
  //TODO: currently only geometry pack files are stored for later
  //load and other assets will be loaded by this worker thread before
  //we return to the SvfLoader in the main thread.

  for (var i = 0; i < assets.length; i++)
  {
    var asset = assets[i];
    if ((0,_compat__WEBPACK_IMPORTED_MODULE_0__.isMobileDevice)() && asset.id === "Set.bin")
    continue;
    var type = asset["type"];
    if (type.indexOf("Autodesk.CloudPlatform.") == 0)
    type = type.substr(23);
    var uri = asset["URI"];
    var typeset = asset["typeset"] ? typesets[asset["typeset"]] : null;
    var usize = asset["usize"] || 0;
    var megaBytes = Math.round(usize / 1048576 * 100000) / 100000 | 0;

    //If the asset is a geometry pack or property pack
    //just remember it for later demand loading
    if (uri.indexOf("embed:/") != 0) {
      if (type == "PackFile") {
        var typeclass = typeset ? typeset[0]["class"] : null;

        if (typeclass == "Autodesk.CloudPlatform.Geometry") {

          this.packFileTotalSize += usize;

          this.geompacks.push({ id: asset["id"], uri: uri, usize: usize });
        }
      } else
      if (type == "PropertyAttributes") {
        this.propertydb.attrs.push({ path: uri });
      } else
      if (type == "PropertyAVs") {
        this.propertydb.avs.push({ path: uri });
      } else
      if (type == "PropertyIDs") {
        this.propertydb.ids.push({ path: uri });
      } else
      if (type == "PropertyOffsets") {
        this.propertydb.offsets.push({ path: uri });
      } else
      if (type == "PropertyValues") {
        this.propertydb.values.push({ path: uri });
      }
    }

    //parse assets which we will need immediately when
    // setting up the scene (whether embedded or not)
    var path = asset["URI"];
    var contents = null; //if the data was in the zip, this will contain it
    if (path.indexOf("embed:/") == 0) {
      path = path.substr(7);
      contents = getSingleFileFromZip(this.zipPack, path);
    }

    if (type == "ProteinMaterials") {
      //For simple materials, we want the file named "Materials.json" and not "ProteinMaterials.json"
      if (path.indexOf("Protein") == -1) {
        this.loadAsyncResource(loadContext, path, contents, function (data) {
          var jdr = new _common_InputStream__WEBPACK_IMPORTED_MODULE_4__.InputStream(data);
          var byteLength = data.byteLength;
          if (0 < byteLength) {
            svf.materials = JSON.parse(jdr.getString(byteLength));
          } else {
            svf.materials = null;
          }
        });
      } else {
        //Also parse the Protein materials -- at the moment this helps
        //With some Prism materials that have properties we can handle, but
        //are not in the Simple variant.
        this.loadAsyncResource(loadContext, path, contents, function (data) {
          var jdr = new _common_InputStream__WEBPACK_IMPORTED_MODULE_4__.InputStream(data);
          var byteLength = data.byteLength;
          if (0 < byteLength) {
            try {
              svf.proteinMaterials = JSON.parse(jdr.getString(byteLength));
            } catch (e) {
              //TS: This is dumb, but what can we do... Revit extractor had (has?) a bug where
              //materials are written as ANSI instead of UTF8 encoded. So we have this fallback attempt
              var ansi = "";
              for (var i = 0; i < data.length; i++)
              ansi += String.fromCharCode(data[i]);

              try {
                svf.proteinMaterials = JSON.parse(ansi);
              } catch (e) {
                console.error("Failed to parse Protein materials file either as UTF8 or ANSI");
              }
            }
          } else {
            svf.proteinMaterials = null;
          }
        });
      }
    } else
    if (type == "StandardMaterials") {

      this.loadAsyncResource(loadContext, path, contents, function (data) {
        var jdr = new _common_InputStream__WEBPACK_IMPORTED_MODULE_4__.InputStream(data);
        var byteLength = data.byteLength;
        if (0 < byteLength) {
          var strContent = jdr.getString(byteLength);
          svf.stdSurfMats = JSON.parse(strContent);
        } else {
          svf.stdSurfMats = null;
        }
      });
    } else

    if (type == "MaterialX") {
      this.loadAsyncResource(loadContext, path, contents, function (data) {
        var jdr = new _common_InputStream__WEBPACK_IMPORTED_MODULE_4__.InputStream(data);
        var byteLength = data.byteLength;
        if (0 < byteLength) {
          svf.mtlx = jdr.getString(byteLength);
        } else {
          svf.mtlx = null;
        }
      });

    } else
    if (type == "FragmentList") {

      this.parseFragmentList(asset, loadContext, path, contents);

    } else
    if (type == "GeometryMetadataList") {

      this.parseGeometryMetadata(asset, loadContext, path, contents);

    } else
    if (type == "PackFile") {

      if (path.indexOf("CameraDefinitions.bin") != -1) {
        this.loadAsyncResource(loadContext, path, contents, function (data) {
          svf.camDefPack = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);
        });
      } else

      if (path.indexOf("CameraList.bin") != -1) {
        this.loadAsyncResource(loadContext, path, contents, function (data) {
          svf.camInstPack = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);
        });
      } else

      if (path.indexOf("LightDefinitions.bin") != -1) {
        this.loadAsyncResource(loadContext, path, contents, function (data) {
          svf.lightDefPack = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);
        });
      } else

      if (path.indexOf("LightList.bin") != -1) {
        this.loadAsyncResource(loadContext, path, contents, function (data) {
          svf.lightInstPack = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);
        });
      } else

      if (path.indexOf("OverrideSets.bin") != -1) {
        this.loadAsyncResource(loadContext, path, contents, function (data) {
          svf.overrideSetsPack = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);
        });
      } else

      if (path.indexOf("Viewpoints.bin") != -1) {
        this.loadAsyncResource(loadContext, path, contents, function (data) {
          svf.viewpointDefPack = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);
        });
      } else

      if (path.indexOf("ViewpointTree.bin") != -1) {
        this.loadAsyncResource(loadContext, path, contents, function (data) {
          svf.viewpointTreePack = new _common_PackReader__WEBPACK_IMPORTED_MODULE_5__.PackFileReader(data);
        });
      }
    } else
    if (type == "Animations") {
      this.loadAsyncResource(loadContext, path, contents, function (data) {
        var jdr = new _common_InputStream__WEBPACK_IMPORTED_MODULE_4__.InputStream(data);
        var byteLength = data.byteLength;
        if (0 < byteLength) {
          svf.animations = JSON.parse(jdr.getString(byteLength));
        } else {
          svf.animations = null;
        }
      });
    } else
    if (type == "Topology") {

      // save the path for later download.
      svf.topologyPath = loadContext.basePath + path;
      svf.topologySizeMB = megaBytes;

    } else
    if (loadContext.loadInstanceTree && (
    type == "InstanceTree" || type == "InstanceTreeTree")) {//Yes, the typo does occur in some older files

      //Instance tree node serialization version is stored in the type set
      var version = typeset ? typeset[0]["version"] : 1;

      this.parseInstanceTree(loadContext, path, contents, version);
    }
  }


  if (this.pendingRequests == 0)
  this.postLoad(loadContext);

  delete this.zipPack;
};

Package.prototype.addTransparencyFlagsToMaterials = function (mats) {
  for (var id in mats) {
    var mat = mats[id];
    var userAssets = mat["userassets"];
    var innerMats = mat["materials"];
    var innerMat = innerMats[userAssets[0]];
    mat.transparent = innerMat["transparent"];
  }
};

Package.prototype.postLoadOfCam = function (loadContext) {

  //Combine camera instances and camera definitions -- we need
  //both to be loaded to get the camera list
  if (this.camDefPack && this.camInstPack) {
    const tmpCenter = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__.LmvVector3();
    for (var k = 0, kEnd = this.camInstPack.getEntryCounts(); k < kEnd; k++) {
      var inst = (0,_Instances__WEBPACK_IMPORTED_MODULE_7__.readInstance)(this.camInstPack, k, this.placementTransform, this.globalOffset);
      var cam = (0,_Cameras__WEBPACK_IMPORTED_MODULE_9__.readCameraDefinition)(this.camDefPack, inst);

      //Apply any instance transform to get the camera to world space.
      (0,_common_SvfPlacementUtils__WEBPACK_IMPORTED_MODULE_8__.transformCameraData)(cam, inst.transform);

      // Fix camera's target if it is not inside the scene's bounding box.
      var bbox = this.bbox;
      if (bbox && !bbox.containsPoint(cam.target)) {
        var distanceFromCenter = bbox.getCenter(tmpCenter).distanceTo(cam.position);
        var direction = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__.LmvVector3().copy(cam.target).sub(cam.position).normalize().multiplyScalar(distanceFromCenter);
        cam.target = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_2__.LmvVector3().copy(cam.position).add(direction);
      }

      this.cameras.push(cam);
    }

    delete this.camDefPack;
    delete this.camInstPack;
  }
};

Package.prototype.postLoadOfOverrideSets = function (loadContext) {
  if (this.overrideSetsPack) {
    for (let i = 0, iEnd = this.overrideSetsPack.getEntryCounts(); i < iEnd; i++) {
      const set = (0,_common_OverrideSets__WEBPACK_IMPORTED_MODULE_13__.readOverrideSet)(this.overrideSetsPack, i);

      if (set) {
        this.overrideSets.push(set);
      }
    }

    delete this.overrideSetsPack;
  }
};

Package.prototype.postLoadOfViewpointTree = function (loadContext) {
  if (this.viewpointTreePack) {
    const root = (0,_common_NamedItemTree__WEBPACK_IMPORTED_MODULE_11__.readNamedItemTree)(this.viewpointTreePack);
    this.viewpointTreeRoot = root;

    delete this.viewpointTreePack;
  }
};

Package.prototype.postLoadOfViewpoints = function (loadContext) {
  if (this.viewpointDefPack && this.camDefPack) {
    for (let i = 0, iEnd = this.viewpointDefPack.getEntryCounts(); i < iEnd; i++) {
      const def = (0,_common_Viewpoints__WEBPACK_IMPORTED_MODULE_12__.readViewpointDefinition)(this.viewpointDefPack, this.camDefPack, i);

      if (def) {
        this.viewpoints.push(def);
      }
    }

    delete this.viewpointDefPack;
  }
};

Package.prototype.postLoadOfLight = function (loadContext) {

  //Lights need the same thing as the cameras
  if (this.lightDefPack && this.lightInstPack) {
    for (var k = 0, kEnd = this.lightInstPack.getEntryCounts(); k < kEnd; k++) {
      var inst = (0,_Instances__WEBPACK_IMPORTED_MODULE_7__.readInstance)(this.lightInstPack, k, this.placementTransform, this.globalOffset);
      this.lights.push((0,_Lights__WEBPACK_IMPORTED_MODULE_10__.readLightDefinition)(this.lightDefPack, inst.definition));
    }

    delete this.lightInstPack;
    delete this.lightDefPack;
  }

};

Package.prototype.postLoadOfFragments = function (loadContext) {

  //Post processing step -- splice geometry metadata information
  //into the fragments list, in case it was given separately
  //TODO: consider keeping the geom metadata as is instead of splicing
  //into the fragments, as it would be more efficient --
  //but that would require special handling on the viewer side,
  //changing the fragment filter code, etc.
  var frags = this.fragments;

  if (this.geomMetadata) {

    //reusing the geomDataIndexes array to store
    //polygon counts, now that we don't need the geomIndexes
    //after this loop.
    frags.polygonCounts = frags.geomDataIndexes;

    var gm = this.geomMetadata;

    // Holds the indexes to the topology data.
    if (gm.topoIndexes != undefined) {
      frags.topoIndexes = new Int32Array(frags.length);
    }

    for (var i = 0, iEnd = frags.length; i < iEnd; i++) {
      var geomIndex = frags.geomDataIndexes[i];
      frags.entityIndexes[i] = gm.entityIndexes[geomIndex];
      frags.packIds[i] = gm.packIds[geomIndex];

      frags.polygonCounts[i] = gm.primCounts[geomIndex];
      this.primitiveCount += gm.primCounts[geomIndex];

      // Fills in the indexes to the topology data.
      if (gm.topoIndexes != undefined) {
        frags.topoIndexes[i] = gm.topoIndexes[geomIndex];
      }
    }

    frags.geomDataIndexes = null;

    this.geomMetadata = null;
  }

  //Build a map from mesh to its referencing fragment(s)
  //So that we can quickly find them once meshes begin loading
  //incrementally. This requires the packIds and entityIndexes
  //to be known per fragment, so it happens after geometry metadata
  //is resolved above
  this.calculateMesh2Frag(frags);
};

Package.prototype.calculateMesh2Frag = function (frags) {
  var mesh2frag = frags.mesh2frag = {};
  var packIds = frags.packIds;
  var entityIndexes = frags.entityIndexes;

  for (var i = 0, iEnd = frags.length; i < iEnd; i++) {
    var meshid = packIds[i] + ":" + entityIndexes[i];

    var meshRefs = mesh2frag[meshid];
    if (meshRefs === undefined) {
      //If it's the first fragments for this mesh,
      //store the index directly -- most common case.
      mesh2frag[meshid] = i;
    } else
    if (!Array.isArray(meshRefs)) {
      //otherwise put the fragments that
      //reference the mesh into an array
      mesh2frag[meshid] = [meshRefs, i];
    } else
    {
      //already is an array
      meshRefs.push(i);
    }
  }
};

Package.prototype.postLoadOfBBox = function (loadContext) {

  //if we don't know the overall scene bounds, compute them from the
  //fragment boxes
  if (!this.bbox || loadContext.placementTransform) {

    var totalbox = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
    var frags = this.fragments;
    var fragBoxes = frags.boxes;

    for (var f = 0, fEnd = frags.length; f < fEnd; f++) {
      var bboff = f * 6;
      var i;
      for (i = 0; i < 3; i++)
      if (fragBoxes[bboff + i] < totalbox[i])
      totalbox[i] = fragBoxes[bboff + i];

      for (i = 3; i < 6; i++)
      if (fragBoxes[bboff + i] > totalbox[i])
      totalbox[i] = fragBoxes[bboff + i];
    }

    this.bbox = {
      min: { x: totalbox[0], y: totalbox[1], z: totalbox[2] },
      max: { x: totalbox[3], y: totalbox[4], z: totalbox[5] }
    };
  }


};

Package.prototype.postLoadOfObjectIds = function (loadContext) {

  // If object ids are specified, clean up pack file list by only keeping the packs that's
  // we intended to load.
  let ids = new Set(loadContext.objectIds);
  if (ids.size > 0) {
    let packIds = new Set();
    let fragIds = new Set();
    // Pick out pack ids that referenced by fragments with specified db ids.

    for (let j = 0; j < this.fragments.length; ++j) {
      if (ids.has(this.fragments.fragId2dbId[j])) {
        packIds.add(this.fragments.packIds[j]);
        fragIds.add(j);
      }
    }

    // Reduce pack files based on selected pack ids.
    let packs = new Set();
    for (let i = 0; i < this.geompacks.length; ++i) {
      // LMVTK pre-2.0 release uses integers for pack file id.
      // LMVTK 2.0 release uses integer + .pf as id.
      // We just drop the suffix here as we did in SVFLoader.
      // More info: https://git.autodesk.com/A360/LMVTK/commit/68b8c07a643a7ac39ecd5651d031d170e3a325be
      if (packIds.has(parseInt(this.geompacks[i].id))) {
        packs.add(this.geompacks[i]);
      }
    }
    this.geompacks = [...packs];

    let bb = (0,_Fragments__WEBPACK_IMPORTED_MODULE_6__.filterFragments)(this.fragments, [...fragIds]);
    this.bbox = {
      min: { x: bb[0], y: bb[1], z: bb[2] },
      max: { x: bb[3], y: bb[4], z: bb[5] }
    };
  }

};

Package.prototype.postLoadBubbleConsolidation = function () {

  const vtr = this.viewpointTreeRoot;

  if (vtr) {
    vtr.name = vtr.name || 'Saved Viewpoints';
  }

  if (!(vtr !== null && vtr !== void 0 && vtr.children)) {
    return;
  }

  let order = 0;
  function traverseBubble(node) {
    if (node.children) {
      for (let i = 0; i < node.children.length; i++) {
        traverseBubble(node.children[i]);
      }
      node.type = 'folder';
      node.role = 'viewable';
      node.guid = order++ + '';
    } else {
      if (!isNaN(node.entry)) {
        node.order = order;

        node.type = 'view';
        node.role = '3d';
        node.guid = order++ + '';
        node.isViewpoint = true;
      }
    }
  }


  for (let i = 0; i < vtr.children.length; i++) {
    traverseBubble(vtr.children[i]);
  }
};

Package.prototype.postLoadComplete = function (loadContext) {

  loadContext.loadDoneCB("svf");

  if (this.fragments.polygonCounts) {
    //Build the R-Tree
    var t0 = performance.now();
    var mats = this.materials ? this.materials["materials"] : null;
    if (mats)
    this.addTransparencyFlagsToMaterials(mats);
    this.bvh = new _wgs_scene_BVHBuilder__WEBPACK_IMPORTED_MODULE_1__.BVHBuilder(this.fragments, mats);
    this.bvh.build(loadContext.bvhOptions);
    var t1 = performance.now();
    loadContext.worker.debug("BVH build time (worker thread):" + (t1 - t0));

    // In normal mode, just post back BVH as svf is already posted back earlier.
    loadContext.loadDoneCB("bvh");
  }

  loadContext.loadDoneCB("done");
};

Package.prototype.postLoad = function (loadContext) {

  (0,_common_SvfPlacementUtils__WEBPACK_IMPORTED_MODULE_8__.transformAnimations)(this);

  // TODO: this function appears to take quite a
  //       while if it has lots of data to load.
  //       maybe move to a background thread?
  this.postLoadOfOverrideSets(loadContext);

  this.postLoadOfViewpoints(loadContext);

  this.postLoadOfViewpointTree(loadContext);

  this.postLoadOfCam(loadContext);

  this.postLoadOfLight(loadContext);

  this.postLoadOfFragments(loadContext);

  this.postLoadOfBBox(loadContext);

  this.postLoadOfObjectIds(loadContext);

  this.postLoadBubbleConsolidation();

  this.postLoadComplete(loadContext);
};

/***/ }),

/***/ "./src/file-loaders/net/ErrorCodes.js":
/*!********************************************!*\
  !*** ./src/file-loaders/net/ErrorCodes.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorCodes: () => (/* binding */ ErrorCodes),
/* harmony export */   errorCodeString: () => (/* binding */ errorCodeString),
/* harmony export */   getErrorCode: () => (/* binding */ getErrorCode)
/* harmony export */ });

/**
 * Error code constants
 * These constants will be used in {@link Callbacks#onGenericError} functions.
 *
 * @namespace Autodesk.Viewing.ErrorCodes
 */
const ErrorCodes = {
  /** 
   * An unknown failure has occurred. 
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  UNKNOWN_FAILURE: 1,

  /** 
   * Bad data (corrupted or malformed) was encountered. 
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  BAD_DATA: 2,

  /** 
   * A network failure was encountered. 
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  NETWORK_FAILURE: 3,

  /** 
   * Access was denied to a network resource (HTTP 403)
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  NETWORK_ACCESS_DENIED: 4,

  /** 
   * A network resource could not be found (HTTP 404)
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  NETWORK_FILE_NOT_FOUND: 5,

  /** 
   * A server error was returned when accessing a network resource (HTTP 5xx)
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  NETWORK_SERVER_ERROR: 6,

  /** 
   * An unhandled response code was returned when accessing a network resource (HTTP 'everything else')
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  NETWORK_UNHANDLED_RESPONSE_CODE: 7,

  /** 
   * Browser error = webGL is not supported by the current browser
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  BROWSER_WEBGL_NOT_SUPPORTED: 8,

  /** 
   * There is nothing viewable in the fetched document 
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  BAD_DATA_NO_VIEWABLE_CONTENT: 9,

  /** 
   * Browser error = webGL is supported, but not enabled 
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  BROWSER_WEBGL_DISABLED: 10,

  /**
   * There is no geometry in loaded model
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  BAD_DATA_MODEL_IS_EMPTY: 11,

  /** 
   * The extension of the loaded file is not supported 
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  UNSUPORTED_FILE_EXTENSION: 13,

  /** 
   * Viewer error: wrong or forbidden usage of the viewer
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes
   * @type {number}
   */
  VIEWER_INTERNAL_ERROR: 14,

  /** 
   * WebGL error while loading a model, typically due to IE11 limitations
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes 
   * @type {number}
   */
  WEBGL_LOST_CONTEXT: 15,

  /** 
   * Viewer error because loading a resource was canceled
   *
   * @constant
   * @memberof Autodesk.Viewing.ErrorCodes 
   * @type {number}
   */
  LOAD_CANCELED: 16
};

/**
 * Formatted error message
 * @param {number} errorCode - Error code
 * @returns {string} - Error message
 * @alias Autodesk.Viewing.errorCodeString
 * @private
 */
function errorCodeString(errorCode) {
  return "ErrorCode:" + errorCode + ".";
}

/**
 * Get ErrorCodes enum from http status code
 * @param {number} networkStatus - HTTP status code
 * @returns {number} - Autodesk.Viewing.ErrorCodes enum
 * @alias Autodesk.Viewing.getErrorCode
 * @private
 */
function getErrorCode(networkStatus)
{
  if (networkStatus === 403 || networkStatus === 401)
  {
    return ErrorCodes.NETWORK_ACCESS_DENIED;
  } else
  if (networkStatus === 404)
  {
    return ErrorCodes.NETWORK_FILE_NOT_FOUND;
  } else
  if (networkStatus >= 500)
  {
    return ErrorCodes.NETWORK_SERVER_ERROR;
  }

  return ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE;
}

/***/ }),

/***/ "./src/file-loaders/net/Xhr.js":
/*!*************************************!*\
  !*** ./src/file-loaders/net/Xhr.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ViewingService: () => (/* binding */ ViewingService),
/* harmony export */   pathToURL: () => (/* binding */ pathToURL),
/* harmony export */   textToArrayBuffer: () => (/* binding */ textToArrayBuffer)
/* harmony export */ });
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.includes.js */ "./node_modules/core-js/modules/es.array.includes.js");
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.regexp.flags.js */ "./node_modules/core-js/modules/es.regexp.flags.js");
/* harmony import */ var core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_typed_array_set_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.typed-array.set.js */ "./node_modules/core-js/modules/es.typed-array.set.js");
/* harmony import */ var core_js_modules_es_typed_array_set_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_set_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_esnext_array_last_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/esnext.array.last-index.js */ "./node_modules/core-js/modules/esnext.array.last-index.js");
/* harmony import */ var core_js_modules_esnext_array_last_index_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_array_last_index_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_esnext_array_last_item_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/esnext.array.last-item.js */ "./node_modules/core-js/modules/esnext.array.last-item.js");
/* harmony import */ var core_js_modules_esnext_array_last_item_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_array_last_item_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_esnext_composite_key_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/esnext.composite-key.js */ "./node_modules/core-js/modules/esnext.composite-key.js");
/* harmony import */ var core_js_modules_esnext_composite_key_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_composite_key_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_esnext_composite_symbol_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/esnext.composite-symbol.js */ "./node_modules/core-js/modules/esnext.composite-symbol.js");
/* harmony import */ var core_js_modules_esnext_composite_symbol_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_composite_symbol_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_esnext_map_delete_all_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/esnext.map.delete-all.js */ "./node_modules/core-js/modules/esnext.map.delete-all.js");
/* harmony import */ var core_js_modules_esnext_map_delete_all_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_delete_all_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_esnext_map_every_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/esnext.map.every.js */ "./node_modules/core-js/modules/esnext.map.every.js");
/* harmony import */ var core_js_modules_esnext_map_every_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_every_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_esnext_map_filter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/esnext.map.filter.js */ "./node_modules/core-js/modules/esnext.map.filter.js");
/* harmony import */ var core_js_modules_esnext_map_filter_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_filter_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_esnext_map_find_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/esnext.map.find.js */ "./node_modules/core-js/modules/esnext.map.find.js");
/* harmony import */ var core_js_modules_esnext_map_find_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_find_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_esnext_map_find_key_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! core-js/modules/esnext.map.find-key.js */ "./node_modules/core-js/modules/esnext.map.find-key.js");
/* harmony import */ var core_js_modules_esnext_map_find_key_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_find_key_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_esnext_map_from_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/esnext.map.from.js */ "./node_modules/core-js/modules/esnext.map.from.js");
/* harmony import */ var core_js_modules_esnext_map_from_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_from_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_esnext_map_group_by_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! core-js/modules/esnext.map.group-by.js */ "./node_modules/core-js/modules/esnext.map.group-by.js");
/* harmony import */ var core_js_modules_esnext_map_group_by_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_group_by_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var core_js_modules_esnext_map_includes_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! core-js/modules/esnext.map.includes.js */ "./node_modules/core-js/modules/esnext.map.includes.js");
/* harmony import */ var core_js_modules_esnext_map_includes_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_includes_js__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var core_js_modules_esnext_map_key_by_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/esnext.map.key-by.js */ "./node_modules/core-js/modules/esnext.map.key-by.js");
/* harmony import */ var core_js_modules_esnext_map_key_by_js__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_key_by_js__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var core_js_modules_esnext_map_key_of_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! core-js/modules/esnext.map.key-of.js */ "./node_modules/core-js/modules/esnext.map.key-of.js");
/* harmony import */ var core_js_modules_esnext_map_key_of_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_key_of_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var core_js_modules_esnext_map_map_keys_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! core-js/modules/esnext.map.map-keys.js */ "./node_modules/core-js/modules/esnext.map.map-keys.js");
/* harmony import */ var core_js_modules_esnext_map_map_keys_js__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_map_keys_js__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var core_js_modules_esnext_map_map_values_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! core-js/modules/esnext.map.map-values.js */ "./node_modules/core-js/modules/esnext.map.map-values.js");
/* harmony import */ var core_js_modules_esnext_map_map_values_js__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_map_values_js__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var core_js_modules_esnext_map_merge_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! core-js/modules/esnext.map.merge.js */ "./node_modules/core-js/modules/esnext.map.merge.js");
/* harmony import */ var core_js_modules_esnext_map_merge_js__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_merge_js__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var core_js_modules_esnext_map_of_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! core-js/modules/esnext.map.of.js */ "./node_modules/core-js/modules/esnext.map.of.js");
/* harmony import */ var core_js_modules_esnext_map_of_js__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_of_js__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var core_js_modules_esnext_map_reduce_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! core-js/modules/esnext.map.reduce.js */ "./node_modules/core-js/modules/esnext.map.reduce.js");
/* harmony import */ var core_js_modules_esnext_map_reduce_js__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_reduce_js__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var core_js_modules_esnext_map_some_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! core-js/modules/esnext.map.some.js */ "./node_modules/core-js/modules/esnext.map.some.js");
/* harmony import */ var core_js_modules_esnext_map_some_js__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_some_js__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var core_js_modules_esnext_map_update_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! core-js/modules/esnext.map.update.js */ "./node_modules/core-js/modules/esnext.map.update.js");
/* harmony import */ var core_js_modules_esnext_map_update_js__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_map_update_js__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var core_js_modules_esnext_math_clamp_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! core-js/modules/esnext.math.clamp.js */ "./node_modules/core-js/modules/esnext.math.clamp.js");
/* harmony import */ var core_js_modules_esnext_math_clamp_js__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_clamp_js__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var core_js_modules_esnext_math_deg_per_rad_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! core-js/modules/esnext.math.deg-per-rad.js */ "./node_modules/core-js/modules/esnext.math.deg-per-rad.js");
/* harmony import */ var core_js_modules_esnext_math_deg_per_rad_js__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_deg_per_rad_js__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var core_js_modules_esnext_math_degrees_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! core-js/modules/esnext.math.degrees.js */ "./node_modules/core-js/modules/esnext.math.degrees.js");
/* harmony import */ var core_js_modules_esnext_math_degrees_js__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_degrees_js__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var core_js_modules_esnext_math_fscale_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! core-js/modules/esnext.math.fscale.js */ "./node_modules/core-js/modules/esnext.math.fscale.js");
/* harmony import */ var core_js_modules_esnext_math_fscale_js__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_fscale_js__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var core_js_modules_esnext_math_iaddh_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! core-js/modules/esnext.math.iaddh.js */ "./node_modules/core-js/modules/esnext.math.iaddh.js");
/* harmony import */ var core_js_modules_esnext_math_iaddh_js__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_iaddh_js__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var core_js_modules_esnext_math_imulh_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! core-js/modules/esnext.math.imulh.js */ "./node_modules/core-js/modules/esnext.math.imulh.js");
/* harmony import */ var core_js_modules_esnext_math_imulh_js__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_imulh_js__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var core_js_modules_esnext_math_isubh_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! core-js/modules/esnext.math.isubh.js */ "./node_modules/core-js/modules/esnext.math.isubh.js");
/* harmony import */ var core_js_modules_esnext_math_isubh_js__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_isubh_js__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var core_js_modules_esnext_math_rad_per_deg_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! core-js/modules/esnext.math.rad-per-deg.js */ "./node_modules/core-js/modules/esnext.math.rad-per-deg.js");
/* harmony import */ var core_js_modules_esnext_math_rad_per_deg_js__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_rad_per_deg_js__WEBPACK_IMPORTED_MODULE_31__);
/* harmony import */ var core_js_modules_esnext_math_radians_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! core-js/modules/esnext.math.radians.js */ "./node_modules/core-js/modules/esnext.math.radians.js");
/* harmony import */ var core_js_modules_esnext_math_radians_js__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_radians_js__WEBPACK_IMPORTED_MODULE_32__);
/* harmony import */ var core_js_modules_esnext_math_scale_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! core-js/modules/esnext.math.scale.js */ "./node_modules/core-js/modules/esnext.math.scale.js");
/* harmony import */ var core_js_modules_esnext_math_scale_js__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_scale_js__WEBPACK_IMPORTED_MODULE_33__);
/* harmony import */ var core_js_modules_esnext_math_seeded_prng_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! core-js/modules/esnext.math.seeded-prng.js */ "./node_modules/core-js/modules/esnext.math.seeded-prng.js");
/* harmony import */ var core_js_modules_esnext_math_seeded_prng_js__WEBPACK_IMPORTED_MODULE_34___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_seeded_prng_js__WEBPACK_IMPORTED_MODULE_34__);
/* harmony import */ var core_js_modules_esnext_math_signbit_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! core-js/modules/esnext.math.signbit.js */ "./node_modules/core-js/modules/esnext.math.signbit.js");
/* harmony import */ var core_js_modules_esnext_math_signbit_js__WEBPACK_IMPORTED_MODULE_35___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_signbit_js__WEBPACK_IMPORTED_MODULE_35__);
/* harmony import */ var core_js_modules_esnext_math_umulh_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! core-js/modules/esnext.math.umulh.js */ "./node_modules/core-js/modules/esnext.math.umulh.js");
/* harmony import */ var core_js_modules_esnext_math_umulh_js__WEBPACK_IMPORTED_MODULE_36___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_math_umulh_js__WEBPACK_IMPORTED_MODULE_36__);
/* harmony import */ var core_js_modules_esnext_number_from_string_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! core-js/modules/esnext.number.from-string.js */ "./node_modules/core-js/modules/esnext.number.from-string.js");
/* harmony import */ var core_js_modules_esnext_number_from_string_js__WEBPACK_IMPORTED_MODULE_37___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_number_from_string_js__WEBPACK_IMPORTED_MODULE_37__);
/* harmony import */ var core_js_modules_esnext_observable_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! core-js/modules/esnext.observable.js */ "./node_modules/core-js/modules/esnext.observable.js");
/* harmony import */ var core_js_modules_esnext_observable_js__WEBPACK_IMPORTED_MODULE_38___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_observable_js__WEBPACK_IMPORTED_MODULE_38__);
/* harmony import */ var core_js_modules_esnext_promise_try_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! core-js/modules/esnext.promise.try.js */ "./node_modules/core-js/modules/esnext.promise.try.js");
/* harmony import */ var core_js_modules_esnext_promise_try_js__WEBPACK_IMPORTED_MODULE_39___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_promise_try_js__WEBPACK_IMPORTED_MODULE_39__);
/* harmony import */ var core_js_modules_esnext_reflect_define_metadata_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! core-js/modules/esnext.reflect.define-metadata.js */ "./node_modules/core-js/modules/esnext.reflect.define-metadata.js");
/* harmony import */ var core_js_modules_esnext_reflect_define_metadata_js__WEBPACK_IMPORTED_MODULE_40___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_reflect_define_metadata_js__WEBPACK_IMPORTED_MODULE_40__);
/* harmony import */ var core_js_modules_esnext_reflect_delete_metadata_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! core-js/modules/esnext.reflect.delete-metadata.js */ "./node_modules/core-js/modules/esnext.reflect.delete-metadata.js");
/* harmony import */ var core_js_modules_esnext_reflect_delete_metadata_js__WEBPACK_IMPORTED_MODULE_41___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_reflect_delete_metadata_js__WEBPACK_IMPORTED_MODULE_41__);
/* harmony import */ var core_js_modules_esnext_reflect_get_metadata_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! core-js/modules/esnext.reflect.get-metadata.js */ "./node_modules/core-js/modules/esnext.reflect.get-metadata.js");
/* harmony import */ var core_js_modules_esnext_reflect_get_metadata_js__WEBPACK_IMPORTED_MODULE_42___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_reflect_get_metadata_js__WEBPACK_IMPORTED_MODULE_42__);
/* harmony import */ var core_js_modules_esnext_reflect_get_metadata_keys_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! core-js/modules/esnext.reflect.get-metadata-keys.js */ "./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js");
/* harmony import */ var core_js_modules_esnext_reflect_get_metadata_keys_js__WEBPACK_IMPORTED_MODULE_43___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_reflect_get_metadata_keys_js__WEBPACK_IMPORTED_MODULE_43__);
/* harmony import */ var core_js_modules_esnext_reflect_get_own_metadata_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! core-js/modules/esnext.reflect.get-own-metadata.js */ "./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js");
/* harmony import */ var core_js_modules_esnext_reflect_get_own_metadata_js__WEBPACK_IMPORTED_MODULE_44___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_reflect_get_own_metadata_js__WEBPACK_IMPORTED_MODULE_44__);
/* harmony import */ var core_js_modules_esnext_reflect_get_own_metadata_keys_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! core-js/modules/esnext.reflect.get-own-metadata-keys.js */ "./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js");
/* harmony import */ var core_js_modules_esnext_reflect_get_own_metadata_keys_js__WEBPACK_IMPORTED_MODULE_45___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_reflect_get_own_metadata_keys_js__WEBPACK_IMPORTED_MODULE_45__);
/* harmony import */ var core_js_modules_esnext_reflect_has_metadata_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! core-js/modules/esnext.reflect.has-metadata.js */ "./node_modules/core-js/modules/esnext.reflect.has-metadata.js");
/* harmony import */ var core_js_modules_esnext_reflect_has_metadata_js__WEBPACK_IMPORTED_MODULE_46___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_reflect_has_metadata_js__WEBPACK_IMPORTED_MODULE_46__);
/* harmony import */ var core_js_modules_esnext_reflect_has_own_metadata_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! core-js/modules/esnext.reflect.has-own-metadata.js */ "./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js");
/* harmony import */ var core_js_modules_esnext_reflect_has_own_metadata_js__WEBPACK_IMPORTED_MODULE_47___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_reflect_has_own_metadata_js__WEBPACK_IMPORTED_MODULE_47__);
/* harmony import */ var core_js_modules_esnext_reflect_metadata_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! core-js/modules/esnext.reflect.metadata.js */ "./node_modules/core-js/modules/esnext.reflect.metadata.js");
/* harmony import */ var core_js_modules_esnext_reflect_metadata_js__WEBPACK_IMPORTED_MODULE_48___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_reflect_metadata_js__WEBPACK_IMPORTED_MODULE_48__);
/* harmony import */ var core_js_modules_esnext_set_add_all_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! core-js/modules/esnext.set.add-all.js */ "./node_modules/core-js/modules/esnext.set.add-all.js");
/* harmony import */ var core_js_modules_esnext_set_add_all_js__WEBPACK_IMPORTED_MODULE_49___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_add_all_js__WEBPACK_IMPORTED_MODULE_49__);
/* harmony import */ var core_js_modules_esnext_set_delete_all_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! core-js/modules/esnext.set.delete-all.js */ "./node_modules/core-js/modules/esnext.set.delete-all.js");
/* harmony import */ var core_js_modules_esnext_set_delete_all_js__WEBPACK_IMPORTED_MODULE_50___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_delete_all_js__WEBPACK_IMPORTED_MODULE_50__);
/* harmony import */ var core_js_modules_esnext_set_difference_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! core-js/modules/esnext.set.difference.js */ "./node_modules/core-js/modules/esnext.set.difference.js");
/* harmony import */ var core_js_modules_esnext_set_difference_js__WEBPACK_IMPORTED_MODULE_51___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_difference_js__WEBPACK_IMPORTED_MODULE_51__);
/* harmony import */ var core_js_modules_esnext_set_every_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! core-js/modules/esnext.set.every.js */ "./node_modules/core-js/modules/esnext.set.every.js");
/* harmony import */ var core_js_modules_esnext_set_every_js__WEBPACK_IMPORTED_MODULE_52___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_every_js__WEBPACK_IMPORTED_MODULE_52__);
/* harmony import */ var core_js_modules_esnext_set_filter_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! core-js/modules/esnext.set.filter.js */ "./node_modules/core-js/modules/esnext.set.filter.js");
/* harmony import */ var core_js_modules_esnext_set_filter_js__WEBPACK_IMPORTED_MODULE_53___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_filter_js__WEBPACK_IMPORTED_MODULE_53__);
/* harmony import */ var core_js_modules_esnext_set_find_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! core-js/modules/esnext.set.find.js */ "./node_modules/core-js/modules/esnext.set.find.js");
/* harmony import */ var core_js_modules_esnext_set_find_js__WEBPACK_IMPORTED_MODULE_54___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_find_js__WEBPACK_IMPORTED_MODULE_54__);
/* harmony import */ var core_js_modules_esnext_set_from_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! core-js/modules/esnext.set.from.js */ "./node_modules/core-js/modules/esnext.set.from.js");
/* harmony import */ var core_js_modules_esnext_set_from_js__WEBPACK_IMPORTED_MODULE_55___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_from_js__WEBPACK_IMPORTED_MODULE_55__);
/* harmony import */ var core_js_modules_esnext_set_intersection_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! core-js/modules/esnext.set.intersection.js */ "./node_modules/core-js/modules/esnext.set.intersection.js");
/* harmony import */ var core_js_modules_esnext_set_intersection_js__WEBPACK_IMPORTED_MODULE_56___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_intersection_js__WEBPACK_IMPORTED_MODULE_56__);
/* harmony import */ var core_js_modules_esnext_set_is_disjoint_from_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! core-js/modules/esnext.set.is-disjoint-from.js */ "./node_modules/core-js/modules/esnext.set.is-disjoint-from.js");
/* harmony import */ var core_js_modules_esnext_set_is_disjoint_from_js__WEBPACK_IMPORTED_MODULE_57___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_is_disjoint_from_js__WEBPACK_IMPORTED_MODULE_57__);
/* harmony import */ var core_js_modules_esnext_set_is_subset_of_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! core-js/modules/esnext.set.is-subset-of.js */ "./node_modules/core-js/modules/esnext.set.is-subset-of.js");
/* harmony import */ var core_js_modules_esnext_set_is_subset_of_js__WEBPACK_IMPORTED_MODULE_58___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_is_subset_of_js__WEBPACK_IMPORTED_MODULE_58__);
/* harmony import */ var core_js_modules_esnext_set_is_superset_of_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! core-js/modules/esnext.set.is-superset-of.js */ "./node_modules/core-js/modules/esnext.set.is-superset-of.js");
/* harmony import */ var core_js_modules_esnext_set_is_superset_of_js__WEBPACK_IMPORTED_MODULE_59___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_is_superset_of_js__WEBPACK_IMPORTED_MODULE_59__);
/* harmony import */ var core_js_modules_esnext_set_join_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! core-js/modules/esnext.set.join.js */ "./node_modules/core-js/modules/esnext.set.join.js");
/* harmony import */ var core_js_modules_esnext_set_join_js__WEBPACK_IMPORTED_MODULE_60___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_join_js__WEBPACK_IMPORTED_MODULE_60__);
/* harmony import */ var core_js_modules_esnext_set_map_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! core-js/modules/esnext.set.map.js */ "./node_modules/core-js/modules/esnext.set.map.js");
/* harmony import */ var core_js_modules_esnext_set_map_js__WEBPACK_IMPORTED_MODULE_61___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_map_js__WEBPACK_IMPORTED_MODULE_61__);
/* harmony import */ var core_js_modules_esnext_set_of_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! core-js/modules/esnext.set.of.js */ "./node_modules/core-js/modules/esnext.set.of.js");
/* harmony import */ var core_js_modules_esnext_set_of_js__WEBPACK_IMPORTED_MODULE_62___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_of_js__WEBPACK_IMPORTED_MODULE_62__);
/* harmony import */ var core_js_modules_esnext_set_reduce_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! core-js/modules/esnext.set.reduce.js */ "./node_modules/core-js/modules/esnext.set.reduce.js");
/* harmony import */ var core_js_modules_esnext_set_reduce_js__WEBPACK_IMPORTED_MODULE_63___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_reduce_js__WEBPACK_IMPORTED_MODULE_63__);
/* harmony import */ var core_js_modules_esnext_set_some_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! core-js/modules/esnext.set.some.js */ "./node_modules/core-js/modules/esnext.set.some.js");
/* harmony import */ var core_js_modules_esnext_set_some_js__WEBPACK_IMPORTED_MODULE_64___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_some_js__WEBPACK_IMPORTED_MODULE_64__);
/* harmony import */ var core_js_modules_esnext_set_symmetric_difference_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! core-js/modules/esnext.set.symmetric-difference.js */ "./node_modules/core-js/modules/esnext.set.symmetric-difference.js");
/* harmony import */ var core_js_modules_esnext_set_symmetric_difference_js__WEBPACK_IMPORTED_MODULE_65___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_symmetric_difference_js__WEBPACK_IMPORTED_MODULE_65__);
/* harmony import */ var core_js_modules_esnext_set_union_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! core-js/modules/esnext.set.union.js */ "./node_modules/core-js/modules/esnext.set.union.js");
/* harmony import */ var core_js_modules_esnext_set_union_js__WEBPACK_IMPORTED_MODULE_66___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_set_union_js__WEBPACK_IMPORTED_MODULE_66__);
/* harmony import */ var core_js_modules_esnext_string_at_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! core-js/modules/esnext.string.at.js */ "./node_modules/core-js/modules/esnext.string.at.js");
/* harmony import */ var core_js_modules_esnext_string_at_js__WEBPACK_IMPORTED_MODULE_67___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_string_at_js__WEBPACK_IMPORTED_MODULE_67__);
/* harmony import */ var core_js_modules_esnext_string_code_points_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! core-js/modules/esnext.string.code-points.js */ "./node_modules/core-js/modules/esnext.string.code-points.js");
/* harmony import */ var core_js_modules_esnext_string_code_points_js__WEBPACK_IMPORTED_MODULE_68___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_string_code_points_js__WEBPACK_IMPORTED_MODULE_68__);
/* harmony import */ var core_js_modules_esnext_symbol_dispose_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! core-js/modules/esnext.symbol.dispose.js */ "./node_modules/core-js/modules/esnext.symbol.dispose.js");
/* harmony import */ var core_js_modules_esnext_symbol_dispose_js__WEBPACK_IMPORTED_MODULE_69___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_symbol_dispose_js__WEBPACK_IMPORTED_MODULE_69__);
/* harmony import */ var core_js_modules_esnext_symbol_observable_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! core-js/modules/esnext.symbol.observable.js */ "./node_modules/core-js/modules/esnext.symbol.observable.js");
/* harmony import */ var core_js_modules_esnext_symbol_observable_js__WEBPACK_IMPORTED_MODULE_70___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_symbol_observable_js__WEBPACK_IMPORTED_MODULE_70__);
/* harmony import */ var core_js_modules_esnext_symbol_pattern_match_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! core-js/modules/esnext.symbol.pattern-match.js */ "./node_modules/core-js/modules/esnext.symbol.pattern-match.js");
/* harmony import */ var core_js_modules_esnext_symbol_pattern_match_js__WEBPACK_IMPORTED_MODULE_71___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_symbol_pattern_match_js__WEBPACK_IMPORTED_MODULE_71__);
/* harmony import */ var core_js_modules_esnext_weak_map_delete_all_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! core-js/modules/esnext.weak-map.delete-all.js */ "./node_modules/core-js/modules/esnext.weak-map.delete-all.js");
/* harmony import */ var core_js_modules_esnext_weak_map_delete_all_js__WEBPACK_IMPORTED_MODULE_72___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_weak_map_delete_all_js__WEBPACK_IMPORTED_MODULE_72__);
/* harmony import */ var core_js_modules_esnext_weak_map_from_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! core-js/modules/esnext.weak-map.from.js */ "./node_modules/core-js/modules/esnext.weak-map.from.js");
/* harmony import */ var core_js_modules_esnext_weak_map_from_js__WEBPACK_IMPORTED_MODULE_73___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_weak_map_from_js__WEBPACK_IMPORTED_MODULE_73__);
/* harmony import */ var core_js_modules_esnext_weak_map_of_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! core-js/modules/esnext.weak-map.of.js */ "./node_modules/core-js/modules/esnext.weak-map.of.js");
/* harmony import */ var core_js_modules_esnext_weak_map_of_js__WEBPACK_IMPORTED_MODULE_74___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_weak_map_of_js__WEBPACK_IMPORTED_MODULE_74__);
/* harmony import */ var core_js_modules_esnext_weak_set_add_all_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! core-js/modules/esnext.weak-set.add-all.js */ "./node_modules/core-js/modules/esnext.weak-set.add-all.js");
/* harmony import */ var core_js_modules_esnext_weak_set_add_all_js__WEBPACK_IMPORTED_MODULE_75___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_weak_set_add_all_js__WEBPACK_IMPORTED_MODULE_75__);
/* harmony import */ var core_js_modules_esnext_weak_set_delete_all_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! core-js/modules/esnext.weak-set.delete-all.js */ "./node_modules/core-js/modules/esnext.weak-set.delete-all.js");
/* harmony import */ var core_js_modules_esnext_weak_set_delete_all_js__WEBPACK_IMPORTED_MODULE_76___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_weak_set_delete_all_js__WEBPACK_IMPORTED_MODULE_76__);
/* harmony import */ var core_js_modules_esnext_weak_set_from_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! core-js/modules/esnext.weak-set.from.js */ "./node_modules/core-js/modules/esnext.weak-set.from.js");
/* harmony import */ var core_js_modules_esnext_weak_set_from_js__WEBPACK_IMPORTED_MODULE_77___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_weak_set_from_js__WEBPACK_IMPORTED_MODULE_77__);
/* harmony import */ var core_js_modules_esnext_weak_set_of_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! core-js/modules/esnext.weak-set.of.js */ "./node_modules/core-js/modules/esnext.weak-set.of.js");
/* harmony import */ var core_js_modules_esnext_weak_set_of_js__WEBPACK_IMPORTED_MODULE_78___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_esnext_weak_set_of_js__WEBPACK_IMPORTED_MODULE_78__);
/* harmony import */ var core_js_modules_web_immediate_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! core-js/modules/web.immediate.js */ "./node_modules/core-js/modules/web.immediate.js");
/* harmony import */ var core_js_modules_web_immediate_js__WEBPACK_IMPORTED_MODULE_79___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_immediate_js__WEBPACK_IMPORTED_MODULE_79__);
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ../../logger/Logger */ "./src/logger/Logger.js");
/* harmony import */ var _ErrorCodes__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./ErrorCodes */ "./src/file-loaders/net/ErrorCodes.js");
/* harmony import */ var _lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ../lmvtk/common/StringUtils */ "./src/file-loaders/lmvtk/common/StringUtils.js");
/* harmony import */ var _endpoints__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./endpoints */ "./src/file-loaders/net/endpoints.js");
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ../../compat */ "./src/compat.js");
/* harmony import */ var exponential_backoff__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! exponential-backoff */ "./node_modules/exponential-backoff/dist/backoff.js");
/* harmony import */ var exponential_backoff__WEBPACK_IMPORTED_MODULE_85___default = /*#__PURE__*/__webpack_require__.n(exponential_backoff__WEBPACK_IMPORTED_MODULE_85__);
/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! fflate */ "./node_modules/fflate/esm/browser.js");
 // These are needed in order to support async/await.











let ViewingService = {};
ViewingService.WORKER_REGISTER_FILE_PORT = "REGISTER_FILE_PORT";
ViewingService.WORKER_READ_FILE = "READ_FILE";

var warnedGzip = false;

// Simplify Unix style file path. For example, turn '/a/./b/../../c/' into "/c".
// Required to deal with OSS crappy URNs where there are embedded '..'.
function simplifyPath(path) {

  var elements = path.split('/');
  if (elements.length == 0)
  return path;

  var stack = [];
  for (var index = 0; index < elements.length; ++index) {
    var c = elements[index];
    if (c === '.') {
      continue;
    }if (c === '..' && stack.length) {
      stack.pop();
    } else {
      stack.push(c);
    }
  }

  // Great, the path commits suicide.
  if (stack.length == 0)
  return '';

  return stack.join("/");
}

//Maps a relative resource path (like a pack file or texture)
//to an absolute URL. If absoluteBasePath is specified, it is
//used to construct the absolute URL, otherwise the window location
//is used.
function pathToURL(path, absoluteBasePath) {

  if (path.indexOf("://") !== -1 ||
  path.indexOf("urn:") === 0) {
    return path;
  }

  if (absoluteBasePath) {
    return absoluteBasePath + path;
  }

  if (typeof window === "undefined")
  return path;

  const _window = (0,_compat__WEBPACK_IMPORTED_MODULE_84__.getGlobal)();
  var rootRelPath = _window.location.pathname;
  //chop off the index.html part
  var lastSlash = rootRelPath.lastIndexOf("/");
  rootRelPath = rootRelPath.substr(0, lastSlash + 1);
  var absPath = _window.location.protocol + "//" + _window.location.host + rootRelPath + path;
  return absPath;
}


ViewingService.simplifyPath = simplifyPath;

function textToArrayBuffer(textBuffer, startOffset) {
  var len = textBuffer.length - startOffset;
  var arrayBuffer = new ArrayBuffer(len);
  var ui8a = new Uint8Array(arrayBuffer, 0);
  for (var i = 0, j = startOffset; i < len; i++, j++)
  ui8a[i] = textBuffer.charCodeAt(j) & 0xff;
  return ui8a;
}


ViewingService.OSS_PREFIX = "urn:adsk.objects:os.object:";

/**
 * Construct full URL given a potentially partial viewing service "urn:" prefixed resource
 * @returns {string}
 */
ViewingService.generateUrl = function (baseUrl, api, path, apiData, escapeOssObjects, guid) {

  path = path || "";

  //NODE
  if ((0,_compat__WEBPACK_IMPORTED_MODULE_84__.isNodeJS)() && !isRemotePath(baseUrl, path)) {
    return path;
  }

  path = simplifyPath(path);

  //V2 only accepts URL encoded paths
  var urnidx = path.indexOf("urn:");
  var qidx = path.indexOf("?");
  if (urnidx != -1) {
    if (qidx !== -1) {
      //TODO: not sure this will happen, queryParams are normally
      //passed in separately in the options object
      path = path.slice(0, urnidx) + encodeURIComponent(path.slice(urnidx, qidx)) + path.slice(qidx);
    } else {
      path = path.slice(0, urnidx) + encodeURIComponent(path.slice(urnidx));
    }
  } else {
    path = encodeURI(path);
  }

  // OSS only accepts object ids with escaped slashes
  if (escapeOssObjects && ViewingService.isOSSUrl(path)) {
    var objectsIndex = path.indexOf("/objects/") + 9;
    var objectPath = path.substring(objectsIndex);
    path = path.substring(0, objectsIndex) + encodeURIComponent(objectPath);
  }

  //Check if it's a viewing service item path
  //Public/static content will not have the urn: prefix.
  //So URL construction is a no-op
  if (!api || decodeURIComponent(path).indexOf('urn:') !== 0) {
    if (isRemotePath(null, path))
    return path;else

    return baseUrl + path;
  }

  //Remove "urn:" prefix when getting URN-based stuff (manifests and thumbnails)
  if (api !== 'items') {
    path = path.substr(6);
  }

  switch (api) {
    case "items":return _endpoints__WEBPACK_IMPORTED_MODULE_83__.endpoint.getItemApi(baseUrl, path, apiData);
    case "bubbles":return _endpoints__WEBPACK_IMPORTED_MODULE_83__.endpoint.getManifestApi(baseUrl, path, apiData);
    case "thumbnails":return _endpoints__WEBPACK_IMPORTED_MODULE_83__.endpoint.getThumbnailApi(baseUrl, path, apiData);
    case "properties":return _endpoints__WEBPACK_IMPORTED_MODULE_83__.endpoint.getPropertyQueryApi(baseUrl, path, apiData, guid);
  }
};

function isRemotePath(baseUrl, path) {
  if (path.indexOf("file://") !== -1)
  return false;
  if (path.indexOf("://") !== -1)
  return true;
  if (baseUrl)
  return true;
}


//Conditional GET request implementation for node vs. browser
if ((0,_compat__WEBPACK_IMPORTED_MODULE_84__.isNodeJS)()) {

  (function () {

    var fs = __webpack_require__(/*! fs */ "?99b8");
    var zlib = __webpack_require__(/*! zlib */ "?d497");
    var https = __webpack_require__(/*! https */ "?8571");
    var http = __webpack_require__(/*! http */ "?aca8");
    var urllib = __webpack_require__(/*! url */ "./node_modules/url/url.js");

    let httpsAgent = new https.Agent({
      keepAlive: true,
      keepAliveMsecs: 100,
      maxSockets: 10
    });
    let httpAgent = new http.Agent({
      keepAlive: true,
      keepAliveMsecs: 100,
      maxSockets: 10
    });


    var forgeAgent = new https.Agent({ maxSockets: 10 });

    function loadLocalFile(url, onSuccess, onFailure, options) {

      if (url.indexOf("file://") === 0)
      url = url.substr(7);

      function postProcess(data) {
        if (options.responseType === "json") {
          try {
            return JSON.parse(data.toString("utf8"));
          } catch (e) {
            onFailure(e);
          }
        }
        return data;
      }

      //Always use async on Node
      fs.readFile(url, function (error, data) {
        if (error) {
          onFailure(0, 0, { httpStatusText: error, url: url });
        } else {
          if (data[0] === 31 && data[1] === 139) {
            zlib.gunzip(data, null, function (error, data) {
              if (error)
              onFailure(0, 0, { httpStatusText: error, url: url });else
              {
                data = postProcess(data);
                if (options.ondata)
                options.ondata(data);
                onSuccess(data);
              }
            });
          } else {
            data = postProcess(data);
            if (options.ondata)
            options.ondata(data);
            onSuccess(data);
          }
        }
      });
    }

    function needsGunzip(res, pathname) {

      if (res.headers['content-encoding'] === 'gzip')
      return true;

      //These SVF related files come pre-gzipped
      //regardless of content-encoding header

      if (pathname.endsWith(".json.gz"))
      return true;

      if (pathname.endsWith("FragmentList.pack"))
      return true;

      if (pathname.endsWith("LightList.bin"))
      return true;

      if (pathname.endsWith("CameraList.bin"))
      return true;

      if (pathname.endsWith("CameraDefinitions.bin"))
      return true;

      if (pathname.endsWith("LightDefinitions.bin"))
      return true;

      return false;
    }


    /**
     *  Performs a GET/HEAD request to Viewing Service. (Node.js specific implementation)
     *
     * @param {string} viewingServiceBaseUrl - The base url for the viewing service.
     * @param {string} api - The api to call in the viewing service.
     *  @param {string} url - The url for the request.
     *  @param {function} onSuccess - A function that takes a single parameter that represents the response
     *                                returned if the request is successful.
     *  @param {function} onFailure - A function that takes an integer status code, and a string status, which together represent
     *                                the response returned if the request is unsuccessful, and a third data argument, which
     *                                has more information about the failure.  The data is a dictionary that minimally includes
     *                                the url, and an exception if one was raised.
     *  @param {Object=} [options] - A dictionary of options that can include:
     *                               headers - A dictionary representing the additional headers to add.
     *                               queryParams - A string representing the query parameters
     *                               responseType - A string representing the response type for this request.
     *                               {boolean} [encodeUrn] - when true, encodes the document urn if found.
     *                               {boolean} [noBody] - when true, will perform a HEAD request
     */
    ViewingService.rawGet = function (viewingServiceBaseUrl, api, url, onSuccess, onFailure, options) {

      options = options || {};

      url = ViewingService.generateUrl(viewingServiceBaseUrl, api, url, undefined, options.escapeOssObjects);

      if (!isRemotePath(viewingServiceBaseUrl, url)) {
        loadLocalFile(url, onSuccess, onFailure, options);
        return;
      }

      if (options.queryParams) {
        var concatSymbol = url.indexOf('?') === -1 ? '?' : '&';
        url = url + concatSymbol + options.queryParams;
      }

      var parsed = urllib.parse(url);

      var req = {
        host: parsed.hostname,
        port: parsed.port,
        method: options.method || "GET",
        path: parsed.path,
        headers: {},
        retryCount: 0,
        agent: parsed.protocol === "https:" ? httpsAgent : httpAgent
      };

      //Don't overload derivative service with requests
      if (req.host.endsWith(".api.autodesk.com") && (
      req.path.startsWith("/derivativeservice") || req.path.startsWith("/modelderivative"))) {
        req.agent = forgeAgent;
      }

      if (options.headers) {
        for (var p in options.headers) {
          req.headers[p] = options.headers[p];
        }
      }

      if (!req.headers['accept-encoding']) {
        req.headers['accept-encoding'] = 'gzip, deflate';
      }

      if (options.range) {
        req.headers["Range"] = "bytes=" + options.range.min + "-" + options.range.max;
      }

      //Undo hack used to make streaming receive work on browser XHR -- the hack
      //involves processing the response as text, so responseType is set to "".
      if (options.ondata || options.onprogress) {
        options.responseType = "arraybuffer";
      }

      var request = (parsed.protocol === "https:" ? https : http).request(req, function (res) {

        var hasError = !(res.statusCode >= 200 && res.statusCode < 400);

        //Pipe through gunzip if needed
        var stream = res;
        if (!hasError && needsGunzip(res, parsed.pathname)) {
          stream = res.pipe(zlib.createGunzip());
        }

        //Decode as UTF8 string if needed
        if (options.responseType === "json" || options.responseType === "text" || !options.responseType)
        stream.setEncoding('utf8');

        var chunks = [];
        var receiveBuffer = Buffer.allocUnsafe(65536);
        var receivedLen = 0;
        stream.on('data', function (chunk) {

          //The onprogress callback is special in that it
          //want us to accumulate the data as we receive it, and it only looks at it.
          if (options.onprogress) {

            if (chunk.length + receivedLen > receiveBuffer.length) {
              var nb = Buffer.allocUnsafe(0 | Math.ceil(receiveBuffer.length * 1.5));
              receiveBuffer.copy(nb, 0, 0, receivedLen);
              receiveBuffer = nb;
            }

            chunk.copy(receiveBuffer, receivedLen, 0, chunk.length);
            receivedLen += chunk.length;
            let abort = options.onprogress(receiveBuffer, receivedLen);
            if (abort)
            request.abort();
            return;
          } else {
            chunks.push(chunk);
          }

          if (options.ondata) {
            options.ondata(chunk);
          }

        });

        stream.on('end', function () {

          if (res.statusCode >= 200 && res.statusCode < 400) {

            if (options.responseType === "json") {
              var jsobj = JSON.parse(chunks.join(''));
              onSuccess(jsobj);
              return;
            }

            if (options.responseType === "text" || options.responseType === "") {
              var str = chunks.join('');
              onSuccess(str);
              return;
            }

            var buf = options.onprogress ? receiveBuffer : Buffer.concat(chunks);

            if (buf[0] === 31 && buf[1] === 139) {

              _logger_Logger__WEBPACK_IMPORTED_MODULE_80__.logger.warn("An LMV resource (" + url + ") was double compressed, or Content-Encoding header missing");

              try {
                buf = zlib.gunzipSync(buf);
                receivedLen = buf.length;
              } catch (err) {
                onFailure(_ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.BAD_DATA,
                "Malformed data received when requesting file",
                { "url": url, "exception": err.toString(), "stack": err.stack });
              }
            }

            if (request.status === 200 && options.range) {
              //If we requested a range, but the entire content was returned,
              //make sure to give back just the requested subset to the caller
              buf = new Uint8Array(buf, options.range.min, options.range.max - options.range.min);
            }

            onSuccess(buf, receivedLen);

          } else {

            if (onFailure)
            onFailure(res.statusCode, res.statusMessage, { url: url });

          }
        });

      });

      request.on("error", function (error) {
        if (onFailure)
        onFailure(error.code, error.message, { url: url });
      });

      if (options.postData) {
        request.write(options.postData);
      }

      request.end();

    };

  })();

} else {

  var Pend = __webpack_require__(/*! pend */ "./node_modules/pend/index.js");
  var xhrThrottle = new Pend();
  xhrThrottle.max = 25;

  var protocolPortMap = {};
  var pendingPortRequest = {};
  var pendingRequestChannelMap = {};

  /**
   * Explain how the protocol handler working in general here
   * Why adding this function:
   * In Emscripten it has a virtual file system, it provide us ability to run wasm loader to load 
   * native DWF models, and write the output in that virtual file system
   * 
   * While, we run the extraction code in the worker, it makes us hard to read the data back since only 
   * the worker thread can read that data. But we need put the resource in the bubble data to indicate that
   * this data is from Emscripten Virtual File System, the urn is not an http(s) or file.
   * 
   * It makes the whole process complex, we don't want to change the existing data schema(bubble) so we need
   * to add a support in the Xhr.js to support the this resource request.
   * 
   * The idea here is we register a MessagePort in the main thread, and once we create a worker which need to
   * load the special resource, it will check whether this special protocol has a handler or not. If it does,
   * it will let the handler to do the heavy lifting. 
   * 
   * In the WorkerCreator, it will create new  MessageChannel between new created worker and the main thread,
   * it became the bridge to get the actual resource from the loader who registered the protocol
   * 
   */
  ViewingService.registerProtocolPort = function (protocol, port) {
    if (/^(http(s)?|file):/gi.test(protocol)) {
      // for peace of mind: security
      console.warn("http(s) or file protocol were not allowed to be handled");
      return;
    }

    if (!port) {
      // means we need to remove if there is a port open
      if (protocolPortMap[protocol] && protocolPortMap[protocol] instanceof MessagePort) {
        protocolPortMap[protocol].onmessage = undefined;
        protocolPortMap[protocol] = undefined;
      }

      return;
    }

    protocolPortMap[protocol] = port;

    port.onmessage = function (message) {
      var url = message.data.url;
      if (pendingPortRequest[url]) {
        var pendingHandler = pendingPortRequest[url];

        if (message.data.error) {
          pendingHandler.onFailureWrapped(_ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.BAD_DATA,
          "Malformed data received when requesting file",
          { "url": url, "exception": message.data.error.message, "stack": message.data.error.stack });
        } else {
          // In the worker whom is root when request the data
          var rawbuf = message.data.buffer;
          pendingPortRequest[url] = undefined;

          if (rawbuf[0] === 31 && rawbuf[1] === 139 && url.match(/(.f2d|.gz)$/gi)) {
            try {
              rawbuf = (0,fflate__WEBPACK_IMPORTED_MODULE_86__.gunzipSync)(rawbuf);
              if (pendingHandler.options && pendingHandler.options.ondata) {
                pendingHandler.options.ondata(rawbuf);
              }
              pendingHandler.onSuccessWrapped(rawbuf);
            } catch (err) {
              pendingHandler.onFailureWrapped(_ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.BAD_DATA,
              "Malformed data received when requesting file",
              { "url": url, "exception": err.toString(), "stack": err.stack });
            }
          } else {
            pendingHandler.onSuccessWrapped(rawbuf);
          }
        }
      } else if (pendingRequestChannelMap[url]) {
        // For the middle man
        var transfer = [];
        if (message.data && message.data.buffer && message.data.buffer.buffer instanceof ArrayBuffer) {
          transfer.push(message.data.buffer.buffer);
        }
        pendingRequestChannelMap[url].postMessage(message.data, transfer);
        pendingRequestChannelMap[url] = undefined;
      }
    };
  };

  ViewingService.handlerProtocol = function (protocol, url, onSuccessWrapped, onFailureWrapped, options) {
    var port = protocolPortMap[protocol];
    pendingPortRequest[url] = {
      onSuccessWrapped,
      onFailureWrapped,
      options
    };

    port.postMessage({
      operation: ViewingService.WORKER_READ_FILE,
      url
    });

  };

  ViewingService.forwardProtocolHandlerToWorker = function (worker) {
    var map = {};

    // create the middle man who connect between the worker who need to request the resource
    // and the main thread
    var channel = new MessageChannel();
    channel.port1.onmessage = function (message) {
      var url = new URL(message.data.url);
      protocolPortMap[url.protocol].postMessage(message.data);
      pendingRequestChannelMap[url] = channel.port1;
    };

    for (var key in protocolPortMap) {
      if (protocolPortMap[key] instanceof MessagePort) {
        map[key] = channel.port2;
      }
    }

    worker.doOperation({
      operation: ViewingService.WORKER_REGISTER_FILE_PORT,
      protocolPortMap: map
    }, [channel.port2]);
  };

  /**
   * Performs a GET/HEAD request to the Viewing Service.
   *
   * @param {string} viewingServiceBaseUrl - The base url for the viewing service.
   * @param {string} api - The api to call in the viewing service.
   * @param {string} url - The url for the request.
   * @param {function} onSuccess - A function that takes a single parameter that represents the response
   *  returned if the request is successful.
   * @param {function} onFailure - A function that takes an integer status code and a string status, which together
   *  represent the response returned if the request is unsuccessful, and a third data argument, which has more
   *  information about the failure. The data is a dictionary that minimally includes the url, and an exception if
   *  one was raised.
   * @param {Object} [options] - A dictionary of options that can include:
   *  {String}  [method='get'] - The request method to use. Confusingly, this accepts any method, not just 'get' and
   *                             'head'. It seems like at least 'post' is officially supported.
   *  {Object}  [postData] - The body data to send with the request. Use only in conjunction with method='post'.
   *  {boolean} [noBody=false] - When true, will perform a HEAD request.
   *  {Object}  [headers] - A dictionary representing the additional headers to add. Will be ignored for signed urls.
   *  {String}  [queryParams] - A string representing the query parameters. It will only be used if the url is not
   *                            signed.
   *  {Object}  [range] - An object that defines the specifies the ranged response through 'min' and 'max' offsets
   *                      in bytes.
   *  {String}  [responseType='text'] - A string representing the response type for this request.
   *  {boolean} [withCredentials=true] - Defines whether to send and store credentials. Will be ignored for signed
   *                                     urls.
   *  {boolean} [useFetch=false] - When true, the request will use fetch instead of XMLHttpRequest (experimental!).
   *  {function}[onprogress] - If this is specified, the response will be received progressively. On each update,
   *                           the callback function is invoked with the full response that has been received up to
   *                           that point.
   *  {function}[ondata] - If this is specified, the response will be received progressively. On each update,
   *                       the callback function is invoked with only the new chunk of data.
   */
  ViewingService.rawGet = function (viewingServiceBaseUrl, api, url, onSuccess, onFailure, options) {
    xhrThrottle.go((pendCB) => {
      let onFailureWrapped = function () {
        pendCB();for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
        onFailure && onFailure.apply(onFailure, args);
      };

      let onSuccessWrapped = function () {
        pendCB();for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}
        onSuccess && onSuccess.apply(onSuccess, args);
      };

      var protocolMatch = /^(\w+:)\/\//gi.exec(url);
      // if there is a special handler for this request, delegate this request to the handler
      if (protocolMatch && protocolMatch.length == 2 && protocolPortMap[protocolMatch[1]]) {
        ViewingService.handlerProtocol(protocolMatch[1], url, onSuccessWrapped, onFailureWrapped, options);
      } else {
        let getFunc = ViewingService._rawGet;
        if (options !== null && options !== void 0 && options.useFetch) {
          getFunc = ViewingService._rawGetFetch;
        }
        getFunc(viewingServiceBaseUrl, api, url, onSuccessWrapped, function () {
          const errorCode = arguments.length <= 0 ? undefined : arguments[0];
          const method = ((options === null || options === void 0 ? void 0 : options.method) || (options !== null && options !== void 0 && options.noBody ? 'HEAD' : 'GET')).toLowerCase();

          let shouldRetry = method === 'get' && (
          // A status code of 0 indicates any sort of connection error (e.g. network issue, timeout or
          // CORS problems) or overall exception in the request code. We would usually not want to retry
          // requests that fail due to such errors. We still do it 'temporarily', because DS has an issue
          // that leads to temporary CORS errors, which can be resolved by a retry. This is a client-side
          // work-around for a server-side issue, to unblock customers.
          // See https://jira.autodesk.com/browse/LMV-6827 and the corresponding DS ticket:
          // https://jira.autodesk.com/browse/DERI-8924
          errorCode === 0 ||
          errorCode === 429 ||
          errorCode >= 500);

          // Don't retry if the request was cancelled explicitly.
          const data = arguments.length <= 2 ? undefined : arguments[2];
          if (data.aborted) {
            shouldRetry = false;
          }

          if (shouldRetry) {
            const request = arguments.length <= 3 ? undefined : arguments[3];
            let delayMs = 100;
            let timeMultiple = 5;
            // 429 - too many requests, 503 - Service Unavailable until
            let retryAfter = false;
            if ((errorCode === 429 || errorCode === 503) && request !== null && request !== void 0 && request.getResponseHeader('Retry-After')) {
              retryAfter = request.getResponseHeader('Retry-After');
            } else if (errorCode === 0) {
              retryAfter = 3;
              timeMultiple = 2;
            }
            if (retryAfter) {
              // retryAfter could be either delay-seconds or http-date 
              const seconds = Number(retryAfter);
              delayMs = !isNaN(seconds) && seconds * 1000 || Date.parse(retryAfter) - new Date().getTime();
              delayMs = delayMs > 100 ? delayMs : 100;
            }

            ViewingService._retryRequest(viewingServiceBaseUrl, api, url, options, delayMs, timeMultiple).
            then((args) => {_logger_Logger__WEBPACK_IMPORTED_MODULE_80__.logger.warn(`request ${url} successful after retries.`);onSuccessWrapped(...args);}).
            catch((args) => {_logger_Logger__WEBPACK_IMPORTED_MODULE_80__.logger.warn(`request ${url} unsuccessful after retries.`);onFailureWrapped(...args);});
          } else {
            onFailureWrapped(...arguments);
          }

        }, options);
      }
    });
  };


  ViewingService._retryRequest = function (viewingServiceBaseUrl, api, url, options, delayMs, timeMultiple) {
    const backOffOptions = {
      delayFirstAttempt: true,
      startingDelay: delayMs,
      numOfAttempts: 4,
      retry: (_ref, attemptNumber) => {let [errorCode, errorMsg, { url }] = _ref;
        _logger_Logger__WEBPACK_IMPORTED_MODULE_80__.logger.warn(`request ${url} failed with status ${errorCode} ${errorMsg}. Attempt ${attemptNumber}`);
        return true;
      },
      timeMultiple: timeMultiple
    };

    return (0,exponential_backoff__WEBPACK_IMPORTED_MODULE_85__.backOff)(() => new Promise((resolve, reject) => {
      let getFunc = ViewingService._rawGet;
      if (options !== null && options !== void 0 && options.useFetch) {
        getFunc = ViewingService._rawGetFetch;
      }
      getFunc(viewingServiceBaseUrl, api, url, function () {for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}return resolve(args);}, function () {for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {args[_key4] = arguments[_key4];}return reject(args);}, options);
    }), backOffOptions);
  };

  ViewingService.isOSSUrl = function (url) {
    if (!url) {
      return false;
    }

    return url.indexOf('/oss/v2/buckets') !== -1;
  };

  /**
   *  Given an OSS URL, returns a signed-url.
   *
   *  @param {string} url - The url for the request.
   *
   * @returns {Promise} that resolves with a simple success or fail of the request
   */
  ViewingService.getSignedS3DownloadUrl = function (url) {
    return new Promise((resolve) => {
      const acmsessionIndex = url.indexOf("?acmsession=");

      // When using signedURL, no need to append acmsession.
      if (acmsessionIndex !== -1) {
        url = url.substring(0, acmsessionIndex);
      }

      // https://wiki.autodesk.com/display/FDPA/API+Endpoints#APIEndpoints-GetDownloadURL
      url += "/signeds3download?useCdn=true";

      const request = new XMLHttpRequest();

      request.open('GET', url);

      // Bearer token is needed.
      request.setRequestHeader("Authorization", _endpoints__WEBPACK_IMPORTED_MODULE_83__.endpoint.HTTP_REQUEST_HEADERS["Authorization"]);
      request.responseType = 'json';

      request.send();

      const success = (e) => {
        const response = e.currentTarget.response;
        resolve(response.url);
      };

      const fail = () => {
        resolve(null);
      };

      request.onload = success;
      request.onerror = fail;
      request.ontimeout = fail;
      request.onabort = fail;
    });
  };

  /**
   * A specific implementation of `rawGet` that uses XMLHttpRequest. See `rawGet` for most of the common parameters.
   * We only document implementation-specific behavior here.
   *
   * @param {Object} [options] - In addition to the common options documented on `rawGet`:
   *  {boolean} [asynchronous=true] - Whether the request is asynchronous or blocking.
   *  Progressive loading (onprogress / ondata) requires `responseType='text'`.
   */
  ViewingService._rawGet = async function (viewingServiceBaseUrl, api, url, onSuccess, onFailure, options) {

    options = options || {};

    url = ViewingService.generateUrl(viewingServiceBaseUrl, api, url, options.apiData, options.escapeOssObjects, options.guid);

    let isSignedUrl = false;

    if (ViewingService.isOSSUrl(url)) {
      const signedUrl = await ViewingService.getSignedS3DownloadUrl(url);

      if (signedUrl) {
        url = signedUrl;
        isSignedUrl = true;
      } else {
        // In case that we couldn't get the signed URL for some reason, try to use the original URL.
        // If it's under 10MB it should work - so we got lucky.
        console.warn('Failed getting signed URL - Fallback to direct OSS resource.');
      }

    }

    // If we are dealing with signed URL, adding additional query params will prevent it from working.
    if (options.queryParams && !isSignedUrl) {
      var concatSymbol = url.indexOf('?') === -1 ? '?' : '&';
      url = url + concatSymbol + options.queryParams;
    }

    var request = new XMLHttpRequest();

    function onError(e) {
      if (onFailure)
      onFailure(request.status, request.statusText, { url: url }, request);
    }

    function onAbort(e) {
      if (onFailure)
      onFailure(request.status, 'request was aborted', { url: url, aborted: true }, request);
    }

    function fixJsonResponse(response) {
      if (options.responseType === "json") {
        try {
          if (response instanceof Uint8Array) {
            //This should only happen in the node.js case so we can do toString
            //instead of using the LMV utf8 converter.
            return (0,_lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_82__.blobToJson)(response);
          } else if (typeof response === "string") {
            return JSON.parse(response);
          }
        } catch (e) {}
      }
      return response;
    }

    function onLoad(e) {
      if (request.status >= 200 && request.status < 400) {

        if (request.response &&
        request.response instanceof ArrayBuffer) {

          var rawbuf;
          if (request.status === 200 && options.range) {
            //If we requested a range, but the entire content was returned,
            //make sure to give back just the requested subset to the caller
            rawbuf = new Uint8Array(request.response, options.range.min, options.range.max - options.range.min);
          } else {
            rawbuf = new Uint8Array(request.response);
          }

          // It's possible that if the Content-Encoding header is set,
          // the browser unzips the file by itself, so let's check if it did.
          if (rawbuf[0] === 31 && rawbuf[1] === 139) {
            if (!warnedGzip) {
              warnedGzip = true;
              _logger_Logger__WEBPACK_IMPORTED_MODULE_80__.logger.warn("An LMV resource (" + url + ") was not uncompressed by the browser. This hurts performance. Check the Content-Encoding header returned by the server and check whether you're getting double-compressed streams. The warning prints only once but it's likely the problem affects multiple resources.");
            }
            try {
              rawbuf = (0,fflate__WEBPACK_IMPORTED_MODULE_86__.gunzipSync)(rawbuf);
            } catch (err) {
              onFailure(_ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.BAD_DATA,
              "Malformed data received when requesting file",
              { "url": url, "exception": err.toString(), "stack": err.stack },
              request);
            }
          }

          onSuccess && onSuccess(fixJsonResponse(rawbuf));
        } else
        {
          var res = request.response;
          if (!res && (!options.responseType || options.responseType === "text"))
          res = request.responseText;

          onSuccess && onSuccess(fixJsonResponse(res));
        }
      } else
      {
        onError(e);
      }
    }

    try {

      var isAsync = options.hasOwnProperty('asynchronous') ? options.asynchronous : true;
      request.open(options.method || (options.noBody ? 'HEAD' : 'GET'), url, isAsync);

      if (options.hasOwnProperty('responseType')) {
        request.responseType = options.responseType;
      }

      if (options.range) {
        request.setRequestHeader("Range", "bytes=" + options.range.min + "-" + options.range.max);
      }

      // In case that URL already signed, no need to add credentials to it.
      if (!isSignedUrl) {
        request.withCredentials = true;

        if (options.hasOwnProperty("withCredentials"))
        request.withCredentials = options.withCredentials;

        if (options.headers) {
          for (var header in options.headers) {
            request.setRequestHeader(header, options.headers[header]);

            // Disable withCredentials if header is Authorization type
            // NOTE: using withCredentials attaches cookie data to request
            if (header.toLocaleLowerCase() === "authorization") {
              request.withCredentials = false;
            }
          }
        }
      }

      if (isAsync) {
        request.onload = onLoad;
        request.onerror = onError;
        request.ontimeout = onError;
        request.onabort = onAbort;

        if (options.ondata || options.onprogress) {

          //Set up incremental progress notification
          //if needed. We have to do some magic in order
          //to get the received data progressively.
          //https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
          request.overrideMimeType('text/plain; charset=x-user-defined');
          options._dlProgress = {
            streamOffset: 0
          };

          request.onreadystatechange = function () {

            if (request.readyState > 2 && request.status === 200) {

              if (options.ondata) {

                var textBuffer = request.responseText;

                // No new data coming in.
                if (options._dlProgress.streamOffset >= textBuffer.length)
                return;

                var arrayBuffer = textToArrayBuffer(textBuffer, options._dlProgress.streamOffset);

                options._dlProgress.streamOffset = textBuffer.length;

                options.ondata(arrayBuffer);

              } else if (options.onprogress) {

                let abort = options.onprogress(request.responseText);
                if (abort)
                request.abort();
              }
            }
          };
        }
      }

      request.send(options.postData);

      if (!isAsync) {
        onLoad();
      }
    }
    catch (e) {
      onFailure(request.status, request.statusText, { url: url, exception: e }, request);
    }
  };

  // TODO: This method is not fully implemented yet, though (see todos in the code). At the moment, it's only fully
  // tested for the progressive loading of binary data, i.e. the case where options.onprogress is defined. All other
  // cases and response types are not supported yet.
  /**
   * A specific implementation of `rawGet` that uses fetch. See `rawGet` for most of the common parameters.
   * We only document implementation-specific behavior here.
   *
   * @param {Object} [options] - Details on the common options documented on `rawGet`:
   *  Progressive loading (onprogress / ondata) will always return binary data (array buffers), regardless of
   *  `responseType`.
   */
  ViewingService._rawGetFetch = async function (viewingServiceBaseUrl, api, url, onSuccess, onFailure, options) {

    options = options || {};

    url = ViewingService.generateUrl(viewingServiceBaseUrl, api, url, options.apiData, options.escapeOssObjects, options.guid);

    let isSignedUrl = false;

    if (ViewingService.isOSSUrl(url)) {
      const signedUrl = await ViewingService.getSignedS3DownloadUrl(url);

      if (signedUrl) {
        url = signedUrl;
        isSignedUrl = true;
      } else {
        // In case that we couldn't get the signed URL for some reason, try to use the original URL.
        // If it's under 10MB it should work - so we got lucky.
        console.warn('Failed getting signed URL - Fallback to direct OSS resource.');
      }
    }

    // If we are dealing with signed URL, adding additional query params will prevent it from working.
    if (options.queryParams && !isSignedUrl) {
      var concatSymbol = url.indexOf('?') === -1 ? '?' : '&';
      url = url + concatSymbol + options.queryParams;
    }

    var request = new Request(url);
    var response;
    var abortController = new AbortController();

    /**
     * The fetch API is not fully compatible with the XMLHttpRequest API.
     * For _rawGet, the `onFailure` callback can receive the XMLHttpRequest's `request` object as the 4th parameter.
     * There is no corresponding object for fetch that would provide a compatible API. A thorough search through the
     * code base suggests that this parameter is only used in the `rawGet` error handler to read the `retryAfter`
     * header, so we provide a proxy object that mimics this single API.
     * @param {Response} response The response of the fetch request.
     * @returns {Object} A proxy object that mimics the API of an XMLHttpRequest's 'request' instance, to the extent
     *  that we found to be used in the code.
     */
    function wrapResponse(response) {
      return {
        getResponseHeader: (header) => {var _response$headers;return response === null || response === void 0 || (_response$headers = response.headers) === null || _response$headers === void 0 ? void 0 : _response$headers.get(header);}
      };
    }

    /**
     * This is called when the request failed with an HTTP error code (not for actual exceptions, e.g. network errors)
     * @param {Number} status The status code of the response.
     * @param {String} statusText The status text of the response.
     * @param {Response} response The response object of the fetch request.
     */
    function onError(status, statusText, response) {
      if (onFailure)
      onFailure(status, statusText, { url: url }, wrapResponse(response));
    }

    /**
     * This is called when the request is aborted by the code that initiated the request.
     * @param {Response} [response=undefined] The response of the fetch request. Can be undefined if the request is
     *  aborted before any response is received.
     */
    function onAbort() {let response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      if (onFailure)
      onFailure(0, 'request was aborted', { url: url, aborted: true }, wrapResponse(response));
    }

    // TODO: This might be obsolete once we handle JSON responses properly in onLoad.
    // Or maybe we still need it to generate JSON results if the user requested that, while the actual response type
    // was binary or string?
    function fixJsonResponse(response) {
      if (options.responseType === "json") {
        try {
          if (response instanceof Uint8Array) {
            //This should only happen in the node.js case so we can do toString
            //instead of using the LMV utf8 converter.
            return (0,_lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_82__.blobToJson)(response);
          } else if (typeof response === "string") {
            return JSON.parse(response);
          }
        } catch (e) {}
      }
      return response;
    }

    /**
     * This is called when the request completed successfully.
     * @param {Response} response The response object of the fetch request.
     * @param {ArrayBuffer|undefined} data The response data. This will only be set if the response has already been
     *  processed progressively (as we cannot access the data via the response anymore in that case). Otherwise, the
     *  data needs to be accessed through the response.
     */
    async function onLoad(response) {let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (response.status >= 200 && response.status < 400) {

        if (false) { var rawbuf; } else
        {
          var res;
          if (response.bodyUsed) {// the data has already been read progressively
            res = data;
          } else if (!options.responseType || options.responseType === "text") {
            res = await response.text();
          } else {
            res = await response.arrayBuffer();
          }
          // TODO: Handle other types, i.e. json (might make fixJsonResponse obsolete), blob or document.
          // options.responseType can only provide a hint to what the user expects. We also need to look at
          // response headers (content-type) to determine the actual response format (we should still try to
          // provide the type that was requested by the user, if possible).

          onSuccess && onSuccess(fixJsonResponse(res));
        }
      } else
      {
        onError(response.status, response.responseText, response);
      }
    }

    try {

      const requestOptions = {
        method: options.method || (options.noBody ? 'HEAD' : 'GET'),
        body: options.postData,
        headers: options.headers || {},
        signal: abortController.signal
      };

      if (options.range) {
        requestOptions.headers.Range = "bytes=" + options.range.min + "-" + options.range.max;
      }

      // In case that URL already signed, no need to add credentials to it.
      if (!isSignedUrl) {
        requestOptions.credentials = 'include';

        if (options.hasOwnProperty("withCredentials") && options.withCredentials === false)
        requestOptions.credentials = 'omit';

        if (options.headers) {
          for (var header in options.headers) {
            // Disable withCredentials if header is Authorization type
            // NOTE: using withCredentials attaches cookie data to request
            if (header.toLocaleLowerCase() === "authorization") {
              requestOptions.credentials = 'omit';
            }
          }
        }
      }

      response = await fetch(request, requestOptions);

      if (response.ok) {

        if (options.ondata || options.onprogress) {// requester expects progressive updates

          const reader = response.body.getReader();

          let aggregateBuffer;
          let currentView;
          if (options.onprogress) {
            const contentLength = response.headers.get('content-length');
            // Note that content-length will usually refer to the gzipped size, while this array is supposed
            // to store the uncompressed data. So we will have to resize it during the download.
            if (contentLength) {
              aggregateBuffer = new Uint8Array(contentLength);
            } else {
              aggregateBuffer = new Uint8Array(5 << 11); // start with 10 kb; this is arbitrary
            }
          }

          let receivedLength = 0;

          const progressCallback = (_ref2) => {let { done, value } = _ref2;
            if (done) {
              if (options.onprogress && receivedLength < aggregateBuffer.length) {
                // TODO: Is it better to copy instead of just creating a view, so that unused memory can be freed?
                aggregateBuffer = new Uint8Array(aggregateBuffer.buffer, 0, receivedLength);
              }

              onLoad(response, aggregateBuffer);
              return;
            }

            if (options.ondata) {
              options.ondata(value); // only send the incremental update
            } else {// onprogress
              // We need to keep track of the entire response.
              if (aggregateBuffer.length < value.length + receivedLength) {
                const newlen = Math.max(aggregateBuffer.length * 2, value.length + receivedLength);
                var newBuffer = new Uint8Array(newlen);
                newBuffer.set(aggregateBuffer);
                aggregateBuffer = newBuffer;
              }
              aggregateBuffer.set(value, receivedLength);
              receivedLength += value.length;

              currentView = new Uint8Array(aggregateBuffer.buffer, 0, receivedLength);

              const abort = options.onprogress(currentView); // send everything that has been received so far

              if (abort) {
                reader.cancel();
                abortController.abort();
                onAbort(response);
                return;
              }
            }

            reader.read().then(progressCallback);
          };

          // TODO: This (and the instance above) might need error handling (catch), unless this is handled by
          // the try ... catch already.
          reader.read().then(progressCallback);
        } else {// requester expects one-time full response
          onLoad(response);
        }
      } else {// We got a status code that indicates an error (400+)
        onError(response.status, response.statusText, response);
      }
    }
    catch (e) {
      // We might not have a valid response object in this case.
      if (response) {
        onFailure(response.status, response.statusText, { url: url, exception: e }, wrapResponse(response));
      } else {
        onFailure(0, "network error", { url: url, exception: e });
      }
    }
  };

} // browser get implementation

// Create the default failure callback.
//
ViewingService.defaultFailureCallback = function (httpStatus, httpStatusText, data) {
  if (httpStatus == 403) {
    this.raiseError(
      _ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.NETWORK_ACCESS_DENIED,
      "Access denied to remote resource",
      { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
  } else
  if (httpStatus == 404) {
    this.raiseError(
      _ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.NETWORK_FILE_NOT_FOUND,
      "Remote resource not found",
      { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
  } else
  if (httpStatus === 0 && data.aborted) {
    this.raiseError(
      _ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.LOAD_CANCELED,
      "Request aborted",
      { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
  } else
  if (httpStatus >= 500 && httpStatus < 600) {
    this.raiseError(
      _ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.NETWORK_SERVER_ERROR,
      "Server error when accessing resource",
      { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
  } else
  if (data.exception) {
    this.raiseError(
      _ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.NETWORK_FAILURE,
      "Network failure",
      { "url": data.url, "exception": data.exception.toString(), "stack": data.exception.stack });
  } else
  {
    this.raiseError(
      _ErrorCodes__WEBPACK_IMPORTED_MODULE_81__.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE,
      "Unhandled response code from server",
      { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText, data: data });
  }
};



function copyOptions(loadContext, options) {

  //Those are the usual defaults when called from the LMV worker

  if (!options.hasOwnProperty("responseType"))
  options.responseType = "arraybuffer";

  //Add options junk we got from the main thread context

  if (!options.hasOwnProperty("withCredentials"))
  options.withCredentials = !!loadContext.auth;

  options.headers = loadContext.headers;
  options.queryParams = loadContext.queryParams;
  options.endpoint = loadContext.endpoint;
  options.escapeOssObjects = loadContext.escapeOssObjects;
}

//Utility function called from the web worker to set up the options for a get request,
//then calling ViewingService.get internally
ViewingService.getItem = function (loadContext, url, onSuccess, onFailure, options) {

  options = options || {};

  copyOptions(loadContext, options);

  //If the endpoint does not support range requests (Apigee), then convert
  //the range to start/end URL parameters.
  if (options.range && !loadContext.supportsRangeRequests) {

    let rangeParam = "start=" + options.range.min + "&end=" + options.range.max;
    if (options.queryParams) {
      options.queryParams += "&" + rangeParam;
    } else {
      options.queryParams = rangeParam;
    }

    options.range = undefined;
  }

  ViewingService.rawGet(loadContext.endpoint, 'items', url, onSuccess, onFailure, options);

};

//Utility function called from the web worker to set up the options for a get request,
//then calling ViewingService.get internally
ViewingService.getManifest = function (loadContext, url, onSuccess, onFailure, options) {

  options = options || {};

  if (!options.hasOwnProperty("responseType"))
  options.responseType = "json";

  copyOptions(loadContext, options);

  ViewingService.rawGet(loadContext.endpoint, 'bubbles', url, onSuccess, onFailure, options);

};

ViewingService.getProperties = function (loadContext, url, guid, query, onSuccess, onFailure) {
  const options = {};
  copyOptions(loadContext, options);
  options.responseType = 'json';
  options.guid = guid;
  options.method = 'POST';
  options.postData = JSON.stringify(query);
  options.headers['Content-Type'] = 'application/json';
  options.headers['accept'] = 'application/json';
  options.headers['Access-Control-Allow-Origin'] = '*';
  ViewingService.rawGet(loadContext.endpoint, 'properties', url, onSuccess, onFailure, options);
};

//Utility function called from the web worker to set up the options for a get request,
//then calling ViewingService.get internally
ViewingService.getThumbnail = function (loadContext, url, onSuccess, onFailure, options) {

  options = options || {};

  copyOptions(loadContext, options);

  var queryParams = options.queryParams || '';
  var missingElements = [];
  if (queryParams.indexOf('guid=') === -1 && options.guid) {
    missingElements.push("guid=" + encodeURIComponent(options.guid));
  }
  if (queryParams.indexOf('role=') === -1) {
    var role = options.role || "rendered";
    missingElements.push("role=" + role);
  }
  if (queryParams.indexOf('width=') === -1) {
    var sz = options.size || 400;
    missingElements.push("width=" + sz);
  }
  if (queryParams.indexOf('height=') === -1) {
    var sz = options.size || 400;
    missingElements.push("height=" + sz);
  }
  if (queryParams.indexOf('acmsession=') === -1 && options.acmsession) {
    missingElements.push("acmsession=" + options.acmsession);
  }
  var thumbQueryParams = missingElements.join('&');

  if (options.queryParams) {
    options.queryParams = options.queryParams + '&' + thumbQueryParams;
  } else {
    options.queryParams = thumbQueryParams;
  }

  ViewingService.rawGet(loadContext.endpoint, 'thumbnails', url, onSuccess, onFailure, options);
};


ViewingService.getACMSession = function (endpoint, acmProperties, onSuccess, onFailure) {
  const backOffOptions = {
    numOfAttempts: 4,
    timeMultiple: 5,
    retry: (_, attemptNumber) => {
      _logger_Logger__WEBPACK_IMPORTED_MODULE_80__.logger.warn(`acmsession request failed. Attempt #${attemptNumber}`);
      return true;
    }
  };

  (0,exponential_backoff__WEBPACK_IMPORTED_MODULE_85__.backOff)(() => new Promise((resolve, reject) => {
    ViewingService._getACMSession(endpoint, acmProperties, resolve, reject);
  }), backOffOptions).
  then(function () {return onSuccess(...arguments);}).
  catch(function () {return onFailure(...arguments);});
};


ViewingService._getACMSession = function (endpoint, acmProperties, onSuccess, onFailure) {

  var acmHeaders = {};
  var token;

  for (var key in acmProperties) {

    if (key === "oauth2AccessToken")
    token = acmProperties[key];else

    if (key.indexOf("x-ads-acm") !== -1)
    acmHeaders[key] = acmProperties[key];
  }

  // The value of this can be anything. Required for some arcane reasons.
  acmHeaders.application = "autodesk";

  var xhr = new XMLHttpRequest();
  xhr.open("POST", endpoint + '/oss-ext/v2/acmsessions', true);
  xhr.setRequestHeader("Content-Type", "application/json");
  xhr.setRequestHeader("Authorization", "Bearer " + token);
  xhr.responseType = "json";

  xhr.onload = function () {
    if (xhr.status === 200 && xhr.response) {
      // If the response is a string (e.g. from IE), need to parse it to an object first
      var response = typeof xhr.response === 'string' ? JSON.parse(xhr.response) : xhr.response;

      if (response && response.acmsession) {
        onSuccess(response.acmsession);
      } else
      {
        onFailure(xhr.status, "Can't get acm session from response.");
      }

    } else {
      onFailure(xhr.status);
    }
  };

  xhr.onerror = onFailure;
  xhr.ontimeout = onFailure;
  xhr.send(JSON.stringify(acmHeaders));

  // "application" header is only required for OSS end point, and should not be passed
  // with normal requests because this header is not in allowed header sets of APIGEE.
  delete acmHeaders.application;

};

/***/ }),

/***/ "./src/file-loaders/net/endpoints.js":
/*!*******************************************!*\
  !*** ./src/file-loaders/net/endpoints.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   endpoint: () => (/* binding */ endpoint),
/* harmony export */   getEnv: () => (/* binding */ getEnv),
/* harmony export */   getOfflineResourcePrefix: () => (/* binding */ getOfflineResourcePrefix),
/* harmony export */   initLoadContext: () => (/* binding */ initLoadContext),
/* harmony export */   isOffline: () => (/* binding */ isOffline),
/* harmony export */   setEnv: () => (/* binding */ setEnv),
/* harmony export */   setOffline: () => (/* binding */ setOffline),
/* harmony export */   setOfflineResourcePrefix: () => (/* binding */ setOfflineResourcePrefix)
/* harmony export */ });
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../compat */ "./src/compat.js");
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals */ "./src/globals.js");




const _window = (0,_compat__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();

var endp = {};

var CDN_ROOT = null;
endp.ENDPOINT_API_DERIVATIVE_SERVICE_V2 = 'derivativeV2';
endp.ENDPOINT_API_MODEL_DERIVATIVE_V2 = 'modelDerivativeV2'; // Forge
endp.ENDPOINT_API_FLUENT = 'fluent';
endp.ENDPOINT_API_D3S = 'D3S';
endp.ENDPOINT_API_DERIVATIVE_STREAMING = 'streamingV2'; // SVF2

var _apis_data = {
  derivativeV2: {
    baseURL: '/derivativeservice/v2',
    itemURL: '/derivativeservice/v2/derivatives/:derivativeurn',
    manifestURL: '/derivativeservice/v2/manifest/:urn',
    thumbnailsURL: '/derivativeservice/v2/thumbnails/:urn',
    propertyQueryURL: '/modelderivative/v2/designdata/:urn/metadata/:guid/properties:query'
  },
  derivativeV2_EU: {
    baseURL: '/derivativeservice/v2/regions/eu',
    itemURL: '/derivativeservice/v2/regions/eu/derivatives/:derivativeurn',
    manifestURL: '/derivativeservice/v2/regions/eu/manifest/:urn',
    thumbnailsURL: '/derivativeservice/v2/regions/eu/thumbnails/:urn'
  },
  derivativeV2_Fedramp: {
    baseURL: '/derivativeservice/v2',
    itemURL: '/derivativeservice/v2/derivatives/:derivativeurn',
    manifestURL: '/derivativeservice/v2/manifest/:urn',
    thumbnailsURL: '/derivativeservice/v2/thumbnails/:urn'
  },
  modelDerivativeV2: {
    baseURL: '/modelderivative/v2/',
    itemURL: '/modelderivative/v2/designdata/:urn/manifest/:derivativeurn',
    manifestURL: '/modelderivative/v2/designdata/:urn/manifest',
    thumbnailsURL: '/modelderivative/v2/designdata/:urn/thumbnail',
    propertyQueryURL: '/modelderivative/v2/designdata/:urn/metadata/:guid/properties:query'
  },
  fluent: {
    baseURL: '/modeldata',
    itemURL: '/modeldata/file/:derivativeurn',
    manifestURL: '/modeldata/manifest/:urn',
    thumbnailsURL: '/derivativeservice/v2/thumbnails/:urn',
    cdnURL: '/cdn',
    cdnWS: '/cdnws'
    //cdnRedirectURL: '/cdnurl', //There is no separate CDN endpoint currently
  },
  D3S: {
    baseURL: '/modeldata',
    itemURL: '/modeldata/file/:derivativeurn',
    manifestURL: '/modeldata/manifest/:urn',
    thumbnailsURL: '/derivativeservice/v2/thumbnails/:urn',
    cdnURL: '/cdn',
    cdnWS: '/cdnws'
  },
  D3S_EU: {
    baseURL: '/modeldata',
    itemURL: '/modeldata/file/:derivativeurn',
    manifestURL: '/modeldata/manifest/:urn',
    thumbnailsURL: '/derivativeservice/v2/regions/eu/thumbnails/:urn',
    cdnURL: '/cdn',
    cdnWS: '/cdnws'
  },
  streamingV2: {
    /** SVF2 */
    baseURL: '/modeldata',
    itemURL: '/modeldata/file/:derivativeurn',
    manifestURL: '/modeldata/manifest/:urn',
    thumbnailsURL: '/derivativeservice/v2/thumbnails/:urn',
    cdnURL: '/cdn',
    cdnWS: '/cdnws'
  },
  streamingV2_EU: {
    /** SVF2 */
    baseURL: '/regions/eu/modeldata',
    itemURL: '/regions/eu/modeldata/file/:derivativeurn',
    manifestURL: '/regions/eu/modeldata/manifest/:urn',
    thumbnailsURL: '/derivativeservice/v2/regions/eu/thumbnails/:urn',
    cdnURL: '/regions/eu/cdn',
    cdnWS: '/regions/eu/cdnws'
  },
  streamingV2_Fedramp: {
    /** SVF2 */
    baseURL: '/modeldata',
    itemURL: '/modeldata/file/:derivativeurn',
    manifestURL: '/modeldata/manifest/:urn',
    thumbnailsURL: '/derivativeservice/v2/thumbnails/:urn',
    cdnURL: '/cdn',
    cdnWS: '/cdnws'
  }
};

var _endpoint = '';
var _api = endp.ENDPOINT_API_DERIVATIVE_SERVICE_V2;
var _useCredentials = false;
var _useCookie = false;
var _acmSession = '';
var _escapeOssObjects = false;

endp.HTTP_REQUEST_HEADERS = {};
endp.queryParams = {};

/**
 * Sets the endpoint and api to be used to create REST API request strings.
 * @param {string} endpoint
 * @param {string} [api] - Possible values are derivativeV2, modelDerivativeV2
 */
endp.setEndpointAndApi = function (endpoint, api) {
  if (endpoint) {
    _endpoint = endpoint;
  }
  if (api) {
    _api = api;
    if (api.startsWith('D3S')) {
      console.warn(`api=${api} is deprecated and will be removed in a future release. Use streamingV2 or streamingV2_EU (europe region) instead`);
    }
  }
};

/**
 * Returns the endpoint plus the api used to create REST API request strings.
 * Example: "developer.api.autodesk.com/modelderivative/v2"
 * @returns {string}
 */
endp.getEndpointAndApi = function () {
  return _endpoint + _apis_data[_api].baseURL;
};

/**
 * Returns the endpoint used to create REST API request strings.
 * Examples: "developer.api.autodesk.com"
 * @returns {string}
 */
endp.getApiEndpoint = function () {
  return _endpoint;
};

/**
 * @private
 * @returns {string}
 */
endp.getApiFlavor = function () {
  return _api;
};

/**
 * Returns the default shared resource CDN location.
 * For best performance (and to not overload our servers), this should
 * be replaced by a direct CloudFront url during initialization, by
 * calling the cdnRedirectUrl and looking at the result.
 */
endp.getCdnUrl = function () {
  return CDN_ROOT || (_endpoint ? _endpoint + _apis_data[_api].cdnURL : undefined);
};

endp.getCdnWebSocketEndpoint = function () {
  return _endpoint + (_apis_data[_api].cdnWS || '');
};

endp.setCdnUrl = function (url) {
  CDN_ROOT = url;
};

endp.getCdnRedirectUrl = function () {
  var redirect = _apis_data[_api].cdnRedirectURL;
  if (!redirect)
  return null;
  return _endpoint + redirect;
};

endp.setAcmSession = function (value) {
  _acmSession = value;
};

endp.getAcmSession = function () {
  return _acmSession;
};

/**
 * Returns a REST API request strings to be used to get the manifest of the provided urn.
 * Example: "developer.api.autodesk.com/modelderivative/v2/designdata/:urn/manifest"
 * @param {string | null} endpoint - When provided is used instead of the globally set endpoint.
 * @param {string} urn
 * @param {string} api - When provided is used instead of the globally set API flavor
 * @returns {string}
 */
endp.getManifestApi = function (endpoint, urn, api) {
  var url = endpoint || _endpoint;
  api = api || _api;
  url += _apis_data[api].manifestURL;
  // If urn is not provided we return same string that before for backward compatibility.
  urn = urn || '';
  url = url.replace(':urn', urn);
  return url;
};

/**
 * Returns a REST API request strings to be used to get a derivative urn.
 * Example: "developer.api.autodesk.com/modelderivative/v2/designdata/:urn/manifest/:derivativeUrn"
 * @param {string | null} endpoint - When provided is used instead of the globally set API endpoint.
 * @param {string} derivativeUrn
 * @param {string} api - When provided is used instead of the globally set API flavor
 * @returns {string}
 */
endp.getItemApi = function (endpoint, derivativeUrn, api) {
  var theApi = api || _api;
  var itemApi = (endpoint || _endpoint) + _apis_data[theApi].itemURL;
  // If urn is not provided we return same string that before for backward compatibility.
  derivativeUrn = derivativeUrn || '';
  var decodedUrn = decodeURIComponent(derivativeUrn);

  // Extract svf urn from item urn, needed when using model derivative.
  if (itemApi.indexOf(':urn') !== -1) {
    var parts = decodedUrn.split('/');
    var urn = parts[0] || '';
    urn = urn.split(':');
    urn = urn[urn.length - 1] || '';

    itemApi = itemApi.replace(':urn', urn);
  }

  if (theApi === endp.ENDPOINT_API_MODEL_DERIVATIVE_V2) {
    derivativeUrn = encodeURIComponent(decodedUrn);
  }

  itemApi = itemApi.replace(':derivativeurn', derivativeUrn);

  return itemApi;
};

/**
 * Returns a REST API request strings to be used to get the thumbnail for a specific urn.
 * Example: "developer.api.autodesk.com/modelderivative/v2/designdata/:urn/thumbnail"
 * @param {string | null} endpoint - When provided is used instead of the globally set endpoint.
 * @param {string} urn
 * @param {string} api - When provided is used instead of the globally set API flavor
 * @returns {string}
 */
endp.getThumbnailApi = function (endpoint, urn, api) {
  var thumbnailApi = (endpoint || _endpoint) + _apis_data[api || _api].thumbnailsURL;
  return thumbnailApi.replace(':urn', urn || '');
};

endp.getPropertyQueryApi = function (endpoint, urn, api, guid) {
  let propertyQueryApi = (endpoint || _endpoint) + _apis_data[api || _api].propertyQueryURL;
  propertyQueryApi = propertyQueryApi.replace(':urn', urn || '');
  return propertyQueryApi.replace(':guid', guid || '');
};

endp.getUseCredentials = function () {
  return _useCredentials;
};

endp.getDomainParam = function () {
  console.warn("getDomainParam is deprecated, switch to getQueryParams instead.");
  return this.getUseCredentials() && !(0,_compat__WEBPACK_IMPORTED_MODULE_0__.isNodeJS)() ? "domain=" + encodeURIComponent(_window.location.origin) : "";
};

/**
 * Adds a URL parameter that will be used in all data load requests.
 * @param {string} param - The name of the parameter
 * @param {string} value - The value of the parameter. It will be URI encoded when constructing the final URL.
 */
endp.addQueryParam = function (param, value) {
  this.queryParams[param] = value;
};

/**
 * Deletes a previously specified URL parameter.
 * @param {string} param - The name of the parameter to delete
 */
endp.deleteQueryParam = function (param) {
  delete this.queryParams[param];
};

endp.getQueryParams = function (inputObj) {

  let qParam = this.getUseCredentials() && !(0,_compat__WEBPACK_IMPORTED_MODULE_0__.isNodeJS)() ? "domain=" + encodeURIComponent(_window.location.origin) : "";

  let bypassDs = (0,_globals__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)("bypassds");
  if (bypassDs) {
    qParam = qParam ? qParam + "&bypassds=1" : "bypassds=1";
  }

  let addedParams = [];
  for (let p in this.queryParams) {
    addedParams.push(encodeURIComponent(p) + "=" + encodeURIComponent(this.queryParams[p]));
  }

  if (addedParams.length) {
    if (qParam)
    qParam += "&" + addedParams.join("&");else

    qParam = addedParams.join("&");
  }

  if (qParam && inputObj) {
    if (inputObj.queryParams) {
      inputObj.queryParams += "&" + qParam;
    } else {
      inputObj.queryParams = qParam;
    }
  }

  return qParam;
};

endp.setUseCredentials = function (useCredentials) {
  _useCredentials = useCredentials;
};

endp.setUseCookie = function (useCookie) {
  _useCookie = useCookie;
};

endp.getUseCookie = function () {
  return _useCookie;
};

endp.isOtgBackend = function () {
  return this.getApiFlavor() === this.ENDPOINT_API_FLUENT;
};

endp.isSVF2Backend = function () {
  let api = this.getApiFlavor();
  return api.startsWith(this.ENDPOINT_API_D3S) || api.startsWith(this.ENDPOINT_API_DERIVATIVE_STREAMING);
};

endp.setEscapeOssObjects = function (escapeOssObjects) {
  _escapeOssObjects = escapeOssObjects;
};

endp.getEscapeOssObjects = function () {
  return _escapeOssObjects;
};

endp.initLoadContext = function (inputObj) {

  inputObj = inputObj || {};

  inputObj.auth = this.getUseCredentials();

  if (!inputObj.endpoint)
  inputObj.endpoint = this.getApiEndpoint();

  if (!inputObj.api)
  inputObj.api = this.getApiFlavor();

  if (!inputObj.headers)
  inputObj.headers = {};

  for (var p in this.HTTP_REQUEST_HEADERS) {
    inputObj.headers[p] = this.HTTP_REQUEST_HEADERS[p];
  }

  if (inputObj.api === this.ENDPOINT_API_FLUENT) {



    //Turned off because Nginx on fluent server is refusing to
    //return ranges from the proxy cache -- and it's not clear why.
    //inputObj.supportsRangeRequests = true;
  } //This is done to avoid CORS errors on content served from proxy or browser cache
  //The cache will respond with a previously received response, but the Access-Control-Allow-Origin
  //response header might not match the current Origin header (e.g. localhost vs. developer.api.autodesk.com)
  //which will cause a CORS error on the second request for the same resource.
  this.getQueryParams(inputObj);
  //shared geometry/material storage
  inputObj.otg_cdn = CDN_ROOT || this.getCdnUrl();
  inputObj.otg_ws = this.getCdnWebSocketEndpoint();

  inputObj.escapeOssObjects = this.getEscapeOssObjects();

  return inputObj;
};

//TODO: Globals that need a better place
var _env; //formerly avp.env
function getEnv() {
  return _env;
}
function setEnv(env) {
  _env = env;
  if (env.startsWith('MD20')) {
    console.warn(`env=${env} is deprecated and will be removed in a future release. Use Autodesk{env}2 instead, where env=Development, Staging, or Production`);
  }
}

// Set viewer in offline mode if set to true. In offline mode, viewer would ignore all URNs in bubble JSON
// and assume the viewables are laid out in local file system path relative to the bubble.json.
var _offline = false;
function isOffline() {
  return _offline;
}
function setOffline(offline) {
  _offline = offline;
}

// Offline resource prefix specified by viewer consumer (e.g. IOS web view). Used as prefix to concatenate with
// each resource relative path to form the absolute path of each resource.
var _offlineResourcePrefix = "";
function setOfflineResourcePrefix(prefix) {
  _offlineResourcePrefix = prefix;
}
function getOfflineResourcePrefix() {
  return _offlineResourcePrefix;
}

let endpoint = endp;

//For backwards compatibility until all code is converted to use
//the function from the endpoint instance.
let initLoadContext = endp.initLoadContext.bind(endp);

/***/ }),

/***/ "./src/file-loaders/workers/BvhWorker.js":
/*!***********************************************!*\
  !*** ./src/file-loaders/workers/BvhWorker.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _wgs_scene_BVHBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../wgs/scene/BVHBuilder */ "./src/wgs/scene/BVHBuilder.js");


function doComputeBvh(loadContext) {

  var tmpbvh = new _wgs_scene_BVHBuilder__WEBPACK_IMPORTED_MODULE_0__.BVHBuilder(loadContext.fragments);
  tmpbvh.finfo.wantSort = loadContext.fragments.wantSort;
  tmpbvh.build(loadContext.bvhOptions);

  var bvh = {
    nodes: tmpbvh.nodes.getRawData(),
    primitives: tmpbvh.primitives
  };

  loadContext.worker.postMessage({ bvh: bvh, modelId: loadContext.modelId },
  [bvh.nodes, bvh.primitives.buffer]);
}

function register(workerMain) {
  workerMain.register("COMPUTE_BVH", { doOperation: doComputeBvh });
}

/***/ }),

/***/ "./src/file-loaders/workers/ConsolidationWorker.js":
/*!*********************************************************!*\
  !*** ./src/file-loaders/workers/ConsolidationWorker.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   doGeomMerge: () => (/* binding */ doGeomMerge),
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../wgs/scene/LmvMatrix4 */ "./src/wgs/scene/LmvMatrix4.js");
/* harmony import */ var _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../wgs/scene/LmvVector3 */ "./src/wgs/scene/LmvVector3.js");
/* harmony import */ var _wgs_scene_consolidation_GeomMergeTask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../wgs/scene/consolidation/GeomMergeTask */ "./src/wgs/scene/consolidation/GeomMergeTask.js");




/**
 * Main function of ConsolidationWorker. The purpose of this function is to overtake some time-consuming
 * work from mergeGeometries (see Consolidation.js), e.g., baking transforms into vertex-positions and normals.
 *  @param {Object}      context
 *  @param {MergeTask[]} context.tasks - Each MergeTask provides the input data to process a single consolidated mesh.
 *                                       See ParallelGeomMerge.js for details.
 */
function doGeomMerge(context) {

  // Since we are running in the worker script, use LmvVector/LmvMatrix to run the MergeTask
  var matrix = new _wgs_scene_LmvMatrix4__WEBPACK_IMPORTED_MODULE_0__.LmvMatrix4();
  var vec = new _wgs_scene_LmvVector3__WEBPACK_IMPORTED_MODULE_1__.LmvVector3();

  var results = [];
  for (var i = 0; i < context.tasks.length; i++) {
    var task = context.tasks[i];

    var result = _wgs_scene_consolidation_GeomMergeTask__WEBPACK_IMPORTED_MODULE_2__.GeomMergeTask.prototype.run.call(task, matrix, vec);

    results.push(result);
  }

  // add result array buffers to transferlist to avoid copying
  var transferList = [];
  for (var i = 0; i < results.length; i++) {
    transferList.push(results[i].vb.buffer);
    transferList.push(results[i].vertexIds.buffer);
  }

  // send back result
  context.worker.postMessage(results, transferList);
}

function register(workerMain) {
  workerMain.register("MERGE_GEOMETRY", { doOperation: doGeomMerge });
}

/***/ }),

/***/ "./src/file-loaders/workers/F2dParseWorker.js":
/*!****************************************************!*\
  !*** ./src/file-loaders/workers/F2dParseWorker.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _lmvtk_f2d_F2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lmvtk/f2d/F2d */ "./src/file-loaders/lmvtk/f2d/F2d.js");
/* harmony import */ var _lmvtk_f2d_F2dGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lmvtk/f2d/F2dGeometry */ "./src/file-loaders/lmvtk/f2d/F2dGeometry.js");
/* harmony import */ var _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../net/ErrorCodes */ "./src/file-loaders/net/ErrorCodes.js");





function tryCatch(_this, f) {
  try {
    f();
  }
  catch (exc) {
    _this.raiseError(
      _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__.ErrorCodes.BAD_DATA, "",
      { "exception": exc.toString(), "stack": exc.stack });
    _this.postMessage(null);
  }
}

function getF2DParser(loadContext) {
  if (loadContext.f2dLoadOptions.outputType === "geometry") {
    return new _lmvtk_f2d_F2dGeometry__WEBPACK_IMPORTED_MODULE_1__.F2DGeometry(loadContext.metadata, loadContext.f2dLoadOptions);
  }
  return new _lmvtk_f2d_F2d__WEBPACK_IMPORTED_MODULE_0__.F2D(loadContext.metadata, loadContext.manifest, loadContext.basePath, loadContext.f2dLoadOptions);
}

function doParseF2D(loadContext) {
  var _this = loadContext.worker;

  _this.postMessage({ progress: 0.01 }); //Tell the main thread we are alive

  if (loadContext.data) {

    _this.postMessage({ progress: 0.5 }); //rough progress reporting -- can do better
    var f2d = getF2DParser(loadContext);
    loadContext.loadDoneCB = function (success) {

      if (success) {
        var msg = { "f2d": f2d };
        _this.postMessage(msg);
      } else
      {
        _this.raiseError(_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__.ErrorCodes.BAD_DATA, "", {});
        _this.postMessage(null);
      }
    };

    tryCatch(_this, function () {
      f2d.load(loadContext, loadContext.data);
    });
  } else
  {
    _this.postMessage(null);
  }
}

function doParseF2DFrame(loadContext) {
  var _this = loadContext.worker;

  var f2d = _this.f2d;

  if (!f2d) {
    _this.postMessage({ progress: 0.5 }); //rough progress reporting -- can do better
    var f2d = _this.f2d = getF2DParser(loadContext);
    f2d.F2D_MESH_COUNT_OLD = 0;

    // First post needs to post entire F2D so we can set up bounding boxes, etc.
    var msg = { "f2dframe": f2d };
    _this.postMessage(msg);
  }

  function loadDoneCallback(success, finalFlush) {
    if (success) {

      if (!f2d.meshes.length && !finalFlush) {
        // No new data coming in.
        // debug("F2D streaming : no new data coming in.");
        return;
      } else {

        var msg = { "f2dframe": true,
          "meshes": f2d.meshes,
          "baseIndex": f2d.F2D_MESH_COUNT_OLD,
          "bbox": f2d.bbox
        };

        if (loadContext.finalFrame) {var _loadContext$f2dLoadO;

          //Add f2d properties which are cumulative and their
          //final values are not known until the end
          msg.cumulativeProps = {
            maxObjectNumber: f2d.maxObjectNumber,
            viewports: f2d.viewports,
            clips: f2d.clips,
            strings: f2d.strings,
            stringDbIds: f2d.stringDbIds,
            stringBoxes: f2d.stringBoxes,
            linkBoxes: f2d.linkBoxes,
            hasPageShadow: f2d.hasPageShadow,
            minLineWidth: f2d.currentVbb.minLineWidth
          };

          if ((_loadContext$f2dLoadO = loadContext.f2dLoadOptions) !== null && _loadContext$f2dLoadO !== void 0 && _loadContext$f2dLoadO.extendStringsFetching) {
            msg.cumulativeProps.stringCharWidths = f2d.stringCharWidths; // contains width of every character in a string
            msg.cumulativeProps.stringAngles = f2d.stringAngles; // rotation of a string box
            msg.cumulativeProps.stringPositions = f2d.stringPositions; // starting point of string box. this values are not equal to min.x and min.y of stringBoxes
            msg.cumulativeProps.stringHeights = f2d.stringHeights; // height of a string box
          }

          msg.finalFrame = finalFlush;
        }

        // User transferable objects to pass the array buffers used by mesh without deep copying.
        var transferList = [];
        for (var i = 0, e = f2d.meshes.length; i < e; ++i) {
          transferList.push(f2d.meshes[i].vb.buffer);
          transferList.push(f2d.meshes[i].indices.buffer);
        }
        _this.postMessage(msg, transferList);

        f2d.F2D_MESH_COUNT_OLD += f2d.meshes.length;
        f2d.meshes = [];
      }
    } else
    {
      _this.raiseError(
        _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__.ErrorCodes.BAD_DATA, "",
        {});
      _this.postMessage(null);
    }
  }

  loadContext.loadDoneCB = loadDoneCallback;

  tryCatch(_this, function () {
    f2d.loadFrames(loadContext);
  });
}


function register(workerMain) {
  workerMain.register("PARSE_F2D", { doOperation: doParseF2D });
  workerMain.register("PARSE_F2D_FRAME", { doOperation: doParseF2DFrame });
}

/***/ }),

/***/ "./src/file-loaders/workers/F2dStreamWorker.js":
/*!*****************************************************!*\
  !*** ./src/file-loaders/workers/F2dStreamWorker.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _net_Xhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../net/Xhr */ "./src/file-loaders/net/Xhr.js");
/* harmony import */ var _lmvtk_f2d_F2dProbe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lmvtk/f2d/F2dProbe */ "./src/file-loaders/lmvtk/f2d/F2dProbe.js");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../logger/Logger */ "./src/logger/Logger.js");
/* harmony import */ var _lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lmvtk/common/StringUtils */ "./src/file-loaders/lmvtk/common/StringUtils.js");
/* harmony import */ var _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../net/ErrorCodes */ "./src/file-loaders/net/ErrorCodes.js");
/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fflate */ "./node_modules/fflate/esm/browser.js");










var ENABLE_F2D_STREAMING_MODE = true;

function requestFileF2D(loadContext, filename, onSuccess) {
  var url = loadContext.basePath + filename;
  _net_Xhr__WEBPACK_IMPORTED_MODULE_0__.ViewingService.getItem(loadContext, url, onSuccess, null);
}

// Stream loading f2d data and prepare parseable data frames.
function doStreamF2D(loadContext) {

  var _this = loadContext.worker;

  _this.postMessage({ progress: 0.01 }); //Tell the main thread we are alive

  //Get the metadata and manifest first.
  var metadata;
  var manifest;
  var doneFiles = 0;

  var accumulatedStream = new Uint8Array(65536);
  var accumulatedBytes = 0;
  var responseData = null;

  function accumulateData(partial) {
    //Add the new bytes to the accumulation buffer
    if (accumulatedStream.length < partial.length + accumulatedBytes) {
      var newlen = Math.max(accumulatedStream.length * 2, partial.length + accumulatedBytes);
      var ns = new Uint8Array(newlen);
      ns.set(accumulatedStream);
      accumulatedStream = ns;
    }
    accumulatedStream.set(partial, accumulatedBytes);
    accumulatedBytes += partial.length;
  }

  function markSucceeded(response) {
    responseData = response;
  }

  var dataReceived = accumulateData;
  var requestSucceeded = markSucceeded;

  // Start the request for the primary graphics
  // Just accumulate data as it comes in, and remember response
  // when it succeeds. The dataReceived and requestSucceeded
  // variables are changed to other functions once the manifest
  // and metadata are read.
  _net_Xhr__WEBPACK_IMPORTED_MODULE_0__.ViewingService.getItem(loadContext, loadContext.url, function (responseData) {
    requestSucceeded(responseData);
  }, loadContext.onFailureCallback, {
    ondata: function (partial) {
      dataReceived(partial);
    },
    responseType: ""
  }
  );

  requestFileF2D(loadContext, "metadata.json.gz", function (data) {
    try {
      metadata = JSON.parse((0,_lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_3__.utf8ArrayToString)(data));
      doneFiles++;
    } catch (e) {
      self.raiseError(
        _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_4__.ErrorCodes.BAD_DATA,
        "" /* does not matter what strings we put here since the final user facing error message is solely decided
        by ErrorCodes. Invent another code if we want a specific error message for this error. */
      );
    }

    if (doneFiles === 2)
    doStreamF2D_Continued(loadContext, manifest, metadata);
  });
  requestFileF2D(loadContext, "manifest.json.gz", function (data) {
    try {
      if (data)
      manifest = JSON.parse((0,_lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_3__.utf8ArrayToString)(data));
      //The F2D does not necessarily need a manifest file to load (some old F2Ds don't have that)
      doneFiles++;
    } catch (e) {}

    if (doneFiles === 2)
    doStreamF2D_Continued(loadContext, manifest, metadata);
  });

  //Loads the F2D stream once the metadata and manifest files are fetched
  function doStreamF2D_Continued(loadContext, manifest, metadata) {

    var _this = loadContext.worker;

    var url = loadContext.url;

    // Collect asset urls that to be send to main thread for mobile usage.
    var assets = [];

    var f2dSize = 0;
    var altSize = 0;
    if (manifest && manifest.assets) {
      var a = manifest.assets;
      for (var i = 0; i < a.length; i++) {
        if (url.indexOf(a[i].URI) != -1) {
          f2dSize = a[i].usize || 0;
          break;
        } else if (a[i].type == "Autodesk.CloudPlatform.F2D")
        altSize = a[i].usize || 0;
      }
    }
    if (f2dSize == 0 && altSize > 0)
    f2dSize = altSize;

    var probe = new _lmvtk_f2d_F2dProbe__WEBPACK_IMPORTED_MODULE_1__.F2DProbe();

    var first = true;
    var streamOffset = 0;
    var sentMetadata = false;

    function onSuccess(responseData) {
      // Send collected f2d resource urls to main thread.
      _this.postMessage({ "type": "F2DAssetURL", "urls": assets });
      assets = null;

      if (ENABLE_F2D_STREAMING_MODE) {

        var msg = {
          "type": "F2DSTREAM",
          "finalFrame": true,
          "finished": true,
          "progress": 1
        };

        if (!sentMetadata) {
          msg.manifest = manifest;
          msg.metadata = metadata;
          msg.basePath = loadContext.basePath;
          msg.f2dSize = f2dSize;
          sentMetadata = true;
        }

        _this.debug("Total text bytes count : " + responseData.length);

        _this.postMessage(msg);

        //Streaming code path ends here -- we have already sent
        //the data back from the progress callback
        return;
      }

      //Non-streaming code path here
      if (accumulatedStream.length > accumulatedBytes)
      accumulatedStream = new Uint8Array(accumulatedStream.buffer.slice(0, accumulatedBytes));

      var view;
      if (accumulatedStream[0] == 31 && accumulatedStream[1] == 139) {
        try {
          view = new Uint8Array(accumulatedStream.buffer, 0, accumulatedBytes);
          view = (0,fflate__WEBPACK_IMPORTED_MODULE_5__.gunzipSync)(view);
        } catch (e) {
          console.error(e);
        }
      }

      var msg = { "type": "F2DBLOB",
        "metadata": metadata,
        "manifest": manifest,
        "f2dSize": f2dSize,
        "basePath": loadContext.basePath, // TODO: we might be able to infer this elsewhere.
        "progress": 1,
        "buffer": view.buffer };
      var transferList = [];
      transferList.push(view.buffer);
      _this.postMessage(msg, transferList);
    }

    function processData() {

      if (!ENABLE_F2D_STREAMING_MODE)
      return;

      if (first) {
        first = false;

        // If the very first two bytes of the entire stream is GZIP magic number,
        // then we fall back on none streaming mode, because streaming mode only
        // work with browser decompression, and the presence of such magic number
        // implies browser decompression fails, for whatever reasons.
        if (accumulatedStream[0] == 31 && accumulatedStream[1] == 139) {
          _logger_Logger__WEBPACK_IMPORTED_MODULE_2__.logger.error("F2D streaming broken by non-streaming unzip!", (0,_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_4__.errorCodeString)(_net_ErrorCodes__WEBPACK_IMPORTED_MODULE_4__.ErrorCodes.BAD_DATA));
          ENABLE_F2D_STREAMING_MODE = false;
          return;
        }
      }

      var view = new Uint8Array(accumulatedStream.buffer, streamOffset, accumulatedBytes - streamOffset);

      try {
        var marker = probe.load(view);

        if (marker.frameEnd > marker.frameStart) {
          var frames = accumulatedStream.buffer.slice(streamOffset + marker.frameStart, streamOffset + marker.frameEnd);
          streamOffset += marker.frameEnd;

          var transferList = [];
          transferList.push(frames);

          var msg = { "type": "F2DSTREAM",
            "frames": frames,
            "finalFrame": false
          };

          if (f2dSize)
          msg.progress = streamOffset / f2dSize;

          if (!sentMetadata) {
            msg.manifest = manifest;
            msg.metadata = metadata;
            msg.f2dSize = f2dSize;
            msg.basePath = loadContext.basePath;
            sentMetadata = true;
          }

          _this.postMessage(msg, transferList);

        }
      } catch (e) {
        _this.debug(e);
      }
    }

    function onData(partial) {
      accumulateData(partial);
      processData();
    }

    requestSucceeded = onSuccess;
    dataReceived = onData;
    // check to see if the primary graphics request has received any data
    if (accumulatedBytes > 0)
    processData();
    // check to see if primary graphics request succeeded
    if (responseData != null)
    onSuccess(responseData);
  }
}

function register(workerMain) {
  workerMain.register("STREAM_F2D", { doOperation: doStreamF2D });
}

/***/ }),

/***/ "./src/file-loaders/workers/GeomWorker.js":
/*!************************************************!*\
  !*** ./src/file-loaders/workers/GeomWorker.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _lmvtk_common_PackReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lmvtk/common/PackReader */ "./src/file-loaders/lmvtk/common/PackReader.js");
/* harmony import */ var _lmvtk_svf_Geoms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lmvtk/svf/Geoms */ "./src/file-loaders/lmvtk/svf/Geoms.js");
/* harmony import */ var _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../net/ErrorCodes */ "./src/file-loaders/net/ErrorCodes.js");
/* harmony import */ var _net_Xhr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../net/Xhr */ "./src/file-loaders/net/Xhr.js");
/* harmony import */ var _wgs_scene_DeriveTopology__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../wgs/scene/DeriveTopology */ "./src/wgs/scene/DeriveTopology.js");






function guardFunction(loadContext, f) {
  try {
    f();
  }
  catch (exc) {
    loadContext.raiseError(
      _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__.ErrorCodes.BAD_DATA, "Unhandled exception while reading pack file",
      { "url": loadContext.url, "exception": exc.toString(), "stack": exc.stack });
  }
}

function doGeomLoad(loadContext) {

  var _this = loadContext.worker;

  //Make a blocking request -- it's ok, because
  //we are in a worker thread.

  function onSuccess(arrayBuffer) {
    _this.postMessage({
      url: loadContext.url,
      workerId: loadContext.workerId,
      progress: 0.5
    }); //rough progress reporting -- can do better

    guardFunction(loadContext, function () {

      var pfr = new _lmvtk_common_PackReader__WEBPACK_IMPORTED_MODULE_0__.PackFileReader(arrayBuffer);

      var raisedError = false;

      var options = {
        estimateSizeOnly: true,
        packNormals: typeof loadContext.packNormals !== "undefined" ? loadContext.packNormals : true
      };

      var i,iEnd = pfr.getEntryCounts(),mesh;
      var skip = loadContext.inMemory || [];
      var estLength = 0;
      var shouldReadNext = function (i) {
        var v = skip[i >> 5];
        return !v || !(v & 1 << (i & 31));
      };

      for (i = 0; i < iEnd; i++)
      {
        if (shouldReadNext(i)) {
          mesh = (0,_lmvtk_svf_Geoms__WEBPACK_IMPORTED_MODULE_1__.readGeometry)(pfr, i, options);
          estLength += mesh && mesh.sharedBufferBytes || 0;
        }
      }

      var sharedBuffer = estLength ? new ArrayBuffer(estLength) : null;
      var currentOffset = 0;

      var msg = { "packId": loadContext.packId,
        "workerId": loadContext.workerId,
        "progress": 1,
        "meshes": [],
        "sharedBuffer": sharedBuffer
      };

      var transferList = sharedBuffer ? [sharedBuffer] : [];

      options = {
        dstBuffer: sharedBuffer,
        startOffset: 0,
        estimateSizeOnly: false,
        packNormals: typeof loadContext.packNormals !== "undefined" ? loadContext.packNormals : true
      };

      for (i = 0; i < iEnd; i++)
      {
        options.startOffset = currentOffset;

        if (shouldReadNext(i)) {
          mesh = (0,_lmvtk_svf_Geoms__WEBPACK_IMPORTED_MODULE_1__.readGeometry)(pfr, i, options);

          if (mesh) {
            currentOffset += mesh.sharedBufferBytes || 0;
            msg.meshes[i] = mesh;

            if (loadContext.createWireframe) {
              (0,_wgs_scene_DeriveTopology__WEBPACK_IMPORTED_MODULE_4__.createWireframe)(mesh);

              //TODO: optimize the storage of the lines index buffer to use
              //a single shared buffer for all meshes in the pack
              if (mesh.iblines)
              transferList.push(mesh.iblines.buffer);
            }
          } else {
            // it doesn't make much sense to raise an error for each entry that can't
            // be read, because chances are they will all be unreadable after the
            // first bad one.
            if (!raisedError) {
              _this.raiseError(
                _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_2__.ErrorCodes.BAD_DATA, "Unable to load geometry",
                { "url": loadContext.url });
              raisedError = true;
            }

            // in this case, we still post the full message instead of just null;
            // the mesh itself will be null, of course.
            _this.postMessage(msg);
          }
        }
      }

      _this.postMessage(msg, transferList);
    });

  }

  // With this option to control whether want to record assets request.
  var options = {
    skipAssetCallback: loadContext.skipAssetCallback
  };
  _net_Xhr__WEBPACK_IMPORTED_MODULE_3__.ViewingService.getItem(loadContext, loadContext.url, onSuccess, loadContext.onFailureCallback, options);

}

function register(workerMain) {
  workerMain.register("LOAD_GEOMETRY", { doOperation: doGeomLoad });
}

/***/ }),

/***/ "./src/file-loaders/workers/MainWorker.js":
/*!************************************************!*\
  !*** ./src/file-loaders/workers/MainWorker.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkerMain: () => (/* binding */ WorkerMain),
/* harmony export */   workerMain: () => (/* binding */ workerMain)
/* harmony export */ });
/* harmony import */ var _net_Xhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../net/Xhr */ "./src/file-loaders/net/Xhr.js");
/* harmony import */ var _net_endpoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../net/endpoints */ "./src/file-loaders/net/endpoints.js");



class WorkerMain {

  constructor() {
    this._workers = {};
  }
  dispatch(loadContext) {

    if (!loadContext.hasOwnProperty('operation')) {
      return;
    }

    //TODO TS:
    if (loadContext.endpoint)
    _net_endpoints__WEBPACK_IMPORTED_MODULE_1__.endpoint.setEndpointAndApi(loadContext.endpoint, loadContext.api);


    var target = this._workers[loadContext.operation];
    if (!target)
    return;

    //Initialize the path that contains the requested
    //file. It's the root for other relative paths referenced
    //by the base file.
    loadContext.basePath = "";
    if (loadContext.url) {
      var lastSlash = loadContext.url.lastIndexOf("/");
      if (lastSlash != -1)
      loadContext.basePath = loadContext.url.substr(0, lastSlash + 1);
    }

    // Create the default failure callback.
    //
    loadContext.raiseError = function () {
      loadContext.worker.raiseError.apply(loadContext.worker, arguments);
    };
    loadContext.onFailureCallback = _net_Xhr__WEBPACK_IMPORTED_MODULE_0__.ViewingService.defaultFailureCallback.bind(loadContext);

    target.doOperation(loadContext);
  }

  register(operation, worker) {
    this._workers[operation] = worker;
  }

  unregister(operation) {
    delete this._workers[operation];
  }
}

let workerMain = new WorkerMain();

//Add all the worker entry points.
//Those need to execute in order to register themselves
//with the web worker operation dispatcher
(__webpack_require__(/*! ./SvfWorker */ "./src/file-loaders/workers/SvfWorker.js").register)(workerMain);
(__webpack_require__(/*! ./GeomWorker */ "./src/file-loaders/workers/GeomWorker.js").register)(workerMain);
(__webpack_require__(/*! ./F2dParseWorker */ "./src/file-loaders/workers/F2dParseWorker.js").register)(workerMain);
(__webpack_require__(/*! ./F2dStreamWorker */ "./src/file-loaders/workers/F2dStreamWorker.js").register)(workerMain);
(__webpack_require__(/*! ./OtgBvhWorker */ "./src/file-loaders/workers/OtgBvhWorker.js").register)(workerMain);
(__webpack_require__(/*! ./OtgLoadWorker */ "./src/file-loaders/workers/OtgLoadWorker.js").register)(workerMain);
(__webpack_require__(/*! ./OtgDecodeWorker.ts */ "./src/file-loaders/workers/OtgDecodeWorker.ts").register)(workerMain);
(__webpack_require__(/*! ./PropWorker */ "./src/file-loaders/workers/PropWorker.js").register)(workerMain);
(__webpack_require__(/*! ./ConsolidationWorker */ "./src/file-loaders/workers/ConsolidationWorker.js").register)(workerMain);
(__webpack_require__(/*! ./BvhWorker */ "./src/file-loaders/workers/BvhWorker.js").register)(workerMain);

// when we request some resource from some kinds of URL
// This method will give the worker ability to support EMSCRIPTEN File Sytstem
// Or indexedDB in future
function registerFilePort(event) {
  if (event && event.protocolPortMap) {
    for (var p in event.protocolPortMap) {
      _net_Xhr__WEBPACK_IMPORTED_MODULE_0__.ViewingService.registerProtocolPort(p, event.protocolPortMap[p]);
    }
  }
}

workerMain.register("REGISTER_FILE_PORT", { doOperation: registerFilePort });

/***/ }),

/***/ "./src/file-loaders/workers/OtgBvhWorker.js":
/*!**************************************************!*\
  !*** ./src/file-loaders/workers/OtgBvhWorker.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _net_Xhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../net/Xhr */ "./src/file-loaders/net/Xhr.js");
/* harmony import */ var _wgs_scene_BVHBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../wgs/scene/BVHBuilder */ "./src/wgs/scene/BVHBuilder.js");
/* harmony import */ var _lmvtk_otg_OtgFragInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lmvtk/otg/OtgFragInfo */ "./src/file-loaders/lmvtk/otg/OtgFragInfo.js");




function loadAsyncResource(loadContext, resourcePath, responseType, callback) {

  _net_Xhr__WEBPACK_IMPORTED_MODULE_0__.ViewingService.getItem(loadContext, resourcePath,
  callback,
  loadContext.onFailureCallback,
  {
    responseType: responseType || "arraybuffer"
  }
  );

}

function doLoadOtgBvh(loadContext) {

  //TODO: We could process bboxes progressively (in the OtgFragInfo constructions) instead of doing it once the whole file is in
  //although it's probably not worth it, given we are reunning in a worker thread
  if (loadContext.fragments_extra) {
    loadAsyncResource(loadContext, loadContext.fragments_extra, "", function (data) {

      if (!data || !data.length) {
        return;
      }

      //Build the R-Tree
      //var t0 = performance.now();

      var finfo = new _lmvtk_otg_OtgFragInfo__WEBPACK_IMPORTED_MODULE_2__.OtgFragInfo(data, loadContext);

      if (finfo.count) {
        var tmpbvh = new _wgs_scene_BVHBuilder__WEBPACK_IMPORTED_MODULE_1__.BVHBuilder(null, null, finfo);
        tmpbvh.build(loadContext.bvhOptions);

        var bvh = {
          nodes: tmpbvh.nodes.getRawData(),
          primitives: tmpbvh.primitives
        };

        //var t1 = performance.now();
        //console.log("BVH build time:" + (t1 - t0));

        loadContext.worker.postMessage({ bvh: bvh, boxes: finfo.boxes, boxStride: finfo.boxStride },
        [bvh.nodes, bvh.primitives.buffer, finfo.boxes.buffer]);
      }

    });
  }


}

function register(workerMain) {
  workerMain.register("LOAD_OTG_BVH", { doOperation: doLoadOtgBvh });
}

/***/ }),

/***/ "./src/file-loaders/workers/OtgLoadWorker.js":
/*!***************************************************!*\
  !*** ./src/file-loaders/workers/OtgLoadWorker.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _net_Xhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../net/Xhr */ "./src/file-loaders/net/Xhr.js");
/* harmony import */ var _lmvtk_otg_LocalDbCache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lmvtk/otg/LocalDbCache */ "./src/file-loaders/lmvtk/otg/LocalDbCache.js");
/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fflate */ "./node_modules/fflate/esm/browser.js");
/* harmony import */ var _lmvtk_otg_OtgWebSocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lmvtk/otg/OtgWebSocket */ "./src/file-loaders/lmvtk/otg/OtgWebSocket.js");
/* harmony import */ var _lmvtk_otg_WebSocketBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lmvtk/otg/WebSocketBase */ "./src/file-loaders/lmvtk/otg/WebSocketBase.js");
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../compat */ "./src/compat.js");








// OtgLoadWorker implements the "LOAD_CDN_RESOURCE_OTG" operation.

const NUM_WEBSOCKETS = (0,_compat__WEBPACK_IMPORTED_MODULE_4__.isMobileDevice)() ? 2 : 8;
// Avoid batch requests with below this size. Should be some small percentage of OtgResourceCache._maxRequestsInFlight.
// This made no observable perf difference, but the derivative service team likes larger batches.
const SMALL_MESSAGE_THRESHOLD = 20;
// When the number of in flight requests falls below this, send small messages again,
// to avoid not sending the last SMALL_MESSAGE_THRESHOLD-1 messages for too long.
// Should be some moderate percentage of OtgResourceCache._maxRequestsInFlight.
const IN_FLIGHT_THRESHOLD_FOR_SMALL_MESSAGES = 300;

//Do not store state data directly in "self" because in the node.js code path
//there are no separate worker contexts
function getWorkerContext(loadContext) {

  //Initialize the worker context -- we cannot use module/global vars here,
  //because in node.js the module variables are shared for all instances of the worker.
  if (!loadContext.worker.ctx) {

    loadContext.worker.ctx = {

      otgws: [],
      localCache: null,

      numRequests: 0,

      pendingForNetwork: [],

      // Keeps batches of geoms to be sent to decoder threads
      _pendingGeomHashes: [],
      _pendingGeoms: [],
      _pendingFromCache: [],
      _pendingTransferList: [],

      // Track total counts to simplify debugging
      _requestsSent: 0,
      _requestsReceived: 0,

      decoderPorts: [],
      nextPortIndex: 0
    };
  }

  return loadContext.worker.ctx;
}

function doInitGeomWorker(loadContext) {
  var ctx = getWorkerContext(loadContext);

  if (!loadContext.disableWebSocket) {
    const onResourcesReceived = (hashes, arrays, resourceType) => onCdnResourcesReceived(hashes, arrays, loadContext, false, resourceType);
    const onResourceFailed = (hash, resourceType, errorMessage) => onCdnResourceFailed(loadContext, hash, resourceType, errorMessage);
    const onConnectionFailed = (inprogress) => retryPending(loadContext, inprogress);
    for (let i = 0; i < NUM_WEBSOCKETS; i++) {
      ctx.otgws.push(new _lmvtk_otg_OtgWebSocket__WEBPACK_IMPORTED_MODULE_2__.OtgWs(loadContext.otg_ws, loadContext.queryParams, loadContext.headers, onResourcesReceived, onResourceFailed, onConnectionFailed));
    }
  }

  ctx.localCache = new _lmvtk_otg_LocalDbCache__WEBPACK_IMPORTED_MODULE_1__.LocalDbCache(loadContext.disableIndexedDb, loadContext.isInlineWorker);
  ctx.localCache.open(null);

  ctx.decoderPorts = loadContext.ports;
}

function doAddModel(loadContext) {
  var ctx = getWorkerContext(loadContext);
  for (const ws of ctx.otgws) {
    ws.addAuthorizeUrn(loadContext.modelUrn);
  }

  if (!ctx.flushMessages) {
    ctx.flushMessages = setInterval(() => {
      _loadCdnResourceFromNetworkBatch(loadContext);
      flushMessagesToDecoderThread(loadContext);
    }, 25);
  }
}

// Use custom error handler: It  forwards to the default one, but...
//  1. adds the geometry hash to the error message. This is needed by the geometry cache.
//     We use it to determine for which geometry the problem occurred, so that the affected
//     loaders can be informed (see OtgResourceCache.js).
//  2. If any other requests were blocked before to limit the number of parallel
//     requests, we must make sure that these enqueued requests are processed too.
function getHttpErrorHandler(loadContext, hash, resourceType) {

  // add error handler to override raiseError function
  var errorHandler = {
    // add hash and pass on to loadContext.raiseError.
    raiseError: function (code, msg, args) {
      args.hash = hash;
      args.resourceType = resourceType;
      loadContext.raiseError(code, msg, args);
    }
  };

  return function () {
    // forward to default error handler
    _net_Xhr__WEBPACK_IMPORTED_MODULE_0__.ViewingService.defaultFailureCallback.apply(errorHandler, arguments);

    onCdnResourceProcessed(loadContext, hash);
  };
}

function onCdnResourceFailed(loadContext, hash, resourceType, errorMessage) {
  loadContext.raiseError(null, errorMessage, { hash: hash, resourceType: resourceType });
  onCdnResourceProcessed(loadContext, hash);
}

function retryPending(loadContext, inprogress) {
  for (const [hash, value] of inprogress) {
    loadContext.queryParams = value.queryParams;
    loadCdnResource(value.url, hash, loadContext, value.type);
  }
}

function isGzip(data) {
  return data[0] === 31 && data[1] === 139;
}

function onCdnResourcesReceived(hashes, arrays, loadContext, skipCache, resourceType) {
  const ctx = getWorkerContext(loadContext);

  if (!skipCache) {
    for (let i = 0; i < hashes.length; i++) {
      const hash = hashes[i];
      let data = arrays[i];
      // If the HTTP fallback was used, the browser already did the decompression
      // Also, we did encounter uncompressed blobs in production.
      if (!isGzip(data)) {
        data = (0,fflate__WEBPACK_IMPORTED_MODULE_5__.gzipSync)(data);
      }
      ctx.localCache.store(hash, data);
    }
  }

  if (resourceType === "m") {
    //Post materials as soon as possible without batching -- those are fewer
    //and more critical as they are shared across multiple meshes.
    const port = ctx.decoderPorts[ctx.nextPortIndex];
    ctx.nextPortIndex = ++ctx.nextPortIndex % ctx.decoderPorts.length;
    port.postMessage({
      operation: "DECODE_MATERIALS",
      hashes: hashes,
      arrays: arrays
    }, [arrays[0].buffer]);
  } else {
    // Each message has a bit of overhead, both when sending and receiving,
    // and both in the decoder thread and the main thread afterwards.
    // Therefore we batch here, even though it introduces a bit of latency.
    // Ideally, cache and websockets would always return batches, then we could remove this.
    for (let i = 0; i < hashes.length; i++) {
      const hash = hashes[i];
      const data = arrays[i];
      ctx._pendingGeomHashes.push(hash);
      ctx._pendingGeoms.push(data);
      ctx._pendingFromCache.push(skipCache);
      if (i === 0 || data.buffer !== arrays[0].buffer) {
        ctx._pendingTransferList.push(data.buffer);
      }
    }
  }
  for (const hash of hashes) {
    onCdnResourceProcessed(loadContext, hash);
  }
}

// Sends recently received (since last flush) resources to the decoders
function flushMessagesToDecoderThread(loadContext) {

  var ctx = getWorkerContext(loadContext);

  if (!ctx._pendingGeomHashes.length)
  return;

  const port = ctx.decoderPorts[ctx.nextPortIndex];
  ctx.nextPortIndex = ++ctx.nextPortIndex % ctx.decoderPorts.length;
  port.postMessage({
    operation: "DECODE_GEOMETRIES",
    hashes: ctx._pendingGeomHashes,
    arrays: ctx._pendingGeoms,
    fromCache: ctx._pendingFromCache
  }, ctx._pendingTransferList);

  ctx._pendingGeomHashes = [];
  ctx._pendingGeoms = [];
  ctx._pendingFromCache = [];
  ctx._pendingTransferList = [];
}

function onCdnResourceProcessed(loadContext, hash) {
  const ctx = getWorkerContext(loadContext);

  ctx.numRequests--;
  ctx._requestsReceived++;
}

// Request raw geometry data (arraybuffer) and forward result to onCdnResourcesReceived once it is available
//  @param {String}   url - url of the network resource
//  @param {String}   hash - hash of the resource
//  @param {Object}   loadContext - passed through to the receiving callback
//  @param {String}   resourceType - "m" for material and "g" for geometry
//  @param {Boolean}  couldBeInCache - false if it can't be in the cache (i.e., skip the cache and directly load from the network)
//                                     if true and not in cache, the data is still requested from the network
function loadCdnResource(url, hash, loadContext, resourceType, couldBeInCache) {

  var ctx = getWorkerContext(loadContext);

  ctx._requestsSent++;

  if (couldBeInCache) {
    //Make sure the IndexedDb session is started before we ask to get() anything.
    //This is done by a call to open, which will call us back immediately, or delay until
    //the database is open.
    ctx.localCache.open(() => ctx.localCache.get(hash, function (error, data) {
      if (data) {
        onCdnResourcesReceived([hash], [data], loadContext, true, resourceType);
      } else {
        ctx.pendingForNetwork.push([hash, url, resourceType, loadContext.queryParams]);
      }
    }));
  } else {
    ctx.pendingForNetwork.push([hash, url, resourceType, loadContext.queryParams]);
  }
}


function _loadCdnResourceFromNetworkBatch(loadContext) {
  var ctx = getWorkerContext(loadContext);

  if (ctx.pendingForNetwork.length === 0) {
    return;
  }

  // Only fill the queue of open WS. Non-open WS might take a few seconds to open: 
  // Chrome and Firefox throttle opening WS to one per ~500ms, so the eighth WS would open only after 3.5s.
  // Also, the WS might currently be attempting to recover from an error.
  let openWS = [];
  let numNonbrokenWs = 0;
  let totalInFlightRequests = 0;
  for (const ws of ctx.otgws) {var _ws$ws;
    if (!ws.hasPermanentError) {
      numNonbrokenWs++;
    }
    if (((_ws$ws = ws.ws) === null || _ws$ws === void 0 ? void 0 : _ws$ws.readyState) === _lmvtk_otg_WebSocketBase__WEBPACK_IMPORTED_MODULE_3__.STATE.OPEN) {
      openWS.push(ws);
      totalInFlightRequests += ws.inFlightRequests.size;
    } else {
      // Reasons they might need opening: 1. WS was just initialized 2. WS was closed due to model/view changing 3. server closed it due to e.g. timeout
      ws._openWebSocket();
    }
  }

  if (numNonbrokenWs === 0) {
    //Fallback to XHR/HTTP2
    for (const [hash, url, resourceType, queryParams] of ctx.pendingForNetwork) {
      loadContext.queryParams = queryParams;
      _net_Xhr__WEBPACK_IMPORTED_MODULE_0__.ViewingService.getItem(
        loadContext,
        url,
        (data) => onCdnResourcesReceived([hash], [data], loadContext, false, resourceType),
        getHttpErrorHandler(loadContext, hash, resourceType),
        {
          responseType: "arraybuffer",
          withCredentials: true
        }
      );
    }
    ctx.pendingForNetwork = [];
    return;
  }

  if (openWS.length <= 0) {
    return;
  }

  const wsSortedByLoad = openWS.sort((a, b) => a.inFlightRequests.size - b.inFlightRequests.size);

  // Do load balancing among WS: every request should go to the WS which is currently least busy.
  // In other words, the minimum of the WS's inFlightRequests.size should be as high as possible,
  // otherwise that would mean that some WS are underutilized.
  // To achieve that, starting with the least busy WS, we raise the targeted requests in flight
  // so that after iteration n, the n least busy WS are utilized equally, until all incoming requests are distributed.
  let requestsToDistribute = ctx.pendingForNetwork.length;
  let targetRequestsInFlight = wsSortedByLoad[0].inFlightRequests.size;
  for (let i = 1; i < wsSortedByLoad.length; i++) {
    const raiseTargetBy = wsSortedByLoad[i].inFlightRequests.size - targetRequestsInFlight;
    requestsToDistribute -= raiseTargetBy * i;
    targetRequestsInFlight += raiseTargetBy;
    if (requestsToDistribute <= 0) {
      wsSortedByLoad.length = i; // cut out WS that we won't use anyway
      break;
    }
  }

  // If there are more requests left, distribute them equally across all WS,
  // or if targetRequestsInFlight got too high (i.e. if requestsToDistribute < 0), trim it down.
  targetRequestsInFlight += Math.ceil(requestsToDistribute / wsSortedByLoad.length);

  // If there are some WS not-yet-open, keep work in the queue for them and not overload the open ones
  const totalRequests = totalInFlightRequests + ctx.pendingForNetwork.length;
  targetRequestsInFlight = Math.min(targetRequestsInFlight, Math.ceil(totalRequests / numNonbrokenWs));

  for (let i = wsSortedByLoad.length - 1; i >= 0; i--) {
    const ws = wsSortedByLoad[i];
    const numHashesToSend = targetRequestsInFlight - ws.inFlightRequests.size;

    if (numHashesToSend < SMALL_MESSAGE_THRESHOLD && !(i == 0 && totalRequests < IN_FLIGHT_THRESHOLD_FOR_SMALL_MESSAGES)) {
      // Message is too small, distribute it to the other WS
      targetRequestsInFlight += Math.ceil(numHashesToSend / i);
      continue;
    }
    for (const [hash, url, resourceType, queryParams] of ctx.pendingForNetwork.splice(0, numHashesToSend)) {
      ws.requestResource(url, hash, resourceType, queryParams);
    }
    ws._flushSendQueue();
  }
}

// @param {string[]}   loadContext.urls            - request urls
// @param {string[]}   loadContext.hashes          - content hashes corresponding to each request URL
// @param {function} loadContext.onFailureCallback - defined in workerMain()
// @param {Worker}   loadContext.worker            - defined in MainWorker.worker
function doCdnResourceLoad(loadContext) {
  var ctx = getWorkerContext(loadContext);

  for (let i = 0; i < loadContext.urls.length; i++) {
    loadCdnResource(loadContext.urls[i], loadContext.hashes[i], loadContext, loadContext.type, loadContext.couldBeInCache[i]);
    ctx.numRequests++;
  }
}

function doFlushCacheAndDisconnect(loadContext) {

  var ctx = getWorkerContext(loadContext);

  if (ctx.numRequests || ctx._pendingGeomHashes.length) {
    console.error("OtgLoadWorker disconnect requested even though there are requests in flight");
    flushMessagesToDecoderThread(loadContext);
  }

  for (const ws of ctx.otgws) {
    ws.closeWebSocket();
  }

  clearInterval(ctx.flushMessages);
  ctx.flushMessages = null;

  if (ctx.localCache) {
    ctx.localCache.open(() => ctx.localCache.flushStoresAndTimestamps());
  }
}

// Helper task to faciliate console debugging.
// How to use:
//  If OTG loading gets stuck, call NOP_VIEWER.impl.geomCache().reportLoadingState()
function doReportLoadingState(loadContext) {

  var ctx = getWorkerContext(loadContext);

  // Uncomment to debug a worker that got stuck:
  // const pending = ctx._requestsSent - ctx._requestsReceived;
  // if (pending) {
  //     debugger;
  // }

  const loadingState = {
    // Total number of send/receive (also indexDB etc)
    sent: ctx._requestsSent,
    received: ctx._requestsReceived,

    // Actual websocket sends/receives
    wsSent: ctx.otgws.map((ws) => ws.numRequestsSent),
    wsReceived: ctx.otgws.map((ws) => ws.numRequestsReceived)
  };
  console.log('WorkerState: ', loadingState);
}

function register(workerMain) {
  workerMain.register("INIT_WORKER_OTG", { doOperation: doInitGeomWorker });
  workerMain.register("ADD_MODEL_OTG", { doOperation: doAddModel });
  workerMain.register("LOAD_CDN_RESOURCE_OTG", { doOperation: doCdnResourceLoad });
  workerMain.register("FLUSH_CACHE_AND_DISCONNECT_OTG", { doOperation: doFlushCacheAndDisconnect });
  workerMain.register("REPORT_LOADING_STATE", { doOperation: doReportLoadingState });
}

/***/ }),

/***/ "./src/file-loaders/workers/PropWorker.js":
/*!************************************************!*\
  !*** ./src/file-loaders/workers/PropWorker.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _net_Xhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../net/Xhr */ "./src/file-loaders/net/Xhr.js");
/* harmony import */ var _lmvtk_common_Propdb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lmvtk/common/Propdb */ "./src/file-loaders/lmvtk/common/Propdb.js");
/* harmony import */ var _wgs_scene_InstanceTreeStorage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../wgs/scene/InstanceTreeStorage */ "./src/wgs/scene/InstanceTreeStorage.js");







function PdbCacheEntry(dbPath, isShared) {
  this.pdb = null;
  this.waitingCallbacks = [];
  this.error = false;
  this.dbPath = dbPath;
  this.dbFiles = null;
  this.isShared = isShared;
  this.timestamp = Date.now();
}

function FileCacheEntry(data) {
  this.data = data;
  this.refCount = 1;
}

class PdbCache {

  constructor() {
    this.pdbCache = {};
    this.fileCache = {};
  }

  get(dbPath) {
    let cacheEntry = this.pdbCache[dbPath];

    if (cacheEntry) {
      cacheEntry.timestamp = Date.now();
    }

    return cacheEntry;
  }

  set(dbPath, isShared) {
    let cacheEntry = new PdbCacheEntry(dbPath, isShared);
    this.pdbCache[dbPath] = cacheEntry;
    return cacheEntry;
  }

  getFile(path) {
    let cacheEntry = this.fileCache[path];

    if (cacheEntry) {
      cacheEntry.timestamp = Date.now();
    }

    return cacheEntry;
  }

  setFile(path, data) {
    this.fileCache[path] = new FileCacheEntry(data);
  }

  delete(dbPath) {
    var cacheEntry = this.get(dbPath);

    if (cacheEntry && cacheEntry.pdb)
    cacheEntry.pdb.refCount--;else

    return;

    if (cacheEntry.pdb.refCount === 0) {

      //TODO: erase the entry even if db is shared once it's no longer used?
      //The db files are still cached anyway.
      if (!cacheEntry.isShared) {
        delete this.pdbCache[dbPath];
      }

      if (!cacheEntry.isShared) {
        //Also erase any per-file cache, unless the file is shared across multiple property databases
        for (var fileName in cacheEntry.dbFiles) {
          var file = cacheEntry.dbFiles[fileName];
          this.unrefFileCacheEntry(file.storage);
        }
      }
    }
  }

  // Releases a fileCache entry reference if a file is not used anymore.
  //   @param {Object} storage - contains the full file path as (only) key
  unrefFileCacheEntry(storage) {

    // key is the full file path
    for (var key in storage) {
      var fileCacheEntry = this.fileCache[key];
      if (fileCacheEntry) {
        fileCacheEntry.refCount--;
        if (fileCacheEntry.refCount === 0)
        delete this.fileCache[key];
      }
    }
  }
}


function loadPropertyPacks(loadContext, dbId, onPropertyPackLoadComplete) {

  let _this = loadContext.worker;
  let pdbCache = _this.pdbCache;

  if (!pdbCache) {
    _this.pdbCache = pdbCache = new PdbCache();
  }

  //get the cache entry for the given property database URL
  var cacheEntry = pdbCache.get(loadContext.dbPath);
  var repeatedCall = false;
  if (!cacheEntry) {
    cacheEntry = pdbCache.set(loadContext.dbPath, !!loadContext.sharedDbPath);
  } else {
    repeatedCall = true;
  }

  if (cacheEntry.pdb) {
    onPropertyPackLoadComplete(cacheEntry.pdb, cacheEntry.dbidOldToNew);
    return;
  } else if (!cacheEntry.error) {
    //If we are already loading the same property database, queue the callback
    if (repeatedCall) {
      cacheEntry.waitingCallbacks.push(onPropertyPackLoadComplete);
      return;
    }
  } else {
    onPropertyPackLoadComplete(null);
    return;
  }

  var dbfiles = loadContext.propertydb;
  if (!dbfiles) {
    _this.propdbFailed = true;
    onPropertyPackLoadComplete(null);
    return;
  }

  var loadedDbFiles = {};
  var filesToRequest = [];

  if (dbfiles.avs.length) {

    for (var tag in dbfiles) {
      // Skip loading of externalId table if wanted
      if (loadContext.skipExternalIds && tag == 'ids') {
        continue;
      }

      loadedDbFiles[tag] = {};
      filesToRequest.push({ filename: dbfiles[tag][0].path, isShared: dbfiles[tag][0].isShared, storage: loadedDbFiles[tag] });
    }

  } else {

    //Hardcoded list of pdb files -- deprecated, still used when loading F2D files locally, without
    //having loaded a manifest first. And probably in some other cases.

    loadedDbFiles = {
      ids: {},
      attrs: {},
      offsets: {},
      values: {},
      avs: {}
    };

    filesToRequest.push({ filename: dbfiles.attrs.length ? dbfiles.attrs[0] : "objects_attrs.json.gz", storage: loadedDbFiles.attrs });
    filesToRequest.push({ filename: dbfiles.values.length ? dbfiles.values[0] : "objects_vals.json.gz", storage: loadedDbFiles.values });
    filesToRequest.push({ filename: dbfiles.avs.length ? dbfiles.avs[0] : "objects_avs.json.gz", storage: loadedDbFiles.avs });
    filesToRequest.push({ filename: dbfiles.offsets.length ? dbfiles.offsets[0] : "objects_offs.json.gz", storage: loadedDbFiles.offsets });

    // Loading the externalId table is optional
    if (!loadContext.skipExternalIds) {
      filesToRequest.push({ filename: dbfiles.ids.length ? dbfiles.ids[0] : "objects_ids.json.gz", storage: loadedDbFiles.ids });
    }
  }

  var filesRemaining = filesToRequest.length;
  var filesFailed = 0;

  function onRequestCompletion(data) {

    filesRemaining--;

    // Rough estimate for progress. Although we just count received files here,
    // it already helps to signficantly reduce the perceived "nothing happens" time periods.
    //
    // Tracking the progress of single requests would be more accurate, but:
    //  - Attaching an onprogress handler to XHR would cause it to consume 2-3x more memory,
    //    because it has to receive the data as text and then convert to array buffer on the fly.
    //  - Due to the content encoding, the progress callbacks wouldn't know the file size, but only
    //    the amount of transferred data, so that they wouldn't help much.
    _this.postMessage({
      cbId: loadContext.cbId,
      progress: {
        // Having all files loaded doesn't mean we are fully done. Reserve 5 percent for the rest.
        percent: 95 * (filesToRequest.length - filesRemaining) / filesToRequest.length
      }
    });

    if (!data)
    filesFailed++;

    // If all of the files we've requested have been retrieved, create the
    // property database.  Otherwise, request the next required file.
    //
    if (!filesRemaining) {
      if (filesFailed) {
        cacheEntry.error = true;
        onPropertyPackLoadComplete(null);
        while (cacheEntry.waitingCallbacks.length) {
          cacheEntry.waitingCallbacks.shift()(null);
        }
      } else {

        //De-reference the result buffer from this array so that
        //it can be freed on the fly when the PropertyDatabases parses itself
        filesToRequest.forEach(function (f) {
          f.storage = null;
        });

        //Store the property db instance in its cache entry
        try {
          cacheEntry.pdb = new _lmvtk_common_Propdb__WEBPACK_IMPORTED_MODULE_1__.PropertyDatabase(loadedDbFiles);
          cacheEntry.pdb.refCount = 0; //will be incremented by the success callback
          cacheEntry.loaded = true;
          cacheEntry.dbFiles = filesToRequest;

          cacheEntry.timestamp = Date.now();

          //TODO: revise this to use the pdb.byteSize() call once it's merged in.
          cacheEntry.byteSize = 0;
          for (let f in loadedDbFiles) {
            for (let p in loadedDbFiles[f]) {
              let fdata = loadedDbFiles[f][p];
              cacheEntry.byteSize += fdata && fdata.byteLength;
            }
          }

          for (let p in loadedDbFiles.dbid) {
            var b = loadedDbFiles.dbid[p];
            cacheEntry.dbidOldToNew = new Int32Array(b.buffer, b.byteOffset, b.byteLength / 4);
            break;
          }

          onPropertyPackLoadComplete(cacheEntry.pdb, cacheEntry.dbidOldToNew);

          while (cacheEntry.waitingCallbacks.length) {
            cacheEntry.waitingCallbacks.shift()(cacheEntry.pdb, cacheEntry.dbidOldToNew);
          }
        }
        catch (err) {
          onPropertyPackLoadComplete(null, null, err && err.message);
        }
      }
    }
  }
  // Request the files.
  //
  filesToRequest.forEach(function (f) {
    requestFile(f.filename, loadContext, onRequestCompletion, f.storage, f.isShared);
  });
}


function requestFile(filename, loadContext, onRequestCompletion, storage, isShared) {

  function onFailure(status, statusText, data) {
    // We're explicitly ignoring missing property files.
    if (status !== 404) {
      loadContext.onFailureCallback(status, statusText, data);
    }
    onRequestCompletion(null);
  }

  var url;
  if (filename.indexOf("://") !== -1 || filename.indexOf("urn:") === 0) {
    url = filename;
  } else {
    url = (loadContext.dbPath || '') + filename;
  }

  var fullPath = _net_Xhr__WEBPACK_IMPORTED_MODULE_0__.ViewingService.generateUrl(loadContext.endpoint, "items", url);

  var onSuccess = function (response)
  {
    //Cache for future reuse
    if (isShared) {
      loadContext.worker.pdbCache && loadContext.worker.pdbCache.setFile(fullPath, response);
    }

    storage[fullPath] = response;
    onRequestCompletion(response);
  };

  //Fulfill the request from cache if available
  var cacheEntry = loadContext.worker.pdbCache && loadContext.worker.pdbCache.getFile(fullPath);
  if (cacheEntry) {
    cacheEntry.refCount++;
    onSuccess(cacheEntry.data);
  } else {
    _net_Xhr__WEBPACK_IMPORTED_MODULE_0__.ViewingService.getItem(loadContext, url, onSuccess, onFailure);
  }

}

function createTree(node, parent, dbToFrag, nodeStorage) {
  var dbId = node.dbId;
  var children = node.children;
  var childrenIds = [];
  if (children) {
    for (var j = 0; j < children.length; j++) {
      var childHasChildren = createTree(children[j], dbId, dbToFrag, nodeStorage);

      if (childHasChildren)
      childrenIds.push(children[j].dbId);
    }
  }

  var fragIds;

  //leaf node
  if (dbToFrag) {
    var frags = dbToFrag[dbId];
    if (frags !== undefined) {
      if (!Array.isArray(frags))
      fragIds = [frags];else

      fragIds = frags;
    }
  }

  var childCount = childrenIds.length + (fragIds ? fragIds.length : 0);
  if (childCount) {
    nodeStorage.setNode(dbId, parent, node.name.toString(), 0, childrenIds, fragIds);
  }
  return childCount;
}

function doObjectTreeCreate(loadContext) {
  var _this = loadContext.worker;
  var gltfTree = loadContext.gltfTree;
  var dbToFragId = loadContext.dbToFragId;
  var nodeStorage = new _wgs_scene_InstanceTreeStorage__WEBPACK_IMPORTED_MODULE_2__.InstanceTreeStorage();

  createTree(gltfTree, 0, dbToFragId, nodeStorage);
  nodeStorage.flatten();

  _this.postMessage({ cbId: loadContext.cbId,
    result: {
      rootId: gltfTree.dbId,
      instanceTreeStorage: nodeStorage
    }
  });
}

function doObjectTreeParse(loadContext) {

  var _this = loadContext.worker;

  function onPropertyPackLoadComplete(propertyDb, dbidOldToNew, errorMessage) {
    if (!propertyDb) {
      _this.postMessage({
        cbId: loadContext.cbId,
        error: { instanceTree: null, maxTreeDepth: 0, err: errorMessage }
      });
      return;
    }

    propertyDb.refCount++;

    //Find the root object:
    //TODO: internalize this into the pdb object.
    if (!loadContext.skipInstanceTreeResult && !propertyDb.rootsDone) {
      propertyDb.idroots = propertyDb.findRootNodes();
      propertyDb.rootsDone = true;
    }

    var rootId;
    var maxDepth = [0];

    var transferList = [];
    var storage;
    let nodeAccess = null;

    var fragToDbId = loadContext.fragToDbId;

    // Only need to rebuild fragToDbId using the old IDs in F2D case.
    if (loadContext.needsDbIdRemap && loadContext.is2d) {
      if (!dbidOldToNew) {
        console.warn("ID remap required, but not loaded.");
      } else if (!fragToDbId) {
        console.warn("No frag->dbid mapping!.");
      } else {

        //Replace the frag2dbid mapping by a new one using the
        //correct property db v2 ids.
        var old2new = dbidOldToNew;
        var fr2id = [];

        for (var i = 0; i < fragToDbId.length; i++) {

          var d = fragToDbId[i];

          if (!Array.isArray(d)) {
            fr2id[i] = old2new[d];
          } else {
            fr2id[i] = [];
            for (var j = 0; j < d.length; j++) {
              fr2id[i][j] = old2new[d[j]];
            }
          }
        }

        fragToDbId = fr2id;
      }
    }

    //In the cases of 2D drawings, there is no meaningful
    //object hierarchy, so we don't build a tree.
    var idroots = propertyDb.idroots;
    if (idroots && idroots.length)
    {
      storage = new _wgs_scene_InstanceTreeStorage__WEBPACK_IMPORTED_MODULE_2__.InstanceTreeStorage();

      if (idroots.length == 1 && propertyDb.nodeHasChild(idroots[0])) {
        //Case of a single root in the property database,
        //use that as the document root.
        rootId = idroots[0];
        propertyDb.buildObjectTree(rootId, fragToDbId, maxDepth, storage);
      } else
      {
        //Case of multiple nodes at the root level
        //This happens in DWFs coming from Revit.
        //Create a dummy root and add all the other roots
        //as its children.
        rootId = -1e10; // Big negative number to prevent conflicts with F2D
        var childrenIds = [];

        for (var i = 0; i < idroots.length; i++) {
          propertyDb.buildObjectTree(idroots[i], fragToDbId, maxDepth, storage);
          childrenIds.push(idroots[i]);
        }

        storage.setNode(rootId, 0, "", 0, childrenIds, false);
      }

      storage.flatten();
      transferList.push(storage.nodes.buffer);
      transferList.push(storage.children.buffer);
      transferList.push(storage.strings.buf.buffer);
      transferList.push(storage.strings.idx.buffer);


      //Now compute the bounding boxes for instance tree nodes
      if (loadContext.fragBoxes) {
        nodeAccess = new _wgs_scene_InstanceTreeStorage__WEBPACK_IMPORTED_MODULE_2__.InstanceTreeAccess(storage, rootId);
        nodeAccess.computeBoxes(loadContext.fragBoxes);
        transferList.push(nodeAccess.nodeBoxes.buffer);
      }
    }

    _this.postMessage({ cbId: loadContext.cbId,
      result: {
        rootId: rootId,
        instanceTreeStorage: storage,
        instanceBoxes: !!nodeAccess ? nodeAccess.nodeBoxes : undefined,
        dbidOldToNew: loadContext.needsDbIdRemap ? dbidOldToNew : null, //If we have a dbId mapping (from new OTG dbIds to old F2D dbIds send it to the main thread.
        maxTreeDepth: maxDepth[0],
        objectCount: propertyDb.getObjectCount()
      }
    }, transferList);
  }

  loadPropertyPacks(loadContext, null, onPropertyPackLoadComplete);
}

function doPropertySearch(loadContext) {

  var _this = loadContext.worker;

  var cacheEntry = _this.pdbCache && _this.pdbCache.get(loadContext.dbPath);

  if (cacheEntry && cacheEntry.pdb) {
    const searchText = loadContext.searchText;
    var result = cacheEntry.pdb.bruteForceSearch(searchText, loadContext.attributeNames, loadContext.searchOptions);
    _this.postMessage({ cbId: loadContext.cbId, result: result });
  }

}

function doPropertyDiff(loadContext) {

  var _this = loadContext.worker;

  // get property dbs to compare
  var cacheEntry1 = _this.pdbCache && _this.pdbCache.get(loadContext.dbPath);
  var cacheEntry2 = _this.pdbCache && _this.pdbCache.get(loadContext.dbPath2);
  var pdb1 = cacheEntry1 && cacheEntry1.pdb;
  var pdb2 = cacheEntry2 && cacheEntry2.pdb;

  // send messages for progress events to main thread
  var onProgress = function (percent) {
    loadContext.worker.postMessage({
      cbId: loadContext.cbId,
      progress: { percent: percent }
    });
  };

  if (pdb1 && pdb2) {
    var result = pdb1.findDifferences(pdb2, loadContext.diffOptions, onProgress);
    _this.postMessage({ cbId: loadContext.cbId, result: result });
  }
}

function doPropertyFind(loadContext) {

  var _this = loadContext.worker;

  var cacheEntry = _this.pdbCache && _this.pdbCache.get(loadContext.dbPath);

  if (cacheEntry && cacheEntry.pdb) {
    var result = cacheEntry.pdb.bruteForceFind(loadContext.propertyName);
    _this.postMessage({ cbId: loadContext.cbId, result: result });
  }

}

function doLayersFind(loadContext) {
  var _this = loadContext.worker;

  var cacheEntry = _this.pdbCache && _this.pdbCache.get(loadContext.dbPath);

  if (cacheEntry && cacheEntry.pdb) {
    var result = cacheEntry.pdb.findLayers();
    _this.postMessage({ cbId: loadContext.cbId, result: result });
  }
}

function searchTree(node, dbId, result) {
  if (Object.keys(result).length > 0) {
    return;
  }

  if (dbId == node.dbId) {
    result['name'] = node.name;
    result['dbId'] = dbId;
    return;
  }

  var children = node.children;
  if (children) {
    for (var j = 0; j < children.length; j++) {
      searchTree(children[j], dbId, result);
    }
  }
}

function getPropertyResults(loadContext) {
  var _this = loadContext.worker;

  var cacheEntry = _this.pdbCache && _this.pdbCache.get(loadContext.dbPath);

  if (!cacheEntry || !cacheEntry.pdb) {
    if (loadContext.gltfTree) {
      var gltfTree = loadContext.gltfTree;
      var result = {};
      searchTree(gltfTree, loadContext.dbId, result);
      return result;
    }
    return;
  }

  var dbId = loadContext.dbId;
  var dbIds = loadContext.dbIds;
  var propFilter = loadContext.propFilter;
  var ignoreHidden = loadContext.ignoreHidden;
  var categoryFilter = loadContext.categoryFilter;
  const fileType = loadContext.fileType;

  if (typeof dbIds !== "undefined") {
    var results = [];
    if (dbIds && dbIds.length) {
      for (var i = 0; i < dbIds.length; i++) {
        var result = cacheEntry.pdb.getObjectProperties(dbIds[i], propFilter, ignoreHidden, undefined, categoryFilter);
        if (result)
        results.push(result);
      }
    } else {//If dbIds is empty, return results for all objects (i.e. no ID filter)
      for (var i = 1, last = cacheEntry.pdb.getObjectCount(); i <= last; i++) {
        var result = cacheEntry.pdb.getObjectProperties(i, propFilter, ignoreHidden, undefined, categoryFilter);
        if (result)
        results.push(result);
      }
    }
    return results;
  } else {
    var result = cacheEntry.pdb.getObjectProperties(dbId, propFilter, undefined, undefined, categoryFilter);
    return result;
  }
}

function doPropertyGet(loadContext) {
  var results = getPropertyResults(loadContext);
  if (!results) {
    loadContext.worker.postMessage({ cbId: loadContext.cbId, error: { msg: "Properties are not available." } });
  } else {
    loadContext.worker.postMessage({ cbId: loadContext.cbId, result: results });
  }
}

function doPropertySetGet(loadContext) {
  var results = getPropertyResults(loadContext);
  if (!results) {
    loadContext.worker.postMessage({ cbId: loadContext.cbId, error: { msg: "Properties are not available." } });
  }

  var map = {};
  var names = [];

  // Process the results and generate a map.
  // The map's keys are "displayCategory/displayName" and the map's values are all of the properties containing the same name and category.
  for (var i = 0; i < results.length; ++i) {
    var result = results[i];
    const props = result.properties;

    // Not every document type has a proper externalId
    // We will handle only RVT which has translatable from Hex to Decimal value
    if (loadContext.fileType === 'rvt') {
      try {
        let elementId;

        // Check if the properties include an element ID already
        const elementIdProperty = props.find((each) => each.attributeName === "ElementId");

        if (elementIdProperty) {
          elementId = elementIdProperty.displayValue;
        }

        // Or fall back and generate it from the external ID, if the external ID is present
        if (result.externalId && !elementId) {
          const externalIdSplit = result.externalId.split('-');

          if (externalIdSplit.length) {
            elementId = parseInt(externalIdSplit[externalIdSplit.length - 1], 16);
          }
        }

        // since in this context we don't know either model OTG/SVF, we will add elementId only if name isn't already included
        if (elementId && !result.name.includes(elementId)) {
          result.name += ` [${elementId}]`;
        }
      } catch (e) {
        // We don't want failures to generate ElementId to fail the whole PropertySet process.
        console.warn(`Caught error in updating ElementIds, object with dbId ${result.dbId} skipped`, e);
      }
    }

    props.forEach(function (prop) {
      // The category is always present for revit but not fusion.
      // Make sure to add a Name key to the property set map.
      if (prop.displayName === 'Name' && !prop.displayCategory) {
        // Keep track of the Name entries.
        names.push(result.name);
      }

      var identifier = !prop.displayCategory ? prop.displayName : `${prop.displayCategory}/${prop.displayName}`;
      if (!map.hasOwnProperty(identifier)) {
        map[identifier] = [];
      }
      prop.parentName = result.name;
      prop.dbId = result.dbId;
      map[identifier].push(prop);
    });

    // Add a Name key to the property set map.
    if (result.hasOwnProperty('name') && names.indexOf(result.name) === -1) {
      if (!map.hasOwnProperty('Name')) {
        map['Name'] = [];
      }

      map['Name'].push({
        displayName: 'Name',
        displayValue: result.name,
        displayCategory: null,
        attributeName: 'Name',
        type: 20,
        units: null,
        hidden: false,
        precision: 0,
        dbId: result.dbId,
        parentName: result.name
      });
    }
  }
  names = [];
  map["__selected_dbIds__"] = loadContext.dbIds;
  loadContext.worker.postMessage({ cbId: loadContext.cbId, result: map });
}


function doBuildExternalIdMapping(loadContext) {

  var _this = loadContext.worker;

  var cacheEntry = _this.pdbCache && _this.pdbCache.get(loadContext.dbPath);

  if (cacheEntry && cacheEntry.pdb) {
    var mapping = cacheEntry.pdb.getExternalIdMapping(loadContext.extIdFilter);
    _this.postMessage({ cbId: loadContext.cbId, result: mapping });
  }
}

function doBuildLayerToNodeIdMapping(loadContext) {
  var _this = loadContext.worker;

  var cacheEntry = _this.pdbCache && _this.pdbCache.get(loadContext.dbPath);

  if (cacheEntry && cacheEntry.pdb) {
    var mapping = cacheEntry.pdb.getLayerToNodeIdMapping();
    _this.postMessage({ cbId: loadContext.cbId, result: mapping });
  }
}

function doUnloadPropertyDb(loadContext) {
  var _this = loadContext.worker;

  if (loadContext.clearCaches) {
    _this.pdbCache = null;
    return;
  }

  _this.pdbCache && _this.pdbCache.delete(loadContext.dbPath);
}

// Required params
//  @param {string} loadContext.dbPath
//  @param {string} loadContext.idsFile - filename of the ids-file
//  @param {string} loadContext.cbId    - worker callback id
//  @param {Object} loadContext.worker  - global worker context
//
// Preconditions:
//  - PropDbLoader makes sure that this task is not called before propDb finished loading. (see asyncPropertyOperation in PropDblLoader)
function doLoadExternalIds(loadContext) {

  var _this = loadContext.worker;

  // Deprecated case: If pdbFiles are not known use hard-wired one (see comment in loadPropertyPacks)
  var idsFileEntry = loadContext.idsFile || { path: "objects_ids.json.gz" };

  // After loading, storage[fullPath] will contain the response blob.
  var storage = {};

  // Purpose of doLoadExternalIds is to delay-load the ids for a PropDb.
  // If this propDb is not loaded and not even requested to load, we cannot add externalIds to it.
  var cacheEntry = _this.pdbCache.get(loadContext.dbPath);
  if (!cacheEntry) {
    console.error('Delay-loading of externalIDs requires to load the propDb first.');
    return;
  }

  // Skip here if we have the ids already. Note that this will usually be prevented by propDbLoader already.
  if (cacheEntry.pdb && cacheEntry.pdb.externalIdsLoaded()) {
    _this.postMessage({ cbId: loadContext.cbId });
    return;
  }

  // Receives ids-file blob (or null on failure)
  var onDone = function (data) {

    if (!data) {
      // Loading failed. requestFile() already posted an error message in this case.
      return;
    }

    // Find propertyDB in cache that we want to load ids for
    let pdbCache = _this.pdbCache;
    cacheEntry = pdbCache.get(loadContext.dbPath);
    if (!cacheEntry || !cacheEntry.pdb) {

      // PropDBLoader delays id-loading until propertyDB finished loading.
      // So, if we get here and cannot find the propDb, we can assume that the propertyDb must have been unloaded meanwhile.

      // Make sure that we don't leak the blob in the file-cache (requestFile adds the reference automatically)
      pdbCache.unrefFileCacheEntry(storage);

      // Send message to inform that waiting makes no sense anymore, because
      // propDb has been unloaded meanwhile.
      _this.postMessage({
        cbId: loadContext.cbId,
        error: {
          propDbWasUnloaded: true
        }
      });
    }

    // Make ids available in pdb
    cacheEntry.pdb.setIdsBlob(data);
    cacheEntry.byteSize += data.byteLength;

    // Append entry to cacheEntry.dbFiles. This makes sure that the id file blob is released just like
    // all other dbFiles when the propDb is unloaded later. (see unloadPropertyDb)
    var newFile = {
      filename: idsFileEntry.path,
      storage: storage
    };
    cacheEntry.dbFiles.push(newFile);

    // Signal that we are done - main thread is now ready to query externalIds.
    _this.postMessage({ cbId: loadContext.cbId });
  };

  requestFile(idsFileEntry.path, loadContext, onDone, storage, idsFileEntry.isShared);
}

function doExecuteCode(loadContext) {

  var _this = loadContext.worker;

  //This is expected to load a function named "userFunction"
  if (loadContext.userFunction) {
    try {
      importScripts(loadContext.userFunction);
    } catch (err) {
      console.error(err);
      _this.postMessage({ cbId: loadContext.cbId, error: { msg: "Error while importing 'userFunction'." } });
      return;
    }
  }

  if (!self.userFunction) {
    _this.postMessage({ cbId: loadContext.cbId, error: { msg: "function 'userFunction' was not found." } });
    return;
  }

  var cacheEntry = _this.pdbCache && _this.pdbCache.get(loadContext.dbPath);

  if (cacheEntry && cacheEntry.pdb) {
    var result;
    try {
      result = self.userFunction(cacheEntry.pdb, loadContext.userData);
    } catch (err) {
      console.error(err);
      _this.postMessage({ cbId: loadContext.cbId, error: { msg: "Error while executing 'userFunction'." } });
      return;
    } finally {
      self.userFunction = undefined; // cleanup
    }
    _this.postMessage({ cbId: loadContext.cbId, result: result });
  }
}

function register(workerMain) {
  workerMain.register("BUILD_EXTERNAL_ID_MAPPING", { doOperation: doBuildExternalIdMapping });
  workerMain.register("BUILD_LAYER_TO_NODE_ID_MAPPING", { doOperation: doBuildLayerToNodeIdMapping });
  workerMain.register("GET_PROPERTIES", { doOperation: doPropertyGet });
  workerMain.register("GET_PROPERTY_SET", { doOperation: doPropertySetGet });
  workerMain.register("SEARCH_PROPERTIES", { doOperation: doPropertySearch });
  workerMain.register("DIFF_PROPERTIES", { doOperation: doPropertyDiff });
  workerMain.register("FIND_PROPERTY", { doOperation: doPropertyFind });
  workerMain.register("FIND_LAYERS", { doOperation: doLayersFind });
  workerMain.register("LOAD_PROPERTYDB", { doOperation: doObjectTreeParse });
  workerMain.register("CREATE_TREE", { doOperation: doObjectTreeCreate });
  workerMain.register("UNLOAD_PROPERTYDB", { doOperation: doUnloadPropertyDb });
  workerMain.register("USER_FUNCTION", { doOperation: doExecuteCode });
  workerMain.register("LOAD_EXTERNAL_IDS", { doOperation: doLoadExternalIds });
}

/***/ }),

/***/ "./src/file-loaders/workers/SvfWorker.js":
/*!***********************************************!*\
  !*** ./src/file-loaders/workers/SvfWorker.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _lmvtk_svf_Package__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lmvtk/svf/Package */ "./src/file-loaders/lmvtk/svf/Package.js");
/* harmony import */ var _lmvtk_common_InputStream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lmvtk/common/InputStream */ "./src/file-loaders/lmvtk/common/InputStream.js");
/* harmony import */ var _net_Xhr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../net/Xhr */ "./src/file-loaders/net/Xhr.js");
/* harmony import */ var _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../net/ErrorCodes */ "./src/file-loaders/net/ErrorCodes.js");





function guardFunction(loadContext, func)
{
  try {
    func();
  }
  catch (exc) {
    loadContext.worker.raiseError(
      _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__.ErrorCodes.BAD_DATA, "Unhandled exception while loading SVF",
      { "url": loadContext.url, "exception": exc.toString(), "stack": exc.stack });
    loadContext.worker.postMessage(null);
  }
}

function doLoadSvfContinued(loadContext)
{
  var _this = loadContext.worker;

  guardFunction(loadContext, function () {
    var svf = loadContext.svf;
    function loadDoneCallback(type, meshMessage) {
      if (type == "svf") {

        var msg, xfer;
        var frags = svf.fragments;
        var transferable = [
        frags.transforms.buffer,
        frags.packIds.buffer,
        frags.entityIndexes.buffer,
        frags.fragId2dbId.buffer,
        frags.visibilityFlags.buffer];


        if (svf.bvh) {
          // BVH is posted together with svf,
          // so can add more buffer to transfer.
          xfer = {
            nodes: svf.bvh.nodes.getRawData(),
            primitives: svf.bvh.primitives,
            useLeanNodes: svf.bvh.nodes.bytes_per_node == 32
          };
          transferable.push(xfer.nodes);
          transferable.push(xfer.primitives.buffer);

          // Then can safely transfer following buffers from fragments.
          transferable.push(frags.boxes.buffer);
          transferable.push(frags.polygonCounts.buffer);
          transferable.push(frags.materials.buffer);

          msg = { "svf": svf, "bvh": xfer, progress: 1.0 };
        } else
        {
          msg = { "svf": svf, progress: 0.8 };
        }

        _this.postMessage(msg, transferable);
      } else if (type == "bvh") {
        xfer = {
          nodes: svf.bvh.nodes.getRawData(),
          primitives: svf.bvh.primitives,
          useLeanNodes: svf.bvh.nodes.bytes_per_node == 32
        };

        _this.postMessage({ "bvh": xfer, basePath: svf.basePath, progress: 1.0 },
        [xfer.nodes, xfer.primitives.buffer]);

      } else if (type == "mesh") {

        var transferList = [];
        if (meshMessage.mesh)
        transferList.push(meshMessage.mesh.vb.buffer);

        _this.postMessage(meshMessage, transferList);

      } else if (type == "done") {
        _this.postMessage({ progress: 1.0 });
      } else
      {
        _this.raiseError(
          _net_ErrorCodes__WEBPACK_IMPORTED_MODULE_3__.ErrorCodes.BAD_DATA, "Failure while loading SVF",
          { "url": loadContext.url });
        _this.postMessage(null);
      }
    }

    loadContext.loadDoneCB = loadDoneCallback;

    svf.loadRemainingSvf(loadContext);
  });
}

function doLoadSvf(loadContext) {

  var _this = loadContext.worker;

  _this.postMessage({ progress: 0.01 }); //Tell the main thread we are alive

  var type = "svf";

  function onSuccess(result) {

    _this.postMessage({ progress: 0.5 }); //rough progress reporting -- can do better

    guardFunction(loadContext, function () {

      // result is arraybuffer
      var svf = new _lmvtk_svf_Package__WEBPACK_IMPORTED_MODULE_0__.Package(new Uint8Array(result));
      loadContext.svf = svf;
      svf.loadManifest(loadContext);


      if (loadContext.interceptManifest) {
        _this.postMessage({ "manifest": svf.manifest });
      } else {
        loadContext.manifest = svf.manifest;
        doLoadSvfContinued(loadContext);
      }
    });
  }

  var options = {
    responseType: "arraybuffer"
  };

  // Begin download the target SVF file with a GET request.
  _net_Xhr__WEBPACK_IMPORTED_MODULE_2__.ViewingService.getItem(loadContext, loadContext.url, onSuccess, loadContext.onFailureCallback, options);

  if (type === "svf") {
    // Prefetch the first geometry pack (we assume there is one) to mask 
    // some latency. Note that errors are intentionally ignored here.
    _net_Xhr__WEBPACK_IMPORTED_MODULE_2__.ViewingService.getItem(loadContext, loadContext.basePath + "0.pf", function () {}, function () {}, options);
  }
}


function doFetchTopology(loadContext) {

  var _this = loadContext.worker;
  _net_Xhr__WEBPACK_IMPORTED_MODULE_2__.ViewingService.getItem(loadContext, loadContext.path, onSuccess, onFailure);

  // on success
  function onSuccess(data) {

    _this.postMessage({ "status-topology": {} }); // download is complete

    // This lines below may take a while...
    var topology = null;
    try {
      var jdr = new _lmvtk_common_InputStream__WEBPACK_IMPORTED_MODULE_1__.InputStream(data);
      var byteLength = data.byteLength;
      if (0 < byteLength) {
        topology = JSON.parse(jdr.getString(byteLength));
      }
      if (topology) {
        _this.postMessage({ "fetch-topology": { error: null, topology: topology } }); // parsing is complete
      } else {
        onFailure('topology-no-content');
      }
    } catch (eee) {
      onFailure(eee);
    }
  }

  // on-failure
  function onFailure(err) {
    _this.postMessage({ "fetch-topology": { error: err, topology: null } }); // something went wrong
  }
}

function register(workerMain) {
  workerMain.register("LOAD_SVF", { doOperation: doLoadSvf });
  workerMain.register("LOAD_SVF_CONTD", { doOperation: doLoadSvfContinued });
  workerMain.register("FETCH_TOPOLOGY", { doOperation: doFetchTopology });
}

/***/ }),

/***/ "./src/global.js":
/*!***********************!*\
  !*** ./src/global.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGlobal: () => (/* binding */ getGlobal)
/* harmony export */ });
/**
 * Functions on the global scope need to be called with the global scope as their 'this' context.
 * Therefore, we can't simply return function properties from the global scope proxy like other properties.
 * We create another (temporary) proxy instead, which implements the 'apply' hook.
 * Invoking a function through this hook will ensure the correct 'this' context inside of the function.
 * 
 * @param {Object} globalScope The global scope that the function is a property of (e.g. window).
 * @param {Function} func The function property that is accessed through the global scope proxy.
 * @returns {Proxy} A new proxy that forwards function invocations so that the 'this' context of the invoked function
 *   is set up properly.
 */
function createFunctionProxy(globalScope, func) {
  return new Proxy(func, {
    get(obj, prop) {
      return obj[prop];
    },
    apply(target, thisArg, argumentsList) {
      return target.call(globalScope || thisArg, ...argumentsList);
    }
  });
}

// A helper method to get an app-specific namespace under the global scope, or create it if it's not present yet.
function getAppNamespace(globalScope) {
  return globalScope[globalScope.LMV_APP_NAMESPACE] = globalScope[globalScope.LMV_APP_NAMESPACE] || {};
}

/**
 * Returns the global object of the current environment (e.g. window in a browser).
 * If `USE_LMV_APP_NAMESPACES` is set to `true` on the global scope, the returned value will be a proxy that intercepts
 * set operations on non-existing properties and writes the value to an app-specific namespace instead. The actual
 * property on the window object is a placeholder that forwards read and write operations to the app-specific version.
 *
 * Example:
 * Given that window.LMV_APP_NAMESPACE is 'myApp' and window.Autodesk does not exist yet
 *
 * getGlobal().Autodesk = {}
 *
 * will be rewritten as
 *
 * window.myApp.Autodesk = {};
 * window.Autodesk = Placeholder that forwards to window[window.LMV_APP_NAMESPACE].Autodesk
 *
 * Changing window.LMV_APP_NAMESPACE to 'myOtherApp' will then rewrite
 *
 * window.Autodesk to window.myOtherApp.Autodesk
 *
 * @returns {Object} The global scope of the environment.
 */
function getGlobal() {
  // Determine the global scope of the environment
  const globalScope = typeof window !== "undefined" && window !== null ?
  window :
  typeof self !== "undefined" && self !== null ?
  self :
  __webpack_require__.g;

  // If app namespaces are used, create and return a proxy instead of the actual global scope object.
  if (globalScope.USE_LMV_APP_NAMESPACES) {
    if (!globalScope.globalProxy) {
      // The proxy is a singleton that will only be created once, even across multiple viewer bundles.
      globalScope.globalProxy = new Proxy({}, {
        // Get requests are simply forwarded to the global scope.
        // Functions get some special treatment, because they need to invoked with the global scope as their
        // 'this' context.
        get(obj, prop) {
          let value = globalScope[prop];
          if (typeof value === 'function') {
            return createFunctionProxy(globalScope, value);
          }
          return value;
        },
        // Set requests are intercepted to create properties in app-specific namespaces.
        set(obj, prop, value) {
          if (Object.prototype.hasOwnProperty.call(globalScope, prop)) {
            // Don't proxy existing properties
            if (globalScope[prop] !== value)
            globalScope[prop] = value;
          } else {
            // Create the property under the app's namespace and inject a proxy object in the global
            // scope that forwards to the namespaced property.
            getAppNamespace(globalScope)[prop] = value;
            Object.defineProperty(globalScope, prop, {
              get: () => {return getAppNamespace(globalScope)[prop];},
              set: (value) => {getAppNamespace(globalScope)[prop] = value;}
            });
          }
          return true; // Proxy setters must return true
        }
      });
    }

    return globalScope.globalProxy;
  } else {
    return globalScope;
  }
}

/***/ }),

/***/ "./src/globals.js":
/*!************************!*\
  !*** ./src/globals.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DISABLE_FORGE_CANVAS_LOGO: () => (/* binding */ DISABLE_FORGE_CANVAS_LOGO),
/* harmony export */   DISABLE_FORGE_LOGO: () => (/* binding */ DISABLE_FORGE_LOGO),
/* harmony export */   fromUrlSafeBase64: () => (/* binding */ fromUrlSafeBase64),
/* harmony export */   getHtmlTemplate: () => (/* binding */ getHtmlTemplate),
/* harmony export */   getParameterByName: () => (/* binding */ getParameterByName),
/* harmony export */   getParameterByNameFromPath: () => (/* binding */ getParameterByNameFromPath),
/* harmony export */   getResourceUrl: () => (/* binding */ getResourceUrl),
/* harmony export */   getScript: () => (/* binding */ getScript),
/* harmony export */   injectCSS: () => (/* binding */ injectCSS),
/* harmony export */   isExperimentalFlagEnabled: () => (/* binding */ isExperimentalFlagEnabled),
/* harmony export */   stringToDOM: () => (/* binding */ stringToDOM),
/* harmony export */   toUrlSafeBase64: () => (/* binding */ toUrlSafeBase64)
/* harmony export */ });
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compat */ "./src/compat.js");



var g = (0,_compat__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
var _window = g;
var _document = _window && _window.document;

g.USE_FETCH_API = true;

g.LOCALIZATION_REL_PATH = "";

/**
 * Contains the Viewer's version.
 *
 * @type {string}
 * @global
 */
g.LMV_VIEWER_VERSION = "7.93.1";

g.LMV_BUILD_TYPE = "Production";
g.LMV_RESOURCE_ROOT = "";

/** Allows for external code, e.g. collosseum tests, to check which version is used. */
g.LMV_IS_FLUENT_BUILD = false;

/**
 * When true, non-OTG resources (i.e. 2D documents, image files) will get fetched directly from DS.
 * When false, non-OTG resources will get fetched using OTG-DS proxy.
 * 
 * https://git.autodesk.com/A360/firefly.js/pull/4319
 */
g.USE_OTG_DS_PROXY = false;

/**
 * When true, requests to APS are authenticated with a cookie. 
 * When false, requests to APS are authenticated with an Authentication header.
 * When undefined, the viewer will first try authentication via cookie, if 
 * that doesn't work it will fallback to using an Authentication header.
 *
 * @type {boolean|undefined}
 * @global
 * @default undefined
 */
g.LMV_THIRD_PARTY_COOKIE = (0,_compat__WEBPACK_IMPORTED_MODULE_0__.isNodeJS)() ? false : undefined;

if (g.LMV_VIEWER_VERSION.charAt(0) === 'v') {
  // remove prefixed 'v'
  // Required due to TeamCity build pipeline (LMV-1361)
  g.LMV_VIEWER_VERSION = g.LMV_VIEWER_VERSION.substr(1);
}


/**
 * When true, the viewer will favor loading the PDF file over the Leaflet derivative, 
 * ignoring the manifest value for `totalRasterPixels`. A true value will take precedence over {@link LMV_RASTER_PDF}.
 *
 * @type {boolean}
 * @default 
 * @global
 */
g.LMV_VECTOR_PDF = false;

/**
 * When true, the viewer will favor loading the Leaflet derivative over the PDF file,
 * ignoring the manifest value for `totalRasterPixels`. When {@link LMV_RASTER_PDF} is true, this value is ignored. 
 *
 * @type {boolean}
 * @default 
 * @global
 */
g.LMV_RASTER_PDF = true;

/**
 * When true, LMV will remove the APS Logo spinner and the in canvas APS logo
 * Note: We disable the branding for the fluent build. For the regular build this will be enabled.
 *
 * @private
 */
let DISABLE_FORGE_LOGO = false;


/**
 * When true, LMV will remove the in canvas APS logo. To remove both the in canvas and the spinner logos use DISABLE_FORGE_LOG
 *
 * @private
 */
let DISABLE_FORGE_CANVAS_LOGO = true; // Switch to false to enable the in-canvas logo


// TODO:  This is here for now, until we find a better place for it.
//
/**
 * Returns the first source url found containing the given script name.
 *
 * @private
 * @param {string} scriptName - Script name.
 * @returns {HTMLScriptElement} The script element whose source location matches the input parameter.
 */
function getScript(scriptName) {
  scriptName = scriptName.toLowerCase();
  var scripts = _document.getElementsByTagName('SCRIPT');
  if (scripts && scripts.length > 0) {
    for (var i = 0; i < scripts.length; ++i) {
      if (scripts[i].src && scripts[i].src.toLowerCase().indexOf(scriptName) !== -1) {
        return scripts[i];
      }
    }
  }
  return null;
}

/**
 * Inject a css file into the page.
 * There's a callback if you need to know when it gets downloaded (rare).
 * Accepts both relative and absolute URLs.
 *
 * @param cssUrl
 * @param callback
 * @param onError
 * @private
 */
function injectCSS(cssUrl, callback, onError) {
  var href = cssUrl.indexOf('://') > 0 ? cssUrl : getResourceUrl(cssUrl);

  // Verify that we haven't downloaded it already
  var results = _document.getElementsByTagName('link');
  for (var i = 0, len = results.length; i < len; i++) {
    if (results[i].href === href) {
      // Already downloaded
      callback && callback();
      return;
    }
  }

  // else, download it
  var s = _document.createElement("link");
  s.setAttribute('rel', "stylesheet");
  s.setAttribute('type', "text/css");
  s.setAttribute('href', href);
  if (callback) {
    s.onload = callback;
  }
  if (onError) {
    s.onerror = onError;
  }
  _document.head.appendChild(s);
}

/**
 * Download an HTML template.
 * If successful, will invoke callback(null, templateString)
 * If failure, will invoke callback("some error", null)
 *
 * @param templateUrl
 * @param callback
 * @private
 * @deprecated
 */
function getHtmlTemplate(templateUrl, callback) {
  var href = templateUrl.indexOf('://') > 0 ? templateUrl : getResourceUrl(templateUrl);
  var request = new XMLHttpRequest();
  request.onload = requestLoad;
  request.onerror = requestError;
  request.ontimeout = requestError;
  request.open('GET', href, true);
  request.send();

  /**
   * @param err
   * @private
   */
  function requestError(err) {
    callback(err, null);
  }
  /**
   * @param event
   * @private
   */
  function requestLoad(event) {
    var content = event.currentTarget.responseText;
    callback(null, content);
  }

}

/**
 * Checks whether an experimental flag has been set into the viewer's' `config`
 * object, which happens to be the same as the extension's `options` object.
 *
 * @param flagName
 * @param config3d
 * @private
 */
function isExperimentalFlagEnabled(flagName, config3d) {
  if (!config3d || !Array.isArray(config3d.experimental))
  return false;
  return config3d.experimental.indexOf(flagName) !== -1;
}


/**
 * Returns the full url of a resource with version.
 * The version will be determined from the LMV_VIEWER_VERSION variable.
 *
 * @private
 * @param {string} resourceRelativePath - The path of the resource relative to LMV_RESOURCE_ROOT.
 * @returns {string} The full resource path.
 */
function getResourceUrl(resourceRelativePath) {
  return g.LMV_RESOURCE_ROOT + resourceRelativePath;
}


/**
 * Returns the query parameter value from window url
 * @param {string} name - Parameter name
 * @returns {string} - Parameter value
 * @alias Autodesk.Viewing.getParameterByName
 */
function getParameterByName(name) {
  if (typeof window === "undefined") {
    return "";
  }
  return getParameterByNameFromPath(name, _window.location.href);
}

/**
 * Parameter from url
 * @param {string} name - Parameter name
 * @param {string} url - URL
 * @returns {string} - Parameter value
 * @alias Autodesk.Viewing.getParameterByNameFromPath
 */
function getParameterByNameFromPath(name, url) {
  name = name.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
  var regexS = "[\\?&]" + name + "=([^&#]*)";
  var regex = new RegExp(regexS);
  var results = regex.exec(url);
  if (results == null)
  return "";else

  return decodeURIComponent(results[1].replace(/\+/g, " "));
}


/**
 * Creae a dom element
 * @param {string} str - String to generate DOM object
 * @private
 */
function stringToDOM(str) {
  var d = _document.createElement("div");
  d.innerHTML = str;
  return d.firstChild;
}

/**
 * Convert to url-safe base 64 string
 * @param {string} str - String to convert
 * @returns - Url-safe base64 string
 * @alias Autodesk.Viewing.toUrlSafeBase64
 */
function toUrlSafeBase64(str) {
  const base64 = btoa(str).
  replace(/\+/g, '-') // Convert '+' to '-' (dash)
  .replace(/\//g, '_') // Convert '/' to '_' (underscore)
  .replace(/=+$/, ''); // Remove trailing '='

  return base64;
}

/**
 * Decode base64 string
 * @param {string} str - String to convert
 * @returns string after decoding from base64
 * @alias Autodesk.Viewing.fromUrlSafeBase64
 */
function fromUrlSafeBase64(str) {
  str = str.replace(/-/g, '+'); // Convert '-' (dash) to '+'
  str = str.replace(/_/g, '/'); // Convert '_' (underscore) to '/'
  while (str.length % 4) {str += '=';} // Add padding '='

  if ((0,_compat__WEBPACK_IMPORTED_MODULE_0__.isNodeJS)()) {
    return Buffer.from(str, "base64").toString();
  } else {
    return atob(str);
  }
}

/***/ }),

/***/ "./src/logger/Logger.js":
/*!******************************!*\
  !*** ./src/logger/Logger.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogLevels: () => (/* binding */ LogLevels),
/* harmony export */   Logger: () => (/* binding */ Logger),
/* harmony export */   logger: () => (/* binding */ logger),
/* harmony export */   setLogger: () => (/* binding */ setLogger)
/* harmony export */ });
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../compat */ "./src/compat.js");
/* harmony import */ var _file_loaders_net_endpoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../file-loaders/net/endpoints */ "./src/file-loaders/net/endpoints.js");
/* harmony import */ var _analytics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../analytics */ "./src/analytics/index.js");





const global = (0,_compat__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
const _window = global;

/**
 * Logging levels. Higher number means more verbose logs,
 * for example, with level 3, `info`, `warn`, or `error`
 * logs will show up in the console but `debug` and `log` won't.
 *
 * Semantics of specific levels:
 *  - debug: low-level debugging logs
 *  - log: common, higher-level debugging logs
 *  - info: helpful runtime information (even for stag/prod environments)
 *  - warn: potentially problematic situations; handled exceptions
 *  - error: definitely problematic situations; unhandled exceptions
 * @readonly
 * @enum {number}
 */
const LogLevels = {
  DEBUG: 5,
  LOG: 4,
  INFO: 3,
  WARNING: 2,
  ERROR: 1,
  NONE: 0
};


/**
 * Logger class. 
 * Depending on options.logLevel setting in initilize function, corresponding functions would be activated.
 */
function Logger() {
  this.runtimeStats = {};
  this.level = -1;
  this.setLevel(LogLevels.ERROR);
  this._reportError = this._reportError.bind(this);
}

/**
 * Initialize Logger object with options. 
 * 
 * @param {object}   [options] - Options object to configure the Logger.
 * @param {function} [options.eventCallback] - An optional callback used for processing the log entry with properties like "category", "timestamp", etc. 
                                               It can be used as for analytics tracking by filtering and listening to specific category users are interested. 
                                               The expected argument is the user supplied entry object instrumented with "timestamp" and "sessionId" properties. 
 * @param {string}   [options.sessionId] - An optional id for each browser session. Default gets generated based on current time stamp if not specified. 
 * @param {number}   [options.logLevel] - An optional level to define the log level. Default is LogLevels.ERROR if not specified.
 *
 */

Logger.prototype.initialize = function (options) {

  if (options.eventCallback)
  this.callback = options.eventCallback;

  this.sessionId = options.sessionId;
  if (!this.sessionId) {
    var now = Date.now() + "";
    this.sessionId = parseFloat((Math.random() * 10000 | 0) + "" + now.substring(4));
  }

  // Initialize log level is passed in
  if (typeof options.logLevel === 'number') {
    this.setLevel(options.logLevel);
  }

  this.environmentInfo = {
    touch: (0,_compat__WEBPACK_IMPORTED_MODULE_0__.isTouchDevice)(),
    env: (0,_file_loaders_net_endpoints__WEBPACK_IMPORTED_MODULE_1__.getEnv)(),
    referer: getReferer(),
    version: global.LMV_VIEWER_VERSION,
    build_type: global.LMV_BUILD_TYPE
  };

  //Kick off with a viewer start event
  var startEvent = {
    category: "viewer_start",
    touch: this.environmentInfo.touch,
    env: this.environmentInfo.env,
    referer: this.environmentInfo.referer,
    version: this.environmentInfo.version,
    build_type: this.environmentInfo.build_type
  };
  this.track(startEvent);

  var _this = this;
  this.interval = setInterval(function () {
    _this.reportRuntimeStats();
  }, 60000);
};

/**
 * Stop the runtime stats reporting every min.
 */
Logger.prototype.shutdown = function () {
  clearInterval(this.interval);
  this.interval = undefined;
};


/**
 * Track the user inputted entry by appending additional info "timestamp", "sessionId"
 * @param {object} [entry] - User object to define the track object, 
        e.g. {
            category : "load_document",
            urn: "xyz"
        }   
 */
Logger.prototype.track = function (entry) {

  this.updateRuntimeStats(entry);

  if ((0,_file_loaders_net_endpoints__WEBPACK_IMPORTED_MODULE_1__.isOffline)() || !this.sessionId) {
    return;
  }

  if (this.callback) {

    entry.timestamp = Date.now();
    entry.sessionId = this.sessionId;

    this.callback(entry);
  }

  if ((entry === null || entry === void 0 ? void 0 : entry.category) === 'error') {
    trackError('viewer.error.tracked', entry);
  }
};

Logger.prototype.updateRuntimeStats = function (entry) {
  if (Object.prototype.hasOwnProperty.call(entry, 'aggregate')) {
    switch (entry.aggregate) {
      case 'count':
        if (this.runtimeStats[entry.name] > 0) {
          this.runtimeStats[entry.name]++;
        } else {
          this.runtimeStats[entry.name] = 1;
        }
        this.runtimeStats._nonempty = true;
        break;
      case 'last':
        this.runtimeStats[entry.name] = entry.value;
        this.runtimeStats._nonempty = true;
        break;
      default:
        this.warn('unknown log aggregate type');
    }
  }
};

Logger.prototype.reportRuntimeStats = function () {
  if (this.runtimeStats._nonempty) {
    delete this.runtimeStats._nonempty;

    this.runtimeStats.category = 'misc_stats';
    this.track(this.runtimeStats);
    this.runtimeStats = {};
  }
};

Logger.prototype.setLevel = function (level) {
  if (this.level === level)
  return;

  this.level = level;

  // Bind to console
  this.debug = level >= LogLevels.DEBUG ? console.log : consoleNothing;
  this.log = level >= LogLevels.LOG ? console.log : consoleNothing;
  this.info = level >= LogLevels.INFO ? console.info : consoleNothing;
  this.warn = level >= LogLevels.WARNING ? console.warn : consoleNothing;
  this.error = level >= LogLevels.ERROR ? this._reportError : consoleNothing;
};


/**
 * Reports an error to the browser console and to the logger's callback.
 * Invoked by developers when method `logger.error()` is used. 
 * Forwards the arguments directly into `console.error()`. 
 * @private
 */
Logger.prototype._reportError = function () {
  console.error.apply(console, arguments);

  const msg = Array.prototype.slice.call(arguments).join(' ');
  if (this.callback) {
    this.callback({ category: 'error', message: msg });
  }

  trackError('viewer.error.logged', msg);
};

function trackError(name, content) {
  let value;
  if (typeof content === 'string') {
    value = {
      message: content
    };
  } else if (typeof content === 'object') {
    value = content;
  }
  _analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(name, value);
}

/**
 * @private
 */
function getReferer() {
  // Wrapping href retrieval due to Fortify complains
  if (typeof window !== 'undefined') {
    return encodeURI(_window.location.href);
  }
  return '';
}



/**
 * Swallows log/debug/info/warn/error calls when the logLevel disallows it.
 * @private
 */
function consoleNothing() {

}


let logger = new Logger();

function setLogger(l) {
  logger = l;
}

/***/ }),

/***/ "./src/wgs/scene/BVHBuilder.js":
/*!*************************************!*\
  !*** ./src/wgs/scene/BVHBuilder.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BVHBuilder: () => (/* binding */ BVHBuilder),
/* harmony export */   NodeArray: () => (/* binding */ NodeArray)
/* harmony export */ });
/**
 * BVH definitions:
 *
 * BVH Node: if this was C (the only real programming language), it would go something like this,
 * but with better alignment.
 *
 * This is definition for "fat" nodes (for rasterization),
 * i.e. when inner nodes also contain primitives.
 * struct Node {                                                            byte/short/int offset
 *      float worldBox[6]; //world box of the node node                         0/0/0
 *      int leftChildIndex; //pointer to left child node (right is left+1)     24/12/6
 *      ushort primCount; //how many fragments are at this node                28/14/7
 *      ushort flags; //bitfield of good stuff                                 30/15/7.5
 *
 *      int primStart; //start of node's own primitives (fragments) list       32/16/8
 * };
 * => sizeof(Node) = 36 bytes

 * Definition for lean nodes (for ray casting): when a node is either inner node (just children, no primitives)
 * or leaf (just primitives, no children).
 * struct Node {
 *      float worldBox[6]; //world box of the node
 *      union {
 *          int leftChildIndex; //pointer to left child node (right is left+1)
 *          int primStart; //start of node's own primitives (fragments) list
 *      };
 *      ushort primCount; //how many fragments are at this node
 *      ushort flags; //bitfield of good stuff
 * };
 * => sizeof(Node) = 32 bytes
 *
 * The class below encapsulates an array of such nodes using ArrayBuffer as backing store.
 *
 * @param {ArrayBuffer|number} initialData  Initial content of the NodeArray, or initial allocation of empty nodes
 * @param {boolean} useLeanNode Use minimal node structure size. Currently this parameter must be set to false.
 * @constructor
 */
function NodeArray(initialData, useLeanNode) {
  'use strict';

  if (useLeanNode) {
    this.bytes_per_node = 32;
  } else {
    this.bytes_per_node = 36;
  }

  var initialCount;
  var initialBuffer;

  if (initialData instanceof ArrayBuffer) {
    initialCount = initialData.byteLength / this.bytes_per_node;
    initialBuffer = initialData;
    this.nodeCount = initialCount;
  } else
  {
    initialCount = initialData | 0;
    initialBuffer = new ArrayBuffer(this.bytes_per_node * initialCount);
    this.nodeCount = 0;
  }

  this.nodeCapacity = initialCount;
  this.nodesRaw = initialBuffer;

  this.is_lean_node = useLeanNode;
  this.node_stride = this.bytes_per_node / 4;
  this.node_stride_short = this.bytes_per_node / 2;

  //Allocate memory buffer for all tree nodes
  this.nodesF = new Float32Array(this.nodesRaw);
  this.nodesI = new Int32Array(this.nodesRaw);
  this.nodesS = new Uint16Array(this.nodesRaw);
}

NodeArray.prototype.setLeftChild = function (nodeidx, childidx) {
  this.nodesI[nodeidx * this.node_stride + 6] = childidx;
};
NodeArray.prototype.getLeftChild = function (nodeidx) {
  return this.nodesI[nodeidx * this.node_stride + 6];
};

NodeArray.prototype.setPrimStart = function (nodeidx, start) {
  if (this.is_lean_node)
  this.nodesI[nodeidx * this.node_stride + 6] = start;else

  this.nodesI[nodeidx * this.node_stride + 8] = start;
};
NodeArray.prototype.getPrimStart = function (nodeidx) {
  if (this.is_lean_node)
  return this.nodesI[nodeidx * this.node_stride + 6];else

  return this.nodesI[nodeidx * this.node_stride + 8];
};

NodeArray.prototype.setPrimCount = function (nodeidx, count) {
  this.nodesS[nodeidx * this.node_stride_short + 14] = count;
};
NodeArray.prototype.getPrimCount = function (nodeidx) {
  return this.nodesS[nodeidx * this.node_stride_short + 14];
};

NodeArray.prototype.setFlags = function (nodeidx, axis, isFirst, isTransparent) {
  this.nodesS[nodeidx * this.node_stride_short + 15] = isTransparent << 3 | isFirst << 2 | axis & 0x3;
};
NodeArray.prototype.getFlags = function (nodeidx) {
  return this.nodesS[nodeidx * this.node_stride_short + 15];
};

NodeArray.prototype.setBox0 = function (nodeidx, src) {
  var off = nodeidx * this.node_stride;
  var dst = this.nodesF;
  dst[off] = src[0];
  dst[off + 1] = src[1];
  dst[off + 2] = src[2];
  dst[off + 3] = src[3];
  dst[off + 4] = src[4];
  dst[off + 5] = src[5];
};
NodeArray.prototype.getBoxThree = function (nodeidx, dst) {
  var off = nodeidx * this.node_stride;
  var src = this.nodesF;
  dst.min.x = src[off];
  dst.min.y = src[off + 1];
  dst.min.z = src[off + 2];
  dst.max.x = src[off + 3];
  dst.max.y = src[off + 4];
  dst.max.z = src[off + 5];
};
NodeArray.prototype.getBoxArray = function (nodeidx, dst, offset) {
  var off = nodeidx * this.node_stride;
  var src = this.nodesF;
  offset = offset || 0;
  dst[0 + offset] = src[off];
  dst[1 + offset] = src[off + 1];
  dst[2 + offset] = src[off + 2];
  dst[3 + offset] = src[off + 3];
  dst[4 + offset] = src[off + 4];
  dst[5 + offset] = src[off + 5];
};
NodeArray.prototype.setBoxThree = function (nodeidx, src) {
  var off = nodeidx * this.node_stride;
  var dst = this.nodesF;
  dst[off] = src.min.x;
  dst[off + 1] = src.min.y;
  dst[off + 2] = src.min.z;
  dst[off + 3] = src.max.x;
  dst[off + 4] = src.max.y;
  dst[off + 5] = src.max.z;
};




NodeArray.prototype.makeEmpty = function (nodeidx) {

  var off = nodeidx * this.node_stride;
  var dst = this.nodesI;

  //No point to makeEmpty here, because the box gets set
  //directly when the node is initialized in bvh_subdivide.
  //box_make_empty(this.nodesF, off);

  //_this.setLeftChild(nodeidx,-1);
  dst[off + 6] = -1;

  //both prim count and flags to 0
  dst[off + 7] = 0;

  //_this.setPrimStart(nodeidx, -1);
  if (!this.is_lean_node)
  dst[off + 8] = -1;

};

NodeArray.prototype.realloc = function (extraSize) {
  if (this.nodeCount + extraSize > this.nodeCapacity) {
    var nsz = 0 | this.nodeCapacity * 3 / 2;
    if (nsz < this.nodeCount + extraSize)
    nsz = this.nodeCount + extraSize;

    var nnodes = new ArrayBuffer(nsz * this.bytes_per_node);
    var nnodesI = new Int32Array(nnodes);
    nnodesI.set(this.nodesI);

    this.nodeCapacity = nsz;
    this.nodesRaw = nnodes;
    this.nodesF = new Float32Array(nnodes);
    this.nodesI = nnodesI;
    this.nodesS = new Uint16Array(nnodes);
  }
};

NodeArray.prototype.nextNodes = function (howMany) {

  this.realloc(howMany);

  var res = this.nodeCount;
  this.nodeCount += howMany;

  for (var i = 0; i < howMany; i++) {
    this.makeEmpty(res + i);
  }

  return res;
};

NodeArray.prototype.getRawData = function () {
  return this.nodesRaw.slice(0, this.nodeCount * this.bytes_per_node);
};

var POINT_STRIDE = 3;
var BOX_EPSILON = 1e-5;
var BOX_SCALE_EPSILON = 1e-5;
var MAX_DEPTH = 15; /* max tree depth */
var MAX_BINS = 16;

/**
* Bounding Volume Hierarchy build algorithm.
* Uses top down binning -- see "On fast Construction of SAH-based Bounding Volume Hierarchies" by I.Wald
* Ported from the C version here: https://git.autodesk.com/stanevt/t-ray/blob/master/render3d/t-ray/t-core/t-bvh.c
* Optimized for JavaScript.
*/
var BVHModule = function () {
  //There be dragons in this closure.

  "use strict";


  /**
   * Utilities for manipulating bounding boxes stored
   * in external array (as sextuplets of float32)
   */


  function box_get_centroid(dst, dst_off, src, src_off) {
    dst[dst_off] = 0.5 * (src[src_off] + src[src_off + 3]);
    dst[dst_off + 1] = 0.5 * (src[src_off + 1] + src[src_off + 4]);
    dst[dst_off + 2] = 0.5 * (src[src_off + 2] + src[src_off + 5]);
  }

  function box_add_point_0(dst, src, src_off) {

    if (dst[0] > src[src_off]) dst[0] = src[src_off];
    if (dst[3] < src[src_off]) dst[3] = src[src_off];

    if (dst[1] > src[src_off + 1]) dst[1] = src[src_off + 1];
    if (dst[4] < src[src_off + 1]) dst[4] = src[src_off + 1];

    if (dst[2] > src[src_off + 2]) dst[2] = src[src_off + 2];
    if (dst[5] < src[src_off + 2]) dst[5] = src[src_off + 2];

  }

  function box_add_box_0(dst, src, src_off) {

    if (dst[0] > src[src_off]) dst[0] = src[src_off];
    if (dst[1] > src[src_off + 1]) dst[1] = src[src_off + 1];
    if (dst[2] > src[src_off + 2]) dst[2] = src[src_off + 2];

    if (dst[3] < src[src_off + 3]) dst[3] = src[src_off + 3];
    if (dst[4] < src[src_off + 4]) dst[4] = src[src_off + 4];
    if (dst[5] < src[src_off + 5]) dst[5] = src[src_off + 5];
  }

  function box_add_box_00(dst, src) {
    if (dst[0] > src[0]) dst[0] = src[0];
    if (dst[1] > src[1]) dst[1] = src[1];
    if (dst[2] > src[2]) dst[2] = src[2];

    if (dst[3] < src[3]) dst[3] = src[3];
    if (dst[4] < src[4]) dst[4] = src[4];
    if (dst[5] < src[5]) dst[5] = src[5];
  }

  function box_get_size(dst, dst_off, src, src_off) {
    for (var i = 0; i < 3; i++) {
      dst[dst_off + i] = src[src_off + 3 + i] - src[src_off + i];
    }
  }

  //function box_copy(dst, dst_off, src, src_off) {
  //    for (var i=0; i<6; i++) {
  //        dst[dst_off+i] = src[src_off+i];
  //    }
  //}

  // unwound version of box_copy
  function box_copy_00(dst, src) {
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
  }

  var dbl_max = Infinity;

  //function box_make_empty(dst, dst_off) {
  //        dst[dst_off]   =  dbl_max;
  //        dst[dst_off+1] =  dbl_max;
  //        dst[dst_off+2] =  dbl_max;
  //        dst[dst_off+3] = -dbl_max;
  //        dst[dst_off+4] = -dbl_max;
  //        dst[dst_off+5] = -dbl_max;
  //}

  function box_make_empty_0(dst) {
    dst[0] = dbl_max;
    dst[1] = dbl_max;
    dst[2] = dbl_max;
    dst[3] = -dbl_max;
    dst[4] = -dbl_max;
    dst[5] = -dbl_max;
  }

  function box_area(src, src_off) {

    var dx = src[src_off + 3] - src[src_off];
    var dy = src[src_off + 4] - src[src_off + 1];
    var dz = src[src_off + 5] - src[src_off + 2];

    if (dx < 0 || dy < 0 || dz < 0)
    return 0;

    return 2.0 * (dx * dy + dy * dz + dz * dx);
  }

  function box_area_0(src) {

    var dx = src[3] - src[0];
    var dy = src[4] - src[1];
    var dz = src[5] - src[2];

    if (dx < 0 || dy < 0 || dz < 0)
    return 0;

    return 2.0 * (dx * dy + dy * dz + dz * dx);
  }





  function bvh_split_info() {
    this.vb_left = new Float32Array(6);
    this.vb_right = new Float32Array(6);
    this.cb_left = new Float32Array(6);
    this.cb_right = new Float32Array(6);
    this.num_left = 0;
    this.best_split = -1;
    this.best_cost = -1;
    this.num_bins = -1;
  }

  bvh_split_info.prototype.reset = function () {
    this.num_left = 0;
    this.best_split = -1;
    this.best_cost = -1;
    this.num_bins = -1;
  };


  function bvh_bin() {
    this.box_bbox = new Float32Array(6); // bbox of all primitive bboxes
    this.box_centroid = new Float32Array(6); // bbox of all primitive centroids
    this.num_prims = 0; // number of primitives in the bin
  }

  bvh_bin.prototype.reset = function () {
    this.num_prims = 0; // number of primitives in the bin
    box_make_empty_0(this.box_bbox);
    box_make_empty_0(this.box_centroid);
  };

  function accum_bin_info() {
    this.BL = new Float32Array(6);
    this.CL = new Float32Array(6);
    this.NL = 0;
    this.AL = 0;
  }

  accum_bin_info.prototype.reset = function () {
    this.NL = 0;
    this.AL = 0;

    box_make_empty_0(this.BL);
    box_make_empty_0(this.CL);
  };


  //Scratch variables used by bvh_bin_axis
  //TODO: can be replaced by a flat ArrayBuffer
  var bins = [];
  var i;
  for (i = 0; i < MAX_BINS; i++) {
    bins.push(new bvh_bin());
  }

  //TODO: can be replaced by a flat ArrayBuffer
  var ai = [];
  for (i = 0; i < MAX_BINS - 1; i++)
  ai.push(new accum_bin_info());

  var BR = new Float32Array(6);
  var CR = new Float32Array(6);


  function assign_bins(bvh, start, end, axis, cb, cbdiag, num_bins) {

    var centroids = bvh.centroids;
    var primitives = bvh.primitives;
    var boxes = bvh.finfo.boxes;
    var boxStride = bvh.finfo.boxStride;

    /* bin assignment */
    var k1 = num_bins * (1.0 - BOX_SCALE_EPSILON) / cbdiag[axis];
    var cbaxis = cb[axis];
    var sp = bvh.sort_prims;

    for (var j = start; j <= end; j++)
    {
      /* map array index to primitive index -- since primitive index array gets reordered by the BVH build*/
      /* while the primitive info array is not reordered */
      var iprim = primitives[j] | 0;

      var fpbin = k1 * (centroids[iprim * 3 /*POINT_STRIDE*/ + axis] - cbaxis);
      var binid = fpbin | 0; //Truncate to int is algorithmic -> not an optimization thing!

      /* possible floating point problems */
      if (binid < 0)
      {
        binid = 0;
        //debug("Bin index out of range " + fpbin);
      } else
      if (binid >= num_bins)
      {
        binid = num_bins - 1;
        //debug("Bin index out of range. " + fpbin);
      }

      /* Store the bin index for the partitioning step, so we don't recompute it there */
      sp[j] = binid;

      /* update other bin data with the new primitive */
      //var bin = bins[binid];
      bins[binid].num_prims++;

      box_add_box_0(bins[binid].box_bbox, boxes, iprim * boxStride);
      box_add_point_0(bins[binid].box_centroid, centroids, iprim * 3 /*POINT_STRIDE*/);
    }
    /* at this point all primitves are assigned to a bin */
  }


  function bvh_bin_axis(bvh, start, end, axis, cb, cbdiag, split_info) {

    /* if size is near 0 on this axis, cost of split is infinite */
    if (cbdiag[axis] < bvh.scene_epsilon)
    {
      split_info.best_cost = Infinity;
      return;
    }

    var num_bins = MAX_BINS;
    if (num_bins > end - start + 1)
    num_bins = end - start + 1;

    var i;
    for (i = 0; i < num_bins; i++)
    bins[i].reset();

    for (i = 0; i < num_bins - 1; i++)
    ai[i].reset();

    split_info.num_bins = num_bins;

    assign_bins(bvh, start, end, axis, cb, cbdiag, num_bins);


    /* now do the accumulation sweep from left to right */
    box_copy_00(ai[0].BL, bins[0].box_bbox);
    box_copy_00(ai[0].CL, bins[0].box_centroid);
    ai[0].AL = box_area_0(ai[0].BL);
    ai[0].NL = bins[0].num_prims;
    var bin;
    for (i = 1; i < num_bins - 1; i++)
    {
      bin = bins[i];
      var aii = ai[i];
      box_copy_00(aii.BL, ai[i - 1].BL);
      box_add_box_00(aii.BL, bin.box_bbox);
      aii.AL = box_area_0(aii.BL);

      box_copy_00(aii.CL, ai[i - 1].CL);
      box_add_box_00(aii.CL, bin.box_centroid);

      aii.NL = ai[i - 1].NL + bin.num_prims;
    }

    /* sweep from right to left, keeping track of lowest cost and split */
    i = num_bins - 1;
    box_copy_00(BR, bins[i].box_bbox);
    box_copy_00(CR, bins[i].box_centroid);
    var AR = box_area_0(BR);
    var NR = bins[i].num_prims;

    var best_split = i;
    var best_cost = AR * NR + ai[i - 1].AL * ai[i - 1].NL;
    box_copy_00(split_info.vb_right, BR);
    box_copy_00(split_info.cb_right, bins[i].box_centroid);
    box_copy_00(split_info.vb_left, ai[i - 1].BL);
    box_copy_00(split_info.cb_left, ai[i - 1].CL);
    split_info.num_left = ai[i - 1].NL;

    for (i = i - 1; i >= 1; i--)
    {
      bin = bins[i];
      box_add_box_00(BR, bin.box_bbox);
      box_add_box_00(CR, bin.box_centroid);
      AR = box_area_0(BR);
      NR += bin.num_prims;

      var cur_cost = AR * NR + ai[i - 1].AL * ai[i - 1].NL;

      if (cur_cost <= best_cost)
      {
        best_cost = cur_cost;
        best_split = i;

        box_copy_00(split_info.vb_right, BR);
        box_copy_00(split_info.cb_right, CR);
        box_copy_00(split_info.vb_left, ai[i - 1].BL);
        box_copy_00(split_info.cb_left, ai[i - 1].CL);
        split_info.num_left = ai[i - 1].NL;
      }
    }

    split_info.best_split = best_split;
    split_info.best_cost = best_cost;
  }

  function bvh_partition(bvh, start, end, axis, cb, cbdiag, split_info) {

    //At this point, the original algorithm does an in-place NON-STABLE partition
    //to move primitives to the left and right sides of the split plane
    //into contiguous location of the primitives list for use by
    //the child nodes. But, we want to preserve the ordering by size
    //without having to do another sort, so we have to use
    //a temporary storage location to copy into. We place right-side primitives
    //in temporary storage, then copy back into the original storage in the right order.
    //Left-side primitives are still put directly into the destination location.
    var primitives = bvh.primitives;
    //var centroids = bvh.centroids;
    var i, j;

    //sort_prims contains bin indices computed during the split step.
    //Here we read those and also use sort_prims as temporary holding
    //of primitive indices. Hopefully the read happens before the write. :)
    //In C it was cheap enough to compute this again...
    //var k1 = split_info.num_bins * (1.0 - BOX_SCALE_EPSILON) / cbdiag[axis];
    //var cbaxis = cb[axis];
    var sp = bvh.sort_prims;

    var right = 0;
    var left = start | 0;
    var best_split = split_info.best_split | 0;

    for (i = start; i <= end; i++) {
      var iprim = primitives[i] | 0;
      //var fpbin = (k1 * (centroids[3/*POINT_STRIDE*/ * iprim + axis] - cbaxis));
      var binid = sp[i]; /* fpbin|0; */

      if (binid < best_split) {
        primitives[left++] = iprim;
      } else {
        sp[right++] = iprim;
      }
    }

    //if ((left-start) != split_info.num_left)
    //    debug("Mismatch between binning and partitioning.");

    //Copy back the right-side primitives into main primitives array, while
    //maintaining order
    for (j = 0; j < right; j++) {
      primitives[left + j] = sp[j];
    }
    /* at this point the binning is complete and we have computed a split */
  }


  function bvh_fatten_inner_node(bvh, nodes, nodeidx, start, end, cb, cbdiag, poly_cut_off) {

    var primitives = bvh.primitives;
    var centroids = bvh.centroids;

    //Take the first few items to place into the inner node,
    //but do not go over the max item or polygon count.
    var prim_count = end - start + 1;

    if (prim_count > bvh.frags_per_inner_node)
    prim_count = bvh.frags_per_inner_node;

    if (prim_count > poly_cut_off)
    prim_count = poly_cut_off;


    nodes.setPrimStart(nodeidx, start);
    nodes.setPrimCount(nodeidx, prim_count);
    start += prim_count;

    //Because we take some primitives off the input, we have to recompute
    //the bounding box used for computing the node split.
    box_make_empty_0(cb);
    for (var i = start; i <= end; i++) {
      box_add_point_0(cb, centroids, 3 /*POINT_STRIDE*/ * primitives[i]);
    }

    //Also update the split axis -- it could possibly change too.
    box_get_size(cbdiag, 0, cb, 0);
    //Decide which axis to split on. Done purely by longest.
    var axis = 0;
    if (cbdiag[1] > cbdiag[0])
    axis = 1;
    if (cbdiag[2] > cbdiag[axis])
    axis = 2;

    return axis;
  }


  var cbdiag = new Float32Array(3); //scratch variable used in bvh_subdivide

  function bvh_subdivide(bvh,
  nodeidx, /* current parent node to consider splitting */
  start, end, /* primitive sub-range to be considered at this recursion step */
  vb, /* bounding volume of the primitives' bounds in the sub-range */
  cb, /* bounding box of primitive centroids in this range */
  transparent, /* does the node contain opaque or transparent objects */
  depth /* recursion depth */)

  {
    box_get_size(cbdiag, 0, cb, 0);
    var nodes = bvh.nodes;
    var frags_per_leaf = transparent ? bvh.frags_per_leaf_node_transparent : bvh.frags_per_leaf_node;
    var frags_per_inner = transparent ? bvh.frags_per_inner_node_transparent : bvh.frags_per_inner_node;
    var polys_per_node = bvh.max_polys_per_node;

    //Decide which axis to split on.
    var axis = 0;
    if (cbdiag[1] > cbdiag[0])
    axis = 1;
    if (cbdiag[2] > cbdiag[axis])
    axis = 2;

    //Whether the node gets split or not, it gets
    //the same overall bounding box.
    nodes.setBox0(nodeidx, vb);

    //Check the expected polygon count of the node. This figures out the maximum number of fragments
    // we can put at the node as determined by polys_per_node
    var poly_count = 0;
    var poly_cut_off = 0;
    var prim_count = end - start + 1;

    // If we have the number of triangles in each mesh, limit the number of primitives in an inner node.
    if (bvh.finfo.hasPolygonCounts && bvh.frags_per_inner_node) {
      // Walk through primitives, add up the counts until we reach polys_per_node (10000), or run through
      // frags_per_inner_node (usually 32).
      // We know that later on we'll limit the number to frags_per_inner_node, so also do it here.
      var shorten_end = prim_count <= bvh.frags_per_inner_node ? end : start + bvh.frags_per_inner_node - 1;
      for (var i = start; i <= shorten_end; i++) {
        poly_count += bvh.finfo.getPolygonCount(bvh.primitives[i]);
        poly_cut_off++;
        if (poly_count > polys_per_node)
        break;
      }
    }

    var isSmall = prim_count <= frags_per_leaf && poly_count < polys_per_node ||
    prim_count === 1;

    //Decide whether to terminate recursion
    if (isSmall ||
    depth > MAX_DEPTH || //max recursion depth
    cbdiag[axis] < bvh.scene_epsilon) //node would be way too tiny for math to make sense (a point)
      {
        nodes.setLeftChild(nodeidx, -1);
        nodes.setPrimStart(nodeidx, start);
        nodes.setPrimCount(nodeidx, end - start + 1);
        nodes.setFlags(nodeidx, 0, 0, transparent ? 1 : 0);
        return;
      }

    //Pick the largest (first) primitives to live in this node
    //NOTE: this assumes primitives are sorted by size.
    //NOTE: This step is an optional departure from the original, and we also do a check for it above
    // to compute poly_cut_off.
    if (frags_per_inner) {
      axis = bvh_fatten_inner_node(bvh, nodes, nodeidx, start, end, cb, cbdiag, poly_cut_off);
      start = start + nodes.getPrimCount(nodeidx);
    }

    var split_info = new bvh_split_info();

    //Do the binning of the remaining primitives to go into child nodes
    bvh_bin_axis(bvh, start, end, axis, cb, cbdiag, split_info);

    if (split_info.num_bins < 0) {
      //Split was too costly, so add all objects to the current node and bail
      nodes.setPrimCount(nodeidx, nodes.getPrimCount(nodeidx) + end - start + 1);
      return;
    }

    bvh_partition(bvh, start, end, axis, cb, cbdiag, split_info);

    var child_idx = nodes.nextNodes(2);

    /* set info about split into the node */
    var cleft = (split_info.vb_left[3 + axis] + split_info.vb_left[axis]) * 0.5;
    var cright = (split_info.vb_right[3 + axis] + split_info.vb_right[axis]) * 0.5;

    nodes.setFlags(nodeidx, axis, cleft < cright ? 0 : 1, transparent ? 1 : 0);
    nodes.setLeftChild(nodeidx, child_idx);


    /* validate split */
    /*
    if (true) {
        for (var i=start; i< start+num_left; i++)
        {
            //int binid = (int)(k1 * (info->prim_info[info->bvh->iprims[i]].centroid.v[axis] - cb->min.v[axis]));
            var cen = primitives[i] * POINT_STRIDE;
            if (   centroids[cen] < split_info.cb_left[0]
                || centroids[cen] > split_info.cb_left[3]
                || centroids[cen+1] < split_info.cb_left[1]
                || centroids[cen+1] > split_info.cb_left[4]
                || centroids[cen+2] < split_info.cb_left[2]
                || centroids[cen+2] > split_info.cb_left[5])
            {
                debug ("wrong centroid box");
            }
        }
         for (i=start+num_left; i<=end; i++)
        {
            //int binid = (int)(k1 * (info->prim_info[info->bvh->iprims[i]].centroid.v[axis] - cb->min.v[axis]));
            var cen = primitives[i] * POINT_STRIDE;
            if (   centroids[cen] < split_info.cb_right[0]
                || centroids[cen] > split_info.cb_right[3]
                || centroids[cen+1] < split_info.cb_right[1]
                || centroids[cen+1] > split_info.cb_right[4]
                || centroids[cen+2] < split_info.cb_right[2]
                || centroids[cen+2] > split_info.cb_right[5])
            {
                debug ("wrong centroid box");
            }
        }
    }
    */


    /* recurse */
    //bvh_subdivide(bvh, child_idx, start, start + split_info.num_left - 1, split_info.vb_left, split_info.cb_left, transparent, depth+1);
    //bvh_subdivide(bvh, child_idx + 1, start + split_info.num_left, end, split_info.vb_right, split_info.cb_right, transparent, depth+1);

    //Iterative stack-based recursion for easier profiling
    bvh.recursion_stack.push([bvh, child_idx + 1, start + split_info.num_left, end, split_info.vb_right, split_info.cb_right, transparent, depth + 1]);
    bvh.recursion_stack.push([bvh, child_idx, start, start + split_info.num_left - 1, split_info.vb_left, split_info.cb_left, transparent, depth + 1]);

  }


  function compute_boxes(bvh) {

    var boxv_o = bvh.boxv_o;
    var boxc_o = bvh.boxc_o;
    var boxv_t = bvh.boxv_t;
    var boxc_t = bvh.boxc_t;

    box_make_empty_0(boxv_o);
    box_make_empty_0(boxc_o);
    box_make_empty_0(boxv_t);
    box_make_empty_0(boxc_t);

    var c = bvh.centroids;
    var b = bvh.finfo.boxes;
    var boxStride = bvh.finfo.boxStride;

    for (var i = 0, iEnd = bvh.prim_count; i < iEnd; i++) {

      // find which primitive in the sorted list to use next
      var p = bvh.primitives[i];
      box_get_centroid(c, 3 /*POINT_STRIDE*/ * p, b, boxStride * p);

      if (i >= bvh.first_transparent) {

        box_add_point_0(boxc_t, c, 3 /*POINT_STRIDE*/ * p);
        box_add_box_0(boxv_t, b, boxStride * p);

      } else {

        box_add_point_0(boxc_o, c, 3 /*POINT_STRIDE*/ * p);
        box_add_box_0(boxv_o, b, boxStride * p);

      }
    }

    box_get_size(cbdiag, 0, bvh.boxv_o, 0);
    var maxsz = Math.max(cbdiag[0], cbdiag[1], cbdiag[2]);
    bvh.scene_epsilon = BOX_EPSILON * maxsz;
  }




  //Module exports
  return {
    bvh_subdivide: bvh_subdivide,
    compute_boxes: compute_boxes,
    box_area: box_area
  };

}();


function FragInfo(fragments, materialDefs) {
  //Invariants
  this.boxes = fragments.boxes; //Array of Float32, each bbox is a sextuplet
  this.polygonCounts = fragments.polygonCounts;
  this.hasPolygonCounts = !!this.polygonCounts;
  this.materials = fragments.materials; //material indices (we need to know which fragments are transparent)
  this.materialDefs = materialDefs;
  this.count = fragments.length;
  this.boxStride = 6;
  this.wantSort = true;
}

FragInfo.prototype.getCount = function () {
  return this.count;
};

FragInfo.prototype.isTransparent = function (i) {
  return this.materialDefs && this.materialDefs[this.materials[i]] ? this.materialDefs[this.materials[i]].transparent : false;
};

FragInfo.prototype.getPolygonCount = function (i) {
  return this.polygonCounts[i];
};

/**
 * Given a list of LMV fragments, builds a spatial index for view-dependent traversal and hit testing.
 * @constructor
 */
function BVHBuilder(fragments, materialDefs, finfo) {

  //Initialize the inputs (bboxes, transparent flags, polygon counts)
  this.finfo = finfo || new FragInfo(fragments, materialDefs);

  this.prim_count = this.finfo.getCount();

  //To be initialized by build() function based on build options
  this.frags_per_leaf_node = -1;
  this.frags_per_inner_node = -1;
  this.nodes = null;

  this.work_buf = new ArrayBuffer(this.prim_count * 4);
  this.sort_prims = new Int32Array(this.work_buf);

  //Allocate memory buffer for re-ordered fragment primitive indices,
  //which will be sorted by node ownership and point to the index
  //of the fragment data.
  this.primitives = new Int32Array(this.prim_count);

  //The BVH split algorithm works based on centroids of the bboxes.
  this.centroids = new Float32Array(POINT_STRIDE * this.prim_count);

  //BBoxes and centroid bboxes for opaque and transparent primitive sets
  this.boxv_o = new Float32Array(6);
  this.boxc_o = new Float32Array(6);
  this.boxv_t = new Float32Array(6);
  this.boxc_t = new Float32Array(6);


  this.recursion_stack = [];
}

BVHBuilder.prototype.sortPrimitives = function (wantSort) {

  var prim_sizes = new Float32Array(this.work_buf);
  var primitives = this.primitives;
  var numTransparent = 0;

  //Sort the input objects by size
  //We assume all LMV SVF files come
  //sorted by draw priority already, so in theory we can skip this step.
  //This turns out to not be the case - some fragments are badly sorted.
  //Part of the reason may be that the surface area of the geometry itself,
  //not its bounding box, is used to sort by physical size in LMVTK.
  //In any case, the transparent objects do not always come last (bug in LMVTK?),
  //so we still have to pull them out to the end of the list, so some sorting
  //takes place no matter how this value is set.
  // Turning this option on will mean that the BVH building process as a whole
  // will be 45% to 75% longer, for large models - full sorting takes awhile.
  // In absolute terms this is an increase of a maximum of 1.15 seconds for a
  // very large model (one with over 1 million fragments, i.e., mesh instances).
  // This cost may be acceptable. For smaller models - "only" 70K instances -
  // the cost is 0.05 seconds. For 130k instances, 0.1 seconds. The rise is
  // slightly more than linear, but not excessively slow. I think it's acceptable,
  // given that the cost is still much less than loading even a small part of the
  // model.
  var doSort = wantSort;

  // console.log("BVH sort is " + WANT_SORT);

  var i, iEnd;
  for (i = 0, iEnd = this.prim_count; i < iEnd; i++) {

    //Start with trivial 1:1 order of the indices array
    primitives[i] = i;

    var transparent = this.finfo.isTransparent(i);

    if (transparent)
    numTransparent++;

    if (doSort) {
      prim_sizes[i] = BVHModule.box_area(this.finfo.boxes, this.finfo.boxStride * i);

      //In order to make transparent objects appear last,
      //we give them a negative size, so that they are naturally
      //sorted last in the sort by size.
      if (transparent)
      prim_sizes[i] = -prim_sizes[i];
    } else {
      //We still need the transparency flag for the loop below
      //where we find the last opaque item, but we can
      //short-cut the size computation.
      prim_sizes[i] = transparent ? -1 : 1;
    }
  }


  if (doSort) {
    Array.prototype.sort.call(this.primitives, function (a, b) {
      return prim_sizes[b] - prim_sizes[a];
    });
  } else {
    if (numTransparent && numTransparent < this.prim_count) {

      var tmpTransparent = new Int32Array(numTransparent);
      var oidx = 0,tidx = 0;

      for (i = 0, iEnd = this.prim_count; i < iEnd; i++) {
        if (prim_sizes[i] >= 0)
        primitives[oidx++] = primitives[i];else

        tmpTransparent[tidx++] = primitives[i];
      }

      primitives.set(tmpTransparent, this.prim_count - numTransparent);
    }
  }

  this.first_transparent = this.prim_count - numTransparent;
};


BVHBuilder.prototype.build = function (options) {
  //Kick off the BVH build.

  var useSlimNodes = options && !!options.useSlimNodes;

  var self = this;
  function assign_option(name, defaultVal) {
    if (options.hasOwnProperty(name))
    self[name] = options[name];else

    self[name] = defaultVal;
  }

  // note: frags_per_leaf_node does *not* make an upper limit for the number of frags per node.

  //options for build optimized for rasterization renderer scenes
  if (useSlimNodes) {
    assign_option("frags_per_leaf_node", 1);
    assign_option("frags_per_inner_node", 0);
    assign_option("frags_per_leaf_node_transparent", 1);
    assign_option("frags_per_inner_node_transparent", 0);
    assign_option("max_polys_per_node", Infinity);
  } else {
    var multiplier = options.isWeakDevice ? 0.5 : 1.0;

    //TODO: tune these constants
    assign_option("frags_per_leaf_node", 0 | 256 * multiplier);
    //Placing fragments at inner nodes places more emphasis on bigger objects during tree traversal
    //but it can only be done for opaque objects. Transparent objects have to be strictly back to front
    //traversal regardless of size, unless a unified traversal
    assign_option("frags_per_inner_node", 0 | this.frags_per_leaf_node);
    assign_option("frags_per_leaf_node_transparent", this.frags_per_leaf_node);
    assign_option("frags_per_inner_node_transparent", 0);
    assign_option("max_polys_per_node", 0 | 20000 * multiplier);
  }

  //Reuse existing node array if there
  if (this.nodes && this.nodes.is_lean_node == useSlimNodes)
  this.nodes.nodeCount = 0;else
  {
    var est_nodes = this.prim_count / this.frags_per_leaf_node;
    var num_nodes = 1;
    while (num_nodes < est_nodes)
    num_nodes *= 2;

    this.nodes = new NodeArray(num_nodes, options ? options.useSlimNodes : false);
  }

  this.sortPrimitives(this.finfo.wantSort);

  BVHModule.compute_boxes(this);

  //Init the root nodes at 0 for opaque
  //and 1 for transparent objects
  var root = this.nodes.nextNodes(2);

  //Now kick off the recursive tree build

  //Opaque
  BVHModule.bvh_subdivide(this, root, 0, this.first_transparent - 1, this.boxv_o, this.boxc_o, false, 0);

  var a;
  while (this.recursion_stack.length) {
    a = this.recursion_stack.pop();
    BVHModule.bvh_subdivide(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
  }

  //Transparent
  BVHModule.bvh_subdivide(this, root + 1, this.first_transparent, this.prim_count - 1, this.boxv_t, this.boxc_t, true, 0);

  while (this.recursion_stack.length) {
    a = this.recursion_stack.pop();
    BVHModule.bvh_subdivide(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
  }
};

/***/ }),

/***/ "./src/wgs/scene/BufferGeometryUtils.js":
/*!**********************************************!*\
  !*** ./src/wgs/scene/BufferGeometryUtils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getByteSize: () => (/* binding */ getByteSize),
/* harmony export */   getIndexBufferArray: () => (/* binding */ getIndexBufferArray),
/* harmony export */   getLineIndexBufferArray: () => (/* binding */ getLineIndexBufferArray),
/* harmony export */   getPolygonCount: () => (/* binding */ getPolygonCount),
/* harmony export */   isInterleavedGeometry: () => (/* binding */ isInterleavedGeometry)
/* harmony export */ });





























































/**
 * Checks if any attribute is an interleaved buffer, as LMV assumes all or none attributes are interleaved
 * @param {BufferGeometry} geom
 * @returns {boolean}
 */
function isInterleavedGeometry(geom) {
  let result;

  result = !!geom.vb;






  return result;
}

/**
 * Convenience accessor to the indices (index buffer or 'ib') of a given geometry.
 *
 * @param {BufferGeometry} geometry - Geometry to grab the index buffer array from.
 * @returns {Uint16Array} - Typed array containing the indices of the given geometry.
 */
function getIndexBufferArray(geometry) {
  let ib;

  ib = geometry.ib;




  return ib;
}

/**
 * Convenience accessor to the edge/line indices (indexline buffer or 'iblines') of a given geometry.
 *
 * @param {BufferGeometry} geometry - Geometry to grab the edge/line index buffer array from.
 * @returns {Uint16Array} - Typed array containing the edge/line indices of the given geometry.
 */
function getLineIndexBufferArray(geometry) {
  let iblines;

  iblines = geometry.iblines;



  return iblines;
}

// @todo: An accurate implementation for the polygon count is in GeometryList.addGeometry.
// This function just captures the typical polyCount behavior used in most extensions.
function getPolygonCount(geometry) {var _geometry$attributes$;
  if (!geometry) {
    return 0;
  }

  let indexLength = 0;

  const ib = ((_geometry$attributes$ = geometry.attributes.index) === null || _geometry$attributes$ === void 0 ? void 0 : _geometry$attributes$.array) || geometry.ib;
  indexLength = ib.length;





  return indexLength / 3 || 0;
}

function getByteSize(geom) {var _geom$vb, _geom$ib, _geom$iblines;
  // @todo - To avoid wrong byte size reporting, the geometry should keep track of this itself.
  let res = 0;

  res = (((_geom$vb = geom.vb) === null || _geom$vb === void 0 ? void 0 : _geom$vb.byteLength) || 0) + (((_geom$ib = geom.ib) === null || _geom$ib === void 0 ? void 0 : _geom$ib.byteLength) || 0) + (((_geom$iblines = geom.iblines) === null || _geom$iblines === void 0 ? void 0 : _geom$iblines.byteLength) || 0);





  return res;
}

/***/ }),

/***/ "./src/wgs/scene/DeriveTopology.js":
/*!*****************************************!*\
  !*** ./src/wgs/scene/DeriveTopology.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeshAccessor: () => (/* binding */ MeshAccessor),
/* harmony export */   createWireframe: () => (/* binding */ createWireframe)
/* harmony export */ });
/* harmony import */ var _VertexEnumerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VertexEnumerator */ "./src/wgs/scene/VertexEnumerator.js");
/* harmony import */ var _LmvVector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LmvVector3 */ "./src/wgs/scene/LmvVector3.js");
/* harmony import */ var _LmvBox3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LmvBox3 */ "./src/wgs/scene/LmvBox3.js");
/* harmony import */ var _extensions_CompGeom_point_list_3d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../extensions/CompGeom/point-list-3d */ "./extensions/CompGeom/point-list-3d.js");





// @todo: exports of this file cannot access THREE, due to some worker thread constraints (e.g., GeomWorker).
// Perhaps the import of THREE can be restricted using webpack (e.g., custom restrict-import-loader) or
// custom linter rules (e.g., https://eslint.org/docs/latest/rules/no-restricted-imports).

// @todo: This class seems to have a misleading name (and no documentation). It defines a
// MeshAccessor and a helper for Wireframe (edges?) creation. There is nothing that involves
// geometric topology nor any actual derivation of sth.

function getVertices(geom, bbox) {

  var vbuf = new Float32Array(3 * (0,_VertexEnumerator__WEBPACK_IMPORTED_MODULE_0__.getVertexCount)(geom));

  function cb(v, n, uv, i) {
    if (bbox) {
      bbox.expandByPoint(v);
    }
    vbuf[3 * i] = v.x;
    vbuf[3 * i + 1] = v.y;
    vbuf[3 * i + 2] = v.z;
  }

  (0,_VertexEnumerator__WEBPACK_IMPORTED_MODULE_0__.enumMeshVertices)(geom, cb);

  return vbuf;
}

function transformVertices(verts, toWorld) {

  let _v1 = new _LmvVector3__WEBPACK_IMPORTED_MODULE_1__.LmvVector3();

  for (let i = 0; i < verts.length; i += 3) {
    _v1.x = verts[i];
    _v1.y = verts[i + 1];
    _v1.z = verts[i + 2];

    _v1.applyMatrix4(toWorld);

    verts[i] = _v1.x;
    verts[i + 1] = _v1.y;
    verts[i + 2] = _v1.z;
  }
}

let _v1 = new _LmvVector3__WEBPACK_IMPORTED_MODULE_1__.LmvVector3();
let _v2 = new _LmvVector3__WEBPACK_IMPORTED_MODULE_1__.LmvVector3();
let _v3 = new _LmvVector3__WEBPACK_IMPORTED_MODULE_1__.LmvVector3();
let _n1 = new _LmvVector3__WEBPACK_IMPORTED_MODULE_1__.LmvVector3();
let _n2 = new _LmvVector3__WEBPACK_IMPORTED_MODULE_1__.LmvVector3();

class MeshAccessor {

  constructor(geom, toWorld, boundingBox) {

    let inBox = geom.boundingBox || boundingBox;
    let box = new _LmvBox3__WEBPACK_IMPORTED_MODULE_2__.LmvBox3();
    if (inBox) {
      box.copy(inBox);
    }

    this.geom = geom;
    this.myVerts = getVertices(geom, inBox ? null : box);

    //de-duplicate vertices based on position only (ignoring normals)
    let upl = new _extensions_CompGeom_point_list_3d__WEBPACK_IMPORTED_MODULE_3__.UniquePointList3D(this.getV.bind(this), box, -1.0 / (1 << 16));
    this.remap = new Array((0,_VertexEnumerator__WEBPACK_IMPORTED_MODULE_0__.getVertexCount)(geom));
    for (let i = 0, j = 0; i < this.myVerts.length; i += 3, j++) {
      this.remap[j] = upl.findOrAddPoint(this.myVerts[i], this.myVerts[i + 1], this.myVerts[i + 2], j);
    }
    /*
            let remap = new Array(getVertexCount(geom));
            for (let i=0,j=0; i<worldVerts.length; i+=3,j++) {
                remap[j] = j;
            }
    */

    //get vertices into world space -- we need this for
    //correct angle calculations (in case there is non-uniform scaling, etc)
    if (toWorld) {
      transformVertices(this.myVerts, toWorld);
    }

  }

  getV(i, v) {
    v.x = this.myVerts[3 * i];
    v.y = this.myVerts[3 * i + 1];
    v.z = this.myVerts[3 * i + 2];
  }

  getNormal(i1, i2, i3, n) {
    this.getV(i1, _v1);
    this.getV(i2, _v2);
    this.getV(i3, _v3);

    _v2.sub(_v1);
    _v3.sub(_v1);
    _v2.cross(_v3);

    n.copy(_v2).normalize();
  }
}

// @todo: instead of enriching geom, the edges (indexlines) should be returned as typed array
// and used as required by the caller.
function createWireframe(geom, toWorld, boundingBox, wantAllTriangleEdges) {

  // note: Wide line geometries are actual 3D geometry meshes and do not require a dedicated treatment here.
  // @todo: make this a convenience query, e.g., in BufferGeometryUtils.
  const linesPresent = 'isLines' in geom && geom.isLines ||
  'indexlines' in geom || 'iblines' in geom;

  if (linesPresent) {
    return;
  }

  let mt = new MeshAccessor(geom, toWorld, boundingBox);

  //loop over all triangles, keeping track of
  //edges that seem important
  var seenEdges = {};

  var edgeIB = [];

  function doOneEdge(i1orig, i2orig, opp1orig) {

    var i1 = mt.remap[i1orig];
    var i2 = mt.remap[i2orig];
    var opp1 = mt.remap[opp1orig];

    //Ignore degenerates
    if (i1 === i2 || i1 === opp1 || i2 === opp1)
    return;

    var reversed = false;
    if (i1 > i2) {
      var tmp = i1;
      i1 = i2;
      i2 = tmp;
      reversed = true;
    }

    var e1 = seenEdges[i1];
    if (e1) {
      var opp2orig = e1[i2];
      if (opp2orig === undefined) {
        e1[i2] = reversed ? -opp1orig - 1 : opp1orig;
      } else {
        //We now know two triangles that share this edge,
        //we can check if it's important

        if (!wantAllTriangleEdges) {
          //Use original indices, so that we
          //can do the math with the correct winding order
          mt.getNormal(i1orig, i2orig, opp1orig, _n1);

          if (opp2orig < 0) {
            mt.getNormal(i2, i1, mt.remap[-opp2orig - 1], _n2);
          } else {
            mt.getNormal(i1, i2, mt.remap[opp2orig], _n2);
          }

          var dot = _n1.dot(_n2);

          if (Math.abs(dot) < 0.25) {
            edgeIB.push(i1orig);
            edgeIB.push(i2orig);
          }
        } else {
          edgeIB.push(i1orig);
          edgeIB.push(i2orig);
        }

        delete e1[i2];
      }
    } else {
      seenEdges[i1] = {};
      seenEdges[i1][i2] = opp1orig;
    }
  }

  function tricb(vA, vB, vC, iA, iB, iC) {
    doOneEdge(iA, iB, iC);
    doOneEdge(iB, iC, iA);
    doOneEdge(iC, iA, iB);
  }

  //find edges that have neighboring triangles at sharp angle
  (0,_VertexEnumerator__WEBPACK_IMPORTED_MODULE_0__.enumMeshTriangles)(geom, tricb);

  //process remaining edges (outer edges that only have one triangle)

  for (var i1 in seenEdges) {
    for (var i2 in seenEdges[i1]) {
      edgeIB.push(parseInt(i1));
      edgeIB.push(parseInt(i2));
    }
  }

  if (edgeIB.length < 2) {
    return;
  }

  // @todo: enrichment of buffer geometry/mesh should be either encapsulated or type-safe
  // @todo: modelBuilder is calling this function with BufferGeometry objects, this is the one of
  // two uses within the code base, and since THREE is not available here, the addGeometry
  // function of model builder is adjusted accordingly. When called with a mesh object (e.g., in
  // GeomWorker) the same enrichment is applied. Instead, this function should just return the
  // results and let the caller handle the data: return edgeIB.length > 1 ? edgeIB : undefined;
  geom.iblines = new Uint16Array(edgeIB.length);
  geom.iblines.set(edgeIB);

  /*
  for (var i=0; i<geom.ib.length; i++) {
      geom.ib[i] = remap[geom.ib[i]];
  }
  */
}

/***/ }),

/***/ "./src/wgs/scene/InstanceTreeStorage.js":
/*!**********************************************!*\
  !*** ./src/wgs/scene/InstanceTreeStorage.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FlatStringStorage: () => (/* binding */ FlatStringStorage),
/* harmony export */   InstanceTreeAccess: () => (/* binding */ InstanceTreeAccess),
/* harmony export */   InstanceTreeStorage: () => (/* binding */ InstanceTreeStorage)
/* harmony export */ });
/* harmony import */ var _file_loaders_lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../file-loaders/lmvtk/common/StringUtils */ "./src/file-loaders/lmvtk/common/StringUtils.js");




class FlatStringStorage {

  constructor(initial) {
    if (initial) {
      this.buf = initial.buf;
      this.idx = initial.idx;
      this.next = initial.next;
    } else {
      this.buf = new Uint8Array(256);
      this.next = 0;
      this.idx = [0];
    }
  }

  allocate(len) {
    if (this.buf.length - this.next < len) {
      var nsz = Math.max(this.buf.length * 3 / 2, this.buf.length + len);
      var nb = new Uint8Array(nsz);
      nb.set(this.buf);
      this.buf = nb;
    }
  }

  add(s) {
    if (s === null || typeof s === "undefined") {
      return 0;
    }

    if (!s.length) {
      this.idx.push(this.next);
      return this.idx.length - 1;
    }

    var len = (0,_file_loaders_lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.utf16to8)(s, null);
    this.allocate(len);
    this.next += (0,_file_loaders_lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.utf16to8)(s, this.buf, this.next);
    this.idx.push(this.next);
    return this.idx.length - 1;
  }

  get(i) {
    if (!i) {
      return undefined;
    }

    var start = this.idx[i - 1];
    var end = this.idx[i];
    if (start === end)
    return "";
    return (0,_file_loaders_lmvtk_common_StringUtils__WEBPACK_IMPORTED_MODULE_0__.utf8BlobToStr)(this.buf, start, end - start);
  }

  flatten() {
    this.idx = arrayToBuffer(this.idx);
    //TODO: we could also clip this.buf to the actually used size, but that requires reallocation
  }
}



//
// struct Node {
//     int dbId;
//     int parentDbId;
//     int firstChild; //if negative it's a fragment list
//     int numChildren;
//     int flags;   
// };
// sizeof(Node) == 20
var SIZEOF_NODE = 5, //integers
  OFFSET_DBID = 0,
  OFFSET_PARENT = 1,
  OFFSET_FIRST_CHILD = 2,
  OFFSET_NUM_CHILD = 3,
  OFFSET_FLAGS = 4;

function InstanceTreeStorage() {

  this.nodes = [];
  this.nextNode = 0;

  this.children = [];
  this.nextChild = 0;

  this.dbIdToIndex = {};

  this.names = [];
  this.s2i = {}; //duplicate string pool
  this.strings = new FlatStringStorage();
  this.nameSuffixes = []; //integers

  //Occupy index zero so that we can use index 0 as undefined
  this.getIndex(0);
}

InstanceTreeStorage.prototype.getIndex = function (dbId) {

  var index = this.dbIdToIndex[dbId];

  if (index)
  return index;

  index = this.nextNode++;

  //Allocate space for new node
  this.nodes.push(dbId); //store the dbId as first integer in the Node structure
  //Add four blank integers to be filled by setNode
  for (var i = 1; i < SIZEOF_NODE; i++)
  this.nodes.push(0);

  this.dbIdToIndex[dbId] = index;

  return index;
};

InstanceTreeStorage.prototype.setNode = function (dbId, parentDbId, name, flags, childrenIds, fragIds) {

  var index = this.getIndex(dbId);

  var baseOffset = index * SIZEOF_NODE;

  var numChildren = childrenIds.length;
  var hasFragments = fragIds && fragIds.length;
  if (hasFragments) {
    numChildren += fragIds.length;
  }

  this.nodes[baseOffset + OFFSET_PARENT] = parentDbId;
  this.nodes[baseOffset + OFFSET_FIRST_CHILD] = this.nextChild;
  this.nodes[baseOffset + OFFSET_NUM_CHILD] = hasFragments ? -numChildren : numChildren;
  this.nodes[baseOffset + OFFSET_FLAGS] = flags;

  var i;
  for (i = 0; i < childrenIds.length; i++)
  this.children[this.nextChild++] = this.getIndex(childrenIds[i]);

  //Store fragIds as negative numbers so we can differentiate them when looking through
  //the array later.
  if (hasFragments) {
    for (i = 0; i < fragIds.length; i++)
    this.children[this.nextChild++] = -fragIds[i] - 1; //index 0 stored as -1, etc., since 0 is not negative
  }

  if (this.nextChild > this.children.length) {
    // TODO: this code may run in a worker, replace console with something else
    console.error("Child index out of bounds -- should not happen");
  }

  this.processName(index, name);
};

InstanceTreeStorage.prototype.processName = function (index, name) {

  //Attempt to decompose the name into a base string + integer,
  //like for example "Base Wall [12345678]" or "Crank Shaft:1"
  //We will try to reduce memory usage by storing "Base Wall" just once.
  var base;
  var suffix;

  //Try Revit style [1234] first
  var iStart = -1;
  var iEnd = -1;

  if (name) {//name should not be empty, but hey, it happens.
    iEnd = name.lastIndexOf("]");
    iStart = name.lastIndexOf("[");

    //Try Inventor style :1234
    if (iStart === -1 || iEnd === -1) {
      iStart = name.lastIndexOf(":");
      iEnd = name.length;
    }
  }

  //TODO: Any other separators? What does AutoCAD use?

  if (iStart >= 0 && iEnd > iStart) {
    base = name.slice(0, iStart + 1);
    var ssuffix = name.slice(iStart + 1, iEnd);
    suffix = parseInt(ssuffix, 10);

    //make sure we get the same thing back when
    //converting back to string, otherwise don't 
    //decompose it.
    if (!suffix || suffix + "" !== ssuffix) {
      base = name;
      suffix = 0;
    }
  } else {
    base = name;
    suffix = 0;
  }


  var idx = this.s2i[base];
  if (idx === undefined) {
    idx = this.strings.add(base);
    this.s2i[base] = idx;
  }

  this.names[index] = idx;
  this.nameSuffixes[index] = suffix;
};


function arrayToBuffer(a) {
  var b = new Int32Array(a.length);
  b.set(a);
  return b;
}

InstanceTreeStorage.prototype.flatten = function () {
  this.nodes = arrayToBuffer(this.nodes);
  this.children = arrayToBuffer(this.children);
  this.names = arrayToBuffer(this.names);
  this.nameSuffixes = arrayToBuffer(this.nameSuffixes);
  this.strings.flatten();
  this.s2i = null; //we don't need this temporary map once we've built the strings list
};



function InstanceTreeAccess(nodeArray, rootId, nodeBoxes) {
  this.nodes = nodeArray.nodes;
  this.children = nodeArray.children;
  this.dbIdToIndex = nodeArray.dbIdToIndex;
  this.names = nodeArray.names;
  this.nameSuffixes = nodeArray.nameSuffixes;
  this.strings = new FlatStringStorage(nodeArray.strings);
  this.rootId = rootId;
  this.numNodes = this.nodes.length / SIZEOF_NODE;
  this.visibleIds = null;

  // only used if bboxes are precomputed
  this.nodeBoxes = nodeBoxes;
}

InstanceTreeAccess.prototype.dtor = function () {
  this.nodes = null;
  this.children = null;
  this.dbIdToIndex = null;
  this.names = null;
  this.nameSuffixes = null;
  this.strings = null;
  this.visibleIds = null;
  this.nodeBoxes = null;
};

InstanceTreeAccess.prototype.getNumNodes = function () {
  return this.numNodes;
};

InstanceTreeAccess.prototype.getIndex = function (dbId) {
  return this.dbIdToIndex[dbId];
};

InstanceTreeAccess.prototype.name = function (dbId, includeCount) {
  var idx = this.dbIdToIndex[dbId];
  var base = this.strings.get(this.names[idx]);
  var suffix = this.nameSuffixes[idx];
  var name;
  if (suffix) {
    //NOTE: update this logic if more separators are supported in processName above
    var lastChar = base.charAt(base.length - 1);
    if (lastChar === "[")
    name = base + suffix + "]";else

    name = base + suffix;
  } else {
    name = base;
  }

  if (includeCount) {
    if (!this.childCounts) {
      this.computeChildCounts();
    }
    if (this.childCounts[dbId] > 0) {
      name += " (" + this.childCounts[dbId] + ")";
    }
  }

  return name;
};

InstanceTreeAccess.prototype.getParentId = function (dbId) {
  var idx = this.dbIdToIndex[dbId];
  return this.nodes[idx * SIZEOF_NODE + OFFSET_PARENT];
};

InstanceTreeAccess.prototype.getNodeFlags = function (dbId) {
  var idx = this.dbIdToIndex[dbId];
  return this.nodes[idx * SIZEOF_NODE + OFFSET_FLAGS];
};

InstanceTreeAccess.prototype.setNodeFlags = function (dbId, flags) {
  var idx = this.dbIdToIndex[dbId];
  if (idx) {
    this.nodes[idx * SIZEOF_NODE + OFFSET_FLAGS] = flags;
  }
};

InstanceTreeAccess.prototype.getNumChildren = function (dbId) {

  var idx = this.dbIdToIndex[dbId];
  var numChildren = this.nodes[idx * SIZEOF_NODE + OFFSET_NUM_CHILD];

  //If numChildren is non-negative, then all children are nodes (not fragments)
  if (numChildren >= 0)
  return numChildren;

  //Node has mixed fragments and child nodes, so we have to loop and collect just the node children
  var firstChild = this.nodes[idx * SIZEOF_NODE + OFFSET_FIRST_CHILD];

  numChildren = Math.abs(numChildren);

  var numNodeChildren = 0;

  for (var i = 0; i < numChildren; i++) {
    var childIdx = this.children[firstChild + i];

    //did we reach the fragment ids sub-list?
    if (childIdx < 0)
    break;

    numNodeChildren++;
  }

  return numNodeChildren;
};

InstanceTreeAccess.prototype.getNumFragments = function (dbId) {
  var idx = this.dbIdToIndex[dbId];

  var numChildren = this.nodes[idx * SIZEOF_NODE + OFFSET_NUM_CHILD];

  //If numChildren is non-negative, there aren't any fragments belonging to this node
  if (numChildren >= 0)
  return 0;

  //Node has mixed fragments and child nodes, so we have to loop and collect just the node children
  var firstChild = this.nodes[idx * SIZEOF_NODE + OFFSET_FIRST_CHILD];

  numChildren = Math.abs(numChildren);

  var numFragChildren = 0;

  //Iterate backwards, because fragment children are at the back of the children list
  for (var i = numChildren - 1; i >= 0; i--) {
    var childIdx = this.children[firstChild + i];

    //did we reach the inner node children ids sub-list?
    if (childIdx >= 0)
    break;

    numFragChildren++;
  }

  return numFragChildren;
};

// NOTE: This can only be used if precomputed bboxes are available.
InstanceTreeAccess.prototype.getNodeBox = function (dbId, dst) {
  var idx = this.getIndex(dbId);
  var off = idx * 6;
  for (var i = 0; i < 6; i++)
  dst[i] = this.nodeBoxes[off + i];
};

//Returns an array containing the dbIds of all objects
//that are physically represented in the scene. Not all
//objects in the property database occur physically in each graphics viewable.
InstanceTreeAccess.prototype.getVisibleIds = function () {
  if (!this.visibleIds) {
    this.visibleIds = Object.keys(this.dbIdToIndex).map(function (k) {return parseInt(k);});
  }

  return this.visibleIds;
};


InstanceTreeAccess.prototype.enumNodeChildren = function (dbId, callback) {
  var idx = this.dbIdToIndex[dbId];
  var firstChild = this.nodes[idx * SIZEOF_NODE + OFFSET_FIRST_CHILD];
  var numChildren = this.nodes[idx * SIZEOF_NODE + OFFSET_NUM_CHILD];

  numChildren = Math.abs(numChildren);

  for (var i = 0; i < numChildren; i++) {
    var childIdx = this.children[firstChild + i];

    //did we reach the fragment ids sub-list?
    if (childIdx < 0)
    break;

    var childDbId = this.nodes[childIdx * SIZEOF_NODE + OFFSET_DBID];
    if (callback(childDbId, dbId, idx)) {
      return dbId;
    }
  }
};

InstanceTreeAccess.prototype.enumNodeFragments = function (dbId, callback) {
  var idx = this.dbIdToIndex[dbId];
  var firstChild = this.nodes[idx * SIZEOF_NODE + OFFSET_FIRST_CHILD];
  var numChildren = this.nodes[idx * SIZEOF_NODE + OFFSET_NUM_CHILD];

  //If numChildren is negative, it means there are fragments in the node
  if (numChildren < 0) {
    numChildren = -numChildren;
    for (var i = 0; i < numChildren; i++) {
      var childIdx = this.children[firstChild + i];

      //skip past children that are inner nodes (not fragments)
      if (childIdx > 0)
      continue;

      //Convert fragId from -1 based negative back to the actual fragId
      if (callback(-childIdx - 1, dbId, idx)) {
        return dbId;
      }
    }
  }
};

InstanceTreeAccess.prototype.computeBoxes = function (fragBoxes) {

  if (!this.nodeBoxes) {
    this.nodeBoxes = new Float32Array(6 * this.numNodes);
  }

  var nodeAccess = this;
  var idx = nodeAccess.getIndex(nodeAccess.rootId);
  var nodeBoxes = nodeAccess.nodeBoxes;

  function traverseChildren(child_dbId, parentDbID, parentIdx) {

    var childIdx = nodeAccess.getIndex(child_dbId);

    //Recurse, then add all child boxes to make this node's box
    computeTreeBBoxesRec(child_dbId, childIdx);

    var box_offset = parentIdx * 6;
    var child_box_offset = childIdx * 6;
    for (var k = 0; k < 3; k++) {
      if (nodeBoxes[box_offset + k] > nodeBoxes[child_box_offset + k])
      nodeBoxes[box_offset + k] = nodeBoxes[child_box_offset + k];
      if (nodeBoxes[box_offset + k + 3] < nodeBoxes[child_box_offset + k + 3])
      nodeBoxes[box_offset + k + 3] = nodeBoxes[child_box_offset + k + 3];
    }
  }

  function traverseFragments(fragId, dbId, idx) {
    var frag_box_offset = fragId * 6;
    var box_offset = idx * 6;

    for (var k = 0; k < 3; k++) {
      if (nodeBoxes[box_offset + k] > fragBoxes[frag_box_offset + k])
      nodeBoxes[box_offset + k] = fragBoxes[frag_box_offset + k];
      if (nodeBoxes[box_offset + k + 3] < fragBoxes[frag_box_offset + k + 3])
      nodeBoxes[box_offset + k + 3] = fragBoxes[frag_box_offset + k + 3];
    }
  }

  function computeTreeBBoxesRec(dbId, idx) {

    var box_offset = idx * 6;
    nodeBoxes[box_offset] = nodeBoxes[box_offset + 1] = nodeBoxes[box_offset + 2] = Infinity;
    nodeBoxes[box_offset + 3] = nodeBoxes[box_offset + 4] = nodeBoxes[box_offset + 5] = -Infinity;

    if (nodeAccess.getNumChildren(dbId)) {
      nodeAccess.enumNodeChildren(dbId, traverseChildren, true);
    }

    //Leaf node -- don't think it's possible for a node to have
    //both children and leaf fragments, but we do handle that here.
    if (nodeAccess.getNumFragments(dbId)) {
      nodeAccess.enumNodeFragments(dbId, traverseFragments);
    }

  }

  computeTreeBBoxesRec(nodeAccess.rootId, idx);
};

InstanceTreeAccess.prototype.computeChildCounts = function () {
  if (!this.childCounts) {
    this.childCounts = new Uint32Array(this.numNodes);
  }

  var nodeAccess = this;
  var idx = nodeAccess.getIndex(nodeAccess.rootId);
  var childCounts = nodeAccess.childCounts;

  function traverseChildren(child_dbId, parentDbID, parentIdx) {

    var childIdx = nodeAccess.getIndex(child_dbId);

    //Recurse, then add all child boxes to make this node's box
    let count = computeChildCountsRec(child_dbId, childIdx);

    childCounts[parentDbID] += count;
  }


  function computeChildCountsRec(dbId, idx) {

    let flags = nodeAccess.getNodeFlags(dbId);
    let myCount = 0;

    if (flags === 0x4 /*NODE_TYPE_COMPOSITE*/) {
      //If it's a composite node, treat it as a single
      //opaque object whose contents don't matter to the user
      //for counting purposes.
      myCount = 1;
    } else {

      if (nodeAccess.getNumChildren(dbId)) {
        nodeAccess.enumNodeChildren(dbId, traverseChildren, true);
      }

      //Leaf node
      if (nodeAccess.getNumFragments(dbId)) {
        myCount = 1;
      }
    }

    return myCount + childCounts[dbId];
  }

  computeChildCountsRec(nodeAccess.rootId, idx);
};

/***/ }),

/***/ "./src/wgs/scene/LmvBox3.js":
/*!**********************************!*\
  !*** ./src/wgs/scene/LmvBox3.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LmvBox3: () => (/* binding */ LmvBox3)
/* harmony export */ });
/* harmony import */ var _LmvVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LmvVector3 */ "./src/wgs/scene/LmvVector3.js");
/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */
/* Pruned version of THREE.Box3, for use in the LMV web worker */



let LmvBox3 = function (min, max) {

  this.min = min !== undefined ? min : new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(Infinity, Infinity, Infinity);
  this.max = max !== undefined ? max : new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(-Infinity, -Infinity, -Infinity);

};

LmvBox3.prototype = {

  constructor: LmvBox3,

  set: function (min, max) {

    this.min.copy(min);
    this.max.copy(max);

    return this;

  },

  setFromPoints: function (points) {

    this.makeEmpty();

    for (var i = 0, il = points.length; i < il; i++) {

      this.expandByPoint(points[i]);

    }

    return this;

  },

  setFromArray: function (array, offset) {

    this.min.x = array[offset];
    this.min.y = array[offset + 1];
    this.min.z = array[offset + 2];

    this.max.x = array[offset + 3];
    this.max.y = array[offset + 4];
    this.max.z = array[offset + 5];

    return this;

  },

  copyToArray: function (array, offset) {

    array[offset] = this.min.x;
    array[offset + 1] = this.min.y;
    array[offset + 2] = this.min.z;

    array[offset + 3] = this.max.x;
    array[offset + 4] = this.max.y;
    array[offset + 5] = this.max.z;

  },

  setFromCenterAndSize: function () {

    var v1 = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();

    return function (center, size) {

      var halfSize = v1.copy(size).multiplyScalar(0.5);

      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);

      return this;

    };

  }(),

  clone: function () {

    return new this.constructor().copy(this);

  },

  copy: function (box) {

    this.min.copy(box.min);
    this.max.copy(box.max);

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;

    return this;

  },

  empty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;

  },

  isEmpty: function () {
    // threejs backport - https://github.com/mrdoob/three.js/blob/dev/src/math/Box3.js
    return this.empty();
  },

  center: function (optionalTarget) {
    console.warn("LmvBox3.center() is deprecated. Use LmvBox3.getCenter() instead.");
    return this.getCenter(optionalTarget);
  },

  getCenter: function (optionalTarget) {

    var result = optionalTarget || new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    return result.addVectors(this.min, this.max).multiplyScalar(0.5);

  },

  size: function (optionalTarget) {

    var result = optionalTarget || new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    return result.subVectors(this.max, this.min);

  },

  // For compatibility with latest THREE
  getSize: function (optionalTarget) {

    var result = optionalTarget || new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    return result.subVectors(this.max, this.min);

  },

  expandByPoint: function (point) {

    this.min.min(point);
    this.max.max(point);

    return this;

  },

  expandByVector: function (vector) {

    this.min.sub(vector);
    this.max.add(vector);

    return this;

  },

  expandByScalar: function (scalar) {

    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);

    return this;

  },

  containsPoint: function (point) {

    if (point.x < this.min.x || point.x > this.max.x ||
    point.y < this.min.y || point.y > this.max.y ||
    point.z < this.min.z || point.z > this.max.z) {

      return false;

    }

    return true;

  },

  containsBox: function (box) {

    if (this.min.x <= box.min.x && box.max.x <= this.max.x &&
    this.min.y <= box.min.y && box.max.y <= this.max.y &&
    this.min.z <= box.min.z && box.max.z <= this.max.z) {

      return true;

    }

    return false;

  },

  getParameter: function (point, optionalTarget) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();

    return result.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );

  },

  isIntersectionBox: function (box) {

    // using 6 splitting planes to rule out intersections.

    if (box.max.x < this.min.x || box.min.x > this.max.x ||
    box.max.y < this.min.y || box.min.y > this.max.y ||
    box.max.z < this.min.z || box.min.z > this.max.z) {

      return false;

    }

    return true;

  },

  // For compatibility with latest THREE
  intersectsBox: function (box) {
    return this.isIntersectionBox(box);
  },

  clampPoint: function (point, optionalTarget) {

    var result = optionalTarget || new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    return result.copy(point).clamp(this.min, this.max);

  },

  distanceToPoint: function () {

    var v1 = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();

    return function (point) {

      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();

    };

  }(),

  intersect: function (box) {

    this.min.max(box.min);
    this.max.min(box.max);

    return this;

  },

  union: function (box) {

    this.min.min(box.min);
    this.max.max(box.max);

    return this;

  },

  applyMatrix4: function () {

    var points = [
    new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(),
    new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(),
    new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(),
    new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(),
    new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(),
    new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(),
    new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3(),
    new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3()];


    return function (matrix) {

      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

      this.makeEmpty();
      this.setFromPoints(points);

      return this;

    };

  }(),

  translate: function (offset) {

    this.min.add(offset);
    this.max.add(offset);

    return this;

  },

  equals: function (box) {

    return box.min.equals(this.min) && box.max.equals(this.max);

  }

};

/***/ }),

/***/ "./src/wgs/scene/LmvMatrix4.js":
/*!*************************************!*\
  !*** ./src/wgs/scene/LmvMatrix4.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LmvMatrix4: () => (/* binding */ LmvMatrix4)
/* harmony export */ });
/* harmony import */ var _LmvVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LmvVector3 */ "./src/wgs/scene/LmvVector3.js");
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */
/* Pruned version of THREE.Matrix4, for use in the LMV web worker */



let LmvMatrix4 = function (useDoublePrecision) {

  if (useDoublePrecision) {

    this.elements = new Float64Array([

    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1]

    );

  } else {

    this.elements = new Float32Array([

    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1]

    );

  }

  this.isDoublePrecision = !!useDoublePrecision;

};

LmvMatrix4.prototype = {

  constructor: LmvMatrix4,

  set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {

    var te = this.elements;

    te[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;
    te[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;
    te[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;
    te[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1

    );

    return this;

  },

  copy: function (m) {

    this.elements.set(m.elements);

    return this;

  },

  makeRotationFromQuaternion: function (q) {

    var te = this.elements;

    var x = q.x,y = q.y,z = q.z,w = q.w;
    var x2 = x + x,y2 = y + y,z2 = z + z;
    var xx = x * x2,xy = x * y2,xz = x * z2;
    var yy = y * y2,yz = y * z2,zz = z * z2;
    var wx = w * x2,wy = w * y2,wz = w * z2;

    te[0] = 1 - (yy + zz);
    te[4] = xy - wz;
    te[8] = xz + wy;

    te[1] = xy + wz;
    te[5] = 1 - (xx + zz);
    te[9] = yz - wx;

    te[2] = xz - wy;
    te[6] = yz + wx;
    te[10] = 1 - (xx + yy);

    // last column
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;

    // bottom row
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;

    return this;

  },

  multiply: function (n) {

    return this.multiplyMatrices(this, n);

  },

  multiplyMatrices: function (a, b) {

    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;

    var a11 = ae[0],a12 = ae[4],a13 = ae[8],a14 = ae[12];
    var a21 = ae[1],a22 = ae[5],a23 = ae[9],a24 = ae[13];
    var a31 = ae[2],a32 = ae[6],a33 = ae[10],a34 = ae[14];
    var a41 = ae[3],a42 = ae[7],a43 = ae[11],a44 = ae[15];

    var b11 = be[0],b12 = be[4],b13 = be[8],b14 = be[12];
    var b21 = be[1],b22 = be[5],b23 = be[9],b24 = be[13];
    var b31 = be[2],b32 = be[6],b33 = be[10],b34 = be[14];
    var b41 = be[3],b42 = be[7],b43 = be[11],b44 = be[15];

    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    return this;

  },

  multiplyToArray: function (a, b, r) {

    var te = this.elements;

    this.multiplyMatrices(a, b);

    r[0] = te[0];r[1] = te[1];r[2] = te[2];r[3] = te[3];
    r[4] = te[4];r[5] = te[5];r[6] = te[6];r[7] = te[7];
    r[8] = te[8];r[9] = te[9];r[10] = te[10];r[11] = te[11];
    r[12] = te[12];r[13] = te[13];r[14] = te[14];r[15] = te[15];

    return this;

  },

  multiplyScalar: function (s) {

    var te = this.elements;

    te[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;
    te[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;
    te[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;
    te[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;

    return this;

  },

  determinant: function () {

    var te = this.elements;

    var n11 = te[0],n12 = te[4],n13 = te[8],n14 = te[12];
    var n21 = te[1],n22 = te[5],n23 = te[9],n24 = te[13];
    var n31 = te[2],n32 = te[6],n33 = te[10],n34 = te[14];
    var n41 = te[3],n42 = te[7],n43 = te[11],n44 = te[15];

    //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return (
      n41 * (
      +n14 * n23 * n32 -
      n13 * n24 * n32 -
      n14 * n22 * n33 +
      n12 * n24 * n33 +
      n13 * n22 * n34 -
      n12 * n23 * n34) +

      n42 * (
      +n11 * n23 * n34 -
      n11 * n24 * n33 +
      n14 * n21 * n33 -
      n13 * n21 * n34 +
      n13 * n24 * n31 -
      n14 * n23 * n31) +

      n43 * (
      +n11 * n24 * n32 -
      n11 * n22 * n34 -
      n14 * n21 * n32 +
      n12 * n21 * n34 +
      n14 * n22 * n31 -
      n12 * n24 * n31) +

      n44 * (
      -n13 * n22 * n31 -
      n11 * n23 * n32 +
      n11 * n22 * n33 +
      n13 * n21 * n32 -
      n12 * n21 * n33 +
      n12 * n23 * n31));




  },

  transpose: function () {

    var te = this.elements;
    var tmp;

    tmp = te[1];te[1] = te[4];te[4] = tmp;
    tmp = te[2];te[2] = te[8];te[8] = tmp;
    tmp = te[6];te[6] = te[9];te[9] = tmp;

    tmp = te[3];te[3] = te[12];te[12] = tmp;
    tmp = te[7];te[7] = te[13];te[13] = tmp;
    tmp = te[11];te[11] = te[14];te[14] = tmp;

    return this;

  },

  flattenToArrayOffset: function (array, offset) {

    var te = this.elements;

    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];

    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];

    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];

    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];

    return array;

  },

  setPosition: function (v) {

    var te = this.elements;

    te[12] = v.x;
    te[13] = v.y;
    te[14] = v.z;

    return this;

  },

  invert: function (m) {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    const te = this.elements,

      n11 = te[0],n21 = te[1],n31 = te[2],n41 = te[3],
      n12 = te[4],n22 = te[5],n32 = te[6],n42 = te[7],
      n13 = te[8],n23 = te[9],n33 = te[10],n43 = te[11],
      n14 = te[12],n24 = te[13],n34 = te[14],n44 = te[15],

      t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
      t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
      t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
      t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    const detInv = 1 / det;

    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;

    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;

    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;

    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;

    return this;
  },

  getInverse: function (m, throwOnInvertible) {
    console.warn('LmvMatrix4.getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
    this.copy(m).invert();

    // Pre-invert behavior
    if (this.determinant() === 0) {
      const msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
      if (throwOnInvertible || false) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      this.identity();
    }
    return this;
  },

  scale: function (v) {

    var te = this.elements;
    var x = v.x,y = v.y,z = v.z;

    te[0] *= x;te[4] *= y;te[8] *= z;
    te[1] *= x;te[5] *= y;te[9] *= z;
    te[2] *= x;te[6] *= y;te[10] *= z;
    te[3] *= x;te[7] *= y;te[11] *= z;

    return this;

  },

  getMaxScaleOnAxis: function () {

    var te = this.elements;

    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

    return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));

  },

  makeTranslation: function (x, y, z) {

    this.set(

      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1

    );

    return this;

  },

  makeRotationX: function (theta) {

    var c = Math.cos(theta),s = Math.sin(theta);

    this.set(

      1, 0, 0, 0,
      0, c, -s, 0,
      0, s, c, 0,
      0, 0, 0, 1

    );

    return this;

  },

  makeRotationY: function (theta) {

    var c = Math.cos(theta),s = Math.sin(theta);

    this.set(

      c, 0, s, 0,
      0, 1, 0, 0,
      -s, 0, c, 0,
      0, 0, 0, 1

    );

    return this;

  },

  makeRotationZ: function (theta) {

    var c = Math.cos(theta),s = Math.sin(theta);

    this.set(

      c, -s, 0, 0,
      s, c, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1

    );

    return this;

  },

  makeRotationAxis: function (axis, angle) {

    // Based on http://www.gamedev.net/reference/articles/article1199.asp

    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x,y = axis.y,z = axis.z;
    var tx = t * x,ty = t * y;

    this.set(

      tx * x + c, tx * y - s * z, tx * z + s * y, 0,
      tx * y + s * z, ty * y + c, ty * z - s * x, 0,
      tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
      0, 0, 0, 1

    );

    return this;

  },

  makeScale: function (x, y, z) {

    this.set(

      x, 0, 0, 0,
      0, y, 0, 0,
      0, 0, z, 0,
      0, 0, 0, 1

    );

    return this;

  },

  compose: function (position, quaternion, scale) {

    this.makeRotationFromQuaternion(quaternion);
    this.scale(scale);
    this.setPosition(position);

    return this;

  },

  decompose: function () {

    var vector = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    var matrix = new LmvMatrix4(true);

    return function (position, quaternion, scale) {

      var te = this.elements;

      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length();

      // if determine is negative, we need to invert one scale
      var det = this.determinant();
      if (det < 0) {
        sx = -sx;
      }

      position.x = te[12];
      position.y = te[13];
      position.z = te[14];

      // scale the rotation part

      matrix.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()

      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;

      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;

      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;

      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;

      quaternion.setFromRotationMatrix(matrix);

      scale.x = sx;
      scale.y = sy;
      scale.z = sz;

      return this;

    };

  }(),

  //Added for LMV
  transformPoint: function (pt) {

    // input: THREE.Matrix4 affine matrix

    var x = pt.x,y = pt.y,z = pt.z;

    var e = this.elements;

    pt.x = e[0] * x + e[4] * y + e[8] * z + e[12];
    pt.y = e[1] * x + e[5] * y + e[9] * z + e[13];
    pt.z = e[2] * x + e[6] * y + e[10] * z + e[14];

    return pt;
  },

  //Added for LMV
  transformDirection: function (v) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = v.x,y = v.y,z = v.z;

    var e = this.elements;

    v.x = e[0] * x + e[4] * y + e[8] * z;
    v.y = e[1] * x + e[5] * y + e[9] * z;
    v.z = e[2] * x + e[6] * y + e[10] * z;

    var len = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    if (len > 0) {
      var ilen = 1.0 / len;
      v.x *= ilen;
      v.y *= ilen;
      v.z *= ilen;
    }

    return v;
  },

  equals(matrix) {

    const te = this.elements;
    const me = matrix.elements;

    for (var i = 0; i < 16; i++) {

      if (te[i] !== me[i]) return false;

    }

    return true;

  },

  fromArray: function (array) {

    this.elements.set(array);

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
    te[0], te[1], te[2], te[3],
    te[4], te[5], te[6], te[7],
    te[8], te[9], te[10], te[11],
    te[12], te[13], te[14], te[15]];


  },

  clone: function () {

    return new LmvMatrix4(this.isDoublePrecision).fromArray(this.elements);

  }

};

/***/ }),

/***/ "./src/wgs/scene/LmvVector3.js":
/*!*************************************!*\
  !*** ./src/wgs/scene/LmvVector3.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LmvVector3: () => (/* binding */ LmvVector3)
/* harmony export */ });
/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */
/* Pruned version of THREE.Vector3, for use in the LMV web worker */

let LmvVector3 = function (x, y, z) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;

};

LmvVector3.prototype = {

  constructor: LmvVector3,

  set: function (x, y, z) {

    this.x = x;
    this.y = y;
    this.z = z;

    return this;

  },

  setX: function (x) {

    this.x = x;

    return this;

  },

  setY: function (y) {

    this.y = y;

    return this;

  },

  setZ: function (z) {

    this.z = z;

    return this;

  },

  setComponent: function (index, value) {

    switch (index) {

      case 0:this.x = value;break;
      case 1:this.y = value;break;
      case 2:this.z = value;break;
      default:throw new Error('index is out of range: ' + index);

    }

  },

  getComponent: function (index) {

    switch (index) {

      case 0:return this.x;
      case 1:return this.y;
      case 2:return this.z;
      default:throw new Error('index is out of range: ' + index);

    }

  },

  clone: function () {

    return new this.constructor(this.x, this.y, this.z);

  },

  copy: function (v) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;

  },

  add: function (v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;

  },

  addScalar: function (s) {

    this.x += s;
    this.y += s;
    this.z += s;

    return this;

  },

  addVectors: function (a, b) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;

    return this;

  },

  addScaledVector: function (v, s) {

    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;

    return this;

  },

  sub: function (v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;

  },

  subScalar: function (s) {

    this.x -= s;
    this.y -= s;
    this.z -= s;

    return this;

  },

  subVectors: function (a, b) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;

    return this;

  },

  multiply: function (v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);

    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;

    return this;

  },

  multiplyScalar: function (scalar) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;

    return this;

  },

  multiplyVectors: function (a, b) {

    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;

    return this;

  },

  applyMatrix3: function (m) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var e = m.elements;

    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;

    return this;

  },

  applyMatrix4: function (m) {

    // input: THREE.Matrix4 affine matrix

    var x = this.x,y = this.y,z = this.z;

    var e = m.elements;

    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

    return this;

  },

  applyProjection: function (m) {

    // input: THREE.Matrix4 projection matrix

    var x = this.x,y = this.y,z = this.z;

    var e = m.elements;
    var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]); // perspective divide

    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;

    return this;

  },

  applyQuaternion: function (q) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

    return this;

  },

  transformDirection: function (m) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = this.x,y = this.y,z = this.z;

    var e = m.elements;

    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;

    this.normalize();

    return this;

  },

  divide: function (v) {

    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;

    return this;

  },

  divideScalar: function (scalar) {

    if (scalar !== 0) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;

    }

    return this;

  },

  min: function (v) {

    if (this.x > v.x) {

      this.x = v.x;

    }

    if (this.y > v.y) {

      this.y = v.y;

    }

    if (this.z > v.z) {

      this.z = v.z;

    }

    return this;

  },

  max: function (v) {

    if (this.x < v.x) {

      this.x = v.x;

    }

    if (this.y < v.y) {

      this.y = v.y;

    }

    if (this.z < v.z) {

      this.z = v.z;

    }

    return this;

  },

  clamp: function (min, max) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if (this.x < min.x) {

      this.x = min.x;

    } else if (this.x > max.x) {

      this.x = max.x;

    }

    if (this.y < min.y) {

      this.y = min.y;

    } else if (this.y > max.y) {

      this.y = max.y;

    }

    if (this.z < min.z) {

      this.z = min.z;

    } else if (this.z > max.z) {

      this.z = max.z;

    }

    return this;

  },

  clampScalar: function () {

    var min, max;

    return function clampScalar(minVal, maxVal) {

      if (min === undefined) {

        min = new LmvVector3();
        max = new LmvVector3();

      }

      min.set(minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal);

      return this.clamp(min, max);

    };

  }(),

  floor: function () {

    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);

    return this;

  },

  ceil: function () {

    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);

    return this;

  },

  round: function () {

    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);

    return this;

  },

  roundToZero: function () {

    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);

    return this;

  },

  negate: function () {

    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;

    return this;

  },

  dot: function (v) {

    return this.x * v.x + this.y * v.y + this.z * v.z;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z;

  },

  length: function () {

    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

  },

  lengthManhattan: function () {

    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);

  },

  normalize: function () {

    return this.divideScalar(this.length());

  },

  setLength: function (l) {

    var oldLength = this.length();

    if (oldLength !== 0 && l !== oldLength) {

      this.multiplyScalar(l / oldLength);

    }

    return this;

  },

  lerp: function (v, alpha) {

    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;

    return this;

  },

  lerpVectors: function (v1, v2, alpha) {

    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);

    return this;

  },

  cross: function (v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);

    }

    var x = this.x,y = this.y,z = this.z;

    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;

    return this;

  },

  crossVectors: function (a, b) {

    var ax = a.x,ay = a.y,az = a.z;
    var bx = b.x,by = b.y,bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;

  },

  projectOnVector: function () {

    var v1, dot;

    return function projectOnVector(vector) {

      if (v1 === undefined) v1 = new LmvVector3();

      v1.copy(vector).normalize();

      dot = this.dot(v1);

      return this.copy(v1).multiplyScalar(dot);

    };

  }(),

  projectOnPlane: function () {

    var v1;

    return function projectOnPlane(planeNormal) {

      if (v1 === undefined) v1 = new LmvVector3();

      v1.copy(this).projectOnVector(planeNormal);

      return this.sub(v1);

    };

  }(),

  reflect: function () {

    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length

    var v1;

    return function reflect(normal) {

      if (v1 === undefined) v1 = new LmvVector3();

      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));

    };

  }(),

  distanceTo: function (v) {

    return Math.sqrt(this.distanceToSquared(v));

  },

  distanceToSquared: function (v) {

    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;

    return dx * dx + dy * dy + dz * dz;

  },

  setEulerFromRotationMatrix: function (m, order) {

    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');

  },

  setEulerFromQuaternion: function (q, order) {

    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');

  },

  getPositionFromMatrix: function (m) {

    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');

    return this.setFromMatrixPosition(m);

  },

  getScaleFromMatrix: function (m) {

    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');

    return this.setFromMatrixScale(m);

  },

  getColumnFromMatrix: function (index, matrix) {

    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');

    return this.setFromMatrixColumn(index, matrix);

  },

  setFromMatrixPosition: function (m) {

    this.x = m.elements[12];
    this.y = m.elements[13];
    this.z = m.elements[14];

    return this;

  },

  setFromMatrixScale: function (m) {

    var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
    var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
    var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();

    this.x = sx;
    this.y = sy;
    this.z = sz;

    return this;

  },

  setFromMatrixColumn: function (index, matrix) {

    var offset = index * 4;

    var me = matrix.elements;

    this.x = me[offset];
    this.y = me[offset + 1];
    this.z = me[offset + 2];

    return this;

  },

  equals: function (v) {

    return v.x === this.x && v.y === this.y && v.z === this.z;

  },

  fromArray: function (array, offset) {

    if (offset === undefined) offset = 0;

    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];

    return this;

  },

  toArray: function (array, offset) {

    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;

    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;

    return array;

  },

  fromAttribute: function (attribute, index, offset) {

    if (offset === undefined) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[index];
    this.y = attribute.array[index + 1];
    this.z = attribute.array[index + 2];

    return this;

  }

};

/***/ }),

/***/ "./src/wgs/scene/MeshFlags.js":
/*!************************************!*\
  !*** ./src/wgs/scene/MeshFlags.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeshFlags: () => (/* binding */ MeshFlags)
/* harmony export */ });
let MeshFlags = {
  // FragmentList flags
  //visibility/highlight bitmask flags

  //Byte 0

  //NOTE: This is confusing and it should be fixed, but when the MESH_VISIBLE bit is off, the mesh
  //will draw in ghosted mode. To completely skip drawing a mesh, set the HIDE flag.
  MESH_VISIBLE: 1,
  MESH_HIGHLIGHTED: 2,
  MESH_HIDE: 4,
  MESH_ISLINE: 8,
  MESH_MOVED: 0x10, // indicates if an animation matrix is set
  MESH_RENDERFLAG: 0x20,
  MESH_NOTLOADED: 0x40, // the mesh has not yet loaded or has been unloaded
  MESH_ISPOINT: 0x80, // indicates that the mesh is vertex-only

  //Byte 1
  //TODO: Two bits are enough to hold ISLINE, ISWIDELINE and ISPOINT, we don't need to waste three,
  //but there is no point to optimizing this as long as the required flags go over one byte.
  MESH_ISWIDELINE: 0x100, // indicates that the mesh is wide line
  MESH_TRAVERSED: 0x200, // only used for paging: drawn fragments are tagged and then skipped by forEach() until the flag is being reset (e.g. on scene/camera changes)
  MESH_DRAWN: 0x400 // only used for paging: drawn fragments are tagged. At the end of all render passes flag is copied to MESH_TRAVERSED.
  // The Memory Limited Extension uses the high order three bits of this byte
};

/***/ }),

/***/ "./src/wgs/scene/VertexEnumerator.js":
/*!*******************************************!*\
  !*** ./src/wgs/scene/VertexEnumerator.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VertexEnumerator: () => (/* binding */ VertexEnumerator),
/* harmony export */   enumMeshEdges: () => (/* binding */ enumMeshEdges),
/* harmony export */   enumMeshIndices: () => (/* binding */ enumMeshIndices),
/* harmony export */   enumMeshLines: () => (/* binding */ enumMeshLines),
/* harmony export */   enumMeshTriangles: () => (/* binding */ enumMeshTriangles),
/* harmony export */   enumMeshVertices: () => (/* binding */ enumMeshVertices),
/* harmony export */   getIndicesCount: () => (/* binding */ getIndicesCount),
/* harmony export */   getVertexCount: () => (/* binding */ getVertexCount)
/* harmony export */ });
/* harmony import */ var _LmvVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LmvVector3 */ "./src/wgs/scene/LmvVector3.js");
/* harmony import */ var _BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferGeometryUtils */ "./src/wgs/scene/BufferGeometryUtils.js");


//Utility logic for listing vertex data from LmvBufferGeometry interleaved buffers




//These functions work for both workers side interleaved buffer structures
//and main thread side LmvBufferGeometry instances. The difference in naming
//if the index attribute on both sides is super annoying and should be cleaned up.


/** Works for BufferGeometry as well as THREE.BufferGeometry. Supports interleaved and non-interleaved buffers.
 *   @param {BufferGeometry|THREE.BufferGeometry} geom
 *   @returns {number}
 */
function getVertexCount(geom) {

  if (geom.vb) {
    // interleaved
    return geom.vb.length / geom.vbstride;
  }






  // no interleaved buffer. Return count from position attribute or 0
  return geom.attributes.position ? geom.attributes.position.array.length / 3 : 0;
}

function getIndicesCount(geometry) {

  const indices = getIndexBuffer(geometry);

  if (indices) {

    var groups = geometry.groups;

    if (!groups || groups.length === 0) {
      return indices.length;
    }

    let res = 0;

    for (var oi = 0, ol = groups.length; oi < ol; ++oi) {
      res += groups[oi].count;
    }

    return res;

  } else {
    return getVertexCount(geometry);
  }
}

var _p, _n, _uv;
var _normalsMatrix;

/**
 * @typedef {Object} PositionVBInfo
 * @property {Float32Array} positions - Vertex buffer containing position data
 * @property {number} poffset - The array buffer offset for position data
 * @property {number} stride - The array buffer stride for both positions and normals
 */

/**
 * @typedef {Object} NormalVBInfo
 * @property {Float32Array} normals - Vertex buffer containing normal data
 * @property {number} noffset - The array buffer offset for normal data
 */

/**
 * @param {MeshData} mdata
 * @returns {PositionVBInfo}
 */
function extractVertexBufferPositionDataFromMeshData(mdata) {
  const attributes = mdata.attributes;
  let positions, stride, poffset;
  // Get the offset to positions in the buffer. Be careful, 2D buffers
  // don't use the 'position' attribute for positions. Reject those.
  if (mdata.vblayout) {
    if (!mdata.vblayout.position)
    return { positions: undefined, poffset: undefined };
    poffset = mdata.vblayout.position.offset;
  } else if (!attributes.position)
  return { positions: undefined, poffset: undefined };else
  {
    poffset = attributes.position.offset || 0;
  }
  positions = mdata.vb || attributes.position.array;
  stride = mdata.vb ? mdata.vbstride : 3;
  return { positions, stride, poffset };
}

/**
 * Gathers minimum info to traverse the positions stored in an array buffer
 * @param {BufferGeometry|MeshData} geometry
 * @returns {PositionVBInfo}
 */
function extractVertexBufferPositionData(geometry) {
  let result = {};


  result = extractVertexBufferPositionDataFromMeshData(geometry);















  return result;
}

/**
 * Gathers minimum info to traverse the normals stored in an interleaved array buffer
 * @param {BufferGeometry|MeshData} geometry
 * @returns {NormalVBInfo}
 */
function extractVertexBufferNormalData(geometry) {
  const attributes = geometry.attributes;
  let normals, nattr;
  let noffset = 0;
  let noffsetFactor = 1;

  normals = geometry.vb || attributes.normal && attributes.normal.array;
  nattr = geometry.vblayout ? geometry.vblayout.normal : attributes.normal || null;













  if (nattr) {
    noffset = nattr.offset || 0;
    noffset *= noffsetFactor;
  } else {
    normals = null;
  }


  if (nattr && !nattr.array && (nattr.itemSize !== 3 || nattr.bytesPerItem !== 4)) {
    //console.log("Normals are packed, will be skipped from enumMeshTriangles. Use packNormals=false load option.");
    normals = null;
  }






  return { normals, noffset };
}

/**
 * Extracts the indices array
 * @param {BufferGeometry|MeshData} geometry
 * @returns {Uint16Array|null|undefined}
 */
function getIndexBuffer(geometry) {
  // @todo BufferGeometryUtils.getIndexBufferArray has different but similar behavior, consider consolidation later.
  let indices;

  indices = geometry.ib || geometry.indices || (geometry.index ? geometry.index.array : null);







  return indices;
}

function enumMeshVertices(geometry, callback, matrix) {

  var attributes = geometry.attributes;

  if (!_p) {
    _p = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    _n = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    _uv = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
  }

  if (matrix) {
    if (!_normalsMatrix)
    _normalsMatrix = new THREE.Matrix3();

    _normalsMatrix.getNormalMatrix(matrix);
  }

  const { positions, stride, poffset } = extractVertexBufferPositionData(geometry);
  const { normals, noffset } = extractVertexBufferNormalData(geometry);
  if (!positions) return; // No positions, what to do??

  //TODO: UV channel

  var vcount = getVertexCount(geometry);

  var pi = poffset;
  var ni = noffset;
  for (var i = 0; i < vcount; i++, pi += stride, ni += stride) {

    _p.set(positions[pi], positions[pi + 1], positions[pi + 2]);

    if (matrix)
    _p.applyMatrix4(matrix);

    if (normals) {
      _n.set(normals[ni], normals[ni + 1], normals[ni + 2]);

      if (matrix) {
        _n.applyMatrix3(_normalsMatrix);
      }
    }

    //TODO: UV channel

    callback(_p, normals ? _n : null, null /*, _uv*/, i);
  }
}

function enumMeshIndices(geometry, callback) {
  const indices = getIndexBuffer(geometry);

  if (indices) {

    let groups = geometry.groups;

    if (!groups || groups.length === 0) {
      groups = [{ start: 0, count: indices.length, index: 0 }];
    }

    for (let oi = 0, ol = groups.length; oi < ol; ++oi) {

      let start = groups[oi].start;
      let count = groups[oi].count;
      let index = 0;

      index = groups[oi].index;


      for (let i = start, il = start + count; i < il; i += 3) {

        let a = index + indices[i];
        let b = index + indices[i + 1];
        let c = index + indices[i + 2];

        callback(a, b, c);
      }
    }
  } else {

    let vcount = getVertexCount(geometry);

    for (let i = 0; i < vcount; i++) {

      let a = 3 * i;
      let b = 3 * i + 1;
      let c = 3 * i + 2;

      callback(a, b, c);
    }
  }
}


var vA, vB, vC, nA, nB, nC;

function enumMeshTriangles(geometry, callback) {

  var a, b, c;

  if (!vA) {
    vA = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    vB = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    vC = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();

    nA = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    nB = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    nC = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
  }

  const { positions, stride, poffset } = extractVertexBufferPositionData(geometry);
  const { normals, noffset } = extractVertexBufferNormalData(geometry);
  const indices = getIndexBuffer(geometry);
  if (!positions) return; // No positions, what to do??

  if (indices) {

    var groups = geometry.groups;

    if (!groups || groups.length === 0) {
      groups = [{ start: 0, count: indices.length, index: 0 }];
    }

    for (var oi = 0, ol = groups.length; oi < ol; ++oi) {

      var start = groups[oi].start;
      var count = groups[oi].count;
      var index = 0;

      index = groups[oi].index;


      for (var i = start, il = start + count; i < il; i += 3) {

        a = index + indices[i];
        b = index + indices[i + 1];
        c = index + indices[i + 2];

        var pa = a * stride + poffset;
        var pb = b * stride + poffset;
        var pc = c * stride + poffset;

        vA.x = positions[pa];vA.y = positions[pa + 1];vA.z = positions[pa + 2];
        vB.x = positions[pb];vB.y = positions[pb + 1];vB.z = positions[pb + 2];
        vC.x = positions[pc];vC.y = positions[pc + 1];vC.z = positions[pc + 2];

        if (normals) {
          var na = a * stride + noffset;
          var nb = b * stride + noffset;
          var nc = c * stride + noffset;

          nA.x = normals[na];nA.y = normals[na + 1];nA.z = normals[na + 2];
          nB.x = normals[nb];nB.y = normals[nb + 1];nB.z = normals[nb + 2];
          nC.x = normals[nc];nC.y = normals[nc + 1];nC.z = normals[nc + 2];

          callback(vA, vB, vC, a, b, c, nA, nB, nC, i / 3);
        } else {
          callback(vA, vB, vC, a, b, c, null, null, null, i / 3);
        }


      }

    }

  } else {

    var vcount = getVertexCount(geometry);

    for (var i = 0; i < vcount; i += 3) {

      a = i;
      b = i + 1;
      c = i + 2;

      var pa = a * stride + poffset;
      var pb = b * stride + poffset;
      var pc = c * stride + poffset;

      vA.x = positions[pa];vA.y = positions[pa + 1];vA.z = positions[pa + 2];
      vB.x = positions[pb];vB.y = positions[pb + 1];vB.z = positions[pb + 2];
      vC.x = positions[pc];vC.y = positions[pc + 1];vC.z = positions[pc + 2];

      if (normals) {
        var na = a * stride + noffset;
        var nb = b * stride + noffset;
        var nc = c * stride + noffset;

        nA.x = normals[na];nA.y = normals[na + 1];nA.z = normals[na + 2];
        nB.x = normals[nb];nB.y = normals[nb + 1];nB.z = normals[nb + 2];
        nC.x = normals[nc];nC.y = normals[nc + 1];nC.z = normals[nc + 2];

        callback(vA, vB, vC, a, b, c, nA, nB, nC, i / 3);
      } else {
        callback(vA, vB, vC, a, b, c, null, null, null, i / 3);
      }
    }

  }
}


var vP, vQ;

function enumMeshLines(geometry, callback) {

  var attributes = geometry.attributes;

  var a, b;

  if (!vP) {
    vP = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    vQ = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
  }

  var istep = 2;
  if (geometry.lineWidth) {
    istep = 6;
  }

  const indices = getIndexBuffer(geometry);

  if (indices) {

    let positions, stride;

    positions = geometry.vb ? geometry.vb : attributes.position.array;
    stride = geometry.vb ? geometry.vbstride : 3;











    var groups = geometry.groups;

    if (!groups || groups.length === 0) {

      groups = [{ start: 0, count: indices.length, index: 0 }];

    }

    for (var oi = 0, ol = groups.length; oi < ol; ++oi) {

      var start = groups[oi].start;
      var count = groups[oi].count;
      var index = 0;

      index = groups[oi].index;


      for (var i = start, il = start + count, lineIdx = start / istep; i < il; i += istep, lineIdx++) {

        a = index + indices[i];
        b = index + indices[i + 1];

        vP.x = positions[a * stride];vP.y = positions[a * stride + 1];vP.z = positions[a * stride + 2];
        vQ.x = positions[b * stride];vQ.y = positions[b * stride + 1];vQ.z = positions[b * stride + 2];

        callback(vP, vQ, a, b, lineIdx);
      }

    }

  } else {

    let positions, stride;

    positions = geometry.vb ? geometry.vb : attributes.position.array;
    stride = geometry.vb ? geometry.vbstride : 3;











    for (var i = 0, il = positions.length / stride, lineIdx = 0; i < il; i += istep, lineIdx++) {

      a = i;
      b = i + 1;

      vP.x = positions[a * stride];vP.y = positions[a * stride + 1];vP.z = positions[a * stride + 2];
      vQ.x = positions[b * stride];vQ.y = positions[b * stride + 1];vQ.z = positions[b * stride + 2];

      callback(vP, vQ, a, b, lineIdx);
    }

  }
}


function enumMeshEdges(geometry, callback) {

  var a, b;

  if (!vP) {
    vP = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
    vQ = new _LmvVector3__WEBPACK_IMPORTED_MODULE_0__.LmvVector3();
  }

  var istep = 2;

  let indices;

  indices = geometry.iblines;








  if (!indices) {
    return;
  }

  let positions, stride;

  positions = geometry.vb ? geometry.vb : attributes.position.array;
  stride = geometry.vb ? geometry.vbstride : 3;











  var groups = geometry.groups;

  if (!groups || groups.length === 0) {

    groups = [{ start: 0, count: indices.length, index: 0 }];

  }

  for (var oi = 0, ol = groups.length; oi < ol; ++oi) {

    var start = groups[oi].start;
    var count = groups[oi].count;
    var index = 0;

    index = groups[oi].index;


    for (var i = start, il = start + count; i < il; i += istep) {

      a = index + indices[i];
      b = index + indices[i + 1];

      vP.x = positions[a * stride];vP.y = positions[a * stride + 1];vP.z = positions[a * stride + 2];
      vQ.x = positions[b * stride];vQ.y = positions[b * stride + 1];vQ.z = positions[b * stride + 2];

      callback(vP, vQ, a, b);
    }

  }
}

let VertexEnumerator = {
  getVertexCount,
  enumMeshVertices,
  enumMeshIndices,
  enumMeshTriangles,
  enumMeshLines,
  enumMeshEdges
};

/***/ }),

/***/ "./src/wgs/scene/consolidation/GeomMergeTask.js":
/*!******************************************************!*\
  !*** ./src/wgs/scene/consolidation/GeomMergeTask.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeomMergeTask: () => (/* binding */ GeomMergeTask),
/* harmony export */   writeIdToBuffer: () => (/* binding */ writeIdToBuffer)
/* harmony export */ });
/**
 * A GeomMergeTask is used for mesh consolidation. It fills vertex buffer and id buffer of a consolidated mesh
 * based on a set of compatible input meshes.
 *
 * GeomMergeTask is shared by main wgs script and worker script, so that the same code can be used for single-threaded
 * and multi-threaded consolidation.
 */

// unique task ids
var _nextTaskId = 1;
function createTaskId() {return _nextTaskId++;}

function GeomMergeTask() {

  // Interleaved vertex buffers as Float32Array.
  this.vb = null;

  // floats per vertex
  this.vbstride = 0;

  // offsets in floats where to find position/normal in vertex buffer
  this.posOffset = 0;
  this.normalOffset = 0;

  // matrices per src-geom (Float32Array with 16 floats per matrix)
  this.matrices = null;
  this.ranges = null;

  // must be an Uint32Array that we can efficiently hand-over to the worker
  this.dbIds = null;

  // unique task-id used to find BufferGeometry when a merged vb is returned from worker
  this.id = createTaskId();
}

/**
 *  Packs a Vector3 normal vector into 2 components. This is a CPU-side implementation of PackNormalsShaderChunk
 *  (see ShaderChunks.js)
 *
 *   @param {THREE.Vector3|LmvVector3} normal - InOut normal vector.
 *
 *  Note that 'normal' must be normalized!
 */
function encodeNormal(normal) {
  normal.x = 0.5 * (1.0 + Math.atan2(normal.y, normal.x) / Math.PI);
  normal.y = 0.5 * (1.0 + normal.z);
  normal.z = 0.0; // not used for result
}

/**
 * @param {THREE.Vector3|LmvVector3} normal - InOut normal vector. Input z is ignored.
 */
function decodeNormal(normal) {
  var angX = 2.0 * normal.x - 1.0;
  var angY = 2.0 * normal.y - 1.0;
  var scthX = Math.sin(angX * Math.PI);
  var scthY = Math.cos(angX * Math.PI);
  var scphiX = Math.sqrt(1.0 - angY * angY);
  var scphiY = angY;
  normal.x = scthY * scphiX;
  normal.y = scthX * scphiX;
  normal.z = scphiY;
}

/**
 *  Writes a dbId into 4 subsequent bytes of an Uint8Array. (4th is only for alignment and always 0)
 *   @param {Number}     dbId
 *   @param {Uint8Array} bufferUint8 - view into the vertex buffer that we write to.
 *   @param {Number}     writeIndex  - Index into the uint8 array where we write the first byte.
 */
function writeIdToBuffer(dbId, bufferUint8, writeIndex) {
  bufferUint8[writeIndex++] = dbId & 0xff;
  bufferUint8[writeIndex++] = dbId >> 8 & 0xff;
  bufferUint8[writeIndex++] = dbId >> 16 & 0xff;
  bufferUint8[writeIndex] = 0; // dbIds are only vec3 in the shader
}

// We don't have THREE.Matrix3 in a worker, so that we cannot use getNormalTransform()
function getNormalMatrix(matrix, dstMatrix) {

  // eliminate translation part
  dstMatrix.copy(matrix);
  dstMatrix[12] = 0;
  dstMatrix[13] = 0;
  dstMatrix[14] = 0;

  // tranpose of inverse
  return dstMatrix.invert().transpose();
}

/**
 *  Transforms positions and normals of a vertex buffer range.
 *
 *  NOTE: Only interleaved buffers with packed normals are supported.
 *
 *   @param {GeomMergeTask} geom
 *   @param {Uint16Array}   vbUint16     - additional uint16-view to interleaved vertex-buffer
 *   @param {LmvMatrix4}    matrix
 *   @param {Number}        [rangeStart] - First vertex to transform. (default: 0)
 *   @param {Number}        [rangeEnd]   - End of vertex range.       (default: #vertices)
 *   @param {LmvMatrix4}    tmpMatrix    - reused tmp matrix
 *   @param {LmvVector3}    tmpVec       - reused tmp vector
 */
var transformVertexRange = function (geom, vbUint16, matrix, rangeStart, rangeEnd, tmpMatrix, tmpVec) {

  // transform positions
  var posOffset = geom.posOffset;
  for (var i = rangeStart; i < rangeEnd; i++) {

    // read vertex position i
    var offset = i * geom.vbstride + posOffset;
    tmpVec.set(geom.vb[offset], geom.vb[offset + 1], geom.vb[offset + 2]);

    tmpVec.applyMatrix4(matrix);

    // write vertex position i
    geom.vb[offset] = tmpVec.x;
    geom.vb[offset + 1] = tmpVec.y;
    geom.vb[offset + 2] = tmpVec.z;
  }

  // transform normals (if available)
  if (geom.normalOffset !== -1) {

    // To transform normals, we need an Uint16-view to the data.
    // Packed normals are 2-component Uint16-vectors.
    var uint16PerVertex = geom.vbstride * 2; // Multiply by 2, because vbstride and offset
    var uint16NormalOffset = geom.normalOffset * 2; // are counting 32Bit floats.
    var maxUint16 = 0xFFFF;

    // compute normal transform
    var normalMatrix = getNormalMatrix(matrix, tmpMatrix);

    // transform normal vectors
    for (i = rangeStart; i < rangeEnd; i++) {
      // read byte-normal of vertex i
      var normalIndex = i * uint16PerVertex + uint16NormalOffset;
      tmpVec.set(vbUint16[normalIndex], vbUint16[normalIndex + 1], 0.0);

      // decode to vec3 with components in [0,1]
      tmpVec.divideScalar(maxUint16);
      decodeNormal(tmpVec);

      // Note that normalMatrix is a LmvMatrix4 (although we only use 3x3 matrix)
      tmpVec.applyMatrix4(normalMatrix);

      // Note that encodeNormal requires normalized values. Although a decodedNormal is
      // always normalized, the normalMatrix may involve a scaling.
      tmpVec.normalize();

      // encode back to 2-component uint16
      encodeNormal(tmpVec);
      tmpVec.multiplyScalar(maxUint16);

      // write back to vertex buffer
      vbUint16[normalIndex] = tmpVec.x;
      vbUint16[normalIndex + 1] = tmpVec.y;
    }
  }
};

// read matrix i from Float32 array to target LmvMatrix4
function getMatrix(index, array, target) {
  // TypedArray.set does not support a srcOffset parameter. So we have to use manual copy here.
  var offset = 16 * index;
  for (var i = 0; i < 16; i++) {
    target.elements[i] = array[i + offset];
  }
}

/**
 *  Run merge task. This can be done using Vector/Matrix types from THREE (in main) or LmvVector/LmvMatrix (worker).
 *  To define which types to use while keeping the code independent, a preallocated matrix/vector must be provided.
 *
 *  @param {LmvMatrix4|THREE.Matrix4} matrix
 *  @param {LmvVector3|THREE.Vector3} vector
 *  @returns {Object} - merge result r, containing
 *                        {number}       r.id:        task id
 *                        {Float32Array} r.vb:        merged interleaved vertex buffer
 *                        {Uint8Array}   r.vertexIds: buffer for separate per-vertex id attribute
 */
GeomMergeTask.prototype.run = function (matrix, vec) {

  var vb = this.vb;
  var vertexCount = vb.length / this.vbstride;

  var tmpMatrix = matrix.clone();

  // create buffer for per-vertex ids of consolidated mesh
  var IDBytesPerVertex = 3;
  var dstIds = new Uint8Array(IDBytesPerVertex * vertexCount);

  // to transform normals, we need an Uint16-view to the interleaved vertex buffer.
  // packed normals are 2-component Uin16-vectors.
  var hasNormals = this.normalOffset !== -1;
  var vbUint16 = hasNormals ? new Uint16Array(vb.buffer, vb.byteOffset, vb.length * 2) : null;

  // transform vertex-range and write ids. Each range corresponds to a source fragment geometry
  var ranges = this.ranges;
  var matrices = this.matrices;
  var numRanges = ranges.length - 1; // note that ranges contains an extra element for the last range end
  for (var j = 0; j < numRanges; j++) {

    // get vertex range corresponding to src geom i
    var rangeBegin = ranges[j];
    var rangeEnd = ranges[j + 1];

    // get matrix for src geom i
    getMatrix(j, matrices, matrix);

    // transform vertex positions and normals in this range
    transformVertexRange(this, vbUint16, matrix, rangeBegin, rangeEnd, tmpMatrix, vec);

    // assign dbId to all vertices of this range
    var dstIdsByteOffset = rangeBegin * IDBytesPerVertex;
    var rangeLength = rangeEnd - rangeBegin;
    var dbId = this.dbIds[j];
    for (var k = 0; k < rangeLength; k++) {
      writeIdToBuffer(dbId, dstIds, dstIdsByteOffset);
      dstIdsByteOffset += IDBytesPerVertex;
    }
  }

  // return result object. It contains everything we need to finish a single consolidated mesh.
  return {
    taskId: this.id,
    vb: this.vb, // note that we have to pass back the byte-view
    vertexIds: dstIds
  };
};

/***/ }),

/***/ "./node_modules/core-js/internals/a-callable.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-callable.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-constructor.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/a-constructor.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-map.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/a-map.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var has = (__webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js").has);

// Perform ? RequireInternalSlot(M, [[MapData]])
module.exports = function (it) {
  has(it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-set.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/a-set.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var has = (__webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js").has);

// Perform ? RequireInternalSlot(M, [[SetData]])
module.exports = function (it) {
  has(it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-weak-map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-weak-map.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var has = (__webpack_require__(/*! ../internals/weak-map-helpers */ "./node_modules/core-js/internals/weak-map-helpers.js").has);

// Perform ? RequireInternalSlot(M, [[WeakMapData]])
module.exports = function (it) {
  has(it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-weak-set.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-weak-set.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var has = (__webpack_require__(/*! ../internals/weak-set-helpers */ "./node_modules/core-js/internals/weak-set-helpers.js").has);

// Perform ? RequireInternalSlot(M, [[WeakSetData]])
module.exports = function (it) {
  has(it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] === undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-instance.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw $TypeError('Incorrect invocation');
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-basic-detection.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-basic-detection.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";

// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-non-extensible.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-non-extensible.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = fails(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
  }
});


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-view-core.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-view-core.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__(/*! ../internals/array-buffer-basic-detection */ "./node_modules/core-js/internals/array-buffer-basic-detection.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = global.TypeError;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var getTypedArrayConstructor = function (it) {
  var proto = getPrototypeOf(it);
  if (!isObject(proto)) return;
  var state = getInternalState(proto);
  return (state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
  throw TypeError(tryToString(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced, options) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) { /* empty */ }
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
    configurable: true,
    get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  getTypedArrayConstructor: getTypedArrayConstructor,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-iteration.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-slice-simple.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/array-slice-simple.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  var n = 0;
  for (; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-slice.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/array-slice.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-unique-by.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-unique-by.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var MapHelpers = __webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

var Map = MapHelpers.Map;
var mapHas = MapHelpers.has;
var mapSet = MapHelpers.set;
var push = uncurryThis([].push);

// `Array.prototype.uniqueBy` method
// https://github.com/tc39/proposal-array-unique
module.exports = function uniqueBy(resolver) {
  var that = toObject(this);
  var length = lengthOfArrayLike(that);
  var result = [];
  var map = new Map();
  var resolverFunction = !isNullOrUndefined(resolver) ? aCallable(resolver) : function (value) {
    return value;
  };
  var index, item, key;
  for (index = 0; index < length; index++) {
    item = that[index];
    key = resolverFunction(item);
    if (!mapHas(map, key)) mapSet(map, key, item);
  }
  iterate(map, function (value) {
    push(result, value);
  });
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  try {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  } catch (error) { return false; } // workaround of old WebKit + `eval` bug
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-from.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/collection-from.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var aConstructor = __webpack_require__(/*! ../internals/a-constructor */ "./node_modules/core-js/internals/a-constructor.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");

var push = [].push;

module.exports = function from(source /* , mapFn, thisArg */) {
  var length = arguments.length;
  var mapFn = length > 1 ? arguments[1] : undefined;
  var mapping, array, n, boundFunction;
  aConstructor(this);
  mapping = mapFn !== undefined;
  if (mapping) aCallable(mapFn);
  if (isNullOrUndefined(source)) return new this();
  array = [];
  if (mapping) {
    n = 0;
    boundFunction = bind(mapFn, length > 2 ? arguments[2] : undefined);
    iterate(source, function (nextItem) {
      call(push, array, boundFunction(nextItem, n++));
    });
  } else {
    iterate(source, push, { that: array });
  }
  return new this(array);
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/collection-of.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");

// https://tc39.github.io/proposal-setmap-offrom/
module.exports = function of() {
  return new this(arraySlice(arguments));
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-strong.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/collection-strong.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fastKey = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").fastKey);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key === key) return entry;
      }
    };

    defineBuiltIns(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first === entry) state.first = next;
          if (state.last === entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineBuiltInAccessor(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return createIterResultObject(undefined, true);
      }
      // return step by kind
      if (kind === 'keys') return createIterResultObject(entry.key, false);
      if (kind === 'values') return createIterResultObject(entry.value, false);
      return createIterResultObject([entry.key, entry.value], false);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-weak.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/collection-weak.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var getWeakData = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").getWeakData);
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var ArrayIterationModule = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis([].splice);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) splice(this.entries, index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);
      else data[state.id] = value;
      return that;
    };

    defineBuiltIns(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && hasOwn(data, state.id) && delete data[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && hasOwn(data, state.id);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });

    return Constructor;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/collection.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
    defineBuiltIn(NativePrototype, KEY,
      KEY === 'add' ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY === 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced(
    CONSTRUCTOR_NAME,
    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/composite-key.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/composite-key.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(/*! ../modules/es.map */ "./node_modules/core-js/modules/es.map.js");
__webpack_require__(/*! ../modules/es.weak-map */ "./node_modules/core-js/modules/es.weak-map.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $Object = Object;
var $TypeError = TypeError;
var Map = getBuiltIn('Map');
var WeakMap = getBuiltIn('WeakMap');

var Node = function () {
  // keys
  this.object = null;
  this.symbol = null;
  // child nodes
  this.primitives = null;
  this.objectsByIndex = create(null);
};

Node.prototype.get = function (key, initializer) {
  return this[key] || (this[key] = initializer());
};

Node.prototype.next = function (i, it, IS_OBJECT) {
  var store = IS_OBJECT
    ? this.objectsByIndex[i] || (this.objectsByIndex[i] = new WeakMap())
    : this.primitives || (this.primitives = new Map());
  var entry = store.get(it);
  if (!entry) store.set(it, entry = new Node());
  return entry;
};

var root = new Node();

module.exports = function () {
  var active = root;
  var length = arguments.length;
  var i, it;
  // for prevent leaking, start from objects
  for (i = 0; i < length; i++) {
    if (isObject(it = arguments[i])) active = active.next(i, it, true);
  }
  if (this === $Object && active === root) throw $TypeError('Composite keys must contain a non-primitive component');
  for (i = 0; i < length; i++) {
    if (!isObject(it = arguments[i])) active = active.next(i, it, false);
  } return active;
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js/internals/create-iter-result-object.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iter-result-object.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in-accessor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in-accessor.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-ins.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-ins.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-global-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/define-global-property.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/document-all.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";

var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = {
  all: documentAll,
  IS_HTMLDDA: IS_HTMLDDA
};


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/engine-is-bun.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-bun.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";

/* global Bun -- Deno case */
module.exports = typeof Bun == 'function' && Bun && typeof Bun.version == 'string';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-is-ios.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-ios.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

// eslint-disable-next-line redos/no-vulnerable -- safe
module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);


/***/ }),

/***/ "./node_modules/core-js/internals/engine-is-node.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-node.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

module.exports = classof(global.process) === 'process';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";

module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/freezing.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/freezing.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-apply.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/function-apply.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js/internals/function-uncurry-this-clause.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-native.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-native.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-call.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-call.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-name.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-name.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-accessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-accessor.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-clause.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-clause.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-direct.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-direct.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";

// `GetIteratorDirect(obj)` abstract operation
// https://tc39.es/proposal-iterator-helpers/#sec-getiteratordirect
module.exports = function (obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-method.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/get-method.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-set-record.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/get-set-record.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
var getIteratorDirect = __webpack_require__(/*! ../internals/get-iterator-direct */ "./node_modules/core-js/internals/get-iterator-direct.js");

var INVALID_SIZE = 'Invalid size';
var $RangeError = RangeError;
var $TypeError = TypeError;
var max = Math.max;

var SetRecord = function (set, size, has, keys) {
  this.set = set;
  this.size = size;
  this.has = has;
  this.keys = keys;
};

SetRecord.prototype = {
  getIterator: function () {
    return getIteratorDirect(anObject(call(this.keys, this.set)));
  },
  includes: function (it) {
    return call(this.has, this.set, it);
  }
};

// `GetSetRecord` abstract operation
// https://tc39.es/proposal-set-methods/#sec-getsetrecord
module.exports = function (obj) {
  anObject(obj);
  var numSize = +obj.size;
  // NOTE: If size is undefined, then numSize will be NaN
  // eslint-disable-next-line no-self-compare -- NaN check
  if (numSize !== numSize) throw $TypeError(INVALID_SIZE);
  var intSize = toIntegerOrInfinity(numSize);
  if (intSize < 0) throw $RangeError(INVALID_SIZE);
  return new SetRecord(
    obj,
    max(intSize, 0),
    aCallable(obj.has),
    aCallable(obj.keys)
  );
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || this || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has-own-property.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/has-own-property.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/host-report-errors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/host-report-errors.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (a, b) {
  try {
    // eslint-disable-next-line no-console -- safe
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-metadata.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/internal-metadata.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternalModule = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var isExtensible = __webpack_require__(/*! ../internals/object-is-extensible */ "./node_modules/core-js/internals/object-is-extensible.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");

var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + id++, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () { /* empty */ };
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      } return result;
    };

    $({ target: 'Object', stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = module.exports = {
  enable: enable,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-callable.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js/internals/document-all.js");

var documentAll = $documentAll.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-constructor.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/is-constructor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-iterable.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-iterable.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var $Object = Object;

module.exports = function (it) {
  if (isNullOrUndefined(it)) return false;
  var O = $Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || hasOwn(Iterators, classof(O));
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-null-or-undefined.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/is-null-or-undefined.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js/internals/document-all.js");

var documentAll = $documentAll.all;

module.exports = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-symbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterate-simple.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterate-simple.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");

module.exports = function (record, fn, ITERATOR_INSTEAD_OF_RECORD) {
  var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
  var next = record.next;
  var step, result;
  while (!(step = call(next, iterator)).done) {
    result = fn(step.value);
    if (result !== undefined) return result;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterate.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-close.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-close.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-create-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-create-constructor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype);
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-define.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-define.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var FunctionName = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js/internals/iterator-create-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    }

    return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/length-of-array-like.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/length-of-array-like.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/make-built-in.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/make-built-in.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").CONFIGURABLE);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ "./node_modules/core-js/internals/map-helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/map-helpers.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

// eslint-disable-next-line es/no-map -- safe
var MapPrototype = Map.prototype;

module.exports = {
  // eslint-disable-next-line es/no-map -- safe
  Map: Map,
  set: uncurryThis(MapPrototype.set),
  get: uncurryThis(MapPrototype.get),
  has: uncurryThis(MapPrototype.has),
  remove: uncurryThis(MapPrototype['delete']),
  proto: MapPrototype
};


/***/ }),

/***/ "./node_modules/core-js/internals/map-iterate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/map-iterate.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var iterateSimple = __webpack_require__(/*! ../internals/iterate-simple */ "./node_modules/core-js/internals/iterate-simple.js");
var MapHelpers = __webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js");

var Map = MapHelpers.Map;
var MapPrototype = MapHelpers.proto;
var forEach = uncurryThis(MapPrototype.forEach);
var entries = uncurryThis(MapPrototype.entries);
var next = entries(new Map()).next;

module.exports = function (map, fn, interruptible) {
  return interruptible ? iterateSimple({ iterator: entries(map), next: next }, function (entry) {
    return fn(entry[1], entry[0]);
  }) : forEach(map, fn);
};


/***/ }),

/***/ "./node_modules/core-js/internals/math-fround.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/math-fround.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var sign = __webpack_require__(/*! ../internals/math-sign */ "./node_modules/core-js/internals/math-sign.js");

var abs = Math.abs;
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

// `Math.fround` method implementation
// https://tc39.es/ecma262/#sec-math.fround
// eslint-disable-next-line es/no-math-fround -- safe
module.exports = Math.fround || function fround(x) {
  var n = +x;
  var $abs = abs(n);
  var $sign = sign(n);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (result > MAX32 || result !== result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/math-scale.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-scale.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";

// `Math.scale` method implementation
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  var nx = +x;
  var nInLow = +inLow;
  var nInHigh = +inHigh;
  var nOutLow = +outLow;
  var nOutHigh = +outHigh;
  // eslint-disable-next-line no-self-compare -- NaN check
  if (nx !== nx || nInLow !== nInLow || nInHigh !== nInHigh || nOutLow !== nOutLow || nOutHigh !== nOutHigh) return NaN;
  if (nx === Infinity || nx === -Infinity) return nx;
  return (nx - nInLow) * (nOutHigh - nOutLow) / (nInHigh - nInLow) + nOutLow;
};


/***/ }),

/***/ "./node_modules/core-js/internals/math-sign.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/math-sign.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";

// `Math.sign` method implementation
// https://tc39.es/ecma262/#sec-math.sign
// eslint-disable-next-line es/no-math-sign -- safe
module.exports = Math.sign || function sign(x) {
  var n = +x;
  // eslint-disable-next-line no-self-compare -- NaN check
  return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
};


/***/ }),

/***/ "./node_modules/core-js/internals/math-trunc.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-trunc.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ "./node_modules/core-js/internals/new-promise-capability.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/new-promise-capability.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");

var $TypeError = TypeError;

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw $TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable(resolve);
  this.reject = aCallable(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/internals/number-is-finite.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/number-is-finite.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var globalIsFinite = global.isFinite;

// `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite
// eslint-disable-next-line es/no-number-isfinite -- safe
module.exports = Number.isFinite || function isFinite(it) {
  return typeof it == 'number' && globalIsFinite(it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/number-parse-int.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/number-parse-int.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var trim = (__webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim);
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var $parseInt = global.parseInt;
var Symbol = global.Symbol;
var ITERATOR = Symbol && Symbol.iterator;
var hex = /^[+-]?0x/i;
var exec = uncurryThis(hex.exec);
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22
  // MS Edge 18- broken with boxed symbols
  || (ITERATOR && !fails(function () { $parseInt(Object(ITERATOR)); }));

// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(toString(string));
  return $parseInt(S, (radix >>> 0) || (exec(hex, S) ? 16 : 10));
} : $parseInt;


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var $getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f);
var arraySlice = __webpack_require__(/*! ../internals/array-slice-simple */ "./node_modules/core-js/internals/array-slice-simple.js");

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) === 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-extensible.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-extensible.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__(/*! ../internals/array-buffer-non-extensible */ "./node_modules/core-js/internals/array-buffer-non-extensible.js");

// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
module.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
  if (!isObject(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-prototype-of.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-prototype-of.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(/*! ../internals/function-uncurry-this-accessor */ "./node_modules/core-js/internals/function-uncurry-this-accessor.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/observable-forced.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/observable-forced.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var $$OBSERVABLE = wellKnownSymbol('observable');
var NativeObservable = global.Observable;
var NativeObservablePrototype = NativeObservable && NativeObservable.prototype;

module.exports = !isCallable(NativeObservable)
  || !isCallable(NativeObservable.from)
  || !isCallable(NativeObservable.of)
  || !isCallable(NativeObservablePrototype.subscribe)
  || !isCallable(NativeObservablePrototype[$$OBSERVABLE]);


/***/ }),

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = global;


/***/ }),

/***/ "./node_modules/core-js/internals/perform.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/perform.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/reflect-metadata.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/reflect-metadata.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(/*! ../modules/es.map */ "./node_modules/core-js/modules/es.map.js");
__webpack_require__(/*! ../modules/es.weak-map */ "./node_modules/core-js/modules/es.weak-map.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");

var Map = getBuiltIn('Map');
var WeakMap = getBuiltIn('WeakMap');
var push = uncurryThis([].push);

var metadata = shared('metadata');
var store = metadata.store || (metadata.store = new WeakMap());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};

var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};

var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};

var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};

var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { push(keys, key); });
  return keys;
};

var toMetadataKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};

module.exports = {
  store: store,
  getMap: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  toKey: toMetadataKey
};


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/same-value-zero.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/same-value-zero.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";

// `SameValueZero` abstract operation
// https://tc39.es/ecma262/#sec-samevaluezero
module.exports = function (x, y) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return x === y || x !== x && y !== y;
};


/***/ }),

/***/ "./node_modules/core-js/internals/schedulers-fix.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/schedulers-fix.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var ENGINE_IS_BUN = __webpack_require__(/*! ../internals/engine-is-bun */ "./node_modules/core-js/internals/engine-is-bun.js");
var USER_AGENT = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var validateArgumentsLength = __webpack_require__(/*! ../internals/validate-arguments-length */ "./node_modules/core-js/internals/validate-arguments-length.js");

var Function = global.Function;
// dirty IE9- and Bun 0.3.0- checks
var WRAP = /MSIE .\./.test(USER_AGENT) || ENGINE_IS_BUN && (function () {
  var version = global.Bun.version.split('.');
  return version.length < 3 || version[0] === '0' && (version[1] < 3 || version[1] === '3' && version[2] === '0');
})();

// IE9- / Bun 0.3.0- setTimeout / setInterval / setImmediate additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
// https://github.com/oven-sh/bun/issues/1633
module.exports = function (scheduler, hasTimeArg) {
  var firstParamIndex = hasTimeArg ? 2 : 1;
  return WRAP ? function (handler, timeout /* , ...arguments */) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
    var fn = isCallable(handler) ? handler : Function(handler);
    var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
    var callback = boundArgs ? function () {
      apply(fn, this, params);
    } : fn;
    return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
  } : scheduler;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-clone.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/set-clone.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var SetHelpers = __webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js");
var iterate = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");

var Set = SetHelpers.Set;
var add = SetHelpers.add;

module.exports = function (set) {
  var result = new Set();
  iterate(set, function (it) {
    add(result, it);
  });
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-difference.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/set-difference.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var SetHelpers = __webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js");
var clone = __webpack_require__(/*! ../internals/set-clone */ "./node_modules/core-js/internals/set-clone.js");
var size = __webpack_require__(/*! ../internals/set-size */ "./node_modules/core-js/internals/set-size.js");
var getSetRecord = __webpack_require__(/*! ../internals/get-set-record */ "./node_modules/core-js/internals/get-set-record.js");
var iterateSet = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");
var iterateSimple = __webpack_require__(/*! ../internals/iterate-simple */ "./node_modules/core-js/internals/iterate-simple.js");

var has = SetHelpers.has;
var remove = SetHelpers.remove;

// `Set.prototype.difference` method
// https://github.com/tc39/proposal-set-methods
module.exports = function difference(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  var result = clone(O);
  if (size(O) <= otherRec.size) iterateSet(O, function (e) {
    if (otherRec.includes(e)) remove(result, e);
  });
  else iterateSimple(otherRec.getIterator(), function (e) {
    if (has(O, e)) remove(result, e);
  });
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-helpers.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

// eslint-disable-next-line es/no-set -- safe
var SetPrototype = Set.prototype;

module.exports = {
  // eslint-disable-next-line es/no-set -- safe
  Set: Set,
  add: uncurryThis(SetPrototype.add),
  has: uncurryThis(SetPrototype.has),
  remove: uncurryThis(SetPrototype['delete']),
  proto: SetPrototype
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-intersection.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/set-intersection.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var SetHelpers = __webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js");
var size = __webpack_require__(/*! ../internals/set-size */ "./node_modules/core-js/internals/set-size.js");
var getSetRecord = __webpack_require__(/*! ../internals/get-set-record */ "./node_modules/core-js/internals/get-set-record.js");
var iterateSet = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");
var iterateSimple = __webpack_require__(/*! ../internals/iterate-simple */ "./node_modules/core-js/internals/iterate-simple.js");

var Set = SetHelpers.Set;
var add = SetHelpers.add;
var has = SetHelpers.has;

// `Set.prototype.intersection` method
// https://github.com/tc39/proposal-set-methods
module.exports = function intersection(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  var result = new Set();

  if (size(O) > otherRec.size) {
    iterateSimple(otherRec.getIterator(), function (e) {
      if (has(O, e)) add(result, e);
    });
  } else {
    iterateSet(O, function (e) {
      if (otherRec.includes(e)) add(result, e);
    });
  }

  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-is-disjoint-from.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/set-is-disjoint-from.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var has = (__webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js").has);
var size = __webpack_require__(/*! ../internals/set-size */ "./node_modules/core-js/internals/set-size.js");
var getSetRecord = __webpack_require__(/*! ../internals/get-set-record */ "./node_modules/core-js/internals/get-set-record.js");
var iterateSet = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");
var iterateSimple = __webpack_require__(/*! ../internals/iterate-simple */ "./node_modules/core-js/internals/iterate-simple.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

// `Set.prototype.isDisjointFrom` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom
module.exports = function isDisjointFrom(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  if (size(O) <= otherRec.size) return iterateSet(O, function (e) {
    if (otherRec.includes(e)) return false;
  }, true) !== false;
  var iterator = otherRec.getIterator();
  return iterateSimple(iterator, function (e) {
    if (has(O, e)) return iteratorClose(iterator, 'normal', false);
  }) !== false;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-is-subset-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/set-is-subset-of.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var size = __webpack_require__(/*! ../internals/set-size */ "./node_modules/core-js/internals/set-size.js");
var iterate = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");
var getSetRecord = __webpack_require__(/*! ../internals/get-set-record */ "./node_modules/core-js/internals/get-set-record.js");

// `Set.prototype.isSubsetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf
module.exports = function isSubsetOf(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  if (size(O) > otherRec.size) return false;
  return iterate(O, function (e) {
    if (!otherRec.includes(e)) return false;
  }, true) !== false;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-is-superset-of.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/set-is-superset-of.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var has = (__webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js").has);
var size = __webpack_require__(/*! ../internals/set-size */ "./node_modules/core-js/internals/set-size.js");
var getSetRecord = __webpack_require__(/*! ../internals/get-set-record */ "./node_modules/core-js/internals/get-set-record.js");
var iterateSimple = __webpack_require__(/*! ../internals/iterate-simple */ "./node_modules/core-js/internals/iterate-simple.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

// `Set.prototype.isSupersetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf
module.exports = function isSupersetOf(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  if (size(O) < otherRec.size) return false;
  var iterator = otherRec.getIterator();
  return iterateSimple(iterator, function (e) {
    if (!has(O, e)) return iteratorClose(iterator, 'normal', false);
  }) !== false;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-iterate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-iterate.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var iterateSimple = __webpack_require__(/*! ../internals/iterate-simple */ "./node_modules/core-js/internals/iterate-simple.js");
var SetHelpers = __webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js");

var Set = SetHelpers.Set;
var SetPrototype = SetHelpers.proto;
var forEach = uncurryThis(SetPrototype.forEach);
var keys = uncurryThis(SetPrototype.keys);
var next = keys(new Set()).next;

module.exports = function (set, fn, interruptible) {
  return interruptible ? iterateSimple({ iterator: keys(set), next: next }, fn) : forEach(set, fn);
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-size.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/set-size.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThisAccessor = __webpack_require__(/*! ../internals/function-uncurry-this-accessor */ "./node_modules/core-js/internals/function-uncurry-this-accessor.js");
var SetHelpers = __webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js");

module.exports = uncurryThisAccessor(SetHelpers.proto, 'size', 'get') || function (set) {
  return set.size;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-species.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineBuiltInAccessor(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-symmetric-difference.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/set-symmetric-difference.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var SetHelpers = __webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js");
var clone = __webpack_require__(/*! ../internals/set-clone */ "./node_modules/core-js/internals/set-clone.js");
var getSetRecord = __webpack_require__(/*! ../internals/get-set-record */ "./node_modules/core-js/internals/get-set-record.js");
var iterateSimple = __webpack_require__(/*! ../internals/iterate-simple */ "./node_modules/core-js/internals/iterate-simple.js");

var add = SetHelpers.add;
var has = SetHelpers.has;
var remove = SetHelpers.remove;

// `Set.prototype.symmetricDifference` method
// https://github.com/tc39/proposal-set-methods
module.exports = function symmetricDifference(other) {
  var O = aSet(this);
  var keysIter = getSetRecord(other).getIterator();
  var result = clone(O);
  iterateSimple(keysIter, function (e) {
    if (has(O, e)) remove(result, e);
    else add(result, e);
  });
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-union.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/set-union.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var add = (__webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js").add);
var clone = __webpack_require__(/*! ../internals/set-clone */ "./node_modules/core-js/internals/set-clone.js");
var getSetRecord = __webpack_require__(/*! ../internals/get-set-record */ "./node_modules/core-js/internals/get-set-record.js");
var iterateSimple = __webpack_require__(/*! ../internals/iterate-simple */ "./node_modules/core-js/internals/iterate-simple.js");

// `Set.prototype.union` method
// https://github.com/tc39/proposal-set-methods
module.exports = function union(other) {
  var O = aSet(this);
  var keysIter = getSetRecord(other).getIterator();
  var result = clone(O);
  iterateSimple(keysIter, function (it) {
    add(result, it);
  });
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.32.2',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.32.2/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "./node_modules/core-js/internals/string-multibyte.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-trim.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/string-trim.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var replace = uncurryThis(''.replace);
var ltrim = RegExp('^[' + whitespaces + ']+');
var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '$1');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-constructor-detection.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-constructor-detection.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js/internals/task.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/task.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var validateArgumentsLength = __webpack_require__(/*! ../internals/validate-arguments-length */ "./node_modules/core-js/internals/validate-arguments-length.js");
var IS_IOS = __webpack_require__(/*! ../internals/engine-is-ios */ "./node_modules/core-js/internals/engine-is-ios.js");
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ "./node_modules/core-js/internals/engine-is-node.js");

var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var Dispatch = global.Dispatch;
var Function = global.Function;
var MessageChannel = global.MessageChannel;
var String = global.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var $location, defer, channel, port;

fails(function () {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  $location = global.location;
});

var run = function (id) {
  if (hasOwn(queue, id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var eventListener = function (event) {
  run(event.data);
};

var globalPostMessageDefer = function (id) {
  // old engines have not location.origin
  global.postMessage(String(id), $location.protocol + '//' + $location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function(handler);
    var args = arraySlice(arguments, 1);
    queue[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    isCallable(global.postMessage) &&
    !global.importScripts &&
    $location && $location.protocol !== 'file:' &&
    !fails(globalPostMessageDefer)
  ) {
    defer = globalPostMessageDefer;
    global.addEventListener('message', eventListener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer-or-infinity.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer-or-infinity.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js/internals/math-trunc.js");

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-offset.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-offset.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPositiveInteger = __webpack_require__(/*! ../internals/to-positive-integer */ "./node_modules/core-js/internals/to-positive-integer.js");

var $RangeError = RangeError;

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw $RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-positive-integer.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/to-positive-integer.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var $RangeError = RangeError;

module.exports = function (it) {
  var result = toIntegerOrInfinity(it);
  if (result < 0) throw $RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-property-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-set-like.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/to-set-like.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isIterable = __webpack_require__(/*! ../internals/is-iterable */ "./node_modules/core-js/internals/is-iterable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var Set = getBuiltIn('Set');

var isSetLike = function (it) {
  return isObject(it)
    && typeof it.size == 'number'
    && isCallable(it.has)
    && isCallable(it.keys);
};

// fallback old -> new set methods proposal arguments
module.exports = function (it) {
  if (isSetLike(it)) return it;
  return isIterable(it) ? new Set(it) : it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "./node_modules/core-js/internals/to-string.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-string.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/try-to-string.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/try-to-string.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js/internals/v8-prototype-define-bug.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/v8-prototype-define-bug.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ "./node_modules/core-js/internals/validate-arguments-length.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/validate-arguments-length.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ "./node_modules/core-js/internals/weak-map-basic-detection.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/weak-map-basic-detection.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/weak-map-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/weak-map-helpers.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

// eslint-disable-next-line es/no-weak-map -- safe
var WeakMapPrototype = WeakMap.prototype;

module.exports = {
  // eslint-disable-next-line es/no-weak-map -- safe
  WeakMap: WeakMap,
  set: uncurryThis(WeakMapPrototype.set),
  get: uncurryThis(WeakMapPrototype.get),
  has: uncurryThis(WeakMapPrototype.has),
  remove: uncurryThis(WeakMapPrototype['delete'])
};


/***/ }),

/***/ "./node_modules/core-js/internals/weak-set-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/weak-set-helpers.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

// eslint-disable-next-line es/no-weak-set -- safe
var WeakSetPrototype = WeakSet.prototype;

module.exports = {
  // eslint-disable-next-line es/no-weak-set -- safe
  WeakSet: WeakSet,
  add: uncurryThis(WeakSetPrototype.add),
  has: uncurryThis(WeakSetPrototype.has),
  remove: uncurryThis(WeakSetPrototype['delete'])
};


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol-define.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol-define.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol-wrapped.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js/internals/whitespaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/whitespaces.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.includes.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.includes.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $includes = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").includes);
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  // eslint-disable-next-line es/no-array-prototype-includes -- detection
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "./node_modules/core-js/modules/es.map.constructor.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.map.constructor.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");

// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "./node_modules/core-js/modules/es.map.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/es.map.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(/*! ../modules/es.map.constructor */ "./node_modules/core-js/modules/es.map.constructor.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.flags.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.flags.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var regExpFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// babel-minify and Closure Compiler transpiles RegExp('.', 'd') -> /./d and it causes SyntaxError
var RegExp = global.RegExp;
var RegExpPrototype = RegExp.prototype;

var FORCED = DESCRIPTORS && fails(function () {
  var INDICES_SUPPORT = true;
  try {
    RegExp('.', 'd');
  } catch (error) {
    INDICES_SUPPORT = false;
  }

  var O = {};
  // modern V8 bug
  var calls = '';
  var expected = INDICES_SUPPORT ? 'dgimsy' : 'gimsy';

  var addGetter = function (key, chr) {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(O, key, { get: function () {
      calls += chr;
      return true;
    } });
  };

  var pairs = {
    dotAll: 's',
    global: 'g',
    ignoreCase: 'i',
    multiline: 'm',
    sticky: 'y'
  };

  if (INDICES_SUPPORT) pairs.hasIndices = 'd';

  for (var key in pairs) addGetter(key, pairs[key]);

  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var result = Object.getOwnPropertyDescriptor(RegExpPrototype, 'flags').get.call(O);

  return result !== expected || calls !== expected;
});

// `RegExp.prototype.flags` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
if (FORCED) defineBuiltInAccessor(RegExpPrototype, 'flags', {
  configurable: true,
  get: regExpFlags
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.set.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.set.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var toOffset = __webpack_require__(/*! ../internals/to-offset */ "./node_modules/core-js/internals/to-offset.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var RangeError = global.RangeError;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  var array = new Uint8ClampedArray(2);
  call($set, array, { length: 1, 0: 3 }, 1);
  return array[1] !== 3;
});

// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
  var array = new Int8Array(2);
  array.set(1);
  array.set('2', 1);
  return array[0] !== 0 || array[1] !== 2;
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var src = toIndexedObject(arrayLike);
  if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
  var length = this.length;
  var len = lengthOfArrayLike(src);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-map.constructor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-map.constructor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");
var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js/internals/collection-weak.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var enforceInternalState = (__webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js").enforce);
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");

var $Object = Object;
// eslint-disable-next-line es/no-array-isarray -- safe
var isArray = Array.isArray;
// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible = $Object.isExtensible;
// eslint-disable-next-line es/no-object-isfrozen -- safe
var isFrozen = $Object.isFrozen;
// eslint-disable-next-line es/no-object-issealed -- safe
var isSealed = $Object.isSealed;
// eslint-disable-next-line es/no-object-freeze -- safe
var freeze = $Object.freeze;
// eslint-disable-next-line es/no-object-seal -- safe
var seal = $Object.seal;

var FROZEN = {};
var SEALED = {};
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var InternalWeakMap;

var wrapper = function (init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
};

// `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor
var $WeakMap = collection('WeakMap', wrapper, collectionWeak);
var WeakMapPrototype = $WeakMap.prototype;
var nativeSet = uncurryThis(WeakMapPrototype.set);

// Chakra Edge bug: adding frozen arrays to WeakMap unfreeze them
var hasMSEdgeFreezingBug = function () {
  return FREEZING && fails(function () {
    var frozenArray = freeze([]);
    nativeSet(new $WeakMap(), frozenArray, 1);
    return !isFrozen(frozenArray);
  });
};

// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP) if (IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.enable();
  var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
  var nativeHas = uncurryThis(WeakMapPrototype.has);
  var nativeGet = uncurryThis(WeakMapPrototype.get);
  defineBuiltIns(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen['delete'](key);
      } return nativeDelete(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      } return nativeHas(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      } return nativeGet(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else nativeSet(this, key, value);
      return this;
    }
  });
// Chakra Edge frozen keys fix
} else if (hasMSEdgeFreezingBug()) {
  defineBuiltIns(WeakMapPrototype, {
    set: function set(key, value) {
      var arrayIntegrityLevel;
      if (isArray(key)) {
        if (isFrozen(key)) arrayIntegrityLevel = FROZEN;
        else if (isSealed(key)) arrayIntegrityLevel = SEALED;
      }
      nativeSet(this, key, value);
      if (arrayIntegrityLevel === FROZEN) freeze(key);
      if (arrayIntegrityLevel === SEALED) seal(key);
      return this;
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-map.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-map.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(/*! ../modules/es.weak-map.constructor */ "./node_modules/core-js/modules/es.weak-map.constructor.js");


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.array.last-index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.array.last-index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");

// `Array.prototype.lastIndex` getter
// https://github.com/keithamus/proposal-array-last
if (DESCRIPTORS) {
  defineBuiltInAccessor(Array.prototype, 'lastIndex', {
    configurable: true,
    get: function lastIndex() {
      var O = toObject(this);
      var len = lengthOfArrayLike(O);
      return len === 0 ? 0 : len - 1;
    }
  });

  addToUnscopables('lastIndex');
}


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.array.last-item.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.array.last-item.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");

// `Array.prototype.lastIndex` accessor
// https://github.com/keithamus/proposal-array-last
if (DESCRIPTORS) {
  defineBuiltInAccessor(Array.prototype, 'lastItem', {
    configurable: true,
    get: function lastItem() {
      var O = toObject(this);
      var len = lengthOfArrayLike(O);
      return len === 0 ? undefined : O[len - 1];
    },
    set: function lastItem(value) {
      var O = toObject(this);
      var len = lengthOfArrayLike(O);
      return O[len === 0 ? 0 : len - 1] = value;
    }
  });

  addToUnscopables('lastItem');
}


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.composite-key.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.composite-key.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var getCompositeKeyNode = __webpack_require__(/*! ../internals/composite-key */ "./node_modules/core-js/internals/composite-key.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");

var $Object = Object;

var initializer = function () {
  var freeze = getBuiltIn('Object', 'freeze');
  return freeze ? freeze(create(null)) : create(null);
};

// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
$({ global: true, forced: true }, {
  compositeKey: function compositeKey() {
    return apply(getCompositeKeyNode, $Object, arguments).get('object', initializer);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.composite-symbol.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.composite-symbol.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getCompositeKeyNode = __webpack_require__(/*! ../internals/composite-key */ "./node_modules/core-js/internals/composite-key.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");

// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
$({ global: true, forced: true }, {
  compositeSymbol: function compositeSymbol() {
    if (arguments.length === 1 && typeof arguments[0] == 'string') return getBuiltIn('Symbol')['for'](arguments[0]);
    return apply(getCompositeKeyNode, null, arguments).get('symbol', getBuiltIn('Symbol'));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.delete-all.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.delete-all.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var remove = (__webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js").remove);

// `Map.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  deleteAll: function deleteAll(/* ...elements */) {
    var collection = aMap(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k = 0, len = arguments.length; k < len; k++) {
      wasDeleted = remove(collection, arguments[k]);
      allDeleted = allDeleted && wasDeleted;
    } return !!allDeleted;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.every.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.every.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

// `Map.prototype.every` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  every: function every(callbackfn /* , thisArg */) {
    var map = aMap(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return iterate(map, function (value, key) {
      if (!boundFunction(value, key, map)) return false;
    }, true) !== false;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var MapHelpers = __webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

var Map = MapHelpers.Map;
var set = MapHelpers.set;

// `Map.prototype.filter` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  filter: function filter(callbackfn /* , thisArg */) {
    var map = aMap(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newMap = new Map();
    iterate(map, function (value, key) {
      if (boundFunction(value, key, map)) set(newMap, key, value);
    });
    return newMap;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.find-key.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.find-key.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

// `Map.prototype.findKey` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  findKey: function findKey(callbackfn /* , thisArg */) {
    var map = aMap(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var result = iterate(map, function (value, key) {
      if (boundFunction(value, key, map)) return { key: key };
    }, true);
    return result && result.key;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.find.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.find.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

// `Map.prototype.find` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  find: function find(callbackfn /* , thisArg */) {
    var map = aMap(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var result = iterate(map, function (value, key) {
      if (boundFunction(value, key, map)) return { value: value };
    }, true);
    return result && result.value;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.from.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.from.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/collection-from */ "./node_modules/core-js/internals/collection-from.js");

// `Map.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
$({ target: 'Map', stat: true, forced: true }, {
  from: from
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.group-by.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.group-by.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var MapHelpers = __webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var Map = MapHelpers.Map;
var has = MapHelpers.has;
var get = MapHelpers.get;
var set = MapHelpers.set;
var push = uncurryThis([].push);

// `Map.groupBy` method
// https://github.com/tc39/proposal-array-grouping
$({ target: 'Map', stat: true, forced: IS_PURE }, {
  groupBy: function groupBy(items, callbackfn) {
    requireObjectCoercible(items);
    aCallable(callbackfn);
    var map = new Map();
    var k = 0;
    iterate(items, function (value) {
      var key = callbackfn(value, k++);
      if (!has(map, key)) set(map, key, [value]);
      else push(get(map, key), value);
    });
    return map;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.includes.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.includes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var sameValueZero = __webpack_require__(/*! ../internals/same-value-zero */ "./node_modules/core-js/internals/same-value-zero.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

// `Map.prototype.includes` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  includes: function includes(searchElement) {
    return iterate(aMap(this), function (value) {
      if (sameValueZero(value, searchElement)) return true;
    }, true) === true;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.key-by.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.key-by.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var Map = (__webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js").Map);

// `Map.keyBy` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', stat: true, forced: true }, {
  keyBy: function keyBy(iterable, keyDerivative) {
    var C = isCallable(this) ? this : Map;
    var newMap = new C();
    aCallable(keyDerivative);
    var setter = aCallable(newMap.set);
    iterate(iterable, function (element) {
      call(setter, newMap, keyDerivative(element), element);
    });
    return newMap;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.key-of.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.key-of.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

// `Map.prototype.keyOf` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  keyOf: function keyOf(searchElement) {
    var result = iterate(aMap(this), function (value, key) {
      if (value === searchElement) return { key: key };
    }, true);
    return result && result.key;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.map-keys.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.map-keys.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var MapHelpers = __webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

var Map = MapHelpers.Map;
var set = MapHelpers.set;

// `Map.prototype.mapKeys` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  mapKeys: function mapKeys(callbackfn /* , thisArg */) {
    var map = aMap(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newMap = new Map();
    iterate(map, function (value, key) {
      set(newMap, boundFunction(value, key, map), value);
    });
    return newMap;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.map-values.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.map-values.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var MapHelpers = __webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

var Map = MapHelpers.Map;
var set = MapHelpers.set;

// `Map.prototype.mapValues` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  mapValues: function mapValues(callbackfn /* , thisArg */) {
    var map = aMap(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newMap = new Map();
    iterate(map, function (value, key) {
      set(newMap, key, boundFunction(value, key, map));
    });
    return newMap;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var set = (__webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js").set);

// `Map.prototype.merge` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, arity: 1, forced: true }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  merge: function merge(iterable /* ...iterables */) {
    var map = aMap(this);
    var argumentsLength = arguments.length;
    var i = 0;
    while (i < argumentsLength) {
      iterate(arguments[i++], function (key, value) {
        set(map, key, value);
      }, { AS_ENTRIES: true });
    }
    return map;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.of.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.of.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var of = __webpack_require__(/*! ../internals/collection-of */ "./node_modules/core-js/internals/collection-of.js");

// `Map.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
$({ target: 'Map', stat: true, forced: true }, {
  of: of
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.reduce.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.reduce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

var $TypeError = TypeError;

// `Map.prototype.reduce` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var map = aMap(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    aCallable(callbackfn);
    iterate(map, function (value, key) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, key, map);
      }
    });
    if (noInitial) throw $TypeError('Reduce of empty map with no initial value');
    return accumulator;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.some.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.some.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var iterate = __webpack_require__(/*! ../internals/map-iterate */ "./node_modules/core-js/internals/map-iterate.js");

// `Map.prototype.some` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  some: function some(callbackfn /* , thisArg */) {
    var map = aMap(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return iterate(map, function (value, key) {
      if (boundFunction(value, key, map)) return true;
    }, true) === true;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.map.update.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.map.update.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var aMap = __webpack_require__(/*! ../internals/a-map */ "./node_modules/core-js/internals/a-map.js");
var MapHelpers = __webpack_require__(/*! ../internals/map-helpers */ "./node_modules/core-js/internals/map-helpers.js");

var $TypeError = TypeError;
var get = MapHelpers.get;
var has = MapHelpers.has;
var set = MapHelpers.set;

// `Map.prototype.update` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Map', proto: true, real: true, forced: true }, {
  update: function update(key, callback /* , thunk */) {
    var map = aMap(this);
    var length = arguments.length;
    aCallable(callback);
    var isPresentInMap = has(map, key);
    if (!isPresentInMap && length < 3) {
      throw $TypeError('Updating absent value');
    }
    var value = isPresentInMap ? get(map, key) : aCallable(length > 2 ? arguments[2] : undefined)(key, map);
    set(map, key, callback(value, key, map));
    return map;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.clamp.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.clamp.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var min = Math.min;
var max = Math.max;

// `Math.clamp` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true, forced: true }, {
  clamp: function clamp(x, lower, upper) {
    return min(upper, max(lower, x));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.deg-per-rad.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.deg-per-rad.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Math.DEG_PER_RAD` constant
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true, nonConfigurable: true, nonWritable: true }, {
  DEG_PER_RAD: Math.PI / 180
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.degrees.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.degrees.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var RAD_PER_DEG = 180 / Math.PI;

// `Math.degrees` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true, forced: true }, {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.fscale.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.fscale.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var scale = __webpack_require__(/*! ../internals/math-scale */ "./node_modules/core-js/internals/math-scale.js");
var fround = __webpack_require__(/*! ../internals/math-fround */ "./node_modules/core-js/internals/math-fround.js");

// `Math.fscale` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true, forced: true }, {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.iaddh.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.iaddh.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Math.iaddh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({ target: 'Math', stat: true, forced: true }, {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.imulh.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.imulh.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Math.imulh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({ target: 'Math', stat: true, forced: true }, {
  imulh: function imulh(u, v) {
    var UINT16 = 0xFFFF;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.isubh.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.isubh.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Math.isubh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({ target: 'Math', stat: true, forced: true }, {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.rad-per-deg.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.rad-per-deg.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Math.RAD_PER_DEG` constant
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true, nonConfigurable: true, nonWritable: true }, {
  RAD_PER_DEG: 180 / Math.PI
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.radians.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.radians.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var DEG_PER_RAD = Math.PI / 180;

// `Math.radians` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true, forced: true }, {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.scale.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.scale.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var scale = __webpack_require__(/*! ../internals/math-scale */ "./node_modules/core-js/internals/math-scale.js");

// `Math.scale` method
// https://rwaldron.github.io/proposal-math-extensions/
$({ target: 'Math', stat: true, forced: true }, {
  scale: scale
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.seeded-prng.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.seeded-prng.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var numberIsFinite = __webpack_require__(/*! ../internals/number-is-finite */ "./node_modules/core-js/internals/number-is-finite.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js/internals/iterator-create-constructor.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var SEEDED_RANDOM = 'Seeded Random';
var SEEDED_RANDOM_GENERATOR = SEEDED_RANDOM + ' Generator';
var SEED_TYPE_ERROR = 'Math.seededPRNG() argument should have a "seed" field with a finite value.';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SEEDED_RANDOM_GENERATOR);
var $TypeError = TypeError;

var $SeededRandomGenerator = createIteratorConstructor(function SeededRandomGenerator(seed) {
  setInternalState(this, {
    type: SEEDED_RANDOM_GENERATOR,
    seed: seed % 2147483647
  });
}, SEEDED_RANDOM, function next() {
  var state = getInternalState(this);
  var seed = state.seed = (state.seed * 1103515245 + 12345) % 2147483647;
  return createIterResultObject((seed & 1073741823) / 1073741823, false);
});

// `Math.seededPRNG` method
// https://github.com/tc39/proposal-seeded-random
// based on https://github.com/tc39/proposal-seeded-random/blob/78b8258835b57fc2100d076151ab506bc3202ae6/demo.html
$({ target: 'Math', stat: true, forced: true }, {
  seededPRNG: function seededPRNG(it) {
    var seed = anObject(it).seed;
    if (!numberIsFinite(seed)) throw $TypeError(SEED_TYPE_ERROR);
    return new $SeededRandomGenerator(seed);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.signbit.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.signbit.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Math.signbit` method
// https://github.com/tc39/proposal-Math.signbit
$({ target: 'Math', stat: true, forced: true }, {
  signbit: function signbit(x) {
    var n = +x;
    // eslint-disable-next-line no-self-compare -- NaN check
    return n === n && n === 0 ? 1 / n === -Infinity : n < 0;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.math.umulh.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.math.umulh.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Math.umulh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({ target: 'Math', stat: true, forced: true }, {
  umulh: function umulh(u, v) {
    var UINT16 = 0xFFFF;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.number.from-string.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.number.from-string.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
var parseInt = __webpack_require__(/*! ../internals/number-parse-int */ "./node_modules/core-js/internals/number-parse-int.js");

var INVALID_NUMBER_REPRESENTATION = 'Invalid number representation';
var INVALID_RADIX = 'Invalid radix';
var $RangeError = RangeError;
var $SyntaxError = SyntaxError;
var $TypeError = TypeError;
var valid = /^[\da-z]+$/;
var charAt = uncurryThis(''.charAt);
var exec = uncurryThis(valid.exec);
var numberToString = uncurryThis(1.0.toString);
var stringSlice = uncurryThis(''.slice);

// `Number.fromString` method
// https://github.com/tc39/proposal-number-fromstring
$({ target: 'Number', stat: true, forced: true }, {
  fromString: function fromString(string, radix) {
    var sign = 1;
    var R, mathNum;
    if (typeof string != 'string') throw $TypeError(INVALID_NUMBER_REPRESENTATION);
    if (!string.length) throw $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    if (charAt(string, 0) === '-') {
      sign = -1;
      string = stringSlice(string, 1);
      if (!string.length) throw $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    }
    R = radix === undefined ? 10 : toIntegerOrInfinity(radix);
    if (R < 2 || R > 36) throw $RangeError(INVALID_RADIX);
    if (!exec(valid, string) || numberToString(mathNum = parseInt(string, R), R) !== string) {
      throw $SyntaxError(INVALID_NUMBER_REPRESENTATION);
    }
    return sign * mathNum;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.observable.constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.observable.constructor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// https://github.com/tc39/proposal-observable
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var hostReportErrors = __webpack_require__(/*! ../internals/host-report-errors */ "./node_modules/core-js/internals/host-report-errors.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var OBSERVABLE_FORCED = __webpack_require__(/*! ../internals/observable-forced */ "./node_modules/core-js/internals/observable-forced.js");

var $$OBSERVABLE = wellKnownSymbol('observable');
var OBSERVABLE = 'Observable';
var SUBSCRIPTION = 'Subscription';
var SUBSCRIPTION_OBSERVER = 'SubscriptionObserver';
var getterFor = InternalStateModule.getterFor;
var setInternalState = InternalStateModule.set;
var getObservableInternalState = getterFor(OBSERVABLE);
var getSubscriptionInternalState = getterFor(SUBSCRIPTION);
var getSubscriptionObserverInternalState = getterFor(SUBSCRIPTION_OBSERVER);

var SubscriptionState = function (observer) {
  this.observer = anObject(observer);
  this.cleanup = undefined;
  this.subscriptionObserver = undefined;
};

SubscriptionState.prototype = {
  type: SUBSCRIPTION,
  clean: function () {
    var cleanup = this.cleanup;
    if (cleanup) {
      this.cleanup = undefined;
      try {
        cleanup();
      } catch (error) {
        hostReportErrors(error);
      }
    }
  },
  close: function () {
    if (!DESCRIPTORS) {
      var subscription = this.facade;
      var subscriptionObserver = this.subscriptionObserver;
      subscription.closed = true;
      if (subscriptionObserver) subscriptionObserver.closed = true;
    } this.observer = undefined;
  },
  isClosed: function () {
    return this.observer === undefined;
  }
};

var Subscription = function (observer, subscriber) {
  var subscriptionState = setInternalState(this, new SubscriptionState(observer));
  var start;
  if (!DESCRIPTORS) this.closed = false;
  try {
    if (start = getMethod(observer, 'start')) call(start, observer, this);
  } catch (error) {
    hostReportErrors(error);
  }
  if (subscriptionState.isClosed()) return;
  var subscriptionObserver = subscriptionState.subscriptionObserver = new SubscriptionObserver(subscriptionState);
  try {
    var cleanup = subscriber(subscriptionObserver);
    var subscription = cleanup;
    if (!isNullOrUndefined(cleanup)) subscriptionState.cleanup = isCallable(cleanup.unsubscribe)
      ? function () { subscription.unsubscribe(); }
      : aCallable(cleanup);
  } catch (error) {
    subscriptionObserver.error(error);
    return;
  } if (subscriptionState.isClosed()) subscriptionState.clean();
};

Subscription.prototype = defineBuiltIns({}, {
  unsubscribe: function unsubscribe() {
    var subscriptionState = getSubscriptionInternalState(this);
    if (!subscriptionState.isClosed()) {
      subscriptionState.close();
      subscriptionState.clean();
    }
  }
});

if (DESCRIPTORS) defineBuiltInAccessor(Subscription.prototype, 'closed', {
  configurable: true,
  get: function closed() {
    return getSubscriptionInternalState(this).isClosed();
  }
});

var SubscriptionObserver = function (subscriptionState) {
  setInternalState(this, {
    type: SUBSCRIPTION_OBSERVER,
    subscriptionState: subscriptionState
  });
  if (!DESCRIPTORS) this.closed = false;
};

SubscriptionObserver.prototype = defineBuiltIns({}, {
  next: function next(value) {
    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
    if (!subscriptionState.isClosed()) {
      var observer = subscriptionState.observer;
      try {
        var nextMethod = getMethod(observer, 'next');
        if (nextMethod) call(nextMethod, observer, value);
      } catch (error) {
        hostReportErrors(error);
      }
    }
  },
  error: function error(value) {
    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
    if (!subscriptionState.isClosed()) {
      var observer = subscriptionState.observer;
      subscriptionState.close();
      try {
        var errorMethod = getMethod(observer, 'error');
        if (errorMethod) call(errorMethod, observer, value);
        else hostReportErrors(value);
      } catch (err) {
        hostReportErrors(err);
      } subscriptionState.clean();
    }
  },
  complete: function complete() {
    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
    if (!subscriptionState.isClosed()) {
      var observer = subscriptionState.observer;
      subscriptionState.close();
      try {
        var completeMethod = getMethod(observer, 'complete');
        if (completeMethod) call(completeMethod, observer);
      } catch (error) {
        hostReportErrors(error);
      } subscriptionState.clean();
    }
  }
});

if (DESCRIPTORS) defineBuiltInAccessor(SubscriptionObserver.prototype, 'closed', {
  configurable: true,
  get: function closed() {
    return getSubscriptionObserverInternalState(this).subscriptionState.isClosed();
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, ObservablePrototype);
  setInternalState(this, {
    type: OBSERVABLE,
    subscriber: aCallable(subscriber)
  });
};

var ObservablePrototype = $Observable.prototype;

defineBuiltIns(ObservablePrototype, {
  subscribe: function subscribe(observer) {
    var length = arguments.length;
    return new Subscription(isCallable(observer) ? {
      next: observer,
      error: length > 1 ? arguments[1] : undefined,
      complete: length > 2 ? arguments[2] : undefined
    } : isObject(observer) ? observer : {}, getObservableInternalState(this).subscriber);
  }
});

defineBuiltIn(ObservablePrototype, $$OBSERVABLE, function () { return this; });

$({ global: true, constructor: true, forced: OBSERVABLE_FORCED }, {
  Observable: $Observable
});

setSpecies(OBSERVABLE);


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.observable.from.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.observable.from.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var OBSERVABLE_FORCED = __webpack_require__(/*! ../internals/observable-forced */ "./node_modules/core-js/internals/observable-forced.js");

var $$OBSERVABLE = wellKnownSymbol('observable');

// `Observable.from` method
// https://github.com/tc39/proposal-observable
$({ target: 'Observable', stat: true, forced: OBSERVABLE_FORCED }, {
  from: function from(x) {
    var C = isConstructor(this) ? this : getBuiltIn('Observable');
    var observableMethod = getMethod(anObject(x), $$OBSERVABLE);
    if (observableMethod) {
      var observable = anObject(call(observableMethod, x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    var iterator = getIterator(x);
    return new C(function (observer) {
      iterate(iterator, function (it, stop) {
        observer.next(it);
        if (observer.closed) return stop();
      }, { IS_ITERATOR: true, INTERRUPTED: true });
      observer.complete();
    });
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.observable.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.observable.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/esnext.observable.constructor */ "./node_modules/core-js/modules/esnext.observable.constructor.js");
__webpack_require__(/*! ../modules/esnext.observable.from */ "./node_modules/core-js/modules/esnext.observable.from.js");
__webpack_require__(/*! ../modules/esnext.observable.of */ "./node_modules/core-js/modules/esnext.observable.of.js");


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.observable.of.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.observable.of.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var OBSERVABLE_FORCED = __webpack_require__(/*! ../internals/observable-forced */ "./node_modules/core-js/internals/observable-forced.js");

var Array = getBuiltIn('Array');

// `Observable.of` method
// https://github.com/tc39/proposal-observable
$({ target: 'Observable', stat: true, forced: OBSERVABLE_FORCED }, {
  of: function of() {
    var C = isConstructor(this) ? this : getBuiltIn('Observable');
    var length = arguments.length;
    var items = Array(length);
    var index = 0;
    while (index < length) items[index] = arguments[index++];
    return new C(function (observer) {
      for (var i = 0; i < length; i++) {
        observer.next(items[i]);
        if (observer.closed) return;
      } observer.complete();
    });
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.promise.try.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.promise.try.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");
var perform = __webpack_require__(/*! ../internals/perform */ "./node_modules/core-js/internals/perform.js");

// `Promise.try` method
// https://github.com/tc39/proposal-promise-try
$({ target: 'Promise', stat: true, forced: true }, {
  'try': function (callbackfn) {
    var promiseCapability = newPromiseCapabilityModule.f(this);
    var result = perform(callbackfn);
    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
    return promiseCapability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.define-metadata.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.define-metadata.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;

// `Reflect.defineMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target /* , targetKey */) {
    var targetKey = arguments.length < 4 ? undefined : toMetadataKey(arguments[3]);
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.delete-metadata.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.delete-metadata.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toMetadataKey = ReflectMetadataModule.toKey;
var getOrCreateMetadataMap = ReflectMetadataModule.getMap;
var store = ReflectMetadataModule.store;

// `Reflect.deleteMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var $arrayUniqueBy = __webpack_require__(/*! ../internals/array-unique-by */ "./node_modules/core-js/internals/array-unique-by.js");

var arrayUniqueBy = uncurryThis($arrayUniqueBy);
var concat = uncurryThis([].concat);
var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
var toMetadataKey = ReflectMetadataModule.toKey;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? arrayUniqueBy(concat(oKeys, pKeys)) : pKeys : oKeys;
};

// `Reflect.getMetadataKeys` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
    var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
    return ordinaryMetadataKeys(anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.get-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.get-metadata.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");

var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
var toMetadataKey = ReflectMetadataModule.toKey;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

// `Reflect.getMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryGetMetadata(metadataKey, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
var toMetadataKey = ReflectMetadataModule.toKey;

// `Reflect.getOwnMetadataKeys` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
    var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
    return ordinaryOwnMetadataKeys(anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
var toMetadataKey = ReflectMetadataModule.toKey;

// `Reflect.getOwnMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.has-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.has-metadata.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");

var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var toMetadataKey = ReflectMetadataModule.toKey;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

// `Reflect.hasMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryHasMetadata(metadataKey, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var toMetadataKey = ReflectMetadataModule.toKey;

// `Reflect.hasOwnMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), targetKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.reflect.metadata.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.reflect.metadata.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ReflectMetadataModule = __webpack_require__(/*! ../internals/reflect-metadata */ "./node_modules/core-js/internals/reflect-metadata.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;

// `Reflect.metadata` method
// https://github.com/rbuckton/reflect-metadata
$({ target: 'Reflect', stat: true }, {
  metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, key) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetadataKey(key));
    };
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.add-all.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.add-all.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var add = (__webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js").add);

// `Set.prototype.addAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  addAll: function addAll(/* ...elements */) {
    var set = aSet(this);
    for (var k = 0, len = arguments.length; k < len; k++) {
      add(set, arguments[k]);
    } return set;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.delete-all.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.delete-all.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var remove = (__webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js").remove);

// `Set.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  deleteAll: function deleteAll(/* ...elements */) {
    var collection = aSet(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k = 0, len = arguments.length; k < len; k++) {
      wasDeleted = remove(collection, arguments[k]);
      allDeleted = allDeleted && wasDeleted;
    } return !!allDeleted;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.difference.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.difference.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toSetLike = __webpack_require__(/*! ../internals/to-set-like */ "./node_modules/core-js/internals/to-set-like.js");
var $difference = __webpack_require__(/*! ../internals/set-difference */ "./node_modules/core-js/internals/set-difference.js");

// `Set.prototype.difference` method
// https://github.com/tc39/proposal-set-methods
// TODO: Obsolete version, remove from `core-js@4`
$({ target: 'Set', proto: true, real: true, forced: true }, {
  difference: function difference(other) {
    return call($difference, this, toSetLike(other));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.every.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.every.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var iterate = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");

// `Set.prototype.every` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  every: function every(callbackfn /* , thisArg */) {
    var set = aSet(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return iterate(set, function (value) {
      if (!boundFunction(value, value, set)) return false;
    }, true) !== false;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var SetHelpers = __webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js");
var iterate = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");

var Set = SetHelpers.Set;
var add = SetHelpers.add;

// `Set.prototype.filter` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  filter: function filter(callbackfn /* , thisArg */) {
    var set = aSet(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newSet = new Set();
    iterate(set, function (value) {
      if (boundFunction(value, value, set)) add(newSet, value);
    });
    return newSet;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.find.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.find.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var iterate = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");

// `Set.prototype.find` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  find: function find(callbackfn /* , thisArg */) {
    var set = aSet(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var result = iterate(set, function (value) {
      if (boundFunction(value, value, set)) return { value: value };
    }, true);
    return result && result.value;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.from.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.from.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/collection-from */ "./node_modules/core-js/internals/collection-from.js");

// `Set.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
$({ target: 'Set', stat: true, forced: true }, {
  from: from
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.intersection.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.intersection.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toSetLike = __webpack_require__(/*! ../internals/to-set-like */ "./node_modules/core-js/internals/to-set-like.js");
var $intersection = __webpack_require__(/*! ../internals/set-intersection */ "./node_modules/core-js/internals/set-intersection.js");

// `Set.prototype.intersection` method
// https://github.com/tc39/proposal-set-methods
// TODO: Obsolete version, remove from `core-js@4`
$({ target: 'Set', proto: true, real: true, forced: true }, {
  intersection: function intersection(other) {
    return call($intersection, this, toSetLike(other));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.is-disjoint-from.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.is-disjoint-from.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toSetLike = __webpack_require__(/*! ../internals/to-set-like */ "./node_modules/core-js/internals/to-set-like.js");
var $isDisjointFrom = __webpack_require__(/*! ../internals/set-is-disjoint-from */ "./node_modules/core-js/internals/set-is-disjoint-from.js");

// `Set.prototype.isDisjointFrom` method
// https://github.com/tc39/proposal-set-methods
// TODO: Obsolete version, remove from `core-js@4`
$({ target: 'Set', proto: true, real: true, forced: true }, {
  isDisjointFrom: function isDisjointFrom(other) {
    return call($isDisjointFrom, this, toSetLike(other));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.is-subset-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.is-subset-of.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toSetLike = __webpack_require__(/*! ../internals/to-set-like */ "./node_modules/core-js/internals/to-set-like.js");
var $isSubsetOf = __webpack_require__(/*! ../internals/set-is-subset-of */ "./node_modules/core-js/internals/set-is-subset-of.js");

// `Set.prototype.isSubsetOf` method
// https://github.com/tc39/proposal-set-methods
// TODO: Obsolete version, remove from `core-js@4`
$({ target: 'Set', proto: true, real: true, forced: true }, {
  isSubsetOf: function isSubsetOf(other) {
    return call($isSubsetOf, this, toSetLike(other));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.is-superset-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.is-superset-of.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toSetLike = __webpack_require__(/*! ../internals/to-set-like */ "./node_modules/core-js/internals/to-set-like.js");
var $isSupersetOf = __webpack_require__(/*! ../internals/set-is-superset-of */ "./node_modules/core-js/internals/set-is-superset-of.js");

// `Set.prototype.isSupersetOf` method
// https://github.com/tc39/proposal-set-methods
// TODO: Obsolete version, remove from `core-js@4`
$({ target: 'Set', proto: true, real: true, forced: true }, {
  isSupersetOf: function isSupersetOf(other) {
    return call($isSupersetOf, this, toSetLike(other));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.join.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var iterate = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");

var arrayJoin = uncurryThis([].join);
var push = uncurryThis([].push);

// `Set.prototype.join` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  join: function join(separator) {
    var set = aSet(this);
    var sep = separator === undefined ? ',' : toString(separator);
    var array = [];
    iterate(set, function (value) {
      push(array, value);
    });
    return arrayJoin(array, sep);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.map.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.map.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var SetHelpers = __webpack_require__(/*! ../internals/set-helpers */ "./node_modules/core-js/internals/set-helpers.js");
var iterate = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");

var Set = SetHelpers.Set;
var add = SetHelpers.add;

// `Set.prototype.map` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  map: function map(callbackfn /* , thisArg */) {
    var set = aSet(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var newSet = new Set();
    iterate(set, function (value) {
      add(newSet, boundFunction(value, value, set));
    });
    return newSet;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.of.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.of.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var of = __webpack_require__(/*! ../internals/collection-of */ "./node_modules/core-js/internals/collection-of.js");

// `Set.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
$({ target: 'Set', stat: true, forced: true }, {
  of: of
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.reduce.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.reduce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var iterate = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");

var $TypeError = TypeError;

// `Set.prototype.reduce` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var set = aSet(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    aCallable(callbackfn);
    iterate(set, function (value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, value, set);
      }
    });
    if (noInitial) throw $TypeError('Reduce of empty set with no initial value');
    return accumulator;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.some.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.some.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var aSet = __webpack_require__(/*! ../internals/a-set */ "./node_modules/core-js/internals/a-set.js");
var iterate = __webpack_require__(/*! ../internals/set-iterate */ "./node_modules/core-js/internals/set-iterate.js");

// `Set.prototype.some` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'Set', proto: true, real: true, forced: true }, {
  some: function some(callbackfn /* , thisArg */) {
    var set = aSet(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return iterate(set, function (value) {
      if (boundFunction(value, value, set)) return true;
    }, true) === true;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.symmetric-difference.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.symmetric-difference.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toSetLike = __webpack_require__(/*! ../internals/to-set-like */ "./node_modules/core-js/internals/to-set-like.js");
var $symmetricDifference = __webpack_require__(/*! ../internals/set-symmetric-difference */ "./node_modules/core-js/internals/set-symmetric-difference.js");

// `Set.prototype.symmetricDifference` method
// https://github.com/tc39/proposal-set-methods
// TODO: Obsolete version, remove from `core-js@4`
$({ target: 'Set', proto: true, real: true, forced: true }, {
  symmetricDifference: function symmetricDifference(other) {
    return call($symmetricDifference, this, toSetLike(other));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.set.union.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.set.union.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toSetLike = __webpack_require__(/*! ../internals/to-set-like */ "./node_modules/core-js/internals/to-set-like.js");
var $union = __webpack_require__(/*! ../internals/set-union */ "./node_modules/core-js/internals/set-union.js");

// `Set.prototype.union` method
// https://github.com/tc39/proposal-set-methods
// TODO: Obsolete version, remove from `core-js@4`
$({ target: 'Set', proto: true, real: true, forced: true }, {
  union: function union(other) {
    return call($union, this, toSetLike(other));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.string.at.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.string.at.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var charAt = (__webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt);
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");

// `String.prototype.at` method
// https://github.com/mathiasbynens/String.prototype.at
$({ target: 'String', proto: true, forced: true }, {
  at: function at(index) {
    var S = toString(requireObjectCoercible(this));
    var len = S.length;
    var relativeIndex = toIntegerOrInfinity(index);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return (k < 0 || k >= len) ? undefined : charAt(S, k);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.string.code-points.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.string.code-points.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js/internals/iterator-create-constructor.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var StringMultibyteModule = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js");

var codeAt = StringMultibyteModule.codeAt;
var charAt = StringMultibyteModule.charAt;
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// TODO: unify with String#@@iterator
var $StringIterator = createIteratorConstructor(function StringIterator(string) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: string,
    index: 0
  });
}, 'String', function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject({ codePoint: codeAt(point, 0), position: index }, false);
});

// `String.prototype.codePoints` method
// https://github.com/tc39/proposal-string-prototype-codepoints
$({ target: 'String', proto: true, forced: true }, {
  codePoints: function codePoints() {
    return new $StringIterator(toString(requireObjectCoercible(this)));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.symbol.dispose.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.symbol.dispose.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js/internals/well-known-symbol-define.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);

var Symbol = global.Symbol;

// `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-explicit-resource-management
defineWellKnownSymbol('dispose');

if (Symbol) {
  var descriptor = getOwnPropertyDescriptor(Symbol, 'dispose');
  // workaround of NodeJS 20.4 bug
  // https://github.com/nodejs/node/issues/48699
  // and incorrect descriptor from some transpilers and userland helpers
  if (descriptor.enumerable && descriptor.configurable && descriptor.writable) {
    defineProperty(Symbol, 'dispose', { value: descriptor.value, enumerable: false, configurable: false, writable: false });
  }
}


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.symbol.observable.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.symbol.observable.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js/internals/well-known-symbol-define.js");

// `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable
defineWellKnownSymbol('observable');


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.symbol.pattern-match.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.symbol.pattern-match.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js/internals/well-known-symbol-define.js");

// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('patternMatch');


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.weak-map.delete-all.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.weak-map.delete-all.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aWeakMap = __webpack_require__(/*! ../internals/a-weak-map */ "./node_modules/core-js/internals/a-weak-map.js");
var remove = (__webpack_require__(/*! ../internals/weak-map-helpers */ "./node_modules/core-js/internals/weak-map-helpers.js").remove);

// `WeakMap.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'WeakMap', proto: true, real: true, forced: true }, {
  deleteAll: function deleteAll(/* ...elements */) {
    var collection = aWeakMap(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k = 0, len = arguments.length; k < len; k++) {
      wasDeleted = remove(collection, arguments[k]);
      allDeleted = allDeleted && wasDeleted;
    } return !!allDeleted;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.weak-map.from.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.weak-map.from.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/collection-from */ "./node_modules/core-js/internals/collection-from.js");

// `WeakMap.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
$({ target: 'WeakMap', stat: true, forced: true }, {
  from: from
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.weak-map.of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.weak-map.of.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var of = __webpack_require__(/*! ../internals/collection-of */ "./node_modules/core-js/internals/collection-of.js");

// `WeakMap.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
$({ target: 'WeakMap', stat: true, forced: true }, {
  of: of
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.weak-set.add-all.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.weak-set.add-all.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aWeakSet = __webpack_require__(/*! ../internals/a-weak-set */ "./node_modules/core-js/internals/a-weak-set.js");
var add = (__webpack_require__(/*! ../internals/weak-set-helpers */ "./node_modules/core-js/internals/weak-set-helpers.js").add);

// `WeakSet.prototype.addAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'WeakSet', proto: true, real: true, forced: true }, {
  addAll: function addAll(/* ...elements */) {
    var set = aWeakSet(this);
    for (var k = 0, len = arguments.length; k < len; k++) {
      add(set, arguments[k]);
    } return set;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.weak-set.delete-all.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.weak-set.delete-all.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aWeakSet = __webpack_require__(/*! ../internals/a-weak-set */ "./node_modules/core-js/internals/a-weak-set.js");
var remove = (__webpack_require__(/*! ../internals/weak-set-helpers */ "./node_modules/core-js/internals/weak-set-helpers.js").remove);

// `WeakSet.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({ target: 'WeakSet', proto: true, real: true, forced: true }, {
  deleteAll: function deleteAll(/* ...elements */) {
    var collection = aWeakSet(this);
    var allDeleted = true;
    var wasDeleted;
    for (var k = 0, len = arguments.length; k < len; k++) {
      wasDeleted = remove(collection, arguments[k]);
      allDeleted = allDeleted && wasDeleted;
    } return !!allDeleted;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.weak-set.from.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.weak-set.from.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/collection-from */ "./node_modules/core-js/internals/collection-from.js");

// `WeakSet.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
$({ target: 'WeakSet', stat: true, forced: true }, {
  from: from
});


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.weak-set.of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.weak-set.of.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var of = __webpack_require__(/*! ../internals/collection-of */ "./node_modules/core-js/internals/collection-of.js");

// `WeakSet.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
$({ target: 'WeakSet', stat: true, forced: true }, {
  of: of
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.clear-immediate.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/web.clear-immediate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var clearImmediate = (__webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").clear);

// `clearImmediate` method
// http://w3c.github.io/setImmediate/#si-clearImmediate
$({ global: true, bind: true, enumerable: true, forced: global.clearImmediate !== clearImmediate }, {
  clearImmediate: clearImmediate
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/web.clear-immediate */ "./node_modules/core-js/modules/web.clear-immediate.js");
__webpack_require__(/*! ../modules/web.set-immediate */ "./node_modules/core-js/modules/web.set-immediate.js");


/***/ }),

/***/ "./node_modules/core-js/modules/web.set-immediate.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/web.set-immediate.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setTask = (__webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set);
var schedulersFix = __webpack_require__(/*! ../internals/schedulers-fix */ "./node_modules/core-js/internals/schedulers-fix.js");

// https://github.com/oven-sh/bun/issues/1633
var setImmediate = global.setImmediate ? schedulersFix(setTask, false) : setTask;

// `setImmediate` method
// http://w3c.github.io/setImmediate/#si-setImmediate
$({ global: true, bind: true, enumerable: true, forced: global.setImmediate !== setImmediate }, {
  setImmediate: setImmediate
});


/***/ }),

/***/ "./node_modules/exponential-backoff/dist/backoff.js":
/*!**********************************************************!*\
  !*** ./node_modules/exponential-backoff/dist/backoff.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var options_1 = __webpack_require__(/*! ./options */ "./node_modules/exponential-backoff/dist/options.js");
var delay_factory_1 = __webpack_require__(/*! ./delay/delay.factory */ "./node_modules/exponential-backoff/dist/delay/delay.factory.js");
function backOff(request, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var sanitizedOptions, backOff;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    sanitizedOptions = options_1.getSanitizedOptions(options);
                    backOff = new BackOff(request, sanitizedOptions);
                    return [4 /*yield*/, backOff.execute()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
exports.backOff = backOff;
var BackOff = /** @class */ (function () {
    function BackOff(request, options) {
        this.request = request;
        this.options = options;
        this.attemptNumber = 0;
    }
    BackOff.prototype.execute = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, shouldRetry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.attemptLimitReached) return [3 /*break*/, 7];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 6]);
                        return [4 /*yield*/, this.applyDelay()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.request()];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        e_1 = _a.sent();
                        this.attemptNumber++;
                        return [4 /*yield*/, this.options.retry(e_1, this.attemptNumber)];
                    case 5:
                        shouldRetry = _a.sent();
                        if (!shouldRetry || this.attemptLimitReached) {
                            throw e_1;
                        }
                        return [3 /*break*/, 6];
                    case 6: return [3 /*break*/, 0];
                    case 7: throw new Error("Something went wrong.");
                }
            });
        });
    };
    Object.defineProperty(BackOff.prototype, "attemptLimitReached", {
        get: function () {
            return this.attemptNumber >= this.options.numOfAttempts;
        },
        enumerable: true,
        configurable: true
    });
    BackOff.prototype.applyDelay = function () {
        return __awaiter(this, void 0, void 0, function () {
            var delay;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        delay = delay_factory_1.DelayFactory(this.options, this.attemptNumber);
                        return [4 /*yield*/, delay.apply()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return BackOff;
}());
//# sourceMappingURL=backoff.js.map

/***/ }),

/***/ "./node_modules/exponential-backoff/dist/delay/always/always.delay.js":
/*!****************************************************************************!*\
  !*** ./node_modules/exponential-backoff/dist/delay/always/always.delay.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var delay_base_1 = __webpack_require__(/*! ../delay.base */ "./node_modules/exponential-backoff/dist/delay/delay.base.js");
var AlwaysDelay = /** @class */ (function (_super) {
    __extends(AlwaysDelay, _super);
    function AlwaysDelay() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AlwaysDelay;
}(delay_base_1.Delay));
exports.AlwaysDelay = AlwaysDelay;
//# sourceMappingURL=always.delay.js.map

/***/ }),

/***/ "./node_modules/exponential-backoff/dist/delay/delay.base.js":
/*!*******************************************************************!*\
  !*** ./node_modules/exponential-backoff/dist/delay/delay.base.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var jitter_factory_1 = __webpack_require__(/*! ../jitter/jitter.factory */ "./node_modules/exponential-backoff/dist/jitter/jitter.factory.js");
var Delay = /** @class */ (function () {
    function Delay(options) {
        this.options = options;
        this.attempt = 0;
    }
    Delay.prototype.apply = function () {
        var _this = this;
        return new Promise(function (resolve) { return setTimeout(resolve, _this.jitteredDelay); });
    };
    Delay.prototype.setAttemptNumber = function (attempt) {
        this.attempt = attempt;
    };
    Object.defineProperty(Delay.prototype, "jitteredDelay", {
        get: function () {
            var jitter = jitter_factory_1.JitterFactory(this.options);
            return jitter(this.delay);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Delay.prototype, "delay", {
        get: function () {
            var constant = this.options.startingDelay;
            var base = this.options.timeMultiple;
            var power = this.numOfDelayedAttempts;
            var delay = constant * Math.pow(base, power);
            return Math.min(delay, this.options.maxDelay);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Delay.prototype, "numOfDelayedAttempts", {
        get: function () {
            return this.attempt;
        },
        enumerable: true,
        configurable: true
    });
    return Delay;
}());
exports.Delay = Delay;
//# sourceMappingURL=delay.base.js.map

/***/ }),

/***/ "./node_modules/exponential-backoff/dist/delay/delay.factory.js":
/*!**********************************************************************!*\
  !*** ./node_modules/exponential-backoff/dist/delay/delay.factory.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var skip_first_delay_1 = __webpack_require__(/*! ./skip-first/skip-first.delay */ "./node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js");
var always_delay_1 = __webpack_require__(/*! ./always/always.delay */ "./node_modules/exponential-backoff/dist/delay/always/always.delay.js");
function DelayFactory(options, attempt) {
    var delay = initDelayClass(options);
    delay.setAttemptNumber(attempt);
    return delay;
}
exports.DelayFactory = DelayFactory;
function initDelayClass(options) {
    if (!options.delayFirstAttempt) {
        return new skip_first_delay_1.SkipFirstDelay(options);
    }
    return new always_delay_1.AlwaysDelay(options);
}
//# sourceMappingURL=delay.factory.js.map

/***/ }),

/***/ "./node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js":
/*!************************************************************************************!*\
  !*** ./node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var delay_base_1 = __webpack_require__(/*! ../delay.base */ "./node_modules/exponential-backoff/dist/delay/delay.base.js");
var SkipFirstDelay = /** @class */ (function (_super) {
    __extends(SkipFirstDelay, _super);
    function SkipFirstDelay() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SkipFirstDelay.prototype.apply = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.isFirstAttempt ? true : _super.prototype.apply.call(this)];
            });
        });
    };
    Object.defineProperty(SkipFirstDelay.prototype, "isFirstAttempt", {
        get: function () {
            return this.attempt === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkipFirstDelay.prototype, "numOfDelayedAttempts", {
        get: function () {
            return this.attempt - 1;
        },
        enumerable: true,
        configurable: true
    });
    return SkipFirstDelay;
}(delay_base_1.Delay));
exports.SkipFirstDelay = SkipFirstDelay;
//# sourceMappingURL=skip-first.delay.js.map

/***/ }),

/***/ "./node_modules/exponential-backoff/dist/jitter/full/full.jitter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/exponential-backoff/dist/jitter/full/full.jitter.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function fullJitter(delay) {
    var jitteredDelay = Math.random() * delay;
    return Math.round(jitteredDelay);
}
exports.fullJitter = fullJitter;
//# sourceMappingURL=full.jitter.js.map

/***/ }),

/***/ "./node_modules/exponential-backoff/dist/jitter/jitter.factory.js":
/*!************************************************************************!*\
  !*** ./node_modules/exponential-backoff/dist/jitter/jitter.factory.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var full_jitter_1 = __webpack_require__(/*! ./full/full.jitter */ "./node_modules/exponential-backoff/dist/jitter/full/full.jitter.js");
var no_jitter_1 = __webpack_require__(/*! ./no/no.jitter */ "./node_modules/exponential-backoff/dist/jitter/no/no.jitter.js");
function JitterFactory(options) {
    switch (options.jitter) {
        case "full":
            return full_jitter_1.fullJitter;
        case "none":
        default:
            return no_jitter_1.noJitter;
    }
}
exports.JitterFactory = JitterFactory;
//# sourceMappingURL=jitter.factory.js.map

/***/ }),

/***/ "./node_modules/exponential-backoff/dist/jitter/no/no.jitter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/exponential-backoff/dist/jitter/no/no.jitter.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function noJitter(delay) {
    return delay;
}
exports.noJitter = noJitter;
//# sourceMappingURL=no.jitter.js.map

/***/ }),

/***/ "./node_modules/exponential-backoff/dist/options.js":
/*!**********************************************************!*\
  !*** ./node_modules/exponential-backoff/dist/options.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var defaultOptions = {
    delayFirstAttempt: false,
    jitter: "none",
    maxDelay: Infinity,
    numOfAttempts: 10,
    retry: function () { return true; },
    startingDelay: 100,
    timeMultiple: 2
};
function getSanitizedOptions(options) {
    var sanitized = __assign(__assign({}, defaultOptions), options);
    if (sanitized.numOfAttempts < 1) {
        sanitized.numOfAttempts = 1;
    }
    return sanitized;
}
exports.getSanitizedOptions = getSanitizedOptions;
//# sourceMappingURL=options.js.map

/***/ }),

/***/ "./node_modules/fflate/esm/browser.js":
/*!********************************************!*\
  !*** ./node_modules/fflate/esm/browser.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncCompress: () => (/* binding */ AsyncGzip),
/* harmony export */   AsyncDecompress: () => (/* binding */ AsyncDecompress),
/* harmony export */   AsyncDeflate: () => (/* binding */ AsyncDeflate),
/* harmony export */   AsyncGunzip: () => (/* binding */ AsyncGunzip),
/* harmony export */   AsyncGzip: () => (/* binding */ AsyncGzip),
/* harmony export */   AsyncInflate: () => (/* binding */ AsyncInflate),
/* harmony export */   AsyncUnzipInflate: () => (/* binding */ AsyncUnzipInflate),
/* harmony export */   AsyncUnzlib: () => (/* binding */ AsyncUnzlib),
/* harmony export */   AsyncZipDeflate: () => (/* binding */ AsyncZipDeflate),
/* harmony export */   AsyncZlib: () => (/* binding */ AsyncZlib),
/* harmony export */   Compress: () => (/* binding */ Gzip),
/* harmony export */   DecodeUTF8: () => (/* binding */ DecodeUTF8),
/* harmony export */   Decompress: () => (/* binding */ Decompress),
/* harmony export */   Deflate: () => (/* binding */ Deflate),
/* harmony export */   EncodeUTF8: () => (/* binding */ EncodeUTF8),
/* harmony export */   FlateErrorCode: () => (/* binding */ FlateErrorCode),
/* harmony export */   Gunzip: () => (/* binding */ Gunzip),
/* harmony export */   Gzip: () => (/* binding */ Gzip),
/* harmony export */   Inflate: () => (/* binding */ Inflate),
/* harmony export */   Unzip: () => (/* binding */ Unzip),
/* harmony export */   UnzipInflate: () => (/* binding */ UnzipInflate),
/* harmony export */   UnzipPassThrough: () => (/* binding */ UnzipPassThrough),
/* harmony export */   Unzlib: () => (/* binding */ Unzlib),
/* harmony export */   Zip: () => (/* binding */ Zip),
/* harmony export */   ZipDeflate: () => (/* binding */ ZipDeflate),
/* harmony export */   ZipPassThrough: () => (/* binding */ ZipPassThrough),
/* harmony export */   Zlib: () => (/* binding */ Zlib),
/* harmony export */   compress: () => (/* binding */ gzip),
/* harmony export */   compressSync: () => (/* binding */ gzipSync),
/* harmony export */   decompress: () => (/* binding */ decompress),
/* harmony export */   decompressSync: () => (/* binding */ decompressSync),
/* harmony export */   deflate: () => (/* binding */ deflate),
/* harmony export */   deflateSync: () => (/* binding */ deflateSync),
/* harmony export */   gunzip: () => (/* binding */ gunzip),
/* harmony export */   gunzipSync: () => (/* binding */ gunzipSync),
/* harmony export */   gzip: () => (/* binding */ gzip),
/* harmony export */   gzipSync: () => (/* binding */ gzipSync),
/* harmony export */   inflate: () => (/* binding */ inflate),
/* harmony export */   inflateSync: () => (/* binding */ inflateSync),
/* harmony export */   strFromU8: () => (/* binding */ strFromU8),
/* harmony export */   strToU8: () => (/* binding */ strToU8),
/* harmony export */   unzip: () => (/* binding */ unzip),
/* harmony export */   unzipSync: () => (/* binding */ unzipSync),
/* harmony export */   unzlib: () => (/* binding */ unzlib),
/* harmony export */   unzlibSync: () => (/* binding */ unzlibSync),
/* harmony export */   zip: () => (/* binding */ zip),
/* harmony export */   zipSync: () => (/* binding */ zipSync),
/* harmony export */   zlib: () => (/* binding */ zlib),
/* harmony export */   zlibSync: () => (/* binding */ zlibSync)
/* harmony export */ });
// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).
var ch2 = {};
var wk = (function (c, id, msg, transfer, cb) {
    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
        c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
    ], { type: 'text/javascript' }))));
    w.onmessage = function (e) {
        var d = e.data, ed = d.$e$;
        if (ed) {
            var err = new Error(ed[0]);
            err['code'] = ed[1];
            err.stack = ed[2];
            cb(err, null);
        }
        else
            cb(null, d);
    };
    w.postMessage(msg, transfer);
    return w;
});

// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
// fixed length extra bits
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
// fixed distance extra bits
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
// code length index map
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
// get base, reverse index map from extra bits
var freb = function (eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new i32(b[30]);
    for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = ((j - b[i]) << 5) | i;
        }
    }
    return { b: b, r: r };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
    // reverse table algorithm from SO
    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);
    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);
    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);
    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = (function (cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for (; i < s; ++i) {
        if (cd[i])
            ++l[cd[i] - 1];
    }
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for (i = 1; i < mb; ++i) {
        le[i] = (le[i - 1] + l[i - 1]) << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = (i << 4) | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >> rvb] = sv;
                }
            }
        }
    }
    else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);
            }
        }
    }
    return co;
});
// fixed length tree
var flt = new u8(288);
for (var i = 0; i < 144; ++i)
    flt[i] = 8;
for (var i = 144; i < 256; ++i)
    flt[i] = 9;
for (var i = 256; i < 280; ++i)
    flt[i] = 7;
for (var i = 280; i < 288; ++i)
    flt[i] = 8;
// fixed distance tree
var fdt = new u8(32);
for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
// fixed length map
var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
// fixed distance map
var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
// find max of array
var max = function (a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
        if (a[i] > m)
            m = a[i];
    }
    return m;
};
// read d, starting at bit p and mask with m
var bits = function (d, p, m) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
};
// read d, starting at bit p continuing for at least 16 bits
var bits16 = function (d, p) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
};
// get end of byte
var shft = function (p) { return ((p + 7) / 8) | 0; };
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function (v, s, e) {
    if (s == null || s < 0)
        s = 0;
    if (e == null || e > v.length)
        e = v.length;
    // can't use .constructor in case user-supplied
    var n = new u8(e - s);
    n.set(v.subarray(s, e));
    return n;
};
/**
 * Codes for errors generated within this library
 */
var FlateErrorCode = {
    UnexpectedEOF: 0,
    InvalidBlockType: 1,
    InvalidLengthLiteral: 2,
    InvalidDistance: 3,
    StreamFinished: 4,
    NoStreamHandler: 5,
    InvalidHeader: 6,
    NoCallback: 7,
    InvalidUTF8: 8,
    ExtraFieldTooLong: 9,
    InvalidDate: 10,
    FilenameTooLong: 11,
    StreamFinishing: 12,
    InvalidZipData: 13,
    UnknownCompressionMethod: 14
};
// error codes
var ec = [
    'unexpected EOF',
    'invalid block type',
    'invalid length/literal',
    'invalid distance',
    'stream finished',
    'no stream handler',
    ,
    'no callback',
    'invalid UTF-8 data',
    'extra field too long',
    'date not in range 1980-2099',
    'filename too long',
    'stream finishing',
    'invalid zip data'
    // determined by unknown compression method
];
;
var err = function (ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
        Error.captureStackTrace(e, err);
    if (!nt)
        throw e;
    return e;
};
// expands raw DEFLATE data
var inflt = function (dat, st, buf, dict) {
    // source length       dict length
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
        return buf || new u8(0);
    // have to estimate size
    var noBuf = !buf || st.i != 2;
    // no state
    var noSt = st.i;
    // Assumes roughly 33% compression ratio average
    if (!buf)
        buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function (l) {
        var bl = buf.length;
        // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            var nbuf = new u8(Math.max(bl * 2, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    };
    //  last chunk         bitpos           bytes
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            final = bits(dat, pos, 1);
            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                if (t > sl) {
                    if (noSt)
                        err(0);
                    break;
                }
                // ensure size
                if (noBuf)
                    cbuf(bt + l);
                // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt);
                // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t * 8, st.f = final;
                continue;
            }
            else if (type == 1)
                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                // length+distance tree
                var ldt = new u8(tl);
                // code length tree
                var clt = new u8(19);
                for (var i = 0; i < hcLen; ++i) {
                    // use index map to get real code
                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
                }
                pos += hcLen * 3;
                // code lengths bits
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                // code lengths map
                var clm = hMap(clt, clb, 1);
                for (var i = 0; i < tl;) {
                    var r = clm[bits(dat, pos, clbmsk)];
                    // bits read
                    pos += r & 15;
                    // symbol
                    var s = r >> 4;
                    // code length to copy
                    if (s < 16) {
                        ldt[i++] = s;
                    }
                    else {
                        //  copy   count
                        var c = 0, n = 0;
                        if (s == 16)
                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                        else if (s == 17)
                            n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s == 18)
                            n = 11 + bits(dat, pos, 127), pos += 7;
                        while (n--)
                            ldt[i++] = c;
                    }
                }
                //    length tree                 distance tree
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                // max length bits
                lbt = max(lt);
                // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            }
            else
                err(1);
            if (pos > tbts) {
                if (noSt)
                    err(0);
                break;
            }
        }
        // Make sure the buffer can hold this + the largest possible addition
        // Maximum chunk size (practically, theoretically infinite) is 2^17
        if (noBuf)
            cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (;; lpos = pos) {
            // bits read, code
            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
            pos += c & 15;
            if (pos > tbts) {
                if (noSt)
                    err(0);
                break;
            }
            if (!c)
                err(2);
            if (sym < 256)
                buf[bt++] = sym;
            else if (sym == 256) {
                lpos = pos, lm = null;
                break;
            }
            else {
                var add = sym - 254;
                // no extra bits needed if less
                if (sym > 264) {
                    // index
                    var i = sym - 257, b = fleb[i];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                    pos += b;
                }
                // dist
                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
                if (!d)
                    err(3);
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                    var b = fdeb[dsym];
                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
                }
                if (pos > tbts) {
                    if (noSt)
                        err(0);
                    break;
                }
                if (noBuf)
                    cbuf(bt + 131072);
                var end = bt + add;
                if (bt < dt) {
                    var shift = dl - dt, dend = Math.min(dt, end);
                    if (shift + bt < 0)
                        err(3);
                    for (; bt < dend; ++bt)
                        buf[bt] = dict[shift + bt];
                }
                for (; bt < end; bt += 4) {
                    buf[bt] = buf[bt - dt];
                    buf[bt + 1] = buf[bt + 1 - dt];
                    buf[bt + 2] = buf[bt + 2 - dt];
                    buf[bt + 3] = buf[bt + 3 - dt];
                }
                bt = end;
            }
        }
        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
        if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
};
// starting at p, write the minimum number of bits that can hold v to d
var wbits = function (d, p, v) {
    v <<= p & 7;
    var o = (p / 8) | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
};
// starting at p, write the minimum number of bits (>8) that can hold v to d
var wbits16 = function (d, p, v) {
    v <<= p & 7;
    var o = (p / 8) | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
    d[o + 2] |= v >> 16;
};
// creates code lengths from a frequency table
var hTree = function (d, mb) {
    // Need extra info to make a tree
    var t = [];
    for (var i = 0; i < d.length; ++i) {
        if (d[i])
            t.push({ s: i, f: d[i] });
    }
    var s = t.length;
    var t2 = t.slice();
    if (!s)
        return { t: et, l: 0 };
    if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return { t: v, l: 1 };
    }
    t.sort(function (a, b) { return a.f - b.f; });
    // after i2 reaches last ind, will be stopped
    // freq must be greater than largest possible number of symbols
    t.push({ s: -1, f: 25001 });
    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };
    // efficient algorithm from UZIP.js
    // i0 is lookbehind, i2 is lookahead - after processing two low-freq
    // symbols that combined have high freq, will start processing i2 (high-freq,
    // non-composite) symbols instead
    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
    while (i1 != s - 1) {
        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };
    }
    var maxSym = t2[0].s;
    for (var i = 1; i < s; ++i) {
        if (t2[i].s > maxSym)
            maxSym = t2[i].s;
    }
    // code lengths
    var tr = new u16(maxSym + 1);
    // max bits in tree
    var mbt = ln(t[i1 - 1], tr, 0);
    if (mbt > mb) {
        // more algorithms from UZIP.js
        // TODO: find out how this code works (debt)
        //  ind    debt
        var i = 0, dt = 0;
        //    left            cost
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });
        for (; i < s; ++i) {
            var i2_1 = t2[i].s;
            if (tr[i2_1] > mb) {
                dt += cst - (1 << (mbt - tr[i2_1]));
                tr[i2_1] = mb;
            }
            else
                break;
        }
        dt >>= lft;
        while (dt > 0) {
            var i2_2 = t2[i].s;
            if (tr[i2_2] < mb)
                dt -= 1 << (mb - tr[i2_2]++ - 1);
            else
                ++i;
        }
        for (; i >= 0 && dt; --i) {
            var i2_3 = t2[i].s;
            if (tr[i2_3] == mb) {
                --tr[i2_3];
                ++dt;
            }
        }
        mbt = mb;
    }
    return { t: new u8(tr), l: mbt };
};
// get the max length and assign length codes
var ln = function (n, l, d) {
    return n.s == -1
        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
        : (l[n.s] = d);
};
// length codes generation
var lc = function (c) {
    var s = c.length;
    // Note that the semicolon was intentional
    while (s && !c[--s])
        ;
    var cl = new u16(++s);
    //  ind      num         streak
    var cli = 0, cln = c[0], cls = 1;
    var w = function (v) { cl[cli++] = v; };
    for (var i = 1; i <= s; ++i) {
        if (c[i] == cln && i != s)
            ++cls;
        else {
            if (!cln && cls > 2) {
                for (; cls > 138; cls -= 138)
                    w(32754);
                if (cls > 2) {
                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);
                    cls = 0;
                }
            }
            else if (cls > 3) {
                w(cln), --cls;
                for (; cls > 6; cls -= 6)
                    w(8304);
                if (cls > 2)
                    w(((cls - 3) << 5) | 8208), cls = 0;
            }
            while (cls--)
                w(cln);
            cls = 1;
            cln = c[i];
        }
    }
    return { c: cl.subarray(0, cli), n: s };
};
// calculate the length of output from tree, code lengths
var clen = function (cf, cl) {
    var l = 0;
    for (var i = 0; i < cl.length; ++i)
        l += cf[i] * cl[i];
    return l;
};
// writes a fixed block
// returns the new bit pos
var wfblk = function (out, pos, dat) {
    // no need to write 00 as type: TypedArray defaults to 0
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for (var i = 0; i < s; ++i)
        out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
};
// writes a block
var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, final);
    ++lf[256];
    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;
    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;
    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
    var lcfreq = new u16(19);
    for (var i = 0; i < lclt.length; ++i)
        ++lcfreq[lclt[i] & 31];
    for (var i = 0; i < lcdt.length; ++i)
        ++lcfreq[lcdt[i] & 31];
    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
    var nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
    var flen = (bl + 5) << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen)
        return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for (var i = 0; i < nlcc; ++i)
            wbits(out, p + 3 * i, lct[clim[i]]);
        p += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it = 0; it < 2; ++it) {
            var clct = lcts[it];
            for (var i = 0; i < clct.length; ++i) {
                var len = clct[i] & 31;
                wbits(out, p, llm[len]), p += lct[len];
                if (len > 15)
                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;
            }
        }
    }
    else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (var i = 0; i < li; ++i) {
        var sym = syms[i];
        if (sym > 255) {
            var len = (sym >> 18) & 31;
            wbits16(out, p, lm[len + 257]), p += ll[len + 257];
            if (len > 7)
                wbits(out, p, (sym >> 23) & 31), p += fleb[len];
            var dst = sym & 31;
            wbits16(out, p, dm[dst]), p += dl[dst];
            if (dst > 3)
                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];
        }
        else {
            wbits16(out, p, lm[sym]), p += ll[sym];
        }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
};
// deflate options (nice << 13) | chain
var deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
// empty
var et = /*#__PURE__*/ new u8(0);
// compresses data into a raw DEFLATE buffer
var dflt = function (dat, lvl, plvl, pre, post, st) {
    var s = st.z || dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
    // writing to this writes to the output buffer
    var w = o.subarray(pre, o.length - post);
    var lst = st.l;
    var pos = (st.r || 0) & 7;
    if (lvl) {
        if (pos)
            w[0] = st.r >> 3;
        var opt = deo[lvl - 1];
        var n = opt >> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        //    prev 2-byte val map    curr 2-byte val map
        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };
        // 24576 is an arbitrary number of maximum symbols per block
        // 424 buffer for last block
        var syms = new i32(25000);
        // length/literal freq   distance freq
        var lf = new u16(288), df = new u16(32);
        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos
        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
        for (; i + 2 < s; ++i) {
            // hash value
            var hv = hsh(i);
            // index mod 32768    previous index mod
            var imod = i & 32767, pimod = head[hv];
            prev[imod] = pimod;
            head[hv] = imod;
            // We always should modify head and prev, but only add symbols if
            // this data is not yet processed ("wait" for wait index)
            if (wi <= i) {
                // bytes remaining
                var rem = s - i;
                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {
                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                    li = lc_1 = eb = 0, bs = i;
                    for (var j = 0; j < 286; ++j)
                        lf[j] = 0;
                    for (var j = 0; j < 30; ++j)
                        df[j] = 0;
                }
                //  len    dist   chain
                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
                if (rem > 2 && hv == hsh(i - dif)) {
                    var maxn = Math.min(n, rem) - 1;
                    var maxd = Math.min(32767, i);
                    // max possible length
                    // not capped at dif because decompressors implement "rolling" index population
                    var ml = Math.min(258, rem);
                    while (dif <= maxd && --ch_1 && imod != pimod) {
                        if (dat[i + l] == dat[i + l - dif]) {
                            var nl = 0;
                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                                ;
                            if (nl > l) {
                                l = nl, d = dif;
                                // break out early when we reach "nice" (we are satisfied enough)
                                if (nl > maxn)
                                    break;
                                // now, find the rarest 2-byte sequence within this
                                // length of literals and search for that instead.
                                // Much faster than just using the start
                                var mmd = Math.min(dif, nl - 2);
                                var md = 0;
                                for (var j = 0; j < mmd; ++j) {
                                    var ti = i - dif + j & 32767;
                                    var pti = prev[ti];
                                    var cd = ti - pti & 32767;
                                    if (cd > md)
                                        md = cd, pimod = ti;
                                }
                            }
                        }
                        // check the previous match
                        imod = pimod, pimod = prev[imod];
                        dif += imod - pimod & 32767;
                    }
                }
                // d will be nonzero only when a match was found
                if (d) {
                    // store both dist and len data in one int32
                    // Make sure this is recognized as a len/dist with 28th bit (2^28)
                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];
                    var lin = revfl[l] & 31, din = revfd[d] & 31;
                    eb += fleb[lin] + fdeb[din];
                    ++lf[257 + lin];
                    ++df[din];
                    wi = i + l;
                    ++lc_1;
                }
                else {
                    syms[li++] = dat[i];
                    ++lf[dat[i]];
                }
            }
        }
        for (i = Math.max(i, wi); i < s; ++i) {
            syms[li++] = dat[i];
            ++lf[dat[i]];
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
        if (!lst) {
            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;
            // shft(pos) now 1 less if pos & 7 != 0
            pos -= 7;
            st.h = head, st.p = prev, st.i = i, st.w = wi;
        }
    }
    else {
        for (var i = st.w || 0; i < s + lst; i += 65535) {
            // end
            var e = i + 65535;
            if (e >= s) {
                // write final block
                w[(pos / 8) | 0] = lst;
                e = s;
            }
            pos = wfblk(w, pos + 1, dat.subarray(i, e));
        }
        st.i = s;
    }
    return slc(o, 0, pre + shft(pos) + post);
};
// CRC32 table
var crct = /*#__PURE__*/ (function () {
    var t = new Int32Array(256);
    for (var i = 0; i < 256; ++i) {
        var c = i, k = 9;
        while (--k)
            c = ((c & 1) && -306674912) ^ (c >>> 1);
        t[i] = c;
    }
    return t;
})();
// CRC32
var crc = function () {
    var c = -1;
    return {
        p: function (d) {
            // closures have awful performance
            var cr = c;
            for (var i = 0; i < d.length; ++i)
                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);
            c = cr;
        },
        d: function () { return ~c; }
    };
};
// Adler32
var adler = function () {
    var a = 1, b = 0;
    return {
        p: function (d) {
            // closures have awful performance
            var n = a, m = b;
            var l = d.length | 0;
            for (var i = 0; i != l;) {
                var e = Math.min(i + 2655, l);
                for (; i < e; ++i)
                    m += n += d[i];
                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
            }
            a = n, b = m;
        },
        d: function () {
            a %= 65521, b %= 65521;
            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);
        }
    };
};
;
// deflate with opts
var dopt = function (dat, opt, pre, post, st) {
    if (!st) {
        st = { l: 1 };
        if (opt.dictionary) {
            var dict = opt.dictionary.subarray(-32768);
            var newDat = new u8(dict.length + dat.length);
            newDat.set(dict);
            newDat.set(dat, dict.length);
            dat = newDat;
            st.w = dict.length;
        }
    }
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, st);
};
// Walmart object spread
var mrg = function (a, b) {
    var o = {};
    for (var k in a)
        o[k] = a[k];
    for (var k in b)
        o[k] = b[k];
    return o;
};
// worker clone
// This is possibly the craziest part of the entire codebase, despite how simple it may seem.
// The only parameter to this function is a closure that returns an array of variables outside of the function scope.
// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
// This took me three weeks to figure out how to do.
var wcln = function (fn, fnStr, td) {
    var dt = fn();
    var st = fn.toString();
    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\s+/g, '').split(',');
    for (var i = 0; i < dt.length; ++i) {
        var v = dt[i], k = ks[i];
        if (typeof v == 'function') {
            fnStr += ';' + k + '=';
            var st_1 = v.toString();
            if (v.prototype) {
                // for global objects
                if (st_1.indexOf('[native code]') != -1) {
                    var spInd = st_1.indexOf(' ', 8) + 1;
                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));
                }
                else {
                    fnStr += st_1;
                    for (var t in v.prototype)
                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();
                }
            }
            else
                fnStr += st_1;
        }
        else
            td[k] = v;
    }
    return fnStr;
};
var ch = [];
// clone bufs
var cbfs = function (v) {
    var tl = [];
    for (var k in v) {
        if (v[k].buffer) {
            tl.push((v[k] = new v[k].constructor(v[k])).buffer);
        }
    }
    return tl;
};
// use a worker to execute code
var wrkr = function (fns, init, id, cb) {
    if (!ch[id]) {
        var fnStr = '', td_1 = {}, m = fns.length - 1;
        for (var i = 0; i < m; ++i)
            fnStr = wcln(fns[i], fnStr, td_1);
        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
    }
    var td = mrg({}, ch[id].e);
    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);
};
// base async inflate fn
var bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };
var bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };
// gzip extra
var gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };
// gunzip extra
var guze = function () { return [gzs, gzl]; };
// zlib extra
var zle = function () { return [zlh, wbytes, adler]; };
// unzlib extra
var zule = function () { return [zls]; };
// post buf
var pbf = function (msg) { return postMessage(msg, [msg.buffer]); };
// get opts
var gopt = function (o) { return o && {
    out: o.size && new u8(o.size),
    dictionary: o.dictionary
}; };
// async helper
var cbify = function (dat, opts, fns, init, id, cb) {
    var w = wrkr(fns, init, id, function (err, dat) {
        w.terminate();
        cb(err, dat);
    });
    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
    return function () { w.terminate(); };
};
// auto stream
var astrm = function (strm) {
    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };
    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };
};
// async stream attach
var astrmify = function (fns, strm, opts, init, id, ext) {
    var t;
    var w = wrkr(fns, init, id, function (err, dat) {
        if (err)
            w.terminate(), strm.ondata.call(strm, err);
        else if (!Array.isArray(dat))
            ext(dat);
        else {
            if (dat[1])
                w.terminate();
            strm.ondata.call(strm, err, dat[0], dat[1]);
        }
    });
    w.postMessage(opts);
    strm.push = function (d, f) {
        if (!strm.ondata)
            err(5);
        if (t)
            strm.ondata(err(4, 0, 1), null, !!f);
        w.postMessage([d, t = f], [d.buffer]);
    };
    strm.terminate = function () { w.terminate(); };
};
// read 2 bytes
var b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };
// read 4 bytes
var b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };
var b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };
// write bytes
var wbytes = function (d, b, v) {
    for (; v; ++b)
        d[b] = v, v >>>= 8;
};
// gzip header
var gzh = function (c, o) {
    var fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix
    if (o.mtime != 0)
        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));
    if (fn) {
        c[3] = 8;
        for (var i = 0; i <= fn.length; ++i)
            c[i + 10] = fn.charCodeAt(i);
    }
};
// gzip footer: -8 to -4 = CRC, -4 to -0 is length
// gzip start
var gzs = function (d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
        err(6, 'invalid gzip data');
    var flg = d[3];
    var st = 10;
    if (flg & 4)
        st += (d[10] | d[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
        ;
    return st + (flg & 2);
};
// gzip length
var gzl = function (d) {
    var l = d.length;
    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
// gzip header length
var gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };
// zlib header
var zlh = function (c, o) {
    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);
    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;
    if (o.dictionary) {
        var h = adler();
        h.p(o.dictionary);
        wbytes(c, 2, h.d());
    }
};
// zlib start
var zls = function (d, dict) {
    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
        err(6, 'invalid zlib data');
    if ((d[1] >> 5 & 1) == +!dict)
        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');
    return (d[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
    if (typeof opts == 'function')
        cb = opts, opts = {};
    this.ondata = cb;
    return opts;
}
/**
 * Streaming DEFLATE compression
 */
var Deflate = /*#__PURE__*/ (function () {
    function Deflate(opts, cb) {
        if (typeof opts == 'function')
            cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev
        // 98304 = 32768 (lookback) + 65536 (common chunk size)
        this.b = new u8(98304);
        if (this.o.dictionary) {
            var dict = this.o.dictionary.subarray(-32768);
            this.b.set(dict, 32768 - dict.length);
            this.s.i = 32768 - dict.length;
        }
    }
    Deflate.prototype.p = function (c, f) {
        this.ondata(dopt(c, this.o, 0, 0, this.s), f);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Deflate.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        if (this.s.l)
            err(4);
        var endLen = chunk.length + this.s.z;
        if (endLen > this.b.length) {
            if (endLen > 2 * this.b.length - 32768) {
                var newBuf = new u8(endLen & -32768);
                newBuf.set(this.b.subarray(0, this.s.z));
                this.b = newBuf;
            }
            var split = this.b.length - this.s.z;
            if (split) {
                this.b.set(chunk.subarray(0, split), this.s.z);
                this.s.z = this.b.length;
                this.p(this.b, false);
            }
            this.b.set(this.b.subarray(-32768));
            this.b.set(chunk.subarray(split), 32768);
            this.s.z = chunk.length - split + 32768;
            this.s.i = 32766, this.s.w = 32768;
        }
        else {
            this.b.set(chunk, this.s.z);
            this.s.z += chunk.length;
        }
        this.s.l = final & 1;
        if (this.s.z > this.s.w + 8191 || final) {
            this.p(this.b, final || false);
            this.s.w = this.s.i, this.s.i -= 2;
        }
    };
    return Deflate;
}());

/**
 * Asynchronous streaming DEFLATE compression
 */
var AsyncDeflate = /*#__PURE__*/ (function () {
    function AsyncDeflate(opts, cb) {
        astrmify([
            bDflt,
            function () { return [astrm, Deflate]; }
        ], this, StrmOpt.call(this, opts, cb), function (ev) {
            var strm = new Deflate(ev.data);
            onmessage = astrm(strm);
        }, 6);
    }
    return AsyncDeflate;
}());

function deflate(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bDflt,
    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);
}
/**
 * Compresses data with DEFLATE without any wrapper
 * @param data The data to compress
 * @param opts The compression options
 * @returns The deflated version of the data
 */
function deflateSync(data, opts) {
    return dopt(data, opts || {}, 0, 0);
}
/**
 * Streaming DEFLATE decompression
 */
var Inflate = /*#__PURE__*/ (function () {
    function Inflate(opts, cb) {
        // no StrmOpt here to avoid adding to workerizer
        if (typeof opts == 'function')
            cb = opts, opts = {};
        this.ondata = cb;
        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
        this.s = { i: 0, b: dict ? dict.length : 0 };
        this.o = new u8(32768);
        this.p = new u8(0);
        if (dict)
            this.o.set(dict);
    }
    Inflate.prototype.e = function (c) {
        if (!this.ondata)
            err(5);
        if (this.d)
            err(4);
        if (!this.p.length)
            this.p = c;
        else if (c.length) {
            var n = new u8(this.p.length + c.length);
            n.set(this.p), n.set(c, this.p.length), this.p = n;
        }
    };
    Inflate.prototype.c = function (final) {
        this.s.i = +(this.d = final || false);
        var bts = this.s.b;
        var dt = inflt(this.p, this.s, this.o);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;
    };
    /**
     * Pushes a chunk to be inflated
     * @param chunk The chunk to push
     * @param final Whether this is the final chunk
     */
    Inflate.prototype.push = function (chunk, final) {
        this.e(chunk), this.c(final);
    };
    return Inflate;
}());

/**
 * Asynchronous streaming DEFLATE decompression
 */
var AsyncInflate = /*#__PURE__*/ (function () {
    function AsyncInflate(opts, cb) {
        astrmify([
            bInflt,
            function () { return [astrm, Inflate]; }
        ], this, StrmOpt.call(this, opts, cb), function (ev) {
            var strm = new Inflate(ev.data);
            onmessage = astrm(strm);
        }, 7);
    }
    return AsyncInflate;
}());

function inflate(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bInflt
    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);
}
/**
 * Expands DEFLATE data with no wrapper
 * @param data The data to decompress
 * @param opts The decompression options
 * @returns The decompressed version of the data
 */
function inflateSync(data, opts) {
    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.
/**
 * Streaming GZIP compression
 */
var Gzip = /*#__PURE__*/ (function () {
    function Gzip(opts, cb) {
        this.c = crc();
        this.l = 0;
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be GZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Gzip.prototype.push = function (chunk, final) {
        this.c.p(chunk);
        this.l += chunk.length;
        Deflate.prototype.push.call(this, chunk, final);
    };
    Gzip.prototype.p = function (c, f) {
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
        if (this.v)
            gzh(raw, this.o), this.v = 0;
        if (f)
            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f);
    };
    return Gzip;
}());

/**
 * Asynchronous streaming GZIP compression
 */
var AsyncGzip = /*#__PURE__*/ (function () {
    function AsyncGzip(opts, cb) {
        astrmify([
            bDflt,
            gze,
            function () { return [astrm, Deflate, Gzip]; }
        ], this, StrmOpt.call(this, opts, cb), function (ev) {
            var strm = new Gzip(ev.data);
            onmessage = astrm(strm);
        }, 8);
    }
    return AsyncGzip;
}());

function gzip(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bDflt,
        gze,
        function () { return [gzipSync]; }
    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);
}
/**
 * Compresses data with GZIP
 * @param data The data to compress
 * @param opts The compression options
 * @returns The gzipped version of the data
 */
function gzipSync(data, opts) {
    if (!opts)
        opts = {};
    var c = crc(), l = data.length;
    c.p(data);
    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
/**
 * Streaming single or multi-member GZIP decompression
 */
var Gunzip = /*#__PURE__*/ (function () {
    function Gunzip(opts, cb) {
        this.v = 1;
        this.r = 0;
        Inflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be GUNZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Gunzip.prototype.push = function (chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        this.r += chunk.length;
        if (this.v) {
            var p = this.p.subarray(this.v - 1);
            var s = p.length > 3 ? gzs(p) : 4;
            if (s > p.length) {
                if (!final)
                    return;
            }
            else if (this.v > 1 && this.onmember) {
                this.onmember(this.r - p.length);
            }
            this.p = p.subarray(s), this.v = 0;
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, final);
        // process concatenated GZIP
        if (this.s.f && !this.s.l) {
            this.v = shft(this.s.p) + 9;
            this.s = { i: 0 };
            this.o = new u8(0);
            if (this.p.length)
                this.push(new u8(0), final);
        }
    };
    return Gunzip;
}());

/**
 * Asynchronous streaming single or multi-member GZIP decompression
 */
var AsyncGunzip = /*#__PURE__*/ (function () {
    function AsyncGunzip(opts, cb) {
        var _this_1 = this;
        astrmify([
            bInflt,
            guze,
            function () { return [astrm, Inflate, Gunzip]; }
        ], this, StrmOpt.call(this, opts, cb), function (ev) {
            var strm = new Gunzip(ev.data);
            strm.onmember = function (offset) { return postMessage(offset); };
            onmessage = astrm(strm);
        }, 9, function (offset) { return _this_1.onmember && _this_1.onmember(offset); });
    }
    return AsyncGunzip;
}());

function gunzip(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bInflt,
        guze,
        function () { return [gunzipSync]; }
    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);
}
/**
 * Expands GZIP data
 * @param data The data to decompress
 * @param opts The decompression options
 * @returns The decompressed version of the data
 */
function gunzipSync(data, opts) {
    var st = gzs(data);
    if (st + 8 > data.length)
        err(6, 'invalid gzip data');
    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
/**
 * Streaming Zlib compression
 */
var Zlib = /*#__PURE__*/ (function () {
    function Zlib(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be zlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Zlib.prototype.push = function (chunk, final) {
        this.c.p(chunk);
        Deflate.prototype.push.call(this, chunk, final);
    };
    Zlib.prototype.p = function (c, f) {
        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
        if (this.v)
            zlh(raw, this.o), this.v = 0;
        if (f)
            wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f);
    };
    return Zlib;
}());

/**
 * Asynchronous streaming Zlib compression
 */
var AsyncZlib = /*#__PURE__*/ (function () {
    function AsyncZlib(opts, cb) {
        astrmify([
            bDflt,
            zle,
            function () { return [astrm, Deflate, Zlib]; }
        ], this, StrmOpt.call(this, opts, cb), function (ev) {
            var strm = new Zlib(ev.data);
            onmessage = astrm(strm);
        }, 10);
    }
    return AsyncZlib;
}());

function zlib(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bDflt,
        zle,
        function () { return [zlibSync]; }
    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);
}
/**
 * Compress data with Zlib
 * @param data The data to compress
 * @param opts The compression options
 * @returns The zlib-compressed version of the data
 */
function zlibSync(data, opts) {
    if (!opts)
        opts = {};
    var a = adler();
    a.p(data);
    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
}
/**
 * Streaming Zlib decompression
 */
var Unzlib = /*#__PURE__*/ (function () {
    function Unzlib(opts, cb) {
        Inflate.call(this, opts, cb);
        this.v = opts && opts.dictionary ? 2 : 1;
    }
    /**
     * Pushes a chunk to be unzlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Unzlib.prototype.push = function (chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
            if (this.p.length < 6 && !final)
                return;
            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
        }
        if (final) {
            if (this.p.length < 4)
                err(6, 'invalid zlib data');
            this.p = this.p.subarray(0, -4);
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, final);
    };
    return Unzlib;
}());

/**
 * Asynchronous streaming Zlib decompression
 */
var AsyncUnzlib = /*#__PURE__*/ (function () {
    function AsyncUnzlib(opts, cb) {
        astrmify([
            bInflt,
            zule,
            function () { return [astrm, Inflate, Unzlib]; }
        ], this, StrmOpt.call(this, opts, cb), function (ev) {
            var strm = new Unzlib(ev.data);
            onmessage = astrm(strm);
        }, 11);
    }
    return AsyncUnzlib;
}());

function unzlib(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bInflt,
        zule,
        function () { return [unzlibSync]; }
    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);
}
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param opts The decompression options
 * @returns The decompressed version of the data
 */
function unzlibSync(data, opts) {
    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
// Default algorithm for compression (used because having a known output size allows faster decompression)


/**
 * Streaming GZIP, Zlib, or raw DEFLATE decompression
 */
var Decompress = /*#__PURE__*/ (function () {
    function Decompress(opts, cb) {
        this.G = Gunzip;
        this.I = Inflate;
        this.Z = Unzlib;
        this.o = StrmOpt.call(this, opts, cb) || {};
    }
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Decompress.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        if (!this.s) {
            if (this.p && this.p.length) {
                var n = new u8(this.p.length + chunk.length);
                n.set(this.p), n.set(chunk, this.p.length);
            }
            else
                this.p = chunk;
            if (this.p.length > 2) {
                var _this_2 = this;
                // enables reuse of this method by AsyncDecompress
                var cb = function () { _this_2.ondata.apply(_this_2, arguments); };
                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)
                    ? new this.G(this.o, cb)
                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))
                        ? new this.I(this.o, cb)
                        : new this.Z(this.o, cb);
                this.s.push(this.p, final);
                this.p = null;
            }
        }
        else
            this.s.push(chunk, final);
    };
    return Decompress;
}());

/**
 * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
 */
var AsyncDecompress = /*#__PURE__*/ (function () {
    function AsyncDecompress(opts, cb) {
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
        Decompress.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    AsyncDecompress.prototype.push = function (chunk, final) {
        Decompress.prototype.push.call(this, chunk, final);
    };
    return AsyncDecompress;
}());

function decompress(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return (data[0] == 31 && data[1] == 139 && data[2] == 8)
        ? gunzip(data, opts, cb)
        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))
            ? inflate(data, opts, cb)
            : unzlib(data, opts, cb);
}
/**
 * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format
 * @param data The data to decompress
 * @param opts The decompression options
 * @returns The decompressed version of the data
 */
function decompressSync(data, opts) {
    return (data[0] == 31 && data[1] == 139 && data[2] == 8)
        ? gunzipSync(data, opts)
        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))
            ? inflateSync(data, opts)
            : unzlibSync(data, opts);
}
// flatten a directory structure
var fltn = function (d, p, t, o) {
    for (var k in d) {
        var val = d[k], n = p + k, op = o;
        if (Array.isArray(val))
            op = mrg(o, val[1]), val = val[0];
        if (val instanceof u8)
            t[n] = [val, op];
        else {
            t[n += '/'] = [new u8(0), op];
            fltn(val, n, t, o);
        }
    }
};
// text encoder
var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et, { stream: true });
    tds = 1;
}
catch (e) { }
// decode UTF8
var dutf8 = function (d) {
    for (var r = '', i = 0;;) {
        var c = d[i++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i + eb > d.length)
            return { s: r, r: slc(d, i - 1) };
        if (!eb)
            r += String.fromCharCode(c);
        else if (eb == 3) {
            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,
                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));
        }
        else if (eb & 1)
            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));
        else
            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));
    }
};
/**
 * Streaming UTF-8 decoding
 */
var DecodeUTF8 = /*#__PURE__*/ (function () {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is decoded
     */
    function DecodeUTF8(cb) {
        this.ondata = cb;
        if (tds)
            this.t = new TextDecoder();
        else
            this.p = et;
    }
    /**
     * Pushes a chunk to be decoded from UTF-8 binary
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    DecodeUTF8.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        final = !!final;
        if (this.t) {
            this.ondata(this.t.decode(chunk, { stream: true }), final);
            if (final) {
                if (this.t.decode().length)
                    err(8);
                this.t = null;
            }
            return;
        }
        if (!this.p)
            err(4);
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a = dutf8(dat), s = _a.s, r = _a.r;
        if (final) {
            if (r.length)
                err(8);
            this.p = null;
        }
        else
            this.p = r;
        this.ondata(s, final);
    };
    return DecodeUTF8;
}());

/**
 * Streaming UTF-8 encoding
 */
var EncodeUTF8 = /*#__PURE__*/ (function () {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is encoded
     */
    function EncodeUTF8(cb) {
        this.ondata = cb;
    }
    /**
     * Pushes a chunk to be encoded to UTF-8
     * @param chunk The string data to push
     * @param final Whether this is the last chunk
     */
    EncodeUTF8.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        if (this.d)
            err(4);
        this.ondata(strToU8(chunk), this.d = final || false);
    };
    return EncodeUTF8;
}());

/**
 * Converts a string into a Uint8Array for use with compression/decompression methods
 * @param str The string to encode
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless decoding a binary string.
 * @returns The string encoded in UTF-8/Latin-1 binary
 */
function strToU8(str, latin1) {
    if (latin1) {
        var ar_1 = new u8(str.length);
        for (var i = 0; i < str.length; ++i)
            ar_1[i] = str.charCodeAt(i);
        return ar_1;
    }
    if (te)
        return te.encode(str);
    var l = str.length;
    var ar = new u8(str.length + (str.length >> 1));
    var ai = 0;
    var w = function (v) { ar[ai++] = v; };
    for (var i = 0; i < l; ++i) {
        if (ai + 5 > ar.length) {
            var n = new u8(ai + 8 + ((l - i) << 1));
            n.set(ar);
            ar = n;
        }
        var c = str.charCodeAt(i);
        if (c < 128 || latin1)
            w(c);
        else if (c < 2048)
            w(192 | (c >> 6)), w(128 | (c & 63));
        else if (c > 55295 && c < 57344)
            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),
                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
        else
            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
    }
    return slc(ar, 0, ai);
}
/**
 * Converts a Uint8Array to a string
 * @param dat The data to decode to string
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless encoding to binary string.
 * @returns The original UTF-8/Latin-1 string
 */
function strFromU8(dat, latin1) {
    if (latin1) {
        var r = '';
        for (var i = 0; i < dat.length; i += 16384)
            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
        return r;
    }
    else if (td) {
        return td.decode(dat);
    }
    else {
        var _a = dutf8(dat), s = _a.s, r = _a.r;
        if (r.length)
            err(8);
        return s;
    }
}
;
// deflate bit flag
var dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };
// skip local zip header
var slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };
// read zip header
var zh = function (d, b, z) {
    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];
    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
};
// read zip64 extra field
var z64e = function (d, b) {
    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
        ;
    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
// extra field length
var exfl = function (ex) {
    var le = 0;
    if (ex) {
        for (var k in ex) {
            var l = ex[k].length;
            if (l > 65535)
                err(9);
            le += l + 4;
        }
    }
    return le;
};
// write zip header
var wzh = function (d, b, f, fn, u, c, ce, co) {
    var fl = fn.length, ex = f.extra, col = co && co.length;
    var exl = exfl(ex);
    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
    if (ce != null)
        d[b++] = 20, d[b++] = f.os;
    d[b] = 20, b += 2; // spec compliance? what's that?
    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;
    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
    if (y < 0 || y > 119)
        err(10);
    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;
    if (c != -1) {
        wbytes(d, b, f.crc);
        wbytes(d, b + 4, c < 0 ? -c - 2 : c);
        wbytes(d, b + 8, f.size);
    }
    wbytes(d, b + 12, fl);
    wbytes(d, b + 14, exl), b += 16;
    if (ce != null) {
        wbytes(d, b, col);
        wbytes(d, b + 6, f.attrs);
        wbytes(d, b + 10, ce), b += 14;
    }
    d.set(fn, b);
    b += fl;
    if (exl) {
        for (var k in ex) {
            var exf = ex[k], l = exf.length;
            wbytes(d, b, +k);
            wbytes(d, b + 2, l);
            d.set(exf, b + 4), b += 4 + l;
        }
    }
    if (col)
        d.set(co, b), b += col;
    return b;
};
// write zip footer (end of central directory)
var wzf = function (o, b, c, d, e) {
    wbytes(o, b, 0x6054B50); // skip disk
    wbytes(o, b + 8, c);
    wbytes(o, b + 10, c);
    wbytes(o, b + 12, d);
    wbytes(o, b + 16, e);
};
/**
 * A pass-through stream to keep data uncompressed in a ZIP archive.
 */
var ZipPassThrough = /*#__PURE__*/ (function () {
    /**
     * Creates a pass-through stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     */
    function ZipPassThrough(filename) {
        this.filename = filename;
        this.c = crc();
        this.size = 0;
        this.compression = 0;
    }
    /**
     * Processes a chunk and pushes to the output stream. You can override this
     * method in a subclass for custom behavior, but by default this passes
     * the data through. You must call this.ondata(err, chunk, final) at some
     * point in this method.
     * @param chunk The chunk to process
     * @param final Whether this is the last chunk
     */
    ZipPassThrough.prototype.process = function (chunk, final) {
        this.ondata(null, chunk, final);
    };
    /**
     * Pushes a chunk to be added. If you are subclassing this with a custom
     * compression algorithm, note that you must push data from the source
     * file only, pre-compression.
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    ZipPassThrough.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        this.c.p(chunk);
        this.size += chunk.length;
        if (final)
            this.crc = this.c.d();
        this.process(chunk, final || false);
    };
    return ZipPassThrough;
}());

// I don't extend because TypeScript extension adds 1kB of runtime bloat
/**
 * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
 * for better performance
 */
var ZipDeflate = /*#__PURE__*/ (function () {
    /**
     * Creates a DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */
    function ZipDeflate(filename, opts) {
        var _this_1 = this;
        if (!opts)
            opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate(opts, function (dat, final) {
            _this_1.ondata(null, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
    }
    ZipDeflate.prototype.process = function (chunk, final) {
        try {
            this.d.push(chunk, final);
        }
        catch (e) {
            this.ondata(e, null, final);
        }
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    ZipDeflate.prototype.push = function (chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
    };
    return ZipDeflate;
}());

/**
 * Asynchronous streaming DEFLATE compression for ZIP archives
 */
var AsyncZipDeflate = /*#__PURE__*/ (function () {
    /**
     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */
    function AsyncZipDeflate(filename, opts) {
        var _this_1 = this;
        if (!opts)
            opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function (err, dat, final) {
            _this_1.ondata(err, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
    }
    AsyncZipDeflate.prototype.process = function (chunk, final) {
        this.d.push(chunk, final);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    AsyncZipDeflate.prototype.push = function (chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
    };
    return AsyncZipDeflate;
}());

// TODO: Better tree shaking
/**
 * A zippable archive to which files can incrementally be added
 */
var Zip = /*#__PURE__*/ (function () {
    /**
     * Creates an empty ZIP archive to which files can be added
     * @param cb The callback to call whenever data for the generated ZIP archive
     *           is available
     */
    function Zip(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
    }
    /**
     * Adds a file to the ZIP archive
     * @param file The file stream to add
     */
    Zip.prototype.add = function (file) {
        var _this_1 = this;
        if (!this.ondata)
            err(5);
        // finishing or finished
        if (this.d & 2)
            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
        else {
            var f = strToU8(file.filename), fl_1 = f.length;
            var com = file.comment, o = com && strToU8(com);
            var u = fl_1 != file.filename.length || (o && (com.length != o.length));
            var hl_1 = fl_1 + exfl(file.extra) + 30;
            if (fl_1 > 65535)
                this.ondata(err(11, 0, 1), null, false);
            var header = new u8(hl_1);
            wzh(header, 0, file, f, u, -1);
            var chks_1 = [header];
            var pAll_1 = function () {
                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
                    var chk = chks_2[_i];
                    _this_1.ondata(null, chk, false);
                }
                chks_1 = [];
            };
            var tr_1 = this.d;
            this.d = 0;
            var ind_1 = this.u.length;
            var uf_1 = mrg(file, {
                f: f,
                u: u,
                o: o,
                t: function () {
                    if (file.terminate)
                        file.terminate();
                },
                r: function () {
                    pAll_1();
                    if (tr_1) {
                        var nxt = _this_1.u[ind_1 + 1];
                        if (nxt)
                            nxt.r();
                        else
                            _this_1.d = 1;
                    }
                    tr_1 = 1;
                }
            });
            var cl_1 = 0;
            file.ondata = function (err, dat, final) {
                if (err) {
                    _this_1.ondata(err, dat, final);
                    _this_1.terminate();
                }
                else {
                    cl_1 += dat.length;
                    chks_1.push(dat);
                    if (final) {
                        var dd = new u8(16);
                        wbytes(dd, 0, 0x8074B50);
                        wbytes(dd, 4, file.crc);
                        wbytes(dd, 8, cl_1);
                        wbytes(dd, 12, file.size);
                        chks_1.push(dd);
                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
                        if (tr_1)
                            uf_1.r();
                        tr_1 = 1;
                    }
                    else if (tr_1)
                        pAll_1();
                }
            };
            this.u.push(uf_1);
        }
    };
    /**
     * Ends the process of adding files and prepares to emit the final chunks.
     * This *must* be called after adding all desired files for the resulting
     * ZIP file to work properly.
     */
    Zip.prototype.end = function () {
        var _this_1 = this;
        if (this.d & 2) {
            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
            return;
        }
        if (this.d)
            this.e();
        else
            this.u.push({
                r: function () {
                    if (!(_this_1.d & 1))
                        return;
                    _this_1.u.splice(-1, 1);
                    _this_1.e();
                },
                t: function () { }
            });
        this.d = 3;
    };
    Zip.prototype.e = function () {
        var bt = 0, l = 0, tl = 0;
        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
            var f = _a[_i];
            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
        }
        var out = new u8(tl + 22);
        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {
            var f = _c[_b];
            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);
            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
    };
    /**
     * A method to terminate any internal workers used by the stream. Subsequent
     * calls to add() will fail.
     */
    Zip.prototype.terminate = function () {
        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
            var f = _a[_i];
            f.t();
        }
        this.d = 2;
    };
    return Zip;
}());

function zip(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    var r = {};
    fltn(data, '', r, opts);
    var k = Object.keys(r);
    var lft = k.length, o = 0, tot = 0;
    var slft = lft, files = new Array(lft);
    var term = [];
    var tAll = function () {
        for (var i = 0; i < term.length; ++i)
            term[i]();
    };
    var cbd = function (a, b) {
        mt(function () { cb(a, b); });
    };
    mt(function () { cbd = cb; });
    var cbf = function () {
        var out = new u8(tot + 22), oe = o, cdl = tot - o;
        tot = 0;
        for (var i = 0; i < slft; ++i) {
            var f = files[i];
            try {
                var l = f.c.length;
                wzh(out, tot, f, f.f, f.u, l);
                var badd = 30 + f.f.length + exfl(f.extra);
                var loc = tot + badd;
                out.set(f.c, loc);
                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
            }
            catch (e) {
                return cbd(e, null);
            }
        }
        wzf(out, o, files.length, cdl, oe);
        cbd(null, out);
    };
    if (!lft)
        cbf();
    var _loop_1 = function (i) {
        var fn = k[i];
        var _a = r[fn], file = _a[0], p = _a[1];
        var c = crc(), size = file.length;
        c.p(file);
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        var compression = p.level == 0 ? 0 : 8;
        var cbl = function (e, d) {
            if (e) {
                tAll();
                cbd(e, null);
            }
            else {
                var l = d.length;
                files[i] = mrg(p, {
                    size: size,
                    crc: c.d(),
                    c: d,
                    f: f,
                    m: m,
                    u: s != fn.length || (m && (com.length != ms)),
                    compression: compression
                });
                o += 30 + s + exl + l;
                tot += 76 + 2 * (s + exl) + (ms || 0) + l;
                if (!--lft)
                    cbf();
            }
        };
        if (s > 65535)
            cbl(err(11, 0, 1), null);
        if (!compression)
            cbl(null, file);
        else if (size < 160000) {
            try {
                cbl(null, deflateSync(file, p));
            }
            catch (e) {
                cbl(e, null);
            }
        }
        else
            term.push(deflate(file, p, cbl));
    };
    // Cannot use lft because it can decrease
    for (var i = 0; i < slft; ++i) {
        _loop_1(i);
    }
    return tAll;
}
/**
 * Synchronously creates a ZIP file. Prefer using `zip` for better performance
 * with more than one file.
 * @param data The directory structure for the ZIP archive
 * @param opts The main options, merged with per-file options
 * @returns The generated ZIP archive
 */
function zipSync(data, opts) {
    if (!opts)
        opts = {};
    var r = {};
    var files = [];
    fltn(data, '', r, opts);
    var o = 0;
    var tot = 0;
    for (var fn in r) {
        var _a = r[fn], file = _a[0], p = _a[1];
        var compression = p.level == 0 ? 0 : 8;
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        if (s > 65535)
            err(11);
        var d = compression ? deflateSync(file, p) : file, l = d.length;
        var c = crc();
        c.p(file);
        files.push(mrg(p, {
            size: file.length,
            crc: c.d(),
            c: d,
            f: f,
            m: m,
            u: s != fn.length || (m && (com.length != ms)),
            o: o,
            compression: compression
        }));
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
    }
    var out = new u8(tot + 22), oe = o, cdl = tot - o;
    for (var i = 0; i < files.length; ++i) {
        var f = files[i];
        wzh(out, f.o, f, f.f, f.u, f.c.length);
        var badd = 30 + f.f.length + exfl(f.extra);
        out.set(f.c, f.o + badd);
        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
    }
    wzf(out, o, files.length, cdl, oe);
    return out;
}
/**
 * Streaming pass-through decompression for ZIP archives
 */
var UnzipPassThrough = /*#__PURE__*/ (function () {
    function UnzipPassThrough() {
    }
    UnzipPassThrough.prototype.push = function (data, final) {
        this.ondata(null, data, final);
    };
    UnzipPassThrough.compression = 0;
    return UnzipPassThrough;
}());

/**
 * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
 * better performance.
 */
var UnzipInflate = /*#__PURE__*/ (function () {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */
    function UnzipInflate() {
        var _this_1 = this;
        this.i = new Inflate(function (dat, final) {
            _this_1.ondata(null, dat, final);
        });
    }
    UnzipInflate.prototype.push = function (data, final) {
        try {
            this.i.push(data, final);
        }
        catch (e) {
            this.ondata(e, null, final);
        }
    };
    UnzipInflate.compression = 8;
    return UnzipInflate;
}());

/**
 * Asynchronous streaming DEFLATE decompression for ZIP archives
 */
var AsyncUnzipInflate = /*#__PURE__*/ (function () {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */
    function AsyncUnzipInflate(_, sz) {
        var _this_1 = this;
        if (sz < 320000) {
            this.i = new Inflate(function (dat, final) {
                _this_1.ondata(null, dat, final);
            });
        }
        else {
            this.i = new AsyncInflate(function (err, dat, final) {
                _this_1.ondata(err, dat, final);
            });
            this.terminate = this.i.terminate;
        }
    }
    AsyncUnzipInflate.prototype.push = function (data, final) {
        if (this.i.terminate)
            data = slc(data, 0);
        this.i.push(data, final);
    };
    AsyncUnzipInflate.compression = 8;
    return AsyncUnzipInflate;
}());

/**
 * A ZIP archive decompression stream that emits files as they are discovered
 */
var Unzip = /*#__PURE__*/ (function () {
    /**
     * Creates a ZIP decompression stream
     * @param cb The callback to call whenever a file in the ZIP archive is found
     */
    function Unzip(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
            0: UnzipPassThrough
        };
        this.p = et;
    }
    /**
     * Pushes a chunk to be unzipped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Unzip.prototype.push = function (chunk, final) {
        var _this_1 = this;
        if (!this.onfile)
            err(5);
        if (!this.p)
            err(4);
        if (this.c > 0) {
            var len = Math.min(this.c, chunk.length);
            var toAdd = chunk.subarray(0, len);
            this.c -= len;
            if (this.d)
                this.d.push(toAdd, !this.c);
            else
                this.k[0].push(toAdd);
            chunk = chunk.subarray(len);
            if (chunk.length)
                return this.push(chunk, final);
        }
        else {
            var f = 0, i = 0, is = void 0, buf = void 0;
            if (!this.p.length)
                buf = chunk;
            else if (!chunk.length)
                buf = this.p;
            else {
                buf = new u8(this.p.length + chunk.length);
                buf.set(this.p), buf.set(chunk, this.p.length);
            }
            var l = buf.length, oc = this.c, add = oc && this.d;
            var _loop_2 = function () {
                var _a;
                var sig = b4(buf, i);
                if (sig == 0x4034B50) {
                    f = 1, is = i;
                    this_1.d = null;
                    this_1.c = 0;
                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
                    if (l > i + 30 + fnl + es) {
                        var chks_3 = [];
                        this_1.k.unshift(chks_3);
                        f = 2;
                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
                        if (sc_1 == 4294967295) {
                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];
                        }
                        else if (dd)
                            sc_1 = -1;
                        i += es;
                        this_1.c = sc_1;
                        var d_1;
                        var file_1 = {
                            name: fn_1,
                            compression: cmp_1,
                            start: function () {
                                if (!file_1.ondata)
                                    err(5);
                                if (!sc_1)
                                    file_1.ondata(null, et, true);
                                else {
                                    var ctr = _this_1.o[cmp_1];
                                    if (!ctr)
                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);
                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };
                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                                        var dat = chks_4[_i];
                                        d_1.push(dat, false);
                                    }
                                    if (_this_1.k[0] == chks_3 && _this_1.c)
                                        _this_1.d = d_1;
                                    else
                                        d_1.push(et, true);
                                }
                            },
                            terminate: function () {
                                if (d_1 && d_1.terminate)
                                    d_1.terminate();
                            }
                        };
                        if (sc_1 >= 0)
                            file_1.size = sc_1, file_1.originalSize = su_1;
                        this_1.onfile(file_1);
                    }
                    return "break";
                }
                else if (oc) {
                    if (sig == 0x8074B50) {
                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
                        return "break";
                    }
                    else if (sig == 0x2014B50) {
                        is = i -= 4, f = 3, this_1.c = 0;
                        return "break";
                    }
                }
            };
            var this_1 = this;
            for (; i < l - 4; ++i) {
                var state_1 = _loop_2();
                if (state_1 === "break")
                    break;
            }
            this.p = et;
            if (oc < 0) {
                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);
                if (add)
                    add.push(dat, !!f);
                else
                    this.k[+(f == 2)].push(dat);
            }
            if (f & 2)
                return this.push(buf.subarray(i), final);
            this.p = buf.subarray(i);
        }
        if (final) {
            if (this.c)
                err(13);
            this.p = null;
        }
    };
    /**
     * Registers a decoder with the stream, allowing for files compressed with
     * the compression type provided to be expanded correctly
     * @param decoder The decoder constructor
     */
    Unzip.prototype.register = function (decoder) {
        this.o[decoder.compression] = decoder;
    };
    return Unzip;
}());

var mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };
function unzip(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    var term = [];
    var tAll = function () {
        for (var i = 0; i < term.length; ++i)
            term[i]();
    };
    var files = {};
    var cbd = function (a, b) {
        mt(function () { cb(a, b); });
    };
    mt(function () { cbd = cb; });
    var e = data.length - 22;
    for (; b4(data, e) != 0x6054B50; --e) {
        if (!e || data.length - e > 65558) {
            cbd(err(13, 0, 1), null);
            return tAll;
        }
    }
    ;
    var lft = b2(data, e + 8);
    if (lft) {
        var c = lft;
        var o = b4(data, e + 16);
        var z = o == 4294967295 || c == 65535;
        if (z) {
            var ze = b4(data, e - 12);
            z = b4(data, ze) == 0x6064B50;
            if (z) {
                c = lft = b4(data, ze + 32);
                o = b4(data, ze + 48);
            }
        }
        var fltr = opts && opts.filter;
        var _loop_3 = function (i) {
            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
            o = no;
            var cbl = function (e, d) {
                if (e) {
                    tAll();
                    cbd(e, null);
                }
                else {
                    if (d)
                        files[fn] = d;
                    if (!--lft)
                        cbd(null, files);
                }
            };
            if (!fltr || fltr({
                name: fn,
                size: sc,
                originalSize: su,
                compression: c_1
            })) {
                if (!c_1)
                    cbl(null, slc(data, b, b + sc));
                else if (c_1 == 8) {
                    var infl = data.subarray(b, b + sc);
                    if (sc < 320000) {
                        try {
                            cbl(null, inflateSync(infl, { out: new u8(su) }));
                        }
                        catch (e) {
                            cbl(e, null);
                        }
                    }
                    else
                        term.push(inflate(infl, { size: su }, cbl));
                }
                else
                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);
            }
            else
                cbl(null, null);
        };
        for (var i = 0; i < c; ++i) {
            _loop_3(i);
        }
    }
    else
        cbd(null, {});
    return tAll;
}
/**
 * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
 * performance with more than one file.
 * @param data The raw compressed ZIP file
 * @param opts The ZIP extraction options
 * @returns The decompressed files
 */
function unzipSync(data, opts) {
    var files = {};
    var e = data.length - 22;
    for (; b4(data, e) != 0x6054B50; --e) {
        if (!e || data.length - e > 65558)
            err(13);
    }
    ;
    var c = b2(data, e + 8);
    if (!c)
        return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295 || c == 65535;
    if (z) {
        var ze = b4(data, e - 12);
        z = b4(data, ze) == 0x6064B50;
        if (z) {
            c = b4(data, ze + 32);
            o = b4(data, ze + 48);
        }
    }
    var fltr = opts && opts.filter;
    for (var i = 0; i < c; ++i) {
        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
        o = no;
        if (!fltr || fltr({
            name: fn,
            size: sc,
            originalSize: su,
            compression: c_2
        })) {
            if (!c_2)
                files[fn] = slc(data, b, b + sc);
            else if (c_2 == 8)
                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
            else
                err(14, 'unknown compression type ' + c_2);
        }
    }
    return files;
}


/***/ }),

/***/ "./node_modules/isomorphic-ws/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/isomorphic-ws/browser.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js

var ws = null

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket
} else if (typeof __webpack_require__.g !== 'undefined') {
  ws = __webpack_require__.g.WebSocket || __webpack_require__.g.MozWebSocket
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket
} else if (typeof self !== 'undefined') {
  ws = self.WebSocket || self.MozWebSocket
}

module.exports = ws


/***/ }),

/***/ "./node_modules/pend/index.js":
/*!************************************!*\
  !*** ./node_modules/pend/index.js ***!
  \************************************/
/***/ ((module) => {

module.exports = Pend;

function Pend() {
  this.pending = 0;
  this.max = Infinity;
  this.listeners = [];
  this.waiting = [];
  this.error = null;
}

Pend.prototype.go = function(fn) {
  if (this.pending < this.max) {
    pendGo(this, fn);
  } else {
    this.waiting.push(fn);
  }
};

Pend.prototype.wait = function(cb) {
  if (this.pending === 0) {
    cb(this.error);
  } else {
    this.listeners.push(cb);
  }
};

Pend.prototype.hold = function() {
  return pendHold(this);
};

function pendHold(self) {
  self.pending += 1;
  var called = false;
  return onCb;
  function onCb(err) {
    if (called) throw new Error("callback called twice");
    called = true;
    self.error = self.error || err;
    self.pending -= 1;
    if (self.waiting.length > 0 && self.pending < self.max) {
      pendGo(self, self.waiting.shift());
    } else if (self.pending === 0) {
      var listeners = self.listeners;
      self.listeners = [];
      listeners.forEach(cbListener);
    }
  }
  function cbListener(listener) {
    listener(self.error);
  }
}

function pendGo(self, fn) {
  fn(pendHold(self));
}


/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");


/***/ }),

/***/ "./src/file-loaders/workers/OtgDecodeWorker.ts":
/*!*****************************************************!*\
  !*** ./src/file-loaders/workers/OtgDecodeWorker.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register: () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _lmvtk_otg_OtgGeomCodec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lmvtk/otg/OtgGeomCodec */ "./src/file-loaders/lmvtk/otg/OtgGeomCodec.js");
/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ "./node_modules/fflate/esm/browser.js");


function isGzip(data) {
    return data[0] === 31 && data[1] === 139;
}
function doInstallInputPort(loadContext) {
    loadContext.port.onmessage = (event) => {
        switch (event.data.operation) {
            case 'DECODE_GEOMETRIES':
                doDecodeGeometries(loadContext, event.data.hashes, event.data.arrays, event.data.fromCache);
                break;
            case 'DECODE_MATERIALS':
                doDecodeMaterials(loadContext.worker, event.data.hashes, event.data.arrays);
                break;
        }
    };
}
function doDecodeGeometries(loadContext, hashes, arrays, fromCaches) {
    let mdatas = new Array();
    for (let i = 0; i < hashes.length; i++) {
        const hash = hashes[i];
        let geom = arrays[i];
        const fromCache = fromCaches[i];
        // If the HTTP fallback was used, the browser already did the decompression
        // Also, we did encounter uncompressed blobs in production.
        if (isGzip(geom)) {
            geom = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.gunzipSync)(geom);
        }
        else if (geom.byteLength !== geom.buffer.byteLength) {
            // create a copy so the main thread has individual buffers that can be thrown away individually
            geom = geom.slice();
        }
        let mdata = _lmvtk_otg_OtgGeomCodec__WEBPACK_IMPORTED_MODULE_0__.readLmvBufferGeom(geom);
        if (!mdata) {
            loadContext.raiseError(null, 'Failed to parse geometry', { hash: hash, resourceType: 'g' });
            continue;
        }
        mdata.fromCache = fromCache;
        mdata.hash = hash;
        mdatas.push(mdata);
    }
    let transferList = new Array();
    for (const mdata of mdatas) {
        let mesh = mdata.mesh;
        if (mesh) {
            let b = mesh.vb.buffer;
            transferList.push(b);
            if (mesh.indices && mesh.indices.buffer !== b) {
                transferList.push(mesh.indices.buffer);
            }
            if (mesh.iblines && mesh.iblines.buffer !== b) {
                transferList.push(mesh.iblines.buffer);
            }
        }
    }
    loadContext.worker.postMessage(mdatas, transferList);
}
function doDecodeMaterials(worker, hashes, arrays) {
    let out = new Array;
    for (let i = 0; i < hashes.length; i++) {
        let data = arrays[i];
        if (isGzip(data)) {
            data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.gunzipSync)(data);
        }
        else if (data.byteLength !== data.buffer.byteLength) {
            // create a copy so the main thread has individual buffers that can be thrown away individually
            data = data.slice();
        }
        out.push(data);
    }
    worker.postMessage({ materials: out, hashes: hashes }, out.map((e) => e.buffer));
}
function register(workerMain) {
    workerMain.register('INSTALL_INPUT_PORT', { doOperation: doInstallInputPort });
}


/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}


/***/ }),

/***/ "?99b8":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?aca8":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8571":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?d497":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!****************************************************!*\
  !*** ./src/file-loaders/workers/MainWorker-web.js ***!
  \****************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MainWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainWorker */ "./src/file-loaders/workers/MainWorker.js");


//Web worker dispatcher function -- received a message
//from the main thread and calls the appropriate handler
self.addEventListener('message', function (e) {

  var loadContext = e.data;
  loadContext.worker = self;

  _MainWorker__WEBPACK_IMPORTED_MODULE_0__.workerMain.dispatch(loadContext);

}, false);


self.raiseError = function (code, msg, args) {
  self.postMessage({ "error": { "code": code, "msg": msg, "args": args } });
};

// Shared by all workers to output debug message on console of main thread.
function debug(msg) {
  self.postMessage({ debug: 1, message: msg });
}

self.debug = debug;
})();

LMV = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=lmvworker.js.map