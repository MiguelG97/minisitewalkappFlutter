/*!
 * LMV v7.93.1
 *
 * Copyright 2023 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Viewer SDK Usage Limitations:
 *
 * The Autodesk Viewer SDK JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */
/******/ (() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ "./node_modules/@adsk/pdfjs-dist/legacy/build/pdf.js":
      /*!***********************************************************!*\
  !*** ./node_modules/@adsk/pdfjs-dist/legacy/build/pdf.js ***!
  \***********************************************************/
      /***/ function (
        module,
        __unused_webpack_exports,
        __webpack_require__
      ) {
        /**
         * @licstart The following is the entire license notice for the
         * Javascript code in this page
         *
         * Copyright 2020 Mozilla Foundation
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * @licend The above is the entire license notice for the
         * Javascript code in this page
         */

        (function webpackUniversalModuleDefinition(
          root,
          factory
        ) {
          if (true) module.exports = factory();
          else {
          }
        })(this, function () {
          return /******/ (function () {
            // webpackBootstrap
            /******/ var __webpack_modules__ = [
              /* 0 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                Object.defineProperty(
                  exports,
                  "addLinkAttributes",
                  {
                    enumerable: true,
                    get: function get() {
                      return _display_utils.addLinkAttributes;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "getFilenameFromUrl",
                  {
                    enumerable: true,
                    get: function get() {
                      return _display_utils.getFilenameFromUrl;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "LinkTarget",
                  {
                    enumerable: true,
                    get: function get() {
                      return _display_utils.LinkTarget;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "loadScript",
                  {
                    enumerable: true,
                    get: function get() {
                      return _display_utils.loadScript;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "PDFDateString",
                  {
                    enumerable: true,
                    get: function get() {
                      return _display_utils.PDFDateString;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "RenderingCancelledException",
                  {
                    enumerable: true,
                    get: function get() {
                      return _display_utils.RenderingCancelledException;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "build",
                  {
                    enumerable: true,
                    get: function get() {
                      return _api.build;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "getDocument",
                  {
                    enumerable: true,
                    get: function get() {
                      return _api.getDocument;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "LoopbackPort",
                  {
                    enumerable: true,
                    get: function get() {
                      return _api.LoopbackPort;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "PDFDataRangeTransport",
                  {
                    enumerable: true,
                    get: function get() {
                      return _api.PDFDataRangeTransport;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "PDFWorker",
                  {
                    enumerable: true,
                    get: function get() {
                      return _api.PDFWorker;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "putBinaryImageData",
                  {
                    enumerable: true,
                    get: function get() {
                      return _api.putBinaryImageData;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "version",
                  {
                    enumerable: true,
                    get: function get() {
                      return _api.version;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "CMapCompressionType",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.CMapCompressionType;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "createObjectURL",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.createObjectURL;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "createPromiseCapability",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.createPromiseCapability;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "createValidAbsoluteUrl",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.createValidAbsoluteUrl;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "InvalidPDFException",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.InvalidPDFException;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "MissingPDFException",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.MissingPDFException;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "OPS",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.OPS;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "PasswordResponses",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.PasswordResponses;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "PermissionFlag",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.PermissionFlag;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "removeNullCharacters",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.removeNullCharacters;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "shadow",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.shadow;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "UnexpectedResponseException",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.UnexpectedResponseException;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "UNSUPPORTED_FEATURES",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.UNSUPPORTED_FEATURES;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "Util",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.Util;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "VerbosityLevel",
                  {
                    enumerable: true,
                    get: function get() {
                      return _util.VerbosityLevel;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "AnnotationLayer",
                  {
                    enumerable: true,
                    get: function get() {
                      return _annotation_layer.AnnotationLayer;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "apiCompatibilityParams",
                  {
                    enumerable: true,
                    get: function get() {
                      return _api_compatibility.apiCompatibilityParams;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "GlobalWorkerOptions",
                  {
                    enumerable: true,
                    get: function get() {
                      return _worker_options.GlobalWorkerOptions;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "renderTextLayer",
                  {
                    enumerable: true,
                    get: function get() {
                      return _text_layer.renderTextLayer;
                    },
                  }
                );
                Object.defineProperty(
                  exports,
                  "SVGGraphics",
                  {
                    enumerable: true,
                    get: function get() {
                      return _svg.SVGGraphics;
                    },
                  }
                );

                var _display_utils =
                  __w_pdfjs_require__(1);

                var _api =
                  __w_pdfjs_require__(135);

                var _util =
                  __w_pdfjs_require__(4);

                var _annotation_layer =
                  __w_pdfjs_require__(149);

                var _api_compatibility =
                  __w_pdfjs_require__(139);

                var _worker_options =
                  __w_pdfjs_require__(142);

                var _text_layer =
                  __w_pdfjs_require__(151);

                var _svg =
                  __w_pdfjs_require__(152);

                var pdfjsVersion = "2.8.164";
                var pdfjsBuild = "d37821610";
                {
                  var _require =
                      __w_pdfjs_require__(6),
                    isNodeJS = _require.isNodeJS;

                  if (isNodeJS) {
                    var PDFNodeStream =
                      __w_pdfjs_require__(
                        153
                      ).PDFNodeStream;

                    (0,
                    _api.setPDFNetworkStreamFactory)(
                      function (params) {
                        return new PDFNodeStream(
                          params
                        );
                      }
                    );
                  } else {
                    var PDFNetworkStream =
                      __w_pdfjs_require__(
                        156
                      ).PDFNetworkStream;

                    var PDFFetchStream;

                    if (
                      (0,
                      _display_utils.isFetchSupported)()
                    ) {
                      PDFFetchStream =
                        __w_pdfjs_require__(
                          157
                        ).PDFFetchStream;
                    }

                    (0,
                    _api.setPDFNetworkStreamFactory)(
                      function (params) {
                        if (
                          PDFFetchStream &&
                          (0,
                          _display_utils.isValidFetchUrl)(
                            params.url
                          )
                        ) {
                          return new PDFFetchStream(
                            params
                          );
                        }

                        return new PDFNetworkStream(
                          params
                        );
                      }
                    );
                  }
                }

                /***/
              },
              /* 1 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.addLinkAttributes =
                  addLinkAttributes;
                exports.deprecated = deprecated;
                exports.getFilenameFromUrl =
                  getFilenameFromUrl;
                exports.isFetchSupported =
                  isFetchSupported;
                exports.isValidFetchUrl =
                  isValidFetchUrl;
                exports.loadScript = loadScript;
                exports.StatTimer =
                  exports.RenderingCancelledException =
                  exports.PDFDateString =
                  exports.PageViewport =
                  exports.LinkTarget =
                  exports.DOMSVGFactory =
                  exports.DOMCMapReaderFactory =
                  exports.DOMCanvasFactory =
                  exports.DEFAULT_LINK_REL =
                  exports.BaseCMapReaderFactory =
                  exports.BaseCanvasFactory =
                    void 0;

                var _regenerator =
                  _interopRequireDefault(
                    __w_pdfjs_require__(2)
                  );

                var _util =
                  __w_pdfjs_require__(4);

                function _interopRequireDefault(
                  obj
                ) {
                  return obj && obj.__esModule
                    ? obj
                    : { default: obj };
                }

                function _createForOfIteratorHelper(
                  o,
                  allowArrayLike
                ) {
                  var it;
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    o[Symbol.iterator] == null
                  ) {
                    if (
                      Array.isArray(o) ||
                      (it =
                        _unsupportedIterableToArray(
                          o
                        )) ||
                      (allowArrayLike &&
                        o &&
                        typeof o.length ===
                          "number")
                    ) {
                      if (it) o = it;
                      var i = 0;
                      var F = function F() {};
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return { done: true };
                          return {
                            done: false,
                            value: o[i++],
                          };
                        },
                        e: function e(_e) {
                          throw _e;
                        },
                        f: F,
                      };
                    }
                    throw new TypeError(
                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  }
                  var normalCompletion = true,
                    didErr = false,
                    err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion =
                        step.done;
                      return step;
                    },
                    e: function e(_e2) {
                      didErr = true;
                      err = _e2;
                    },
                    f: function f() {
                      try {
                        if (
                          !normalCompletion &&
                          it["return"] != null
                        )
                          it["return"]();
                      } finally {
                        if (didErr) throw err;
                      }
                    },
                  };
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  key,
                  arg
                ) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(
                      _next,
                      _throw
                    );
                  }
                }

                function _asyncToGenerator(fn) {
                  return function () {
                    var self = this,
                      args = arguments;
                    return new Promise(function (
                      resolve,
                      reject
                    ) {
                      var gen = fn.apply(
                        self,
                        args
                      );
                      function _next(value) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "next",
                          value
                        );
                      }
                      function _throw(err) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "throw",
                          err
                        );
                      }
                      _next(undefined);
                    });
                  };
                }

                function _inherits(
                  subClass,
                  superClass
                ) {
                  if (
                    typeof superClass !==
                      "function" &&
                    superClass !== null
                  ) {
                    throw new TypeError(
                      "Super expression must either be null or a function"
                    );
                  }
                  subClass.prototype =
                    Object.create(
                      superClass &&
                        superClass.prototype,
                      {
                        constructor: {
                          value: subClass,
                          writable: true,
                          configurable: true,
                        },
                      }
                    );
                  if (superClass)
                    _setPrototypeOf(
                      subClass,
                      superClass
                    );
                }

                function _setPrototypeOf(o, p) {
                  _setPrototypeOf =
                    Object.setPrototypeOf ||
                    function _setPrototypeOf(
                      o,
                      p
                    ) {
                      o.__proto__ = p;
                      return o;
                    };
                  return _setPrototypeOf(o, p);
                }

                function _createSuper(Derived) {
                  var hasNativeReflectConstruct =
                    _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super =
                        _getPrototypeOf(Derived),
                      result;
                    if (
                      hasNativeReflectConstruct
                    ) {
                      var NewTarget =
                        _getPrototypeOf(
                          this
                        ).constructor;
                      result = Reflect.construct(
                        Super,
                        arguments,
                        NewTarget
                      );
                    } else {
                      result = Super.apply(
                        this,
                        arguments
                      );
                    }
                    return _possibleConstructorReturn(
                      this,
                      result
                    );
                  };
                }

                function _possibleConstructorReturn(
                  self,
                  call
                ) {
                  if (
                    call &&
                    (_typeof(call) === "object" ||
                      typeof call === "function")
                  ) {
                    return call;
                  }
                  return _assertThisInitialized(
                    self
                  );
                }

                function _assertThisInitialized(
                  self
                ) {
                  if (self === void 0) {
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  }
                  return self;
                }

                function _isNativeReflectConstruct() {
                  if (
                    typeof Reflect ===
                      "undefined" ||
                    !Reflect.construct
                  )
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(
                      Reflect.construct(
                        Date,
                        [],
                        function () {}
                      )
                    );
                    return true;
                  } catch (e) {
                    return false;
                  }
                }

                function _getPrototypeOf(o) {
                  _getPrototypeOf =
                    Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function _getPrototypeOf(
                          o
                        ) {
                          return (
                            o.__proto__ ||
                            Object.getPrototypeOf(
                              o
                            )
                          );
                        };
                  return _getPrototypeOf(o);
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var DEFAULT_LINK_REL =
                  "noopener noreferrer nofollow";
                exports.DEFAULT_LINK_REL =
                  DEFAULT_LINK_REL;
                var SVG_NS =
                  "http://www.w3.org/2000/svg";

                var BaseCanvasFactory =
                  /*#__PURE__*/ (function () {
                    function BaseCanvasFactory() {
                      _classCallCheck(
                        this,
                        BaseCanvasFactory
                      );

                      if (
                        this.constructor ===
                        BaseCanvasFactory
                      ) {
                        (0, _util.unreachable)(
                          "Cannot initialize BaseCanvasFactory."
                        );
                      }
                    }

                    _createClass(
                      BaseCanvasFactory,
                      [
                        {
                          key: "create",
                          value: function create(
                            width,
                            height
                          ) {
                            (0,
                            _util.unreachable)(
                              "Abstract method `create` called."
                            );
                          },
                        },
                        {
                          key: "reset",
                          value: function reset(
                            canvasAndContext,
                            width,
                            height
                          ) {
                            if (
                              !canvasAndContext.canvas
                            ) {
                              throw new Error(
                                "Canvas is not specified"
                              );
                            }

                            if (
                              width <= 0 ||
                              height <= 0
                            ) {
                              throw new Error(
                                "Invalid canvas size"
                              );
                            }

                            canvasAndContext.canvas.width =
                              width;
                            canvasAndContext.canvas.height =
                              height;
                          },
                        },
                        {
                          key: "destroy",
                          value: function destroy(
                            canvasAndContext
                          ) {
                            if (
                              !canvasAndContext.canvas
                            ) {
                              throw new Error(
                                "Canvas is not specified"
                              );
                            }

                            canvasAndContext.canvas.width = 0;
                            canvasAndContext.canvas.height = 0;
                            canvasAndContext.canvas =
                              null;
                            canvasAndContext.context =
                              null;
                          },
                        },
                      ]
                    );

                    return BaseCanvasFactory;
                  })();

                exports.BaseCanvasFactory =
                  BaseCanvasFactory;

                var DOMCanvasFactory =
                  /*#__PURE__*/ (function (
                    _BaseCanvasFactory
                  ) {
                    _inherits(
                      DOMCanvasFactory,
                      _BaseCanvasFactory
                    );

                    var _super = _createSuper(
                      DOMCanvasFactory
                    );

                    function DOMCanvasFactory() {
                      var _this;

                      var _ref =
                          arguments.length > 0 &&
                          arguments[0] !==
                            undefined
                            ? arguments[0]
                            : {},
                        _ref$ownerDocument =
                          _ref.ownerDocument,
                        ownerDocument =
                          _ref$ownerDocument ===
                          void 0
                            ? globalThis.document
                            : _ref$ownerDocument;

                      _classCallCheck(
                        this,
                        DOMCanvasFactory
                      );

                      _this = _super.call(this);
                      _this._document =
                        ownerDocument;
                      return _this;
                    }

                    _createClass(
                      DOMCanvasFactory,
                      [
                        {
                          key: "create",
                          value: function create(
                            width,
                            height
                          ) {
                            if (
                              width <= 0 ||
                              height <= 0
                            ) {
                              throw new Error(
                                "Invalid canvas size"
                              );
                            }

                            var canvas =
                              this._document.createElement(
                                "canvas"
                              );

                            var context =
                              canvas.getContext(
                                "2d"
                              );
                            canvas.width = width;
                            canvas.height =
                              height;
                            return {
                              canvas: canvas,
                              context: context,
                            };
                          },
                        },
                      ]
                    );

                    return DOMCanvasFactory;
                  })(BaseCanvasFactory);

                exports.DOMCanvasFactory =
                  DOMCanvasFactory;

                var BaseCMapReaderFactory =
                  /*#__PURE__*/ (function () {
                    function BaseCMapReaderFactory(
                      _ref2
                    ) {
                      var _ref2$baseUrl =
                          _ref2.baseUrl,
                        baseUrl =
                          _ref2$baseUrl === void 0
                            ? null
                            : _ref2$baseUrl,
                        _ref2$isCompressed =
                          _ref2.isCompressed,
                        isCompressed =
                          _ref2$isCompressed ===
                          void 0
                            ? false
                            : _ref2$isCompressed;

                      _classCallCheck(
                        this,
                        BaseCMapReaderFactory
                      );

                      if (
                        this.constructor ===
                        BaseCMapReaderFactory
                      ) {
                        (0, _util.unreachable)(
                          "Cannot initialize BaseCMapReaderFactory."
                        );
                      }

                      this.baseUrl = baseUrl;
                      this.isCompressed =
                        isCompressed;
                    }

                    _createClass(
                      BaseCMapReaderFactory,
                      [
                        {
                          key: "fetch",
                          value: (function () {
                            var _fetch =
                              _asyncToGenerator(
                                /*#__PURE__*/ _regenerator[
                                  "default"
                                ].mark(
                                  function _callee(
                                    _ref3
                                  ) {
                                    var _this2 =
                                      this;

                                    var name,
                                      url,
                                      compressionType;
                                    return _regenerator[
                                      "default"
                                    ].wrap(
                                      function _callee$(
                                        _context
                                      ) {
                                        while (
                                          1
                                        ) {
                                          switch (
                                            (_context.prev =
                                              _context.next)
                                          ) {
                                            case 0:
                                              name =
                                                _ref3.name;

                                              if (
                                                this
                                                  .baseUrl
                                              ) {
                                                _context.next = 3;
                                                break;
                                              }

                                              throw new Error(
                                                'The CMap "baseUrl" parameter must be specified, ensure that ' +
                                                  'the "cMapUrl" and "cMapPacked" API parameters are provided.'
                                              );

                                            case 3:
                                              if (
                                                name
                                              ) {
                                                _context.next = 5;
                                                break;
                                              }

                                              throw new Error(
                                                "CMap name must be specified."
                                              );

                                            case 5:
                                              url =
                                                this
                                                  .baseUrl +
                                                name +
                                                (this
                                                  .isCompressed
                                                  ? ".bcmap"
                                                  : "");
                                              compressionType =
                                                this
                                                  .isCompressed
                                                  ? _util
                                                      .CMapCompressionType
                                                      .BINARY
                                                  : _util
                                                      .CMapCompressionType
                                                      .NONE;
                                              return _context.abrupt(
                                                "return",
                                                this._fetchData(
                                                  url,
                                                  compressionType
                                                )[
                                                  "catch"
                                                ](
                                                  function (
                                                    reason
                                                  ) {
                                                    throw new Error(
                                                      "Unable to load "
                                                        .concat(
                                                          _this2.isCompressed
                                                            ? "binary "
                                                            : "",
                                                          "CMap at: "
                                                        )
                                                        .concat(
                                                          url
                                                        )
                                                    );
                                                  }
                                                )
                                              );

                                            case 8:
                                            case "end":
                                              return _context.stop();
                                          }
                                        }
                                      },
                                      _callee,
                                      this
                                    );
                                  }
                                )
                              );

                            function fetch(_x) {
                              return _fetch.apply(
                                this,
                                arguments
                              );
                            }

                            return fetch;
                          })(),
                        },
                        {
                          key: "_fetchData",
                          value:
                            function _fetchData(
                              url,
                              compressionType
                            ) {
                              (0,
                              _util.unreachable)(
                                "Abstract method `_fetchData` called."
                              );
                            },
                        },
                      ]
                    );

                    return BaseCMapReaderFactory;
                  })();

                exports.BaseCMapReaderFactory =
                  BaseCMapReaderFactory;

                var DOMCMapReaderFactory =
                  /*#__PURE__*/ (function (
                    _BaseCMapReaderFactor
                  ) {
                    _inherits(
                      DOMCMapReaderFactory,
                      _BaseCMapReaderFactor
                    );

                    var _super2 = _createSuper(
                      DOMCMapReaderFactory
                    );

                    function DOMCMapReaderFactory() {
                      _classCallCheck(
                        this,
                        DOMCMapReaderFactory
                      );

                      return _super2.apply(
                        this,
                        arguments
                      );
                    }

                    _createClass(
                      DOMCMapReaderFactory,
                      [
                        {
                          key: "_fetchData",
                          value:
                            function _fetchData(
                              url,
                              compressionType
                            ) {
                              var _this3 = this;

                              if (
                                isFetchSupported() &&
                                isValidFetchUrl(
                                  url,
                                  document.baseURI
                                )
                              ) {
                                return fetch(
                                  url
                                ).then(
                                  /*#__PURE__*/ (function () {
                                    var _ref4 =
                                      _asyncToGenerator(
                                        /*#__PURE__*/ _regenerator[
                                          "default"
                                        ].mark(
                                          function _callee2(
                                            response
                                          ) {
                                            var cMapData;
                                            return _regenerator[
                                              "default"
                                            ].wrap(
                                              function _callee2$(
                                                _context2
                                              ) {
                                                while (
                                                  1
                                                ) {
                                                  switch (
                                                    (_context2.prev =
                                                      _context2.next)
                                                  ) {
                                                    case 0:
                                                      if (
                                                        response.ok
                                                      ) {
                                                        _context2.next = 2;
                                                        break;
                                                      }

                                                      throw new Error(
                                                        response.statusText
                                                      );

                                                    case 2:
                                                      if (
                                                        !_this3.isCompressed
                                                      ) {
                                                        _context2.next = 10;
                                                        break;
                                                      }

                                                      _context2.t0 =
                                                        Uint8Array;
                                                      _context2.next = 6;
                                                      return response.arrayBuffer();

                                                    case 6:
                                                      _context2.t1 =
                                                        _context2.sent;
                                                      cMapData =
                                                        new _context2.t0(
                                                          _context2.t1
                                                        );
                                                      _context2.next = 15;
                                                      break;

                                                    case 10:
                                                      _context2.t2 =
                                                        _util.stringToBytes;
                                                      _context2.next = 13;
                                                      return response.text();

                                                    case 13:
                                                      _context2.t3 =
                                                        _context2.sent;
                                                      cMapData =
                                                        (0,
                                                        _context2.t2)(
                                                          _context2.t3
                                                        );

                                                    case 15:
                                                      return _context2.abrupt(
                                                        "return",
                                                        {
                                                          cMapData:
                                                            cMapData,
                                                          compressionType:
                                                            compressionType,
                                                        }
                                                      );

                                                    case 16:
                                                    case "end":
                                                      return _context2.stop();
                                                  }
                                                }
                                              },
                                              _callee2
                                            );
                                          }
                                        )
                                      );

                                    return function (
                                      _x2
                                    ) {
                                      return _ref4.apply(
                                        this,
                                        arguments
                                      );
                                    };
                                  })()
                                );
                              }

                              return new Promise(
                                function (
                                  resolve,
                                  reject
                                ) {
                                  var request =
                                    new XMLHttpRequest();
                                  request.open(
                                    "GET",
                                    url,
                                    true
                                  );

                                  if (
                                    _this3.isCompressed
                                  ) {
                                    request.responseType =
                                      "arraybuffer";
                                  }

                                  request.onreadystatechange =
                                    function () {
                                      if (
                                        request.readyState !==
                                        XMLHttpRequest.DONE
                                      ) {
                                        return;
                                      }

                                      if (
                                        request.status ===
                                          200 ||
                                        request.status ===
                                          0
                                      ) {
                                        var cMapData;

                                        if (
                                          _this3.isCompressed &&
                                          request.response
                                        ) {
                                          cMapData =
                                            new Uint8Array(
                                              request.response
                                            );
                                        } else if (
                                          !_this3.isCompressed &&
                                          request.responseText
                                        ) {
                                          cMapData =
                                            (0,
                                            _util.stringToBytes)(
                                              request.responseText
                                            );
                                        }

                                        if (
                                          cMapData
                                        ) {
                                          resolve(
                                            {
                                              cMapData:
                                                cMapData,
                                              compressionType:
                                                compressionType,
                                            }
                                          );
                                          return;
                                        }
                                      }

                                      reject(
                                        new Error(
                                          request.statusText
                                        )
                                      );
                                    };

                                  request.send(
                                    null
                                  );
                                }
                              );
                            },
                        },
                      ]
                    );

                    return DOMCMapReaderFactory;
                  })(BaseCMapReaderFactory);

                exports.DOMCMapReaderFactory =
                  DOMCMapReaderFactory;

                var DOMSVGFactory =
                  /*#__PURE__*/ (function () {
                    function DOMSVGFactory() {
                      _classCallCheck(
                        this,
                        DOMSVGFactory
                      );
                    }

                    _createClass(DOMSVGFactory, [
                      {
                        key: "create",
                        value: function create(
                          width,
                          height
                        ) {
                          (0, _util.assert)(
                            width > 0 &&
                              height > 0,
                            "Invalid SVG dimensions"
                          );
                          var svg =
                            document.createElementNS(
                              SVG_NS,
                              "svg:svg"
                            );
                          svg.setAttribute(
                            "version",
                            "1.1"
                          );
                          svg.setAttribute(
                            "width",
                            width + "px"
                          );
                          svg.setAttribute(
                            "height",
                            height + "px"
                          );
                          svg.setAttribute(
                            "preserveAspectRatio",
                            "none"
                          );
                          svg.setAttribute(
                            "viewBox",
                            "0 0 " +
                              width +
                              " " +
                              height
                          );
                          return svg;
                        },
                      },
                      {
                        key: "createElement",
                        value:
                          function createElement(
                            type
                          ) {
                            (0, _util.assert)(
                              typeof type ===
                                "string",
                              "Invalid SVG element type"
                            );
                            return document.createElementNS(
                              SVG_NS,
                              type
                            );
                          },
                      },
                    ]);

                    return DOMSVGFactory;
                  })();

                exports.DOMSVGFactory =
                  DOMSVGFactory;

                var PageViewport =
                  /*#__PURE__*/ (function () {
                    function PageViewport(_ref5) {
                      var viewBox = _ref5.viewBox,
                        scale = _ref5.scale,
                        rotation = _ref5.rotation,
                        _ref5$offsetX =
                          _ref5.offsetX,
                        offsetX =
                          _ref5$offsetX === void 0
                            ? 0
                            : _ref5$offsetX,
                        _ref5$offsetY =
                          _ref5.offsetY,
                        offsetY =
                          _ref5$offsetY === void 0
                            ? 0
                            : _ref5$offsetY,
                        _ref5$dontFlip =
                          _ref5.dontFlip,
                        dontFlip =
                          _ref5$dontFlip ===
                          void 0
                            ? false
                            : _ref5$dontFlip;

                      _classCallCheck(
                        this,
                        PageViewport
                      );

                      this.viewBox = viewBox;
                      this.scale = scale;
                      this.rotation = rotation;
                      this.offsetX = offsetX;
                      this.offsetY = offsetY;
                      var centerX =
                        (viewBox[2] +
                          viewBox[0]) /
                        2;
                      var centerY =
                        (viewBox[3] +
                          viewBox[1]) /
                        2;
                      var rotateA,
                        rotateB,
                        rotateC,
                        rotateD;
                      rotation = rotation % 360;
                      rotation =
                        rotation < 0
                          ? rotation + 360
                          : rotation;

                      switch (rotation) {
                        case 180:
                          rotateA = -1;
                          rotateB = 0;
                          rotateC = 0;
                          rotateD = 1;
                          break;

                        case 90:
                          rotateA = 0;
                          rotateB = 1;
                          rotateC = 1;
                          rotateD = 0;
                          break;

                        case 270:
                          rotateA = 0;
                          rotateB = -1;
                          rotateC = -1;
                          rotateD = 0;
                          break;

                        case 0:
                          rotateA = 1;
                          rotateB = 0;
                          rotateC = 0;
                          rotateD = -1;
                          break;

                        default:
                          throw new Error(
                            "PageViewport: Invalid rotation, must be a multiple of 90 degrees."
                          );
                      }

                      if (dontFlip) {
                        rotateC = -rotateC;
                        rotateD = -rotateD;
                      }

                      var offsetCanvasX,
                        offsetCanvasY;
                      var width, height;

                      if (rotateA === 0) {
                        offsetCanvasX =
                          Math.abs(
                            centerY - viewBox[1]
                          ) *
                            scale +
                          offsetX;
                        offsetCanvasY =
                          Math.abs(
                            centerX - viewBox[0]
                          ) *
                            scale +
                          offsetY;
                        width =
                          Math.abs(
                            viewBox[3] -
                              viewBox[1]
                          ) * scale;
                        height =
                          Math.abs(
                            viewBox[2] -
                              viewBox[0]
                          ) * scale;
                      } else {
                        offsetCanvasX =
                          Math.abs(
                            centerX - viewBox[0]
                          ) *
                            scale +
                          offsetX;
                        offsetCanvasY =
                          Math.abs(
                            centerY - viewBox[1]
                          ) *
                            scale +
                          offsetY;
                        width =
                          Math.abs(
                            viewBox[2] -
                              viewBox[0]
                          ) * scale;
                        height =
                          Math.abs(
                            viewBox[3] -
                              viewBox[1]
                          ) * scale;
                      }

                      this.transform = [
                        rotateA * scale,
                        rotateB * scale,
                        rotateC * scale,
                        rotateD * scale,
                        offsetCanvasX -
                          rotateA *
                            scale *
                            centerX -
                          rotateC *
                            scale *
                            centerY,
                        offsetCanvasY -
                          rotateB *
                            scale *
                            centerX -
                          rotateD *
                            scale *
                            centerY,
                      ];
                      this.width = width;
                      this.height = height;
                    }

                    _createClass(PageViewport, [
                      {
                        key: "clone",
                        value: function clone() {
                          var _ref6 =
                              arguments.length >
                                0 &&
                              arguments[0] !==
                                undefined
                                ? arguments[0]
                                : {},
                            _ref6$scale =
                              _ref6.scale,
                            scale =
                              _ref6$scale ===
                              void 0
                                ? this.scale
                                : _ref6$scale,
                            _ref6$rotation =
                              _ref6.rotation,
                            rotation =
                              _ref6$rotation ===
                              void 0
                                ? this.rotation
                                : _ref6$rotation,
                            _ref6$offsetX =
                              _ref6.offsetX,
                            offsetX =
                              _ref6$offsetX ===
                              void 0
                                ? this.offsetX
                                : _ref6$offsetX,
                            _ref6$offsetY =
                              _ref6.offsetY,
                            offsetY =
                              _ref6$offsetY ===
                              void 0
                                ? this.offsetY
                                : _ref6$offsetY,
                            _ref6$dontFlip =
                              _ref6.dontFlip,
                            dontFlip =
                              _ref6$dontFlip ===
                              void 0
                                ? false
                                : _ref6$dontFlip;

                          return new PageViewport(
                            {
                              viewBox:
                                this.viewBox.slice(),
                              scale: scale,
                              rotation: rotation,
                              offsetX: offsetX,
                              offsetY: offsetY,
                              dontFlip: dontFlip,
                            }
                          );
                        },
                      },
                      {
                        key: "convertToViewportPoint",
                        value:
                          function convertToViewportPoint(
                            x,
                            y
                          ) {
                            return _util.Util.applyTransform(
                              [x, y],
                              this.transform
                            );
                          },
                      },
                      {
                        key: "convertToViewportRectangle",
                        value:
                          function convertToViewportRectangle(
                            rect
                          ) {
                            var topLeft =
                              _util.Util.applyTransform(
                                [
                                  rect[0],
                                  rect[1],
                                ],
                                this.transform
                              );

                            var bottomRight =
                              _util.Util.applyTransform(
                                [
                                  rect[2],
                                  rect[3],
                                ],
                                this.transform
                              );

                            return [
                              topLeft[0],
                              topLeft[1],
                              bottomRight[0],
                              bottomRight[1],
                            ];
                          },
                      },
                      {
                        key: "convertToPdfPoint",
                        value:
                          function convertToPdfPoint(
                            x,
                            y
                          ) {
                            return _util.Util.applyInverseTransform(
                              [x, y],
                              this.transform
                            );
                          },
                      },
                    ]);

                    return PageViewport;
                  })();

                exports.PageViewport =
                  PageViewport;

                var RenderingCancelledException =
                  /*#__PURE__*/ (function (
                    _BaseException
                  ) {
                    _inherits(
                      RenderingCancelledException,
                      _BaseException
                    );

                    var _super3 = _createSuper(
                      RenderingCancelledException
                    );

                    function RenderingCancelledException(
                      msg,
                      type
                    ) {
                      var _this4;

                      _classCallCheck(
                        this,
                        RenderingCancelledException
                      );

                      _this4 = _super3.call(
                        this,
                        msg
                      );
                      _this4.type = type;
                      return _this4;
                    }

                    return RenderingCancelledException;
                  })(_util.BaseException);

                exports.RenderingCancelledException =
                  RenderingCancelledException;
                var LinkTarget = {
                  NONE: 0,
                  SELF: 1,
                  BLANK: 2,
                  PARENT: 3,
                  TOP: 4,
                };
                exports.LinkTarget = LinkTarget;

                function addLinkAttributes(link) {
                  var _ref7 =
                      arguments.length > 1 &&
                      arguments[1] !== undefined
                        ? arguments[1]
                        : {},
                    url = _ref7.url,
                    target = _ref7.target,
                    rel = _ref7.rel,
                    _ref7$enabled = _ref7.enabled,
                    enabled =
                      _ref7$enabled === void 0
                        ? true
                        : _ref7$enabled;

                  (0, _util.assert)(
                    url &&
                      typeof url === "string",
                    'addLinkAttributes: A valid "url" parameter must provided.'
                  );
                  var urlNullRemoved = (0,
                  _util.removeNullCharacters)(
                    url
                  );

                  if (enabled) {
                    link.href = link.title =
                      urlNullRemoved;
                  } else {
                    link.href = "";
                    link.title =
                      "Disabled: ".concat(
                        urlNullRemoved
                      );

                    link.onclick = function () {
                      return false;
                    };
                  }

                  var targetStr = "";

                  switch (target) {
                    case LinkTarget.NONE:
                      break;

                    case LinkTarget.SELF:
                      targetStr = "_self";
                      break;

                    case LinkTarget.BLANK:
                      targetStr = "_blank";
                      break;

                    case LinkTarget.PARENT:
                      targetStr = "_parent";
                      break;

                    case LinkTarget.TOP:
                      targetStr = "_top";
                      break;
                  }

                  link.target = targetStr;
                  link.rel =
                    typeof rel === "string"
                      ? rel
                      : DEFAULT_LINK_REL;
                }

                function getFilenameFromUrl(url) {
                  var anchor = url.indexOf("#");
                  var query = url.indexOf("?");
                  var end = Math.min(
                    anchor > 0
                      ? anchor
                      : url.length,
                    query > 0 ? query : url.length
                  );
                  return url.substring(
                    url.lastIndexOf("/", end) + 1,
                    end
                  );
                }

                var StatTimer =
                  /*#__PURE__*/ (function () {
                    function StatTimer() {
                      _classCallCheck(
                        this,
                        StatTimer
                      );

                      this.started =
                        Object.create(null);
                      this.times = [];
                    }

                    _createClass(StatTimer, [
                      {
                        key: "time",
                        value: function time(
                          name
                        ) {
                          if (
                            name in this.started
                          ) {
                            (0, _util.warn)(
                              "Timer is already running for ".concat(
                                name
                              )
                            );
                          }

                          this.started[name] =
                            Date.now();
                        },
                      },
                      {
                        key: "timeEnd",
                        value: function timeEnd(
                          name
                        ) {
                          if (
                            !(
                              name in this.started
                            )
                          ) {
                            (0, _util.warn)(
                              "Timer has not been started for ".concat(
                                name
                              )
                            );
                          }

                          this.times.push({
                            name: name,
                            start:
                              this.started[name],
                            end: Date.now(),
                          });
                          delete this.started[
                            name
                          ];
                        },
                      },
                      {
                        key: "toString",
                        value:
                          function toString() {
                            var outBuf = [];
                            var longest = 0;

                            var _iterator =
                                _createForOfIteratorHelper(
                                  this.times
                                ),
                              _step;

                            try {
                              for (
                                _iterator.s();
                                !(_step =
                                  _iterator.n())
                                  .done;

                              ) {
                                var time =
                                  _step.value;
                                var name =
                                  time.name;

                                if (
                                  name.length >
                                  longest
                                ) {
                                  longest =
                                    name.length;
                                }
                              }
                            } catch (err) {
                              _iterator.e(err);
                            } finally {
                              _iterator.f();
                            }

                            var _iterator2 =
                                _createForOfIteratorHelper(
                                  this.times
                                ),
                              _step2;

                            try {
                              for (
                                _iterator2.s();
                                !(_step2 =
                                  _iterator2.n())
                                  .done;

                              ) {
                                var _time =
                                  _step2.value;
                                var duration =
                                  _time.end -
                                  _time.start;
                                outBuf.push(
                                  ""
                                    .concat(
                                      _time.name.padEnd(
                                        longest
                                      ),
                                      " "
                                    )
                                    .concat(
                                      duration,
                                      "ms\n"
                                    )
                                );
                              }
                            } catch (err) {
                              _iterator2.e(err);
                            } finally {
                              _iterator2.f();
                            }

                            return outBuf.join(
                              ""
                            );
                          },
                      },
                    ]);

                    return StatTimer;
                  })();

                exports.StatTimer = StatTimer;

                function isFetchSupported() {
                  return (
                    typeof fetch !==
                      "undefined" &&
                    typeof Response !==
                      "undefined" &&
                    "body" in
                      Response.prototype &&
                    typeof ReadableStream !==
                      "undefined"
                  );
                }

                function isValidFetchUrl(
                  url,
                  baseUrl
                ) {
                  try {
                    var _ref8 = baseUrl
                        ? new URL(url, baseUrl)
                        : new URL(url),
                      protocol = _ref8.protocol;

                    return (
                      protocol === "http:" ||
                      protocol === "https:"
                    );
                  } catch (ex) {
                    return false;
                  }
                }

                function loadScript(src) {
                  var removeScriptElement =
                    arguments.length > 1 &&
                    arguments[1] !== undefined
                      ? arguments[1]
                      : false;
                  return new Promise(function (
                    resolve,
                    reject
                  ) {
                    var script =
                      document.createElement(
                        "script"
                      );
                    script.src = src;

                    script.onload = function (
                      evt
                    ) {
                      if (removeScriptElement) {
                        script.remove();
                      }

                      resolve(evt);
                    };

                    script.onerror = function () {
                      reject(
                        new Error(
                          "Cannot load script at: ".concat(
                            script.src
                          )
                        )
                      );
                    };

                    (
                      document.head ||
                      document.documentElement
                    ).appendChild(script);
                  });
                }

                function deprecated(details) {
                  console.log(
                    "Deprecated API usage: " +
                      details
                  );
                }

                var pdfDateStringRegex;

                var PDFDateString =
                  /*#__PURE__*/ (function () {
                    function PDFDateString() {
                      _classCallCheck(
                        this,
                        PDFDateString
                      );
                    }

                    _createClass(
                      PDFDateString,
                      null,
                      [
                        {
                          key: "toDateObject",
                          value:
                            function toDateObject(
                              input
                            ) {
                              if (
                                !input ||
                                !(0,
                                _util.isString)(
                                  input
                                )
                              ) {
                                return null;
                              }

                              if (
                                !pdfDateStringRegex
                              ) {
                                pdfDateStringRegex =
                                  new RegExp(
                                    "^D:" +
                                      "(\\d{4})" +
                                      "(\\d{2})?" +
                                      "(\\d{2})?" +
                                      "(\\d{2})?" +
                                      "(\\d{2})?" +
                                      "(\\d{2})?" +
                                      "([Z|+|-])?" +
                                      "(\\d{2})?" +
                                      "'?" +
                                      "(\\d{2})?" +
                                      "'?"
                                  );
                              }

                              var matches =
                                pdfDateStringRegex.exec(
                                  input
                                );

                              if (!matches) {
                                return null;
                              }

                              var year = parseInt(
                                matches[1],
                                10
                              );
                              var month =
                                parseInt(
                                  matches[2],
                                  10
                                );
                              month =
                                month >= 1 &&
                                month <= 12
                                  ? month - 1
                                  : 0;
                              var day = parseInt(
                                matches[3],
                                10
                              );
                              day =
                                day >= 1 &&
                                day <= 31
                                  ? day
                                  : 1;
                              var hour = parseInt(
                                matches[4],
                                10
                              );
                              hour =
                                hour >= 0 &&
                                hour <= 23
                                  ? hour
                                  : 0;
                              var minute =
                                parseInt(
                                  matches[5],
                                  10
                                );
                              minute =
                                minute >= 0 &&
                                minute <= 59
                                  ? minute
                                  : 0;
                              var second =
                                parseInt(
                                  matches[6],
                                  10
                                );
                              second =
                                second >= 0 &&
                                second <= 59
                                  ? second
                                  : 0;
                              var universalTimeRelation =
                                matches[7] || "Z";
                              var offsetHour =
                                parseInt(
                                  matches[8],
                                  10
                                );
                              offsetHour =
                                offsetHour >= 0 &&
                                offsetHour <= 23
                                  ? offsetHour
                                  : 0;
                              var offsetMinute =
                                parseInt(
                                  matches[9],
                                  10
                                ) || 0;
                              offsetMinute =
                                offsetMinute >=
                                  0 &&
                                offsetMinute <= 59
                                  ? offsetMinute
                                  : 0;

                              if (
                                universalTimeRelation ===
                                "-"
                              ) {
                                hour +=
                                  offsetHour;
                                minute +=
                                  offsetMinute;
                              } else if (
                                universalTimeRelation ===
                                "+"
                              ) {
                                hour -=
                                  offsetHour;
                                minute -=
                                  offsetMinute;
                              }

                              return new Date(
                                Date.UTC(
                                  year,
                                  month,
                                  day,
                                  hour,
                                  minute,
                                  second
                                )
                              );
                            },
                        },
                      ]
                    );

                    return PDFDateString;
                  })();

                exports.PDFDateString =
                  PDFDateString;

                /***/
              },
              /* 2 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                module.exports =
                  __w_pdfjs_require__(3);

                /***/
              },
              /* 3 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";
                /* module decorator */ module =
                  __w_pdfjs_require__.nmd(module);

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                var runtime = (function (
                  exports
                ) {
                  "use strict";

                  var Op = Object.prototype;
                  var hasOwn = Op.hasOwnProperty;
                  var undefined;
                  var $Symbol =
                    typeof Symbol === "function"
                      ? Symbol
                      : {};
                  var iteratorSymbol =
                    $Symbol.iterator ||
                    "@@iterator";
                  var asyncIteratorSymbol =
                    $Symbol.asyncIterator ||
                    "@@asyncIterator";
                  var toStringTagSymbol =
                    $Symbol.toStringTag ||
                    "@@toStringTag";

                  function define(
                    obj,
                    key,
                    value
                  ) {
                    Object.defineProperty(
                      obj,
                      key,
                      {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true,
                      }
                    );
                    return obj[key];
                  }

                  try {
                    define({}, "");
                  } catch (err) {
                    define = function define(
                      obj,
                      key,
                      value
                    ) {
                      return (obj[key] = value);
                    };
                  }

                  function wrap(
                    innerFn,
                    outerFn,
                    self,
                    tryLocsList
                  ) {
                    var protoGenerator =
                      outerFn &&
                      outerFn.prototype instanceof
                        Generator
                        ? outerFn
                        : Generator;
                    var generator = Object.create(
                      protoGenerator.prototype
                    );
                    var context = new Context(
                      tryLocsList || []
                    );
                    generator._invoke =
                      makeInvokeMethod(
                        innerFn,
                        self,
                        context
                      );
                    return generator;
                  }

                  exports.wrap = wrap;

                  function tryCatch(
                    fn,
                    obj,
                    arg
                  ) {
                    try {
                      return {
                        type: "normal",
                        arg: fn.call(obj, arg),
                      };
                    } catch (err) {
                      return {
                        type: "throw",
                        arg: err,
                      };
                    }
                  }

                  var GenStateSuspendedStart =
                    "suspendedStart";
                  var GenStateSuspendedYield =
                    "suspendedYield";
                  var GenStateExecuting =
                    "executing";
                  var GenStateCompleted =
                    "completed";
                  var ContinueSentinel = {};

                  function Generator() {}

                  function GeneratorFunction() {}

                  function GeneratorFunctionPrototype() {}

                  var IteratorPrototype = {};

                  IteratorPrototype[
                    iteratorSymbol
                  ] = function () {
                    return this;
                  };

                  var getProto =
                    Object.getPrototypeOf;
                  var NativeIteratorPrototype =
                    getProto &&
                    getProto(
                      getProto(values([]))
                    );

                  if (
                    NativeIteratorPrototype &&
                    NativeIteratorPrototype !==
                      Op &&
                    hasOwn.call(
                      NativeIteratorPrototype,
                      iteratorSymbol
                    )
                  ) {
                    IteratorPrototype =
                      NativeIteratorPrototype;
                  }

                  var Gp =
                    (GeneratorFunctionPrototype.prototype =
                    Generator.prototype =
                      Object.create(
                        IteratorPrototype
                      ));
                  GeneratorFunction.prototype =
                    Gp.constructor =
                      GeneratorFunctionPrototype;
                  GeneratorFunctionPrototype.constructor =
                    GeneratorFunction;
                  GeneratorFunction.displayName =
                    define(
                      GeneratorFunctionPrototype,
                      toStringTagSymbol,
                      "GeneratorFunction"
                    );

                  function defineIteratorMethods(
                    prototype
                  ) {
                    [
                      "next",
                      "throw",
                      "return",
                    ].forEach(function (method) {
                      define(
                        prototype,
                        method,
                        function (arg) {
                          return this._invoke(
                            method,
                            arg
                          );
                        }
                      );
                    });
                  }

                  exports.isGeneratorFunction =
                    function (genFun) {
                      var ctor =
                        typeof genFun ===
                          "function" &&
                        genFun.constructor;
                      return ctor
                        ? ctor ===
                            GeneratorFunction ||
                            (ctor.displayName ||
                              ctor.name) ===
                              "GeneratorFunction"
                        : false;
                    };

                  exports.mark = function (
                    genFun
                  ) {
                    if (Object.setPrototypeOf) {
                      Object.setPrototypeOf(
                        genFun,
                        GeneratorFunctionPrototype
                      );
                    } else {
                      genFun.__proto__ =
                        GeneratorFunctionPrototype;
                      define(
                        genFun,
                        toStringTagSymbol,
                        "GeneratorFunction"
                      );
                    }

                    genFun.prototype =
                      Object.create(Gp);
                    return genFun;
                  };

                  exports.awrap = function (arg) {
                    return {
                      __await: arg,
                    };
                  };

                  function AsyncIterator(
                    generator,
                    PromiseImpl
                  ) {
                    function invoke(
                      method,
                      arg,
                      resolve,
                      reject
                    ) {
                      var record = tryCatch(
                        generator[method],
                        generator,
                        arg
                      );

                      if (
                        record.type === "throw"
                      ) {
                        reject(record.arg);
                      } else {
                        var result = record.arg;
                        var value = result.value;

                        if (
                          value &&
                          _typeof(value) ===
                            "object" &&
                          hasOwn.call(
                            value,
                            "__await"
                          )
                        ) {
                          return PromiseImpl.resolve(
                            value.__await
                          ).then(
                            function (value) {
                              invoke(
                                "next",
                                value,
                                resolve,
                                reject
                              );
                            },
                            function (err) {
                              invoke(
                                "throw",
                                err,
                                resolve,
                                reject
                              );
                            }
                          );
                        }

                        return PromiseImpl.resolve(
                          value
                        ).then(
                          function (unwrapped) {
                            result.value =
                              unwrapped;
                            resolve(result);
                          },
                          function (error) {
                            return invoke(
                              "throw",
                              error,
                              resolve,
                              reject
                            );
                          }
                        );
                      }
                    }

                    var previousPromise;

                    function enqueue(
                      method,
                      arg
                    ) {
                      function callInvokeWithMethodAndArg() {
                        return new PromiseImpl(
                          function (
                            resolve,
                            reject
                          ) {
                            invoke(
                              method,
                              arg,
                              resolve,
                              reject
                            );
                          }
                        );
                      }

                      return (previousPromise =
                        previousPromise
                          ? previousPromise.then(
                              callInvokeWithMethodAndArg,
                              callInvokeWithMethodAndArg
                            )
                          : callInvokeWithMethodAndArg());
                    }

                    this._invoke = enqueue;
                  }

                  defineIteratorMethods(
                    AsyncIterator.prototype
                  );

                  AsyncIterator.prototype[
                    asyncIteratorSymbol
                  ] = function () {
                    return this;
                  };

                  exports.AsyncIterator =
                    AsyncIterator;

                  exports.async = function (
                    innerFn,
                    outerFn,
                    self,
                    tryLocsList,
                    PromiseImpl
                  ) {
                    if (PromiseImpl === void 0)
                      PromiseImpl = Promise;
                    var iter = new AsyncIterator(
                      wrap(
                        innerFn,
                        outerFn,
                        self,
                        tryLocsList
                      ),
                      PromiseImpl
                    );
                    return exports.isGeneratorFunction(
                      outerFn
                    )
                      ? iter
                      : iter
                          .next()
                          .then(function (
                            result
                          ) {
                            return result.done
                              ? result.value
                              : iter.next();
                          });
                  };

                  function makeInvokeMethod(
                    innerFn,
                    self,
                    context
                  ) {
                    var state =
                      GenStateSuspendedStart;
                    return function invoke(
                      method,
                      arg
                    ) {
                      if (
                        state ===
                        GenStateExecuting
                      ) {
                        throw new Error(
                          "Generator is already running"
                        );
                      }

                      if (
                        state ===
                        GenStateCompleted
                      ) {
                        if (method === "throw") {
                          throw arg;
                        }

                        return doneResult();
                      }

                      context.method = method;
                      context.arg = arg;

                      while (true) {
                        var delegate =
                          context.delegate;

                        if (delegate) {
                          var delegateResult =
                            maybeInvokeDelegate(
                              delegate,
                              context
                            );

                          if (delegateResult) {
                            if (
                              delegateResult ===
                              ContinueSentinel
                            )
                              continue;
                            return delegateResult;
                          }
                        }

                        if (
                          context.method ===
                          "next"
                        ) {
                          context.sent =
                            context._sent =
                              context.arg;
                        } else if (
                          context.method ===
                          "throw"
                        ) {
                          if (
                            state ===
                            GenStateSuspendedStart
                          ) {
                            state =
                              GenStateCompleted;
                            throw context.arg;
                          }

                          context.dispatchException(
                            context.arg
                          );
                        } else if (
                          context.method ===
                          "return"
                        ) {
                          context.abrupt(
                            "return",
                            context.arg
                          );
                        }

                        state = GenStateExecuting;
                        var record = tryCatch(
                          innerFn,
                          self,
                          context
                        );

                        if (
                          record.type === "normal"
                        ) {
                          state = context.done
                            ? GenStateCompleted
                            : GenStateSuspendedYield;

                          if (
                            record.arg ===
                            ContinueSentinel
                          ) {
                            continue;
                          }

                          return {
                            value: record.arg,
                            done: context.done,
                          };
                        } else if (
                          record.type === "throw"
                        ) {
                          state =
                            GenStateCompleted;
                          context.method =
                            "throw";
                          context.arg =
                            record.arg;
                        }
                      }
                    };
                  }

                  function maybeInvokeDelegate(
                    delegate,
                    context
                  ) {
                    var method =
                      delegate.iterator[
                        context.method
                      ];

                    if (method === undefined) {
                      context.delegate = null;

                      if (
                        context.method === "throw"
                      ) {
                        if (
                          delegate.iterator[
                            "return"
                          ]
                        ) {
                          context.method =
                            "return";
                          context.arg = undefined;
                          maybeInvokeDelegate(
                            delegate,
                            context
                          );

                          if (
                            context.method ===
                            "throw"
                          ) {
                            return ContinueSentinel;
                          }
                        }

                        context.method = "throw";
                        context.arg =
                          new TypeError(
                            "The iterator does not provide a 'throw' method"
                          );
                      }

                      return ContinueSentinel;
                    }

                    var record = tryCatch(
                      method,
                      delegate.iterator,
                      context.arg
                    );

                    if (record.type === "throw") {
                      context.method = "throw";
                      context.arg = record.arg;
                      context.delegate = null;
                      return ContinueSentinel;
                    }

                    var info = record.arg;

                    if (!info) {
                      context.method = "throw";
                      context.arg = new TypeError(
                        "iterator result is not an object"
                      );
                      context.delegate = null;
                      return ContinueSentinel;
                    }

                    if (info.done) {
                      context[
                        delegate.resultName
                      ] = info.value;
                      context.next =
                        delegate.nextLoc;

                      if (
                        context.method !==
                        "return"
                      ) {
                        context.method = "next";
                        context.arg = undefined;
                      }
                    } else {
                      return info;
                    }

                    context.delegate = null;
                    return ContinueSentinel;
                  }

                  defineIteratorMethods(Gp);
                  define(
                    Gp,
                    toStringTagSymbol,
                    "Generator"
                  );

                  Gp[iteratorSymbol] =
                    function () {
                      return this;
                    };

                  Gp.toString = function () {
                    return "[object Generator]";
                  };

                  function pushTryEntry(locs) {
                    var entry = {
                      tryLoc: locs[0],
                    };

                    if (1 in locs) {
                      entry.catchLoc = locs[1];
                    }

                    if (2 in locs) {
                      entry.finallyLoc = locs[2];
                      entry.afterLoc = locs[3];
                    }

                    this.tryEntries.push(entry);
                  }

                  function resetTryEntry(entry) {
                    var record =
                      entry.completion || {};
                    record.type = "normal";
                    delete record.arg;
                    entry.completion = record;
                  }

                  function Context(tryLocsList) {
                    this.tryEntries = [
                      {
                        tryLoc: "root",
                      },
                    ];
                    tryLocsList.forEach(
                      pushTryEntry,
                      this
                    );
                    this.reset(true);
                  }

                  exports.keys = function (
                    object
                  ) {
                    var keys = [];

                    for (var key in object) {
                      keys.push(key);
                    }

                    keys.reverse();
                    return function next() {
                      while (keys.length) {
                        var key = keys.pop();

                        if (key in object) {
                          next.value = key;
                          next.done = false;
                          return next;
                        }
                      }

                      next.done = true;
                      return next;
                    };
                  };

                  function values(iterable) {
                    if (iterable) {
                      var iteratorMethod =
                        iterable[iteratorSymbol];

                      if (iteratorMethod) {
                        return iteratorMethod.call(
                          iterable
                        );
                      }

                      if (
                        typeof iterable.next ===
                        "function"
                      ) {
                        return iterable;
                      }

                      if (
                        !isNaN(iterable.length)
                      ) {
                        var i = -1,
                          next = function next() {
                            while (
                              ++i <
                              iterable.length
                            ) {
                              if (
                                hasOwn.call(
                                  iterable,
                                  i
                                )
                              ) {
                                next.value =
                                  iterable[i];
                                next.done = false;
                                return next;
                              }
                            }

                            next.value =
                              undefined;
                            next.done = true;
                            return next;
                          };

                        return (next.next = next);
                      }
                    }

                    return {
                      next: doneResult,
                    };
                  }

                  exports.values = values;

                  function doneResult() {
                    return {
                      value: undefined,
                      done: true,
                    };
                  }

                  Context.prototype = {
                    constructor: Context,
                    reset: function reset(
                      skipTempReset
                    ) {
                      this.prev = 0;
                      this.next = 0;
                      this.sent = this._sent =
                        undefined;
                      this.done = false;
                      this.delegate = null;
                      this.method = "next";
                      this.arg = undefined;
                      this.tryEntries.forEach(
                        resetTryEntry
                      );

                      if (!skipTempReset) {
                        for (var name in this) {
                          if (
                            name.charAt(0) ===
                              "t" &&
                            hasOwn.call(
                              this,
                              name
                            ) &&
                            !isNaN(+name.slice(1))
                          ) {
                            this[name] =
                              undefined;
                          }
                        }
                      }
                    },
                    stop: function stop() {
                      this.done = true;
                      var rootEntry =
                        this.tryEntries[0];
                      var rootRecord =
                        rootEntry.completion;

                      if (
                        rootRecord.type ===
                        "throw"
                      ) {
                        throw rootRecord.arg;
                      }

                      return this.rval;
                    },
                    dispatchException:
                      function dispatchException(
                        exception
                      ) {
                        if (this.done) {
                          throw exception;
                        }

                        var context = this;

                        function handle(
                          loc,
                          caught
                        ) {
                          record.type = "throw";
                          record.arg = exception;
                          context.next = loc;

                          if (caught) {
                            context.method =
                              "next";
                            context.arg =
                              undefined;
                          }

                          return !!caught;
                        }

                        for (
                          var i =
                            this.tryEntries
                              .length - 1;
                          i >= 0;
                          --i
                        ) {
                          var entry =
                            this.tryEntries[i];
                          var record =
                            entry.completion;

                          if (
                            entry.tryLoc ===
                            "root"
                          ) {
                            return handle("end");
                          }

                          if (
                            entry.tryLoc <=
                            this.prev
                          ) {
                            var hasCatch =
                              hasOwn.call(
                                entry,
                                "catchLoc"
                              );
                            var hasFinally =
                              hasOwn.call(
                                entry,
                                "finallyLoc"
                              );

                            if (
                              hasCatch &&
                              hasFinally
                            ) {
                              if (
                                this.prev <
                                entry.catchLoc
                              ) {
                                return handle(
                                  entry.catchLoc,
                                  true
                                );
                              } else if (
                                this.prev <
                                entry.finallyLoc
                              ) {
                                return handle(
                                  entry.finallyLoc
                                );
                              }
                            } else if (hasCatch) {
                              if (
                                this.prev <
                                entry.catchLoc
                              ) {
                                return handle(
                                  entry.catchLoc,
                                  true
                                );
                              }
                            } else if (
                              hasFinally
                            ) {
                              if (
                                this.prev <
                                entry.finallyLoc
                              ) {
                                return handle(
                                  entry.finallyLoc
                                );
                              }
                            } else {
                              throw new Error(
                                "try statement without catch or finally"
                              );
                            }
                          }
                        }
                      },
                    abrupt: function abrupt(
                      type,
                      arg
                    ) {
                      for (
                        var i =
                          this.tryEntries.length -
                          1;
                        i >= 0;
                        --i
                      ) {
                        var entry =
                          this.tryEntries[i];

                        if (
                          entry.tryLoc <=
                            this.prev &&
                          hasOwn.call(
                            entry,
                            "finallyLoc"
                          ) &&
                          this.prev <
                            entry.finallyLoc
                        ) {
                          var finallyEntry =
                            entry;
                          break;
                        }
                      }

                      if (
                        finallyEntry &&
                        (type === "break" ||
                          type === "continue") &&
                        finallyEntry.tryLoc <=
                          arg &&
                        arg <=
                          finallyEntry.finallyLoc
                      ) {
                        finallyEntry = null;
                      }

                      var record = finallyEntry
                        ? finallyEntry.completion
                        : {};
                      record.type = type;
                      record.arg = arg;

                      if (finallyEntry) {
                        this.method = "next";
                        this.next =
                          finallyEntry.finallyLoc;
                        return ContinueSentinel;
                      }

                      return this.complete(
                        record
                      );
                    },
                    complete: function complete(
                      record,
                      afterLoc
                    ) {
                      if (
                        record.type === "throw"
                      ) {
                        throw record.arg;
                      }

                      if (
                        record.type === "break" ||
                        record.type === "continue"
                      ) {
                        this.next = record.arg;
                      } else if (
                        record.type === "return"
                      ) {
                        this.rval = this.arg =
                          record.arg;
                        this.method = "return";
                        this.next = "end";
                      } else if (
                        record.type ===
                          "normal" &&
                        afterLoc
                      ) {
                        this.next = afterLoc;
                      }

                      return ContinueSentinel;
                    },
                    finish: function finish(
                      finallyLoc
                    ) {
                      for (
                        var i =
                          this.tryEntries.length -
                          1;
                        i >= 0;
                        --i
                      ) {
                        var entry =
                          this.tryEntries[i];

                        if (
                          entry.finallyLoc ===
                          finallyLoc
                        ) {
                          this.complete(
                            entry.completion,
                            entry.afterLoc
                          );
                          resetTryEntry(entry);
                          return ContinueSentinel;
                        }
                      }
                    },
                    catch: function _catch(
                      tryLoc
                    ) {
                      for (
                        var i =
                          this.tryEntries.length -
                          1;
                        i >= 0;
                        --i
                      ) {
                        var entry =
                          this.tryEntries[i];

                        if (
                          entry.tryLoc === tryLoc
                        ) {
                          var record =
                            entry.completion;

                          if (
                            record.type ===
                            "throw"
                          ) {
                            var thrown =
                              record.arg;
                            resetTryEntry(entry);
                          }

                          return thrown;
                        }
                      }

                      throw new Error(
                        "illegal catch attempt"
                      );
                    },
                    delegateYield:
                      function delegateYield(
                        iterable,
                        resultName,
                        nextLoc
                      ) {
                        this.delegate = {
                          iterator:
                            values(iterable),
                          resultName: resultName,
                          nextLoc: nextLoc,
                        };

                        if (
                          this.method === "next"
                        ) {
                          this.arg = undefined;
                        }

                        return ContinueSentinel;
                      },
                  };
                  return exports;
                })(
                  (false
                    ? 0
                    : _typeof(module)) ===
                    "object"
                    ? module.exports
                    : {}
                );

                try {
                  regeneratorRuntime = runtime;
                } catch (accidentalStrictMode) {
                  Function(
                    "r",
                    "regeneratorRuntime = r"
                  )(runtime);
                }

                /***/
              },
              /* 4 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.arrayByteLength =
                  arrayByteLength;
                exports.arraysToBytes =
                  arraysToBytes;
                exports.assert = assert;
                exports.bytesToString =
                  bytesToString;
                exports.createPromiseCapability =
                  createPromiseCapability;
                exports.createValidAbsoluteUrl =
                  createValidAbsoluteUrl;
                exports.encodeToXmlString =
                  encodeToXmlString;
                exports.escapeString =
                  escapeString;
                exports.getModificationDate =
                  getModificationDate;
                exports.getVerbosityLevel =
                  getVerbosityLevel;
                exports.info = info;
                exports.isArrayBuffer =
                  isArrayBuffer;
                exports.isArrayEqual =
                  isArrayEqual;
                exports.isAscii = isAscii;
                exports.isBool = isBool;
                exports.isNum = isNum;
                exports.isSameOrigin =
                  isSameOrigin;
                exports.isString = isString;
                exports.objectFromEntries =
                  objectFromEntries;
                exports.objectSize = objectSize;
                exports.removeNullCharacters =
                  removeNullCharacters;
                exports.setVerbosityLevel =
                  setVerbosityLevel;
                exports.shadow = shadow;
                exports.string32 = string32;
                exports.stringToBytes =
                  stringToBytes;
                exports.stringToPDFString =
                  stringToPDFString;
                exports.stringToUTF16BEString =
                  stringToUTF16BEString;
                exports.stringToUTF8String =
                  stringToUTF8String;
                exports.unreachable = unreachable;
                exports.utf8StringToString =
                  utf8StringToString;
                exports.warn = warn;
                exports.VerbosityLevel =
                  exports.Util =
                  exports.UNSUPPORTED_FEATURES =
                  exports.UnknownErrorException =
                  exports.UnexpectedResponseException =
                  exports.TextRenderingMode =
                  exports.StreamType =
                  exports.PermissionFlag =
                  exports.PasswordResponses =
                  exports.PasswordException =
                  exports.PageActionEventType =
                  exports.OPS =
                  exports.MissingPDFException =
                  exports.IsLittleEndianCached =
                  exports.IsEvalSupportedCached =
                  exports.InvalidPDFException =
                  exports.ImageKind =
                  exports.IDENTITY_MATRIX =
                  exports.FormatError =
                  exports.FontType =
                  exports.FONT_IDENTITY_MATRIX =
                  exports.DocumentActionEventType =
                  exports.createObjectURL =
                  exports.CMapCompressionType =
                  exports.BaseException =
                  exports.AnnotationType =
                  exports.AnnotationStateModelType =
                  exports.AnnotationReviewState =
                  exports.AnnotationReplyType =
                  exports.AnnotationMarkedState =
                  exports.AnnotationFlag =
                  exports.AnnotationFieldFlag =
                  exports.AnnotationBorderStyleType =
                  exports.AnnotationActionEventType =
                  exports.AbortException =
                    void 0;

                __w_pdfjs_require__(5);

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                function _toConsumableArray(arr) {
                  return (
                    _arrayWithoutHoles(arr) ||
                    _iterableToArray(arr) ||
                    _unsupportedIterableToArray(
                      arr
                    ) ||
                    _nonIterableSpread()
                  );
                }

                function _nonIterableSpread() {
                  throw new TypeError(
                    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _iterableToArray(iter) {
                  if (
                    typeof Symbol !==
                      "undefined" &&
                    Symbol.iterator in
                      Object(iter)
                  )
                    return Array.from(iter);
                }

                function _arrayWithoutHoles(arr) {
                  if (Array.isArray(arr))
                    return _arrayLikeToArray(arr);
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _inherits(
                  subClass,
                  superClass
                ) {
                  if (
                    typeof superClass !==
                      "function" &&
                    superClass !== null
                  ) {
                    throw new TypeError(
                      "Super expression must either be null or a function"
                    );
                  }
                  subClass.prototype =
                    Object.create(
                      superClass &&
                        superClass.prototype,
                      {
                        constructor: {
                          value: subClass,
                          writable: true,
                          configurable: true,
                        },
                      }
                    );
                  if (superClass)
                    _setPrototypeOf(
                      subClass,
                      superClass
                    );
                }

                function _setPrototypeOf(o, p) {
                  _setPrototypeOf =
                    Object.setPrototypeOf ||
                    function _setPrototypeOf(
                      o,
                      p
                    ) {
                      o.__proto__ = p;
                      return o;
                    };
                  return _setPrototypeOf(o, p);
                }

                function _createSuper(Derived) {
                  var hasNativeReflectConstruct =
                    _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super =
                        _getPrototypeOf(Derived),
                      result;
                    if (
                      hasNativeReflectConstruct
                    ) {
                      var NewTarget =
                        _getPrototypeOf(
                          this
                        ).constructor;
                      result = Reflect.construct(
                        Super,
                        arguments,
                        NewTarget
                      );
                    } else {
                      result = Super.apply(
                        this,
                        arguments
                      );
                    }
                    return _possibleConstructorReturn(
                      this,
                      result
                    );
                  };
                }

                function _possibleConstructorReturn(
                  self,
                  call
                ) {
                  if (
                    call &&
                    (_typeof(call) === "object" ||
                      typeof call === "function")
                  ) {
                    return call;
                  }
                  return _assertThisInitialized(
                    self
                  );
                }

                function _assertThisInitialized(
                  self
                ) {
                  if (self === void 0) {
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  }
                  return self;
                }

                function _isNativeReflectConstruct() {
                  if (
                    typeof Reflect ===
                      "undefined" ||
                    !Reflect.construct
                  )
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(
                      Reflect.construct(
                        Date,
                        [],
                        function () {}
                      )
                    );
                    return true;
                  } catch (e) {
                    return false;
                  }
                }

                function _getPrototypeOf(o) {
                  _getPrototypeOf =
                    Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function _getPrototypeOf(
                          o
                        ) {
                          return (
                            o.__proto__ ||
                            Object.getPrototypeOf(
                              o
                            )
                          );
                        };
                  return _getPrototypeOf(o);
                }

                var IDENTITY_MATRIX = [
                  1, 0, 0, 1, 0, 0,
                ];
                exports.IDENTITY_MATRIX =
                  IDENTITY_MATRIX;
                var FONT_IDENTITY_MATRIX = [
                  0.001, 0, 0, 0.001, 0, 0,
                ];
                exports.FONT_IDENTITY_MATRIX =
                  FONT_IDENTITY_MATRIX;
                var PermissionFlag = {
                  PRINT: 0x04,
                  MODIFY_CONTENTS: 0x08,
                  COPY: 0x10,
                  MODIFY_ANNOTATIONS: 0x20,
                  FILL_INTERACTIVE_FORMS: 0x100,
                  COPY_FOR_ACCESSIBILITY: 0x200,
                  ASSEMBLE: 0x400,
                  PRINT_HIGH_QUALITY: 0x800,
                };
                exports.PermissionFlag =
                  PermissionFlag;
                var TextRenderingMode = {
                  FILL: 0,
                  STROKE: 1,
                  FILL_STROKE: 2,
                  INVISIBLE: 3,
                  FILL_ADD_TO_PATH: 4,
                  STROKE_ADD_TO_PATH: 5,
                  FILL_STROKE_ADD_TO_PATH: 6,
                  ADD_TO_PATH: 7,
                  FILL_STROKE_MASK: 3,
                  ADD_TO_PATH_FLAG: 4,
                };
                exports.TextRenderingMode =
                  TextRenderingMode;
                var ImageKind = {
                  GRAYSCALE_1BPP: 1,
                  RGB_24BPP: 2,
                  RGBA_32BPP: 3,
                };
                exports.ImageKind = ImageKind;
                var AnnotationType = {
                  TEXT: 1,
                  LINK: 2,
                  FREETEXT: 3,
                  LINE: 4,
                  SQUARE: 5,
                  CIRCLE: 6,
                  POLYGON: 7,
                  POLYLINE: 8,
                  HIGHLIGHT: 9,
                  UNDERLINE: 10,
                  SQUIGGLY: 11,
                  STRIKEOUT: 12,
                  STAMP: 13,
                  CARET: 14,
                  INK: 15,
                  POPUP: 16,
                  FILEATTACHMENT: 17,
                  SOUND: 18,
                  MOVIE: 19,
                  WIDGET: 20,
                  SCREEN: 21,
                  PRINTERMARK: 22,
                  TRAPNET: 23,
                  WATERMARK: 24,
                  THREED: 25,
                  REDACT: 26,
                };
                exports.AnnotationType =
                  AnnotationType;
                var AnnotationStateModelType = {
                  MARKED: "Marked",
                  REVIEW: "Review",
                };
                exports.AnnotationStateModelType =
                  AnnotationStateModelType;
                var AnnotationMarkedState = {
                  MARKED: "Marked",
                  UNMARKED: "Unmarked",
                };
                exports.AnnotationMarkedState =
                  AnnotationMarkedState;
                var AnnotationReviewState = {
                  ACCEPTED: "Accepted",
                  REJECTED: "Rejected",
                  CANCELLED: "Cancelled",
                  COMPLETED: "Completed",
                  NONE: "None",
                };
                exports.AnnotationReviewState =
                  AnnotationReviewState;
                var AnnotationReplyType = {
                  GROUP: "Group",
                  REPLY: "R",
                };
                exports.AnnotationReplyType =
                  AnnotationReplyType;
                var AnnotationFlag = {
                  INVISIBLE: 0x01,
                  HIDDEN: 0x02,
                  PRINT: 0x04,
                  NOZOOM: 0x08,
                  NOROTATE: 0x10,
                  NOVIEW: 0x20,
                  READONLY: 0x40,
                  LOCKED: 0x80,
                  TOGGLENOVIEW: 0x100,
                  LOCKEDCONTENTS: 0x200,
                };
                exports.AnnotationFlag =
                  AnnotationFlag;
                var AnnotationFieldFlag = {
                  READONLY: 0x0000001,
                  REQUIRED: 0x0000002,
                  NOEXPORT: 0x0000004,
                  MULTILINE: 0x0001000,
                  PASSWORD: 0x0002000,
                  NOTOGGLETOOFF: 0x0004000,
                  RADIO: 0x0008000,
                  PUSHBUTTON: 0x0010000,
                  COMBO: 0x0020000,
                  EDIT: 0x0040000,
                  SORT: 0x0080000,
                  FILESELECT: 0x0100000,
                  MULTISELECT: 0x0200000,
                  DONOTSPELLCHECK: 0x0400000,
                  DONOTSCROLL: 0x0800000,
                  COMB: 0x1000000,
                  RICHTEXT: 0x2000000,
                  RADIOSINUNISON: 0x2000000,
                  COMMITONSELCHANGE: 0x4000000,
                };
                exports.AnnotationFieldFlag =
                  AnnotationFieldFlag;
                var AnnotationBorderStyleType = {
                  SOLID: 1,
                  DASHED: 2,
                  BEVELED: 3,
                  INSET: 4,
                  UNDERLINE: 5,
                };
                exports.AnnotationBorderStyleType =
                  AnnotationBorderStyleType;
                var AnnotationActionEventType = {
                  E: "Mouse Enter",
                  X: "Mouse Exit",
                  D: "Mouse Down",
                  U: "Mouse Up",
                  Fo: "Focus",
                  Bl: "Blur",
                  PO: "PageOpen",
                  PC: "PageClose",
                  PV: "PageVisible",
                  PI: "PageInvisible",
                  K: "Keystroke",
                  F: "Format",
                  V: "Validate",
                  C: "Calculate",
                };
                exports.AnnotationActionEventType =
                  AnnotationActionEventType;
                var DocumentActionEventType = {
                  WC: "WillClose",
                  WS: "WillSave",
                  DS: "DidSave",
                  WP: "WillPrint",
                  DP: "DidPrint",
                };
                exports.DocumentActionEventType =
                  DocumentActionEventType;
                var PageActionEventType = {
                  O: "PageOpen",
                  C: "PageClose",
                };
                exports.PageActionEventType =
                  PageActionEventType;
                var StreamType = {
                  UNKNOWN: "UNKNOWN",
                  FLATE: "FLATE",
                  LZW: "LZW",
                  DCT: "DCT",
                  JPX: "JPX",
                  JBIG: "JBIG",
                  A85: "A85",
                  AHX: "AHX",
                  CCF: "CCF",
                  RLX: "RLX",
                };
                exports.StreamType = StreamType;
                var FontType = {
                  UNKNOWN: "UNKNOWN",
                  TYPE1: "TYPE1",
                  TYPE1C: "TYPE1C",
                  CIDFONTTYPE0: "CIDFONTTYPE0",
                  CIDFONTTYPE0C: "CIDFONTTYPE0C",
                  TRUETYPE: "TRUETYPE",
                  CIDFONTTYPE2: "CIDFONTTYPE2",
                  TYPE3: "TYPE3",
                  OPENTYPE: "OPENTYPE",
                  TYPE0: "TYPE0",
                  MMTYPE1: "MMTYPE1",
                };
                exports.FontType = FontType;
                var VerbosityLevel = {
                  ERRORS: 0,
                  WARNINGS: 1,
                  INFOS: 5,
                };
                exports.VerbosityLevel =
                  VerbosityLevel;
                var CMapCompressionType = {
                  NONE: 0,
                  BINARY: 1,
                  STREAM: 2,
                };
                exports.CMapCompressionType =
                  CMapCompressionType;
                var OPS = {
                  dependency: 1,
                  setLineWidth: 2,
                  setLineCap: 3,
                  setLineJoin: 4,
                  setMiterLimit: 5,
                  setDash: 6,
                  setRenderingIntent: 7,
                  setFlatness: 8,
                  setGState: 9,
                  save: 10,
                  restore: 11,
                  transform: 12,
                  moveTo: 13,
                  lineTo: 14,
                  curveTo: 15,
                  curveTo2: 16,
                  curveTo3: 17,
                  closePath: 18,
                  rectangle: 19,
                  stroke: 20,
                  closeStroke: 21,
                  fill: 22,
                  eoFill: 23,
                  fillStroke: 24,
                  eoFillStroke: 25,
                  closeFillStroke: 26,
                  closeEOFillStroke: 27,
                  endPath: 28,
                  clip: 29,
                  eoClip: 30,
                  beginText: 31,
                  endText: 32,
                  setCharSpacing: 33,
                  setWordSpacing: 34,
                  setHScale: 35,
                  setLeading: 36,
                  setFont: 37,
                  setTextRenderingMode: 38,
                  setTextRise: 39,
                  moveText: 40,
                  setLeadingMoveText: 41,
                  setTextMatrix: 42,
                  nextLine: 43,
                  showText: 44,
                  showSpacedText: 45,
                  nextLineShowText: 46,
                  nextLineSetSpacingShowText: 47,
                  setCharWidth: 48,
                  setCharWidthAndBounds: 49,
                  setStrokeColorSpace: 50,
                  setFillColorSpace: 51,
                  setStrokeColor: 52,
                  setStrokeColorN: 53,
                  setFillColor: 54,
                  setFillColorN: 55,
                  setStrokeGray: 56,
                  setFillGray: 57,
                  setStrokeRGBColor: 58,
                  setFillRGBColor: 59,
                  setStrokeCMYKColor: 60,
                  setFillCMYKColor: 61,
                  shadingFill: 62,
                  beginInlineImage: 63,
                  beginImageData: 64,
                  endInlineImage: 65,
                  paintXObject: 66,
                  markPoint: 67,
                  markPointProps: 68,
                  beginMarkedContent: 69,
                  beginMarkedContentProps: 70,
                  endMarkedContent: 71,
                  beginCompat: 72,
                  endCompat: 73,
                  paintFormXObjectBegin: 74,
                  paintFormXObjectEnd: 75,
                  beginGroup: 76,
                  endGroup: 77,
                  beginAnnotations: 78,
                  endAnnotations: 79,
                  beginAnnotation: 80,
                  endAnnotation: 81,
                  paintJpegXObject: 82,
                  paintImageMaskXObject: 83,
                  paintImageMaskXObjectGroup: 84,
                  paintImageXObject: 85,
                  paintInlineImageXObject: 86,
                  paintInlineImageXObjectGroup: 87,
                  paintImageXObjectRepeat: 88,
                  paintImageMaskXObjectRepeat: 89,
                  paintSolidColorImageMask: 90,
                  constructPath: 91,
                };
                exports.OPS = OPS;
                var UNSUPPORTED_FEATURES = {
                  unknown: "unknown",
                  forms: "forms",
                  javaScript: "javaScript",
                  smask: "smask",
                  shadingPattern:
                    "shadingPattern",
                  font: "font",
                  errorTilingPattern:
                    "errorTilingPattern",
                  errorExtGState:
                    "errorExtGState",
                  errorXObject: "errorXObject",
                  errorFontLoadType3:
                    "errorFontLoadType3",
                  errorFontState:
                    "errorFontState",
                  errorFontMissing:
                    "errorFontMissing",
                  errorFontTranslate:
                    "errorFontTranslate",
                  errorColorSpace:
                    "errorColorSpace",
                  errorOperatorList:
                    "errorOperatorList",
                  errorFontToUnicode:
                    "errorFontToUnicode",
                  errorFontLoadNative:
                    "errorFontLoadNative",
                  errorFontGetPath:
                    "errorFontGetPath",
                  errorMarkedContent:
                    "errorMarkedContent",
                };
                exports.UNSUPPORTED_FEATURES =
                  UNSUPPORTED_FEATURES;
                var PasswordResponses = {
                  NEED_PASSWORD: 1,
                  INCORRECT_PASSWORD: 2,
                };
                exports.PasswordResponses =
                  PasswordResponses;
                var verbosity =
                  VerbosityLevel.WARNINGS;

                function setVerbosityLevel(
                  level
                ) {
                  if (Number.isInteger(level)) {
                    verbosity = level;
                  }
                }

                function getVerbosityLevel() {
                  return verbosity;
                }

                function info(msg) {
                  if (
                    verbosity >=
                    VerbosityLevel.INFOS
                  ) {
                    console.log(
                      "Info: ".concat(msg)
                    );
                  }
                }

                function warn(msg) {
                  if (
                    verbosity >=
                    VerbosityLevel.WARNINGS
                  ) {
                    console.log(
                      "Warning: ".concat(msg)
                    );
                  }
                }

                function unreachable(msg) {
                  throw new Error(msg);
                }

                function assert(cond, msg) {
                  if (!cond) {
                    unreachable(msg);
                  }
                }

                function isSameOrigin(
                  baseUrl,
                  otherUrl
                ) {
                  var base;

                  try {
                    base = new URL(baseUrl);

                    if (
                      !base.origin ||
                      base.origin === "null"
                    ) {
                      return false;
                    }
                  } catch (e) {
                    return false;
                  }

                  var other = new URL(
                    otherUrl,
                    base
                  );
                  return (
                    base.origin === other.origin
                  );
                }

                function _isValidProtocol(url) {
                  if (!url) {
                    return false;
                  }

                  switch (url.protocol) {
                    case "http:":
                    case "https:":
                    case "ftp:":
                    case "mailto:":
                    case "tel:":
                      return true;

                    default:
                      return false;
                  }
                }

                function createValidAbsoluteUrl(
                  url,
                  baseUrl
                ) {
                  if (!url) {
                    return null;
                  }

                  try {
                    var absoluteUrl = baseUrl
                      ? new URL(url, baseUrl)
                      : new URL(url);

                    if (
                      _isValidProtocol(
                        absoluteUrl
                      )
                    ) {
                      return absoluteUrl;
                    }
                  } catch (ex) {}

                  return null;
                }

                function shadow(
                  obj,
                  prop,
                  value
                ) {
                  Object.defineProperty(
                    obj,
                    prop,
                    {
                      value: value,
                      enumerable: true,
                      configurable: true,
                      writable: false,
                    }
                  );
                  return value;
                }

                var BaseException =
                  (function BaseExceptionClosure() {
                    function BaseException(
                      message
                    ) {
                      if (
                        this.constructor ===
                        BaseException
                      ) {
                        unreachable(
                          "Cannot initialize BaseException."
                        );
                      }

                      this.message = message;
                      this.name =
                        this.constructor.name;
                    }

                    BaseException.prototype =
                      new Error();
                    BaseException.constructor =
                      BaseException;
                    return BaseException;
                  })();

                exports.BaseException =
                  BaseException;

                var PasswordException =
                  /*#__PURE__*/ (function (
                    _BaseException
                  ) {
                    _inherits(
                      PasswordException,
                      _BaseException
                    );

                    var _super = _createSuper(
                      PasswordException
                    );

                    function PasswordException(
                      msg,
                      code
                    ) {
                      var _this;

                      _classCallCheck(
                        this,
                        PasswordException
                      );

                      _this = _super.call(
                        this,
                        msg
                      );
                      _this.code = code;
                      return _this;
                    }

                    return PasswordException;
                  })(BaseException);

                exports.PasswordException =
                  PasswordException;

                var UnknownErrorException =
                  /*#__PURE__*/ (function (
                    _BaseException2
                  ) {
                    _inherits(
                      UnknownErrorException,
                      _BaseException2
                    );

                    var _super2 = _createSuper(
                      UnknownErrorException
                    );

                    function UnknownErrorException(
                      msg,
                      details
                    ) {
                      var _this2;

                      _classCallCheck(
                        this,
                        UnknownErrorException
                      );

                      _this2 = _super2.call(
                        this,
                        msg
                      );
                      _this2.details = details;
                      return _this2;
                    }

                    return UnknownErrorException;
                  })(BaseException);

                exports.UnknownErrorException =
                  UnknownErrorException;

                var InvalidPDFException =
                  /*#__PURE__*/ (function (
                    _BaseException3
                  ) {
                    _inherits(
                      InvalidPDFException,
                      _BaseException3
                    );

                    var _super3 = _createSuper(
                      InvalidPDFException
                    );

                    function InvalidPDFException() {
                      _classCallCheck(
                        this,
                        InvalidPDFException
                      );

                      return _super3.apply(
                        this,
                        arguments
                      );
                    }

                    return InvalidPDFException;
                  })(BaseException);

                exports.InvalidPDFException =
                  InvalidPDFException;

                var MissingPDFException =
                  /*#__PURE__*/ (function (
                    _BaseException4
                  ) {
                    _inherits(
                      MissingPDFException,
                      _BaseException4
                    );

                    var _super4 = _createSuper(
                      MissingPDFException
                    );

                    function MissingPDFException() {
                      _classCallCheck(
                        this,
                        MissingPDFException
                      );

                      return _super4.apply(
                        this,
                        arguments
                      );
                    }

                    return MissingPDFException;
                  })(BaseException);

                exports.MissingPDFException =
                  MissingPDFException;

                var UnexpectedResponseException =
                  /*#__PURE__*/ (function (
                    _BaseException5
                  ) {
                    _inherits(
                      UnexpectedResponseException,
                      _BaseException5
                    );

                    var _super5 = _createSuper(
                      UnexpectedResponseException
                    );

                    function UnexpectedResponseException(
                      msg,
                      status
                    ) {
                      var _this3;

                      _classCallCheck(
                        this,
                        UnexpectedResponseException
                      );

                      _this3 = _super5.call(
                        this,
                        msg
                      );
                      _this3.status = status;
                      return _this3;
                    }

                    return UnexpectedResponseException;
                  })(BaseException);

                exports.UnexpectedResponseException =
                  UnexpectedResponseException;

                var FormatError =
                  /*#__PURE__*/ (function (
                    _BaseException6
                  ) {
                    _inherits(
                      FormatError,
                      _BaseException6
                    );

                    var _super6 =
                      _createSuper(FormatError);

                    function FormatError() {
                      _classCallCheck(
                        this,
                        FormatError
                      );

                      return _super6.apply(
                        this,
                        arguments
                      );
                    }

                    return FormatError;
                  })(BaseException);

                exports.FormatError = FormatError;

                var AbortException =
                  /*#__PURE__*/ (function (
                    _BaseException7
                  ) {
                    _inherits(
                      AbortException,
                      _BaseException7
                    );

                    var _super7 = _createSuper(
                      AbortException
                    );

                    function AbortException() {
                      _classCallCheck(
                        this,
                        AbortException
                      );

                      return _super7.apply(
                        this,
                        arguments
                      );
                    }

                    return AbortException;
                  })(BaseException);

                exports.AbortException =
                  AbortException;
                var NullCharactersRegExp =
                  /\x00/g;

                function removeNullCharacters(
                  str
                ) {
                  if (typeof str !== "string") {
                    warn(
                      "The argument for removeNullCharacters must be a string."
                    );
                    return str;
                  }

                  return str.replace(
                    NullCharactersRegExp,
                    ""
                  );
                }

                function bytesToString(bytes) {
                  assert(
                    bytes !== null &&
                      _typeof(bytes) ===
                        "object" &&
                      bytes.length !== undefined,
                    "Invalid argument for bytesToString"
                  );
                  var length = bytes.length;
                  var MAX_ARGUMENT_COUNT = 8192;

                  if (
                    length < MAX_ARGUMENT_COUNT
                  ) {
                    return String.fromCharCode.apply(
                      null,
                      bytes
                    );
                  }

                  var strBuf = [];

                  for (
                    var i = 0;
                    i < length;
                    i += MAX_ARGUMENT_COUNT
                  ) {
                    var chunkEnd = Math.min(
                      i + MAX_ARGUMENT_COUNT,
                      length
                    );
                    var chunk = bytes.subarray(
                      i,
                      chunkEnd
                    );
                    strBuf.push(
                      String.fromCharCode.apply(
                        null,
                        chunk
                      )
                    );
                  }

                  return strBuf.join("");
                }

                function stringToBytes(str) {
                  assert(
                    typeof str === "string",
                    "Invalid argument for stringToBytes"
                  );
                  var length = str.length;
                  var bytes = new Uint8Array(
                    length
                  );

                  for (
                    var i = 0;
                    i < length;
                    ++i
                  ) {
                    bytes[i] =
                      str.charCodeAt(i) & 0xff;
                  }

                  return bytes;
                }

                function arrayByteLength(arr) {
                  if (arr.length !== undefined) {
                    return arr.length;
                  }

                  assert(
                    arr.byteLength !== undefined,
                    "arrayByteLength - invalid argument."
                  );
                  return arr.byteLength;
                }

                function arraysToBytes(arr) {
                  var length = arr.length;

                  if (
                    length === 1 &&
                    arr[0] instanceof Uint8Array
                  ) {
                    return arr[0];
                  }

                  var resultLength = 0;

                  for (
                    var i = 0;
                    i < length;
                    i++
                  ) {
                    resultLength +=
                      arrayByteLength(arr[i]);
                  }

                  var pos = 0;
                  var data = new Uint8Array(
                    resultLength
                  );

                  for (
                    var _i = 0;
                    _i < length;
                    _i++
                  ) {
                    var item = arr[_i];

                    if (
                      !(
                        item instanceof Uint8Array
                      )
                    ) {
                      if (
                        typeof item === "string"
                      ) {
                        item =
                          stringToBytes(item);
                      } else {
                        item = new Uint8Array(
                          item
                        );
                      }
                    }

                    var itemLength =
                      item.byteLength;
                    data.set(item, pos);
                    pos += itemLength;
                  }

                  return data;
                }

                function string32(value) {
                  return String.fromCharCode(
                    (value >> 24) & 0xff,
                    (value >> 16) & 0xff,
                    (value >> 8) & 0xff,
                    value & 0xff
                  );
                }

                function objectSize(obj) {
                  return Object.keys(obj).length;
                }

                function objectFromEntries(
                  iterable
                ) {
                  return Object.assign(
                    Object.create(null),
                    Object.fromEntries(iterable)
                  );
                }

                function isLittleEndian() {
                  var buffer8 = new Uint8Array(4);
                  buffer8[0] = 1;
                  var view32 = new Uint32Array(
                    buffer8.buffer,
                    0,
                    1
                  );
                  return view32[0] === 1;
                }

                var IsLittleEndianCached = {
                  get value() {
                    return shadow(
                      this,
                      "value",
                      isLittleEndian()
                    );
                  },
                };
                exports.IsLittleEndianCached =
                  IsLittleEndianCached;

                function isEvalSupported() {
                  try {
                    new Function("");
                    return true;
                  } catch (e) {
                    return false;
                  }
                }

                var IsEvalSupportedCached = {
                  get value() {
                    return shadow(
                      this,
                      "value",
                      isEvalSupported()
                    );
                  },
                };
                exports.IsEvalSupportedCached =
                  IsEvalSupportedCached;

                var hexNumbers =
                  _toConsumableArray(
                    Array(256).keys()
                  ).map(function (n) {
                    return n
                      .toString(16)
                      .padStart(2, "0");
                  });

                var Util =
                  /*#__PURE__*/ (function () {
                    function Util() {
                      _classCallCheck(this, Util);
                    }

                    _createClass(Util, null, [
                      {
                        key: "makeHexColor",
                        value:
                          function makeHexColor(
                            r,
                            g,
                            b
                          ) {
                            return "#"
                              .concat(
                                hexNumbers[r]
                              )
                              .concat(
                                hexNumbers[g]
                              )
                              .concat(
                                hexNumbers[b]
                              );
                          },
                      },
                      {
                        key: "transform",
                        value: function transform(
                          m1,
                          m2
                        ) {
                          return [
                            m1[0] * m2[0] +
                              m1[2] * m2[1],
                            m1[1] * m2[0] +
                              m1[3] * m2[1],
                            m1[0] * m2[2] +
                              m1[2] * m2[3],
                            m1[1] * m2[2] +
                              m1[3] * m2[3],
                            m1[0] * m2[4] +
                              m1[2] * m2[5] +
                              m1[4],
                            m1[1] * m2[4] +
                              m1[3] * m2[5] +
                              m1[5],
                          ];
                        },
                      },
                      {
                        key: "applyTransform",
                        value:
                          function applyTransform(
                            p,
                            m
                          ) {
                            var xt =
                              p[0] * m[0] +
                              p[1] * m[2] +
                              m[4];
                            var yt =
                              p[0] * m[1] +
                              p[1] * m[3] +
                              m[5];
                            return [xt, yt];
                          },
                      },
                      {
                        key: "applyInverseTransform",
                        value:
                          function applyInverseTransform(
                            p,
                            m
                          ) {
                            var d =
                              m[0] * m[3] -
                              m[1] * m[2];
                            var xt =
                              (p[0] * m[3] -
                                p[1] * m[2] +
                                m[2] * m[5] -
                                m[4] * m[3]) /
                              d;
                            var yt =
                              (-p[0] * m[1] +
                                p[1] * m[0] +
                                m[4] * m[1] -
                                m[5] * m[0]) /
                              d;
                            return [xt, yt];
                          },
                      },
                      {
                        key: "getAxialAlignedBoundingBox",
                        value:
                          function getAxialAlignedBoundingBox(
                            r,
                            m
                          ) {
                            var p1 =
                              Util.applyTransform(
                                r,
                                m
                              );
                            var p2 =
                              Util.applyTransform(
                                r.slice(2, 4),
                                m
                              );
                            var p3 =
                              Util.applyTransform(
                                [r[0], r[3]],
                                m
                              );
                            var p4 =
                              Util.applyTransform(
                                [r[2], r[1]],
                                m
                              );
                            return [
                              Math.min(
                                p1[0],
                                p2[0],
                                p3[0],
                                p4[0]
                              ),
                              Math.min(
                                p1[1],
                                p2[1],
                                p3[1],
                                p4[1]
                              ),
                              Math.max(
                                p1[0],
                                p2[0],
                                p3[0],
                                p4[0]
                              ),
                              Math.max(
                                p1[1],
                                p2[1],
                                p3[1],
                                p4[1]
                              ),
                            ];
                          },
                      },
                      {
                        key: "inverseTransform",
                        value:
                          function inverseTransform(
                            m
                          ) {
                            var d =
                              m[0] * m[3] -
                              m[1] * m[2];
                            return [
                              m[3] / d,
                              -m[1] / d,
                              -m[2] / d,
                              m[0] / d,
                              (m[2] * m[5] -
                                m[4] * m[3]) /
                                d,
                              (m[4] * m[1] -
                                m[5] * m[0]) /
                                d,
                            ];
                          },
                      },
                      {
                        key: "apply3dTransform",
                        value:
                          function apply3dTransform(
                            m,
                            v
                          ) {
                            return [
                              m[0] * v[0] +
                                m[1] * v[1] +
                                m[2] * v[2],
                              m[3] * v[0] +
                                m[4] * v[1] +
                                m[5] * v[2],
                              m[6] * v[0] +
                                m[7] * v[1] +
                                m[8] * v[2],
                            ];
                          },
                      },
                      {
                        key: "singularValueDecompose2dScale",
                        value:
                          function singularValueDecompose2dScale(
                            m
                          ) {
                            var transpose = [
                              m[0],
                              m[2],
                              m[1],
                              m[3],
                            ];
                            var a =
                              m[0] *
                                transpose[0] +
                              m[1] * transpose[2];
                            var b =
                              m[0] *
                                transpose[1] +
                              m[1] * transpose[3];
                            var c =
                              m[2] *
                                transpose[0] +
                              m[3] * transpose[2];
                            var d =
                              m[2] *
                                transpose[1] +
                              m[3] * transpose[3];
                            var first =
                              (a + d) / 2;
                            var second =
                              Math.sqrt(
                                Math.pow(
                                  a + d,
                                  2
                                ) -
                                  4 *
                                    (a * d -
                                      c * b)
                              ) / 2;
                            var sx =
                              first + second || 1;
                            var sy =
                              first - second || 1;
                            return [
                              Math.sqrt(sx),
                              Math.sqrt(sy),
                            ];
                          },
                      },
                      {
                        key: "normalizeRect",
                        value:
                          function normalizeRect(
                            rect
                          ) {
                            var r = rect.slice(0);

                            if (
                              rect[0] > rect[2]
                            ) {
                              r[0] = rect[2];
                              r[2] = rect[0];
                            }

                            if (
                              rect[1] > rect[3]
                            ) {
                              r[1] = rect[3];
                              r[3] = rect[1];
                            }

                            return r;
                          },
                      },
                      {
                        key: "intersect",
                        value: function intersect(
                          rect1,
                          rect2
                        ) {
                          function compare(a, b) {
                            return a - b;
                          }

                          var orderedX = [
                            rect1[0],
                            rect1[2],
                            rect2[0],
                            rect2[2],
                          ].sort(compare);
                          var orderedY = [
                            rect1[1],
                            rect1[3],
                            rect2[1],
                            rect2[3],
                          ].sort(compare);
                          var result = [];
                          rect1 =
                            Util.normalizeRect(
                              rect1
                            );
                          rect2 =
                            Util.normalizeRect(
                              rect2
                            );

                          if (
                            (orderedX[0] ===
                              rect1[0] &&
                              orderedX[1] ===
                                rect2[0]) ||
                            (orderedX[0] ===
                              rect2[0] &&
                              orderedX[1] ===
                                rect1[0])
                          ) {
                            result[0] =
                              orderedX[1];
                            result[2] =
                              orderedX[2];
                          } else {
                            return null;
                          }

                          if (
                            (orderedY[0] ===
                              rect1[1] &&
                              orderedY[1] ===
                                rect2[1]) ||
                            (orderedY[0] ===
                              rect2[1] &&
                              orderedY[1] ===
                                rect1[1])
                          ) {
                            result[1] =
                              orderedY[1];
                            result[3] =
                              orderedY[2];
                          } else {
                            return null;
                          }

                          return result;
                        },
                      },
                    ]);

                    return Util;
                  })();

                exports.Util = Util;
                var PDFStringTranslateTable = [
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0x2d8, 0x2c7, 0x2c6,
                  0x2d9, 0x2dd, 0x2db, 0x2da,
                  0x2dc, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0x2022, 0x2020, 0x2021, 0x2026,
                  0x2014, 0x2013, 0x192, 0x2044,
                  0x2039, 0x203a, 0x2212, 0x2030,
                  0x201e, 0x201c, 0x201d, 0x2018,
                  0x2019, 0x201a, 0x2122, 0xfb01,
                  0xfb02, 0x141, 0x152, 0x160,
                  0x178, 0x17d, 0x131, 0x142,
                  0x153, 0x161, 0x17e, 0, 0x20ac,
                ];

                function stringToPDFString(str) {
                  var length = str.length,
                    strBuf = [];

                  if (
                    str[0] === "\xFE" &&
                    str[1] === "\xFF"
                  ) {
                    for (
                      var i = 2;
                      i < length;
                      i += 2
                    ) {
                      strBuf.push(
                        String.fromCharCode(
                          (str.charCodeAt(i) <<
                            8) |
                            str.charCodeAt(i + 1)
                        )
                      );
                    }
                  } else if (
                    str[0] === "\xFF" &&
                    str[1] === "\xFE"
                  ) {
                    for (
                      var _i2 = 2;
                      _i2 < length;
                      _i2 += 2
                    ) {
                      strBuf.push(
                        String.fromCharCode(
                          (str.charCodeAt(
                            _i2 + 1
                          ) <<
                            8) |
                            str.charCodeAt(_i2)
                        )
                      );
                    }
                  } else {
                    for (
                      var _i3 = 0;
                      _i3 < length;
                      ++_i3
                    ) {
                      var code =
                        PDFStringTranslateTable[
                          str.charCodeAt(_i3)
                        ];
                      strBuf.push(
                        code
                          ? String.fromCharCode(
                              code
                            )
                          : str.charAt(_i3)
                      );
                    }
                  }

                  return strBuf.join("");
                }

                function escapeString(str) {
                  return str.replace(
                    /([()\\\n\r])/g,
                    function (match) {
                      if (match === "\n") {
                        return "\\n";
                      } else if (match === "\r") {
                        return "\\r";
                      }

                      return "\\".concat(match);
                    }
                  );
                }

                function isAscii(str) {
                  return /^[\x00-\x7F]*$/.test(
                    str
                  );
                }

                function stringToUTF16BEString(
                  str
                ) {
                  var buf = ["\xFE\xFF"];

                  for (
                    var i = 0, ii = str.length;
                    i < ii;
                    i++
                  ) {
                    var _char = str.charCodeAt(i);

                    buf.push(
                      String.fromCharCode(
                        (_char >> 8) & 0xff
                      )
                    );
                    buf.push(
                      String.fromCharCode(
                        _char & 0xff
                      )
                    );
                  }

                  return buf.join("");
                }

                function stringToUTF8String(str) {
                  return decodeURIComponent(
                    escape(str)
                  );
                }

                function utf8StringToString(str) {
                  return unescape(
                    encodeURIComponent(str)
                  );
                }

                function isBool(v) {
                  return typeof v === "boolean";
                }

                function isNum(v) {
                  return typeof v === "number";
                }

                function isString(v) {
                  return typeof v === "string";
                }

                function isArrayBuffer(v) {
                  return (
                    _typeof(v) === "object" &&
                    v !== null &&
                    v.byteLength !== undefined
                  );
                }

                function isArrayEqual(
                  arr1,
                  arr2
                ) {
                  if (
                    arr1.length !== arr2.length
                  ) {
                    return false;
                  }

                  return arr1.every(function (
                    element,
                    index
                  ) {
                    return (
                      element === arr2[index]
                    );
                  });
                }

                function getModificationDate() {
                  var date =
                    arguments.length > 0 &&
                    arguments[0] !== undefined
                      ? arguments[0]
                      : new Date();
                  var buffer = [
                    date
                      .getUTCFullYear()
                      .toString(),
                    (date.getUTCMonth() + 1)
                      .toString()
                      .padStart(2, "0"),
                    date
                      .getUTCDate()
                      .toString()
                      .padStart(2, "0"),
                    date
                      .getUTCHours()
                      .toString()
                      .padStart(2, "0"),
                    date
                      .getUTCMinutes()
                      .toString()
                      .padStart(2, "0"),
                    date
                      .getUTCSeconds()
                      .toString()
                      .padStart(2, "0"),
                  ];
                  return buffer.join("");
                }

                function createPromiseCapability() {
                  var capability =
                    Object.create(null);
                  var isSettled = false;
                  Object.defineProperty(
                    capability,
                    "settled",
                    {
                      get: function get() {
                        return isSettled;
                      },
                    }
                  );
                  capability.promise =
                    new Promise(function (
                      resolve,
                      reject
                    ) {
                      capability.resolve =
                        function (data) {
                          isSettled = true;
                          resolve(data);
                        };

                      capability.reject =
                        function (reason) {
                          isSettled = true;
                          reject(reason);
                        };
                    });
                  return capability;
                }

                var createObjectURL =
                  (function createObjectURLClosure() {
                    var digits =
                      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                    return function createObjectURL(
                      data,
                      contentType
                    ) {
                      var forceDataSchema =
                        arguments.length > 2 &&
                        arguments[2] !== undefined
                          ? arguments[2]
                          : false;

                      if (
                        !forceDataSchema &&
                        URL.createObjectURL
                      ) {
                        var blob = new Blob(
                          [data],
                          {
                            type: contentType,
                          }
                        );
                        return URL.createObjectURL(
                          blob
                        );
                      }

                      var buffer = "data:".concat(
                        contentType,
                        ";base64,"
                      );

                      for (
                        var i = 0,
                          ii = data.length;
                        i < ii;
                        i += 3
                      ) {
                        var b1 = data[i] & 0xff;
                        var b2 =
                          data[i + 1] & 0xff;
                        var b3 =
                          data[i + 2] & 0xff;
                        var d1 = b1 >> 2,
                          d2 =
                            ((b1 & 3) << 4) |
                            (b2 >> 4);
                        var d3 =
                          i + 1 < ii
                            ? ((b2 & 0xf) << 2) |
                              (b3 >> 6)
                            : 64;
                        var d4 =
                          i + 2 < ii
                            ? b3 & 0x3f
                            : 64;
                        buffer +=
                          digits[d1] +
                          digits[d2] +
                          digits[d3] +
                          digits[d4];
                      }

                      return buffer;
                    };
                  })();

                exports.createObjectURL =
                  createObjectURL;
                var XMLEntities = {
                  0x3c: "&lt;",
                  0x3e: "&gt;",
                  0x26: "&amp;",
                  0x22: "&quot;",
                  0x27: "&apos;",
                };

                function encodeToXmlString(str) {
                  var buffer = [];
                  var start = 0;

                  for (
                    var i = 0, ii = str.length;
                    i < ii;
                    i++
                  ) {
                    var _char2 =
                      str.codePointAt(i);

                    if (
                      0x20 <= _char2 &&
                      _char2 <= 0x7e
                    ) {
                      var entity =
                        XMLEntities[_char2];

                      if (entity) {
                        if (start < i) {
                          buffer.push(
                            str.substring(
                              start,
                              i
                            )
                          );
                        }

                        buffer.push(entity);
                        start = i + 1;
                      }
                    } else {
                      if (start < i) {
                        buffer.push(
                          str.substring(start, i)
                        );
                      }

                      buffer.push(
                        "&#x".concat(
                          _char2
                            .toString(16)
                            .toUpperCase(),
                          ";"
                        )
                      );

                      if (
                        _char2 > 0xd7ff &&
                        (_char2 < 0xe000 ||
                          _char2 > 0xfffd)
                      ) {
                        i++;
                      }

                      start = i + 1;
                    }
                  }

                  if (buffer.length === 0) {
                    return str;
                  }

                  if (start < str.length) {
                    buffer.push(
                      str.substring(
                        start,
                        str.length
                      )
                    );
                  }

                  return buffer.join("");
                }

                /***/
              },
              /* 5 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var _is_node =
                  __w_pdfjs_require__(6);

                if (
                  typeof globalThis ===
                    "undefined" ||
                  !globalThis._pdfjsCompatibilityChecked
                ) {
                  if (
                    typeof globalThis ===
                      "undefined" ||
                    globalThis.Math !== Math
                  ) {
                    globalThis =
                      __w_pdfjs_require__(7);
                  }

                  globalThis._pdfjsCompatibilityChecked = true;

                  (function checkNodeBtoa() {
                    if (
                      globalThis.btoa ||
                      !_is_node.isNodeJS
                    ) {
                      return;
                    }

                    globalThis.btoa = function (
                      chars
                    ) {
                      return Buffer.from(
                        chars,
                        "binary"
                      ).toString("base64");
                    };
                  })();

                  (function checkNodeAtob() {
                    if (
                      globalThis.atob ||
                      !_is_node.isNodeJS
                    ) {
                      return;
                    }

                    globalThis.atob = function (
                      input
                    ) {
                      return Buffer.from(
                        input,
                        "base64"
                      ).toString("binary");
                    };
                  })();

                  (function checkObjectFromEntries() {
                    if (Object.fromEntries) {
                      return;
                    }

                    __w_pdfjs_require__(52);
                  })();

                  (function checkPromise() {
                    if (
                      globalThis.Promise
                        .allSettled
                    ) {
                      return;
                    }

                    globalThis.Promise =
                      __w_pdfjs_require__(82);
                  })();

                  (function checkURL() {
                    globalThis.URL =
                      __w_pdfjs_require__(111);
                  })();

                  (function checkReadableStream() {
                    var isReadableStreamSupported = false;

                    if (
                      typeof ReadableStream !==
                      "undefined"
                    ) {
                      try {
                        new ReadableStream({
                          start: function start(
                            controller
                          ) {
                            controller.close();
                          },
                        });
                        isReadableStreamSupported = true;
                      } catch (e) {}
                    }

                    if (
                      isReadableStreamSupported
                    ) {
                      return;
                    }

                    globalThis.ReadableStream =
                      __w_pdfjs_require__(
                        121
                      ).ReadableStream;
                  })();

                  (function checkStringPadStart() {
                    if (
                      String.prototype.padStart
                    ) {
                      return;
                    }

                    __w_pdfjs_require__(122);
                  })();

                  (function checkStringPadEnd() {
                    if (String.prototype.padEnd) {
                      return;
                    }

                    __w_pdfjs_require__(128);
                  })();

                  (function checkObjectValues() {
                    if (Object.values) {
                      return;
                    }

                    Object.values =
                      __w_pdfjs_require__(130);
                  })();

                  (function checkObjectEntries() {
                    if (Object.entries) {
                      return;
                    }

                    Object.entries =
                      __w_pdfjs_require__(133);
                  })();
                }

                /***/
              },
              /* 6 */
              /***/ function (
                __unused_webpack_module,
                exports
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.isNodeJS = void 0;

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                var isNodeJS =
                  (typeof process === "undefined"
                    ? "undefined"
                    : _typeof(process)) ===
                    "object" &&
                  process + "" ===
                    "[object process]" &&
                  !process.versions.nw &&
                  !(
                    process.versions.electron &&
                    process.type &&
                    process.type !== "browser"
                  );
                exports.isNodeJS = isNodeJS;

                /***/
              },
              /* 7 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                __w_pdfjs_require__(8);
                module.exports =
                  __w_pdfjs_require__(10);

                /***/
              },
              /* 8 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var $ = __w_pdfjs_require__(9);
                var global =
                  __w_pdfjs_require__(10);
                $(
                  { global: true },
                  { globalThis: global }
                );

                /***/
              },
              /* 9 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var getOwnPropertyDescriptor =
                  __w_pdfjs_require__(11).f;
                var createNonEnumerableProperty =
                  __w_pdfjs_require__(25);
                var redefine =
                  __w_pdfjs_require__(28);
                var setGlobal =
                  __w_pdfjs_require__(29);
                var copyConstructorProperties =
                  __w_pdfjs_require__(39);
                var isForced =
                  __w_pdfjs_require__(51);
                module.exports = function (
                  options,
                  source
                ) {
                  var TARGET = options.target;
                  var GLOBAL = options.global;
                  var STATIC = options.stat;
                  var FORCED,
                    target,
                    key,
                    targetProperty,
                    sourceProperty,
                    descriptor;
                  if (GLOBAL) {
                    target = global;
                  } else if (STATIC) {
                    target =
                      global[TARGET] ||
                      setGlobal(TARGET, {});
                  } else {
                    target = (
                      global[TARGET] || {}
                    ).prototype;
                  }
                  if (target)
                    for (key in source) {
                      sourceProperty =
                        source[key];
                      if (options.noTargetGet) {
                        descriptor =
                          getOwnPropertyDescriptor(
                            target,
                            key
                          );
                        targetProperty =
                          descriptor &&
                          descriptor.value;
                      } else
                        targetProperty =
                          target[key];
                      FORCED = isForced(
                        GLOBAL
                          ? key
                          : TARGET +
                              (STATIC
                                ? "."
                                : "#") +
                              key,
                        options.forced
                      );
                      if (
                        !FORCED &&
                        targetProperty !==
                          undefined
                      ) {
                        if (
                          typeof sourceProperty ===
                          typeof targetProperty
                        )
                          continue;
                        copyConstructorProperties(
                          sourceProperty,
                          targetProperty
                        );
                      }
                      if (
                        options.sham ||
                        (targetProperty &&
                          targetProperty.sham)
                      ) {
                        createNonEnumerableProperty(
                          sourceProperty,
                          "sham",
                          true
                        );
                      }
                      redefine(
                        target,
                        key,
                        sourceProperty,
                        options
                      );
                    }
                };

                /***/
              },
              /* 10 */
              /***/ function (module) {
                var check = function (it) {
                  return (
                    it && it.Math == Math && it
                  );
                };
                module.exports =
                  check(
                    typeof globalThis ==
                      "object" && globalThis
                  ) ||
                  check(
                    typeof window == "object" &&
                      window
                  ) ||
                  check(
                    typeof self == "object" &&
                      self
                  ) ||
                  check(
                    typeof __webpack_require__.g ==
                      "object" &&
                      __webpack_require__.g
                  ) ||
                  (function () {
                    return this;
                  })() ||
                  Function("return this")();

                /***/
              },
              /* 11 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                var DESCRIPTORS =
                  __w_pdfjs_require__(12);
                var propertyIsEnumerableModule =
                  __w_pdfjs_require__(14);
                var createPropertyDescriptor =
                  __w_pdfjs_require__(15);
                var toIndexedObject =
                  __w_pdfjs_require__(16);
                var toPrimitive =
                  __w_pdfjs_require__(20);
                var has = __w_pdfjs_require__(22);
                var IE8_DOM_DEFINE =
                  __w_pdfjs_require__(23);
                var nativeGetOwnPropertyDescriptor =
                  Object.getOwnPropertyDescriptor;
                exports.f = DESCRIPTORS
                  ? nativeGetOwnPropertyDescriptor
                  : function getOwnPropertyDescriptor(
                      O,
                      P
                    ) {
                      O = toIndexedObject(O);
                      P = toPrimitive(P, true);
                      if (IE8_DOM_DEFINE)
                        try {
                          return nativeGetOwnPropertyDescriptor(
                            O,
                            P
                          );
                        } catch (error) {}
                      if (has(O, P))
                        return createPropertyDescriptor(
                          !propertyIsEnumerableModule.f.call(
                            O,
                            P
                          ),
                          O[P]
                        );
                    };

                /***/
              },
              /* 12 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var fails =
                  __w_pdfjs_require__(13);
                module.exports = !fails(
                  function () {
                    return (
                      Object.defineProperty(
                        {},
                        1,
                        {
                          get: function () {
                            return 7;
                          },
                        }
                      )[1] != 7
                    );
                  }
                );

                /***/
              },
              /* 13 */
              /***/ function (module) {
                module.exports = function (exec) {
                  try {
                    return !!exec();
                  } catch (error) {
                    return true;
                  }
                };

                /***/
              },
              /* 14 */
              /***/ function (
                __unused_webpack_module,
                exports
              ) {
                "use strict";

                var nativePropertyIsEnumerable =
                  {}.propertyIsEnumerable;
                var getOwnPropertyDescriptor =
                  Object.getOwnPropertyDescriptor;
                var NASHORN_BUG =
                  getOwnPropertyDescriptor &&
                  !nativePropertyIsEnumerable.call(
                    { 1: 2 },
                    1
                  );
                exports.f = NASHORN_BUG
                  ? function propertyIsEnumerable(
                      V
                    ) {
                      var descriptor =
                        getOwnPropertyDescriptor(
                          this,
                          V
                        );
                      return (
                        !!descriptor &&
                        descriptor.enumerable
                      );
                    }
                  : nativePropertyIsEnumerable;

                /***/
              },
              /* 15 */
              /***/ function (module) {
                module.exports = function (
                  bitmap,
                  value
                ) {
                  return {
                    enumerable: !(bitmap & 1),
                    configurable: !(bitmap & 2),
                    writable: !(bitmap & 4),
                    value: value,
                  };
                };

                /***/
              },
              /* 16 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var IndexedObject =
                  __w_pdfjs_require__(17);
                var requireObjectCoercible =
                  __w_pdfjs_require__(19);
                module.exports = function (it) {
                  return IndexedObject(
                    requireObjectCoercible(it)
                  );
                };

                /***/
              },
              /* 17 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var fails =
                  __w_pdfjs_require__(13);
                var classof =
                  __w_pdfjs_require__(18);
                var split = "".split;
                module.exports = fails(
                  function () {
                    return !Object(
                      "z"
                    ).propertyIsEnumerable(0);
                  }
                )
                  ? function (it) {
                      return classof(it) ==
                        "String"
                        ? split.call(it, "")
                        : Object(it);
                    }
                  : Object;

                /***/
              },
              /* 18 */
              /***/ function (module) {
                var toString = {}.toString;
                module.exports = function (it) {
                  return toString
                    .call(it)
                    .slice(8, -1);
                };

                /***/
              },
              /* 19 */
              /***/ function (module) {
                module.exports = function (it) {
                  if (it == undefined)
                    throw TypeError(
                      "Can't call method on " + it
                    );
                  return it;
                };

                /***/
              },
              /* 20 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var isObject =
                  __w_pdfjs_require__(21);
                module.exports = function (
                  input,
                  PREFERRED_STRING
                ) {
                  if (!isObject(input))
                    return input;
                  var fn, val;
                  if (
                    PREFERRED_STRING &&
                    typeof (fn =
                      input.toString) ==
                      "function" &&
                    !isObject(
                      (val = fn.call(input))
                    )
                  )
                    return val;
                  if (
                    typeof (fn = input.valueOf) ==
                      "function" &&
                    !isObject(
                      (val = fn.call(input))
                    )
                  )
                    return val;
                  if (
                    !PREFERRED_STRING &&
                    typeof (fn =
                      input.toString) ==
                      "function" &&
                    !isObject(
                      (val = fn.call(input))
                    )
                  )
                    return val;
                  throw TypeError(
                    "Can't convert object to primitive value"
                  );
                };

                /***/
              },
              /* 21 */
              /***/ function (module) {
                module.exports = function (it) {
                  return typeof it === "object"
                    ? it !== null
                    : typeof it === "function";
                };

                /***/
              },
              /* 22 */
              /***/ function (module) {
                var hasOwnProperty = {}
                  .hasOwnProperty;
                module.exports = function (
                  it,
                  key
                ) {
                  return hasOwnProperty.call(
                    it,
                    key
                  );
                };

                /***/
              },
              /* 23 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var DESCRIPTORS =
                  __w_pdfjs_require__(12);
                var fails =
                  __w_pdfjs_require__(13);
                var createElement =
                  __w_pdfjs_require__(24);
                module.exports =
                  !DESCRIPTORS &&
                  !fails(function () {
                    return (
                      Object.defineProperty(
                        createElement("div"),
                        "a",
                        {
                          get: function () {
                            return 7;
                          },
                        }
                      ).a != 7
                    );
                  });

                /***/
              },
              /* 24 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var isObject =
                  __w_pdfjs_require__(21);
                var document = global.document;
                var EXISTS =
                  isObject(document) &&
                  isObject(
                    document.createElement
                  );
                module.exports = function (it) {
                  return EXISTS
                    ? document.createElement(it)
                    : {};
                };

                /***/
              },
              /* 25 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var DESCRIPTORS =
                  __w_pdfjs_require__(12);
                var definePropertyModule =
                  __w_pdfjs_require__(26);
                var createPropertyDescriptor =
                  __w_pdfjs_require__(15);
                module.exports = DESCRIPTORS
                  ? function (
                      object,
                      key,
                      value
                    ) {
                      return definePropertyModule.f(
                        object,
                        key,
                        createPropertyDescriptor(
                          1,
                          value
                        )
                      );
                    }
                  : function (
                      object,
                      key,
                      value
                    ) {
                      object[key] = value;
                      return object;
                    };

                /***/
              },
              /* 26 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                var DESCRIPTORS =
                  __w_pdfjs_require__(12);
                var IE8_DOM_DEFINE =
                  __w_pdfjs_require__(23);
                var anObject =
                  __w_pdfjs_require__(27);
                var toPrimitive =
                  __w_pdfjs_require__(20);
                var nativeDefineProperty =
                  Object.defineProperty;
                exports.f = DESCRIPTORS
                  ? nativeDefineProperty
                  : function defineProperty(
                      O,
                      P,
                      Attributes
                    ) {
                      anObject(O);
                      P = toPrimitive(P, true);
                      anObject(Attributes);
                      if (IE8_DOM_DEFINE)
                        try {
                          return nativeDefineProperty(
                            O,
                            P,
                            Attributes
                          );
                        } catch (error) {}
                      if (
                        "get" in Attributes ||
                        "set" in Attributes
                      )
                        throw TypeError(
                          "Accessors not supported"
                        );
                      if ("value" in Attributes)
                        O[P] = Attributes.value;
                      return O;
                    };

                /***/
              },
              /* 27 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var isObject =
                  __w_pdfjs_require__(21);
                module.exports = function (it) {
                  if (!isObject(it)) {
                    throw TypeError(
                      String(it) +
                        " is not an object"
                    );
                  }
                  return it;
                };

                /***/
              },
              /* 28 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var createNonEnumerableProperty =
                  __w_pdfjs_require__(25);
                var has = __w_pdfjs_require__(22);
                var setGlobal =
                  __w_pdfjs_require__(29);
                var inspectSource =
                  __w_pdfjs_require__(30);
                var InternalStateModule =
                  __w_pdfjs_require__(32);
                var getInternalState =
                  InternalStateModule.get;
                var enforceInternalState =
                  InternalStateModule.enforce;
                var TEMPLATE =
                  String(String).split("String");
                (module.exports = function (
                  O,
                  key,
                  value,
                  options
                ) {
                  var unsafe = options
                    ? !!options.unsafe
                    : false;
                  var simple = options
                    ? !!options.enumerable
                    : false;
                  var noTargetGet = options
                    ? !!options.noTargetGet
                    : false;
                  var state;
                  if (
                    typeof value == "function"
                  ) {
                    if (
                      typeof key == "string" &&
                      !has(value, "name")
                    ) {
                      createNonEnumerableProperty(
                        value,
                        "name",
                        key
                      );
                    }
                    state =
                      enforceInternalState(value);
                    if (!state.source) {
                      state.source =
                        TEMPLATE.join(
                          typeof key == "string"
                            ? key
                            : ""
                        );
                    }
                  }
                  if (O === global) {
                    if (simple) O[key] = value;
                    else setGlobal(key, value);
                    return;
                  } else if (!unsafe) {
                    delete O[key];
                  } else if (
                    !noTargetGet &&
                    O[key]
                  ) {
                    simple = true;
                  }
                  if (simple) O[key] = value;
                  else
                    createNonEnumerableProperty(
                      O,
                      key,
                      value
                    );
                })(
                  Function.prototype,
                  "toString",
                  function toString() {
                    return (
                      (typeof this ==
                        "function" &&
                        getInternalState(this)
                          .source) ||
                      inspectSource(this)
                    );
                  }
                );

                /***/
              },
              /* 29 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var createNonEnumerableProperty =
                  __w_pdfjs_require__(25);
                module.exports = function (
                  key,
                  value
                ) {
                  try {
                    createNonEnumerableProperty(
                      global,
                      key,
                      value
                    );
                  } catch (error) {
                    global[key] = value;
                  }
                  return value;
                };

                /***/
              },
              /* 30 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var store =
                  __w_pdfjs_require__(31);
                var functionToString =
                  Function.toString;
                if (
                  typeof store.inspectSource !=
                  "function"
                ) {
                  store.inspectSource = function (
                    it
                  ) {
                    return functionToString.call(
                      it
                    );
                  };
                }
                module.exports =
                  store.inspectSource;

                /***/
              },
              /* 31 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var setGlobal =
                  __w_pdfjs_require__(29);
                var SHARED = "__core-js_shared__";
                var store =
                  global[SHARED] ||
                  setGlobal(SHARED, {});
                module.exports = store;

                /***/
              },
              /* 32 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var NATIVE_WEAK_MAP =
                  __w_pdfjs_require__(33);
                var global =
                  __w_pdfjs_require__(10);
                var isObject =
                  __w_pdfjs_require__(21);
                var createNonEnumerableProperty =
                  __w_pdfjs_require__(25);
                var objectHas =
                  __w_pdfjs_require__(22);
                var shared =
                  __w_pdfjs_require__(31);
                var sharedKey =
                  __w_pdfjs_require__(34);
                var hiddenKeys =
                  __w_pdfjs_require__(38);
                var WeakMap = global.WeakMap;
                var set, get, has;
                var enforce = function (it) {
                  return has(it)
                    ? get(it)
                    : set(it, {});
                };
                var getterFor = function (TYPE) {
                  return function (it) {
                    var state;
                    if (
                      !isObject(it) ||
                      (state = get(it)).type !==
                        TYPE
                    ) {
                      throw TypeError(
                        "Incompatible receiver, " +
                          TYPE +
                          " required"
                      );
                    }
                    return state;
                  };
                };
                if (NATIVE_WEAK_MAP) {
                  var store =
                    shared.state ||
                    (shared.state =
                      new WeakMap());
                  var wmget = store.get;
                  var wmhas = store.has;
                  var wmset = store.set;
                  set = function (it, metadata) {
                    metadata.facade = it;
                    wmset.call(
                      store,
                      it,
                      metadata
                    );
                    return metadata;
                  };
                  get = function (it) {
                    return (
                      wmget.call(store, it) || {}
                    );
                  };
                  has = function (it) {
                    return wmhas.call(store, it);
                  };
                } else {
                  var STATE = sharedKey("state");
                  hiddenKeys[STATE] = true;
                  set = function (it, metadata) {
                    metadata.facade = it;
                    createNonEnumerableProperty(
                      it,
                      STATE,
                      metadata
                    );
                    return metadata;
                  };
                  get = function (it) {
                    return objectHas(it, STATE)
                      ? it[STATE]
                      : {};
                  };
                  has = function (it) {
                    return objectHas(it, STATE);
                  };
                }
                module.exports = {
                  set: set,
                  get: get,
                  has: has,
                  enforce: enforce,
                  getterFor: getterFor,
                };

                /***/
              },
              /* 33 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var inspectSource =
                  __w_pdfjs_require__(30);
                var WeakMap = global.WeakMap;
                module.exports =
                  typeof WeakMap === "function" &&
                  /native code/.test(
                    inspectSource(WeakMap)
                  );

                /***/
              },
              /* 34 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var shared =
                  __w_pdfjs_require__(35);
                var uid = __w_pdfjs_require__(37);
                var keys = shared("keys");
                module.exports = function (key) {
                  return (
                    keys[key] ||
                    (keys[key] = uid(key))
                  );
                };

                /***/
              },
              /* 35 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var IS_PURE =
                  __w_pdfjs_require__(36);
                var store =
                  __w_pdfjs_require__(31);
                (module.exports = function (
                  key,
                  value
                ) {
                  return (
                    store[key] ||
                    (store[key] =
                      value !== undefined
                        ? value
                        : {})
                  );
                })("versions", []).push({
                  version: "3.8.3",
                  mode: IS_PURE
                    ? "pure"
                    : "global",
                  copyright:
                    "© 2021 Denis Pushkarev (zloirock.ru)",
                });

                /***/
              },
              /* 36 */
              /***/ function (module) {
                module.exports = false;

                /***/
              },
              /* 37 */
              /***/ function (module) {
                var id = 0;
                var postfix = Math.random();
                module.exports = function (key) {
                  return (
                    "Symbol(" +
                    String(
                      key === undefined ? "" : key
                    ) +
                    ")_" +
                    (++id + postfix).toString(36)
                  );
                };

                /***/
              },
              /* 38 */
              /***/ function (module) {
                module.exports = {};

                /***/
              },
              /* 39 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var has = __w_pdfjs_require__(22);
                var ownKeys =
                  __w_pdfjs_require__(40);
                var getOwnPropertyDescriptorModule =
                  __w_pdfjs_require__(11);
                var definePropertyModule =
                  __w_pdfjs_require__(26);
                module.exports = function (
                  target,
                  source
                ) {
                  var keys = ownKeys(source);
                  var defineProperty =
                    definePropertyModule.f;
                  var getOwnPropertyDescriptor =
                    getOwnPropertyDescriptorModule.f;
                  for (
                    var i = 0;
                    i < keys.length;
                    i++
                  ) {
                    var key = keys[i];
                    if (!has(target, key))
                      defineProperty(
                        target,
                        key,
                        getOwnPropertyDescriptor(
                          source,
                          key
                        )
                      );
                  }
                };

                /***/
              },
              /* 40 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var getBuiltIn =
                  __w_pdfjs_require__(41);
                var getOwnPropertyNamesModule =
                  __w_pdfjs_require__(43);
                var getOwnPropertySymbolsModule =
                  __w_pdfjs_require__(50);
                var anObject =
                  __w_pdfjs_require__(27);
                module.exports =
                  getBuiltIn(
                    "Reflect",
                    "ownKeys"
                  ) ||
                  function ownKeys(it) {
                    var keys =
                      getOwnPropertyNamesModule.f(
                        anObject(it)
                      );
                    var getOwnPropertySymbols =
                      getOwnPropertySymbolsModule.f;
                    return getOwnPropertySymbols
                      ? keys.concat(
                          getOwnPropertySymbols(
                            it
                          )
                        )
                      : keys;
                  };

                /***/
              },
              /* 41 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var path =
                  __w_pdfjs_require__(42);
                var global =
                  __w_pdfjs_require__(10);
                var aFunction = function (
                  variable
                ) {
                  return typeof variable ==
                    "function"
                    ? variable
                    : undefined;
                };
                module.exports = function (
                  namespace,
                  method
                ) {
                  return arguments.length < 2
                    ? aFunction(
                        path[namespace]
                      ) ||
                        aFunction(
                          global[namespace]
                        )
                    : (path[namespace] &&
                        path[namespace][
                          method
                        ]) ||
                        (global[namespace] &&
                          global[namespace][
                            method
                          ]);
                };

                /***/
              },
              /* 42 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                module.exports = global;

                /***/
              },
              /* 43 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                var internalObjectKeys =
                  __w_pdfjs_require__(44);
                var enumBugKeys =
                  __w_pdfjs_require__(49);
                var hiddenKeys =
                  enumBugKeys.concat(
                    "length",
                    "prototype"
                  );
                exports.f =
                  Object.getOwnPropertyNames ||
                  function getOwnPropertyNames(
                    O
                  ) {
                    return internalObjectKeys(
                      O,
                      hiddenKeys
                    );
                  };

                /***/
              },
              /* 44 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var has = __w_pdfjs_require__(22);
                var toIndexedObject =
                  __w_pdfjs_require__(16);
                var indexOf =
                  __w_pdfjs_require__(45).indexOf;
                var hiddenKeys =
                  __w_pdfjs_require__(38);
                module.exports = function (
                  object,
                  names
                ) {
                  var O = toIndexedObject(object);
                  var i = 0;
                  var result = [];
                  var key;
                  for (key in O)
                    !has(hiddenKeys, key) &&
                      has(O, key) &&
                      result.push(key);
                  while (names.length > i)
                    if (
                      has(O, (key = names[i++]))
                    ) {
                      ~indexOf(result, key) ||
                        result.push(key);
                    }
                  return result;
                };

                /***/
              },
              /* 45 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var toIndexedObject =
                  __w_pdfjs_require__(16);
                var toLength =
                  __w_pdfjs_require__(46);
                var toAbsoluteIndex =
                  __w_pdfjs_require__(48);
                var createMethod = function (
                  IS_INCLUDES
                ) {
                  return function (
                    $this,
                    el,
                    fromIndex
                  ) {
                    var O =
                      toIndexedObject($this);
                    var length = toLength(
                      O.length
                    );
                    var index = toAbsoluteIndex(
                      fromIndex,
                      length
                    );
                    var value;
                    if (IS_INCLUDES && el != el)
                      while (length > index) {
                        value = O[index++];
                        if (value != value)
                          return true;
                      }
                    else
                      for (
                        ;
                        length > index;
                        index++
                      ) {
                        if (
                          (IS_INCLUDES ||
                            index in O) &&
                          O[index] === el
                        )
                          return (
                            IS_INCLUDES ||
                            index ||
                            0
                          );
                      }
                    return !IS_INCLUDES && -1;
                  };
                };
                module.exports = {
                  includes: createMethod(true),
                  indexOf: createMethod(false),
                };

                /***/
              },
              /* 46 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var toInteger =
                  __w_pdfjs_require__(47);
                var min = Math.min;
                module.exports = function (
                  argument
                ) {
                  return argument > 0
                    ? min(
                        toInteger(argument),
                        0x1fffffffffffff
                      )
                    : 0;
                };

                /***/
              },
              /* 47 */
              /***/ function (module) {
                var ceil = Math.ceil;
                var floor = Math.floor;
                module.exports = function (
                  argument
                ) {
                  return isNaN(
                    (argument = +argument)
                  )
                    ? 0
                    : (argument > 0
                        ? floor
                        : ceil)(argument);
                };

                /***/
              },
              /* 48 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var toInteger =
                  __w_pdfjs_require__(47);
                var max = Math.max;
                var min = Math.min;
                module.exports = function (
                  index,
                  length
                ) {
                  var integer = toInteger(index);
                  return integer < 0
                    ? max(integer + length, 0)
                    : min(integer, length);
                };

                /***/
              },
              /* 49 */
              /***/ function (module) {
                module.exports = [
                  "constructor",
                  "hasOwnProperty",
                  "isPrototypeOf",
                  "propertyIsEnumerable",
                  "toLocaleString",
                  "toString",
                  "valueOf",
                ];

                /***/
              },
              /* 50 */
              /***/ function (
                __unused_webpack_module,
                exports
              ) {
                exports.f =
                  Object.getOwnPropertySymbols;

                /***/
              },
              /* 51 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var fails =
                  __w_pdfjs_require__(13);
                var replacement =
                  /#|\.prototype\./;
                var isForced = function (
                  feature,
                  detection
                ) {
                  var value =
                    data[normalize(feature)];
                  return value == POLYFILL
                    ? true
                    : value == NATIVE
                    ? false
                    : typeof detection ==
                      "function"
                    ? fails(detection)
                    : !!detection;
                };
                var normalize =
                  (isForced.normalize = function (
                    string
                  ) {
                    return String(string)
                      .replace(replacement, ".")
                      .toLowerCase();
                  });
                var data = (isForced.data = {});
                var NATIVE = (isForced.NATIVE =
                  "N");
                var POLYFILL =
                  (isForced.POLYFILL = "P");
                module.exports = isForced;

                /***/
              },
              /* 52 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                __w_pdfjs_require__(53);
                __w_pdfjs_require__(72);
                var path =
                  __w_pdfjs_require__(42);
                module.exports =
                  path.Object.fromEntries;

                /***/
              },
              /* 53 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var toIndexedObject =
                  __w_pdfjs_require__(16);
                var addToUnscopables =
                  __w_pdfjs_require__(54);
                var Iterators =
                  __w_pdfjs_require__(62);
                var InternalStateModule =
                  __w_pdfjs_require__(32);
                var defineIterator =
                  __w_pdfjs_require__(63);
                var ARRAY_ITERATOR =
                  "Array Iterator";
                var setInternalState =
                  InternalStateModule.set;
                var getInternalState =
                  InternalStateModule.getterFor(
                    ARRAY_ITERATOR
                  );
                module.exports = defineIterator(
                  Array,
                  "Array",
                  function (iterated, kind) {
                    setInternalState(this, {
                      type: ARRAY_ITERATOR,
                      target:
                        toIndexedObject(iterated),
                      index: 0,
                      kind: kind,
                    });
                  },
                  function () {
                    var state =
                      getInternalState(this);
                    var target = state.target;
                    var kind = state.kind;
                    var index = state.index++;
                    if (
                      !target ||
                      index >= target.length
                    ) {
                      state.target = undefined;
                      return {
                        value: undefined,
                        done: true,
                      };
                    }
                    if (kind == "keys")
                      return {
                        value: index,
                        done: false,
                      };
                    if (kind == "values")
                      return {
                        value: target[index],
                        done: false,
                      };
                    return {
                      value: [
                        index,
                        target[index],
                      ],
                      done: false,
                    };
                  },
                  "values"
                );
                Iterators.Arguments =
                  Iterators.Array;
                addToUnscopables("keys");
                addToUnscopables("values");
                addToUnscopables("entries");

                /***/
              },
              /* 54 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var create =
                  __w_pdfjs_require__(58);
                var definePropertyModule =
                  __w_pdfjs_require__(26);
                var UNSCOPABLES = wellKnownSymbol(
                  "unscopables"
                );
                var ArrayPrototype =
                  Array.prototype;
                if (
                  ArrayPrototype[UNSCOPABLES] ==
                  undefined
                ) {
                  definePropertyModule.f(
                    ArrayPrototype,
                    UNSCOPABLES,
                    {
                      configurable: true,
                      value: create(null),
                    }
                  );
                }
                module.exports = function (key) {
                  ArrayPrototype[UNSCOPABLES][
                    key
                  ] = true;
                };

                /***/
              },
              /* 55 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var shared =
                  __w_pdfjs_require__(35);
                var has = __w_pdfjs_require__(22);
                var uid = __w_pdfjs_require__(37);
                var NATIVE_SYMBOL =
                  __w_pdfjs_require__(56);
                var USE_SYMBOL_AS_UID =
                  __w_pdfjs_require__(57);
                var WellKnownSymbolsStore =
                  shared("wks");
                var Symbol = global.Symbol;
                var createWellKnownSymbol =
                  USE_SYMBOL_AS_UID
                    ? Symbol
                    : (Symbol &&
                        Symbol.withoutSetter) ||
                      uid;
                module.exports = function (name) {
                  if (
                    !has(
                      WellKnownSymbolsStore,
                      name
                    )
                  ) {
                    if (
                      NATIVE_SYMBOL &&
                      has(Symbol, name)
                    )
                      WellKnownSymbolsStore[
                        name
                      ] = Symbol[name];
                    else
                      WellKnownSymbolsStore[
                        name
                      ] = createWellKnownSymbol(
                        "Symbol." + name
                      );
                  }
                  return WellKnownSymbolsStore[
                    name
                  ];
                };

                /***/
              },
              /* 56 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var fails =
                  __w_pdfjs_require__(13);
                module.exports =
                  !!Object.getOwnPropertySymbols &&
                  !fails(function () {
                    return !String(Symbol());
                  });

                /***/
              },
              /* 57 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var NATIVE_SYMBOL =
                  __w_pdfjs_require__(56);
                module.exports =
                  NATIVE_SYMBOL &&
                  !Symbol.sham &&
                  typeof Symbol.iterator ==
                    "symbol";

                /***/
              },
              /* 58 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var anObject =
                  __w_pdfjs_require__(27);
                var defineProperties =
                  __w_pdfjs_require__(59);
                var enumBugKeys =
                  __w_pdfjs_require__(49);
                var hiddenKeys =
                  __w_pdfjs_require__(38);
                var html =
                  __w_pdfjs_require__(61);
                var documentCreateElement =
                  __w_pdfjs_require__(24);
                var sharedKey =
                  __w_pdfjs_require__(34);
                var GT = ">";
                var LT = "<";
                var PROTOTYPE = "prototype";
                var SCRIPT = "script";
                var IE_PROTO =
                  sharedKey("IE_PROTO");
                var EmptyConstructor =
                  function () {};
                var scriptTag = function (
                  content
                ) {
                  return (
                    LT +
                    SCRIPT +
                    GT +
                    content +
                    LT +
                    "/" +
                    SCRIPT +
                    GT
                  );
                };
                var NullProtoObjectViaActiveX =
                  function (activeXDocument) {
                    activeXDocument.write(
                      scriptTag("")
                    );
                    activeXDocument.close();
                    var temp =
                      activeXDocument.parentWindow
                        .Object;
                    activeXDocument = null;
                    return temp;
                  };
                var NullProtoObjectViaIFrame =
                  function () {
                    var iframe =
                      documentCreateElement(
                        "iframe"
                      );
                    var JS =
                      "java" + SCRIPT + ":";
                    var iframeDocument;
                    iframe.style.display = "none";
                    html.appendChild(iframe);
                    iframe.src = String(JS);
                    iframeDocument =
                      iframe.contentWindow
                        .document;
                    iframeDocument.open();
                    iframeDocument.write(
                      scriptTag(
                        "document.F=Object"
                      )
                    );
                    iframeDocument.close();
                    return iframeDocument.F;
                  };
                var activeXDocument;
                var NullProtoObject =
                  function () {
                    try {
                      activeXDocument =
                        document.domain &&
                        new ActiveXObject(
                          "htmlfile"
                        );
                    } catch (error) {}
                    NullProtoObject =
                      activeXDocument
                        ? NullProtoObjectViaActiveX(
                            activeXDocument
                          )
                        : NullProtoObjectViaIFrame();
                    var length =
                      enumBugKeys.length;
                    while (length--)
                      delete NullProtoObject[
                        PROTOTYPE
                      ][enumBugKeys[length]];
                    return NullProtoObject();
                  };
                hiddenKeys[IE_PROTO] = true;
                module.exports =
                  Object.create ||
                  function create(O, Properties) {
                    var result;
                    if (O !== null) {
                      EmptyConstructor[
                        PROTOTYPE
                      ] = anObject(O);
                      result =
                        new EmptyConstructor();
                      EmptyConstructor[
                        PROTOTYPE
                      ] = null;
                      result[IE_PROTO] = O;
                    } else
                      result = NullProtoObject();
                    return Properties ===
                      undefined
                      ? result
                      : defineProperties(
                          result,
                          Properties
                        );
                  };

                /***/
              },
              /* 59 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var DESCRIPTORS =
                  __w_pdfjs_require__(12);
                var definePropertyModule =
                  __w_pdfjs_require__(26);
                var anObject =
                  __w_pdfjs_require__(27);
                var objectKeys =
                  __w_pdfjs_require__(60);
                module.exports = DESCRIPTORS
                  ? Object.defineProperties
                  : function defineProperties(
                      O,
                      Properties
                    ) {
                      anObject(O);
                      var keys =
                        objectKeys(Properties);
                      var length = keys.length;
                      var index = 0;
                      var key;
                      while (length > index)
                        definePropertyModule.f(
                          O,
                          (key = keys[index++]),
                          Properties[key]
                        );
                      return O;
                    };

                /***/
              },
              /* 60 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var internalObjectKeys =
                  __w_pdfjs_require__(44);
                var enumBugKeys =
                  __w_pdfjs_require__(49);
                module.exports =
                  Object.keys ||
                  function keys(O) {
                    return internalObjectKeys(
                      O,
                      enumBugKeys
                    );
                  };

                /***/
              },
              /* 61 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var getBuiltIn =
                  __w_pdfjs_require__(41);
                module.exports = getBuiltIn(
                  "document",
                  "documentElement"
                );

                /***/
              },
              /* 62 */
              /***/ function (module) {
                module.exports = {};

                /***/
              },
              /* 63 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var $ = __w_pdfjs_require__(9);
                var createIteratorConstructor =
                  __w_pdfjs_require__(64);
                var getPrototypeOf =
                  __w_pdfjs_require__(66);
                var setPrototypeOf =
                  __w_pdfjs_require__(70);
                var setToStringTag =
                  __w_pdfjs_require__(69);
                var createNonEnumerableProperty =
                  __w_pdfjs_require__(25);
                var redefine =
                  __w_pdfjs_require__(28);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var IS_PURE =
                  __w_pdfjs_require__(36);
                var Iterators =
                  __w_pdfjs_require__(62);
                var IteratorsCore =
                  __w_pdfjs_require__(65);
                var IteratorPrototype =
                  IteratorsCore.IteratorPrototype;
                var BUGGY_SAFARI_ITERATORS =
                  IteratorsCore.BUGGY_SAFARI_ITERATORS;
                var ITERATOR =
                  wellKnownSymbol("iterator");
                var KEYS = "keys";
                var VALUES = "values";
                var ENTRIES = "entries";
                var returnThis = function () {
                  return this;
                };
                module.exports = function (
                  Iterable,
                  NAME,
                  IteratorConstructor,
                  next,
                  DEFAULT,
                  IS_SET,
                  FORCED
                ) {
                  createIteratorConstructor(
                    IteratorConstructor,
                    NAME,
                    next
                  );
                  var getIterationMethod =
                    function (KIND) {
                      if (
                        KIND === DEFAULT &&
                        defaultIterator
                      )
                        return defaultIterator;
                      if (
                        !BUGGY_SAFARI_ITERATORS &&
                        KIND in IterablePrototype
                      )
                        return IterablePrototype[
                          KIND
                        ];
                      switch (KIND) {
                        case KEYS:
                          return function keys() {
                            return new IteratorConstructor(
                              this,
                              KIND
                            );
                          };
                        case VALUES:
                          return function values() {
                            return new IteratorConstructor(
                              this,
                              KIND
                            );
                          };
                        case ENTRIES:
                          return function entries() {
                            return new IteratorConstructor(
                              this,
                              KIND
                            );
                          };
                      }
                      return function () {
                        return new IteratorConstructor(
                          this
                        );
                      };
                    };
                  var TO_STRING_TAG =
                    NAME + " Iterator";
                  var INCORRECT_VALUES_NAME = false;
                  var IterablePrototype =
                    Iterable.prototype;
                  var nativeIterator =
                    IterablePrototype[ITERATOR] ||
                    IterablePrototype[
                      "@@iterator"
                    ] ||
                    (DEFAULT &&
                      IterablePrototype[DEFAULT]);
                  var defaultIterator =
                    (!BUGGY_SAFARI_ITERATORS &&
                      nativeIterator) ||
                    getIterationMethod(DEFAULT);
                  var anyNativeIterator =
                    NAME == "Array"
                      ? IterablePrototype.entries ||
                        nativeIterator
                      : nativeIterator;
                  var CurrentIteratorPrototype,
                    methods,
                    KEY;
                  if (anyNativeIterator) {
                    CurrentIteratorPrototype =
                      getPrototypeOf(
                        anyNativeIterator.call(
                          new Iterable()
                        )
                      );
                    if (
                      IteratorPrototype !==
                        Object.prototype &&
                      CurrentIteratorPrototype.next
                    ) {
                      if (
                        !IS_PURE &&
                        getPrototypeOf(
                          CurrentIteratorPrototype
                        ) !== IteratorPrototype
                      ) {
                        if (setPrototypeOf) {
                          setPrototypeOf(
                            CurrentIteratorPrototype,
                            IteratorPrototype
                          );
                        } else if (
                          typeof CurrentIteratorPrototype[
                            ITERATOR
                          ] != "function"
                        ) {
                          createNonEnumerableProperty(
                            CurrentIteratorPrototype,
                            ITERATOR,
                            returnThis
                          );
                        }
                      }
                      setToStringTag(
                        CurrentIteratorPrototype,
                        TO_STRING_TAG,
                        true,
                        true
                      );
                      if (IS_PURE)
                        Iterators[TO_STRING_TAG] =
                          returnThis;
                    }
                  }
                  if (
                    DEFAULT == VALUES &&
                    nativeIterator &&
                    nativeIterator.name !== VALUES
                  ) {
                    INCORRECT_VALUES_NAME = true;
                    defaultIterator =
                      function values() {
                        return nativeIterator.call(
                          this
                        );
                      };
                  }
                  if (
                    (!IS_PURE || FORCED) &&
                    IterablePrototype[
                      ITERATOR
                    ] !== defaultIterator
                  ) {
                    createNonEnumerableProperty(
                      IterablePrototype,
                      ITERATOR,
                      defaultIterator
                    );
                  }
                  Iterators[NAME] =
                    defaultIterator;
                  if (DEFAULT) {
                    methods = {
                      values:
                        getIterationMethod(
                          VALUES
                        ),
                      keys: IS_SET
                        ? defaultIterator
                        : getIterationMethod(
                            KEYS
                          ),
                      entries:
                        getIterationMethod(
                          ENTRIES
                        ),
                    };
                    if (FORCED)
                      for (KEY in methods) {
                        if (
                          BUGGY_SAFARI_ITERATORS ||
                          INCORRECT_VALUES_NAME ||
                          !(
                            KEY in
                            IterablePrototype
                          )
                        ) {
                          redefine(
                            IterablePrototype,
                            KEY,
                            methods[KEY]
                          );
                        }
                      }
                    else
                      $(
                        {
                          target: NAME,
                          proto: true,
                          forced:
                            BUGGY_SAFARI_ITERATORS ||
                            INCORRECT_VALUES_NAME,
                        },
                        methods
                      );
                  }
                  return methods;
                };

                /***/
              },
              /* 64 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var IteratorPrototype =
                  __w_pdfjs_require__(
                    65
                  ).IteratorPrototype;
                var create =
                  __w_pdfjs_require__(58);
                var createPropertyDescriptor =
                  __w_pdfjs_require__(15);
                var setToStringTag =
                  __w_pdfjs_require__(69);
                var Iterators =
                  __w_pdfjs_require__(62);
                var returnThis = function () {
                  return this;
                };
                module.exports = function (
                  IteratorConstructor,
                  NAME,
                  next
                ) {
                  var TO_STRING_TAG =
                    NAME + " Iterator";
                  IteratorConstructor.prototype =
                    create(IteratorPrototype, {
                      next: createPropertyDescriptor(
                        1,
                        next
                      ),
                    });
                  setToStringTag(
                    IteratorConstructor,
                    TO_STRING_TAG,
                    false,
                    true
                  );
                  Iterators[TO_STRING_TAG] =
                    returnThis;
                  return IteratorConstructor;
                };

                /***/
              },
              /* 65 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var fails =
                  __w_pdfjs_require__(13);
                var getPrototypeOf =
                  __w_pdfjs_require__(66);
                var createNonEnumerableProperty =
                  __w_pdfjs_require__(25);
                var has = __w_pdfjs_require__(22);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var IS_PURE =
                  __w_pdfjs_require__(36);
                var ITERATOR =
                  wellKnownSymbol("iterator");
                var BUGGY_SAFARI_ITERATORS = false;
                var returnThis = function () {
                  return this;
                };
                var IteratorPrototype,
                  PrototypeOfArrayIteratorPrototype,
                  arrayIterator;
                if ([].keys) {
                  arrayIterator = [].keys();
                  if (!("next" in arrayIterator))
                    BUGGY_SAFARI_ITERATORS = true;
                  else {
                    PrototypeOfArrayIteratorPrototype =
                      getPrototypeOf(
                        getPrototypeOf(
                          arrayIterator
                        )
                      );
                    if (
                      PrototypeOfArrayIteratorPrototype !==
                      Object.prototype
                    )
                      IteratorPrototype =
                        PrototypeOfArrayIteratorPrototype;
                  }
                }
                var NEW_ITERATOR_PROTOTYPE =
                  IteratorPrototype ==
                    undefined ||
                  fails(function () {
                    var test = {};
                    return (
                      IteratorPrototype[
                        ITERATOR
                      ].call(test) !== test
                    );
                  });
                if (NEW_ITERATOR_PROTOTYPE)
                  IteratorPrototype = {};
                if (
                  (!IS_PURE ||
                    NEW_ITERATOR_PROTOTYPE) &&
                  !has(
                    IteratorPrototype,
                    ITERATOR
                  )
                ) {
                  createNonEnumerableProperty(
                    IteratorPrototype,
                    ITERATOR,
                    returnThis
                  );
                }
                module.exports = {
                  IteratorPrototype:
                    IteratorPrototype,
                  BUGGY_SAFARI_ITERATORS:
                    BUGGY_SAFARI_ITERATORS,
                };

                /***/
              },
              /* 66 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var has = __w_pdfjs_require__(22);
                var toObject =
                  __w_pdfjs_require__(67);
                var sharedKey =
                  __w_pdfjs_require__(34);
                var CORRECT_PROTOTYPE_GETTER =
                  __w_pdfjs_require__(68);
                var IE_PROTO =
                  sharedKey("IE_PROTO");
                var ObjectPrototype =
                  Object.prototype;
                module.exports =
                  CORRECT_PROTOTYPE_GETTER
                    ? Object.getPrototypeOf
                    : function (O) {
                        O = toObject(O);
                        if (has(O, IE_PROTO))
                          return O[IE_PROTO];
                        if (
                          typeof O.constructor ==
                            "function" &&
                          O instanceof
                            O.constructor
                        ) {
                          return O.constructor
                            .prototype;
                        }
                        return O instanceof Object
                          ? ObjectPrototype
                          : null;
                      };

                /***/
              },
              /* 67 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var requireObjectCoercible =
                  __w_pdfjs_require__(19);
                module.exports = function (
                  argument
                ) {
                  return Object(
                    requireObjectCoercible(
                      argument
                    )
                  );
                };

                /***/
              },
              /* 68 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var fails =
                  __w_pdfjs_require__(13);
                module.exports = !fails(
                  function () {
                    function F() {}
                    F.prototype.constructor =
                      null;
                    return (
                      Object.getPrototypeOf(
                        new F()
                      ) !== F.prototype
                    );
                  }
                );

                /***/
              },
              /* 69 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var defineProperty =
                  __w_pdfjs_require__(26).f;
                var has = __w_pdfjs_require__(22);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var TO_STRING_TAG =
                  wellKnownSymbol("toStringTag");
                module.exports = function (
                  it,
                  TAG,
                  STATIC
                ) {
                  if (
                    it &&
                    !has(
                      (it = STATIC
                        ? it
                        : it.prototype),
                      TO_STRING_TAG
                    )
                  ) {
                    defineProperty(
                      it,
                      TO_STRING_TAG,
                      {
                        configurable: true,
                        value: TAG,
                      }
                    );
                  }
                };

                /***/
              },
              /* 70 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var anObject =
                  __w_pdfjs_require__(27);
                var aPossiblePrototype =
                  __w_pdfjs_require__(71);
                module.exports =
                  Object.setPrototypeOf ||
                  ("__proto__" in {}
                    ? (function () {
                        var CORRECT_SETTER = false;
                        var test = {};
                        var setter;
                        try {
                          setter =
                            Object.getOwnPropertyDescriptor(
                              Object.prototype,
                              "__proto__"
                            ).set;
                          setter.call(test, []);
                          CORRECT_SETTER =
                            test instanceof Array;
                        } catch (error) {}
                        return function setPrototypeOf(
                          O,
                          proto
                        ) {
                          anObject(O);
                          aPossiblePrototype(
                            proto
                          );
                          if (CORRECT_SETTER)
                            setter.call(O, proto);
                          else
                            O.__proto__ = proto;
                          return O;
                        };
                      })()
                    : undefined);

                /***/
              },
              /* 71 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var isObject =
                  __w_pdfjs_require__(21);
                module.exports = function (it) {
                  if (
                    !isObject(it) &&
                    it !== null
                  ) {
                    throw TypeError(
                      "Can't set " +
                        String(it) +
                        " as a prototype"
                    );
                  }
                  return it;
                };

                /***/
              },
              /* 72 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var $ = __w_pdfjs_require__(9);
                var iterate =
                  __w_pdfjs_require__(73);
                var createProperty =
                  __w_pdfjs_require__(81);
                $(
                  {
                    target: "Object",
                    stat: true,
                  },
                  {
                    fromEntries:
                      function fromEntries(
                        iterable
                      ) {
                        var obj = {};
                        iterate(
                          iterable,
                          function (k, v) {
                            createProperty(
                              obj,
                              k,
                              v
                            );
                          },
                          { AS_ENTRIES: true }
                        );
                        return obj;
                      },
                  }
                );

                /***/
              },
              /* 73 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var anObject =
                  __w_pdfjs_require__(27);
                var isArrayIteratorMethod =
                  __w_pdfjs_require__(74);
                var toLength =
                  __w_pdfjs_require__(46);
                var bind =
                  __w_pdfjs_require__(75);
                var getIteratorMethod =
                  __w_pdfjs_require__(77);
                var iteratorClose =
                  __w_pdfjs_require__(80);
                var Result = function (
                  stopped,
                  result
                ) {
                  this.stopped = stopped;
                  this.result = result;
                };
                module.exports = function (
                  iterable,
                  unboundFunction,
                  options
                ) {
                  var that =
                    options && options.that;
                  var AS_ENTRIES = !!(
                    options && options.AS_ENTRIES
                  );
                  var IS_ITERATOR = !!(
                    options && options.IS_ITERATOR
                  );
                  var INTERRUPTED = !!(
                    options && options.INTERRUPTED
                  );
                  var fn = bind(
                    unboundFunction,
                    that,
                    1 + AS_ENTRIES + INTERRUPTED
                  );
                  var iterator,
                    iterFn,
                    index,
                    length,
                    result,
                    next,
                    step;
                  var stop = function (
                    condition
                  ) {
                    if (iterator)
                      iteratorClose(iterator);
                    return new Result(
                      true,
                      condition
                    );
                  };
                  var callFn = function (value) {
                    if (AS_ENTRIES) {
                      anObject(value);
                      return INTERRUPTED
                        ? fn(
                            value[0],
                            value[1],
                            stop
                          )
                        : fn(value[0], value[1]);
                    }
                    return INTERRUPTED
                      ? fn(value, stop)
                      : fn(value);
                  };
                  if (IS_ITERATOR) {
                    iterator = iterable;
                  } else {
                    iterFn =
                      getIteratorMethod(iterable);
                    if (
                      typeof iterFn != "function"
                    )
                      throw TypeError(
                        "Target is not iterable"
                      );
                    if (
                      isArrayIteratorMethod(
                        iterFn
                      )
                    ) {
                      for (
                        index = 0,
                          length = toLength(
                            iterable.length
                          );
                        length > index;
                        index++
                      ) {
                        result = callFn(
                          iterable[index]
                        );
                        if (
                          result &&
                          result instanceof Result
                        )
                          return result;
                      }
                      return new Result(false);
                    }
                    iterator =
                      iterFn.call(iterable);
                  }
                  next = iterator.next;
                  while (
                    !(step = next.call(iterator))
                      .done
                  ) {
                    try {
                      result = callFn(step.value);
                    } catch (error) {
                      iteratorClose(iterator);
                      throw error;
                    }
                    if (
                      typeof result == "object" &&
                      result &&
                      result instanceof Result
                    )
                      return result;
                  }
                  return new Result(false);
                };

                /***/
              },
              /* 74 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var Iterators =
                  __w_pdfjs_require__(62);
                var ITERATOR =
                  wellKnownSymbol("iterator");
                var ArrayPrototype =
                  Array.prototype;
                module.exports = function (it) {
                  return (
                    it !== undefined &&
                    (Iterators.Array === it ||
                      ArrayPrototype[ITERATOR] ===
                        it)
                  );
                };

                /***/
              },
              /* 75 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var aFunction =
                  __w_pdfjs_require__(76);
                module.exports = function (
                  fn,
                  that,
                  length
                ) {
                  aFunction(fn);
                  if (that === undefined)
                    return fn;
                  switch (length) {
                    case 0:
                      return function () {
                        return fn.call(that);
                      };
                    case 1:
                      return function (a) {
                        return fn.call(that, a);
                      };
                    case 2:
                      return function (a, b) {
                        return fn.call(
                          that,
                          a,
                          b
                        );
                      };
                    case 3:
                      return function (a, b, c) {
                        return fn.call(
                          that,
                          a,
                          b,
                          c
                        );
                      };
                  }
                  return function () {
                    return fn.apply(
                      that,
                      arguments
                    );
                  };
                };

                /***/
              },
              /* 76 */
              /***/ function (module) {
                module.exports = function (it) {
                  if (typeof it != "function") {
                    throw TypeError(
                      String(it) +
                        " is not a function"
                    );
                  }
                  return it;
                };

                /***/
              },
              /* 77 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var classof =
                  __w_pdfjs_require__(78);
                var Iterators =
                  __w_pdfjs_require__(62);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var ITERATOR =
                  wellKnownSymbol("iterator");
                module.exports = function (it) {
                  if (it != undefined)
                    return (
                      it[ITERATOR] ||
                      it["@@iterator"] ||
                      Iterators[classof(it)]
                    );
                };

                /***/
              },
              /* 78 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var TO_STRING_TAG_SUPPORT =
                  __w_pdfjs_require__(79);
                var classofRaw =
                  __w_pdfjs_require__(18);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var TO_STRING_TAG =
                  wellKnownSymbol("toStringTag");
                var CORRECT_ARGUMENTS =
                  classofRaw(
                    (function () {
                      return arguments;
                    })()
                  ) == "Arguments";
                var tryGet = function (it, key) {
                  try {
                    return it[key];
                  } catch (error) {}
                };
                module.exports =
                  TO_STRING_TAG_SUPPORT
                    ? classofRaw
                    : function (it) {
                        var O, tag, result;
                        return it === undefined
                          ? "Undefined"
                          : it === null
                          ? "Null"
                          : typeof (tag = tryGet(
                              (O = Object(it)),
                              TO_STRING_TAG
                            )) == "string"
                          ? tag
                          : CORRECT_ARGUMENTS
                          ? classofRaw(O)
                          : (result =
                              classofRaw(O)) ==
                              "Object" &&
                            typeof O.callee ==
                              "function"
                          ? "Arguments"
                          : result;
                      };

                /***/
              },
              /* 79 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var TO_STRING_TAG =
                  wellKnownSymbol("toStringTag");
                var test = {};
                test[TO_STRING_TAG] = "z";
                module.exports =
                  String(test) === "[object z]";

                /***/
              },
              /* 80 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var anObject =
                  __w_pdfjs_require__(27);
                module.exports = function (
                  iterator
                ) {
                  var returnMethod =
                    iterator["return"];
                  if (
                    returnMethod !== undefined
                  ) {
                    return anObject(
                      returnMethod.call(iterator)
                    ).value;
                  }
                };

                /***/
              },
              /* 81 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var toPrimitive =
                  __w_pdfjs_require__(20);
                var definePropertyModule =
                  __w_pdfjs_require__(26);
                var createPropertyDescriptor =
                  __w_pdfjs_require__(15);
                module.exports = function (
                  object,
                  key,
                  value
                ) {
                  var propertyKey =
                    toPrimitive(key);
                  if (propertyKey in object)
                    definePropertyModule.f(
                      object,
                      propertyKey,
                      createPropertyDescriptor(
                        0,
                        value
                      )
                    );
                  else
                    object[propertyKey] = value;
                };

                /***/
              },
              /* 82 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                __w_pdfjs_require__(83);
                __w_pdfjs_require__(84);
                __w_pdfjs_require__(86);
                __w_pdfjs_require__(104);
                __w_pdfjs_require__(105);
                __w_pdfjs_require__(106);
                __w_pdfjs_require__(107);
                __w_pdfjs_require__(109);
                var path =
                  __w_pdfjs_require__(42);
                module.exports = path.Promise;

                /***/
              },
              /* 83 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var $ = __w_pdfjs_require__(9);
                var getPrototypeOf =
                  __w_pdfjs_require__(66);
                var setPrototypeOf =
                  __w_pdfjs_require__(70);
                var create =
                  __w_pdfjs_require__(58);
                var createNonEnumerableProperty =
                  __w_pdfjs_require__(25);
                var createPropertyDescriptor =
                  __w_pdfjs_require__(15);
                var iterate =
                  __w_pdfjs_require__(73);
                var $AggregateError =
                  function AggregateError(
                    errors,
                    message
                  ) {
                    var that = this;
                    if (
                      !(
                        that instanceof
                        $AggregateError
                      )
                    )
                      return new $AggregateError(
                        errors,
                        message
                      );
                    if (setPrototypeOf) {
                      that = setPrototypeOf(
                        new Error(undefined),
                        getPrototypeOf(that)
                      );
                    }
                    if (message !== undefined)
                      createNonEnumerableProperty(
                        that,
                        "message",
                        String(message)
                      );
                    var errorsArray = [];
                    iterate(
                      errors,
                      errorsArray.push,
                      { that: errorsArray }
                    );
                    createNonEnumerableProperty(
                      that,
                      "errors",
                      errorsArray
                    );
                    return that;
                  };
                $AggregateError.prototype =
                  create(Error.prototype, {
                    constructor:
                      createPropertyDescriptor(
                        5,
                        $AggregateError
                      ),
                    message:
                      createPropertyDescriptor(
                        5,
                        ""
                      ),
                    name: createPropertyDescriptor(
                      5,
                      "AggregateError"
                    ),
                  });
                $(
                  { global: true },
                  {
                    AggregateError:
                      $AggregateError,
                  }
                );

                /***/
              },
              /* 84 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var TO_STRING_TAG_SUPPORT =
                  __w_pdfjs_require__(79);
                var redefine =
                  __w_pdfjs_require__(28);
                var toString =
                  __w_pdfjs_require__(85);
                if (!TO_STRING_TAG_SUPPORT) {
                  redefine(
                    Object.prototype,
                    "toString",
                    toString,
                    { unsafe: true }
                  );
                }

                /***/
              },
              /* 85 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var TO_STRING_TAG_SUPPORT =
                  __w_pdfjs_require__(79);
                var classof =
                  __w_pdfjs_require__(78);
                module.exports =
                  TO_STRING_TAG_SUPPORT
                    ? {}.toString
                    : function toString() {
                        return (
                          "[object " +
                          classof(this) +
                          "]"
                        );
                      };

                /***/
              },
              /* 86 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var $ = __w_pdfjs_require__(9);
                var IS_PURE =
                  __w_pdfjs_require__(36);
                var global =
                  __w_pdfjs_require__(10);
                var getBuiltIn =
                  __w_pdfjs_require__(41);
                var NativePromise =
                  __w_pdfjs_require__(87);
                var redefine =
                  __w_pdfjs_require__(28);
                var redefineAll =
                  __w_pdfjs_require__(88);
                var setToStringTag =
                  __w_pdfjs_require__(69);
                var setSpecies =
                  __w_pdfjs_require__(89);
                var isObject =
                  __w_pdfjs_require__(21);
                var aFunction =
                  __w_pdfjs_require__(76);
                var anInstance =
                  __w_pdfjs_require__(90);
                var inspectSource =
                  __w_pdfjs_require__(30);
                var iterate =
                  __w_pdfjs_require__(73);
                var checkCorrectnessOfIteration =
                  __w_pdfjs_require__(91);
                var speciesConstructor =
                  __w_pdfjs_require__(92);
                var task =
                  __w_pdfjs_require__(93).set;
                var microtask =
                  __w_pdfjs_require__(97);
                var promiseResolve =
                  __w_pdfjs_require__(99);
                var hostReportErrors =
                  __w_pdfjs_require__(101);
                var newPromiseCapabilityModule =
                  __w_pdfjs_require__(100);
                var perform =
                  __w_pdfjs_require__(102);
                var InternalStateModule =
                  __w_pdfjs_require__(32);
                var isForced =
                  __w_pdfjs_require__(51);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var IS_NODE =
                  __w_pdfjs_require__(96);
                var V8_VERSION =
                  __w_pdfjs_require__(103);
                var SPECIES =
                  wellKnownSymbol("species");
                var PROMISE = "Promise";
                var getInternalState =
                  InternalStateModule.get;
                var setInternalState =
                  InternalStateModule.set;
                var getInternalPromiseState =
                  InternalStateModule.getterFor(
                    PROMISE
                  );
                var PromiseConstructor =
                  NativePromise;
                var TypeError = global.TypeError;
                var document = global.document;
                var process = global.process;
                var $fetch = getBuiltIn("fetch");
                var newPromiseCapability =
                  newPromiseCapabilityModule.f;
                var newGenericPromiseCapability =
                  newPromiseCapability;
                var DISPATCH_EVENT = !!(
                  document &&
                  document.createEvent &&
                  global.dispatchEvent
                );
                var NATIVE_REJECTION_EVENT =
                  typeof PromiseRejectionEvent ==
                  "function";
                var UNHANDLED_REJECTION =
                  "unhandledrejection";
                var REJECTION_HANDLED =
                  "rejectionhandled";
                var PENDING = 0;
                var FULFILLED = 1;
                var REJECTED = 2;
                var HANDLED = 1;
                var UNHANDLED = 2;
                var Internal,
                  OwnPromiseCapability,
                  PromiseWrapper,
                  nativeThen;
                var FORCED = isForced(
                  PROMISE,
                  function () {
                    var GLOBAL_CORE_JS_PROMISE =
                      inspectSource(
                        PromiseConstructor
                      ) !==
                      String(PromiseConstructor);
                    if (!GLOBAL_CORE_JS_PROMISE) {
                      if (V8_VERSION === 66)
                        return true;
                      if (
                        !IS_NODE &&
                        !NATIVE_REJECTION_EVENT
                      )
                        return true;
                    }
                    if (
                      IS_PURE &&
                      !PromiseConstructor
                        .prototype["finally"]
                    )
                      return true;
                    if (
                      V8_VERSION >= 51 &&
                      /native code/.test(
                        PromiseConstructor
                      )
                    )
                      return false;
                    var promise =
                      PromiseConstructor.resolve(
                        1
                      );
                    var FakePromise = function (
                      exec
                    ) {
                      exec(
                        function () {},
                        function () {}
                      );
                    };
                    var constructor =
                      (promise.constructor = {});
                    constructor[SPECIES] =
                      FakePromise;
                    return !(
                      promise.then(
                        function () {}
                      ) instanceof FakePromise
                    );
                  }
                );
                var INCORRECT_ITERATION =
                  FORCED ||
                  !checkCorrectnessOfIteration(
                    function (iterable) {
                      PromiseConstructor.all(
                        iterable
                      )["catch"](function () {});
                    }
                  );
                var isThenable = function (it) {
                  var then;
                  return isObject(it) &&
                    typeof (then = it.then) ==
                      "function"
                    ? then
                    : false;
                };
                var notify = function (
                  state,
                  isReject
                ) {
                  if (state.notified) return;
                  state.notified = true;
                  var chain = state.reactions;
                  microtask(function () {
                    var value = state.value;
                    var ok =
                      state.state == FULFILLED;
                    var index = 0;
                    while (chain.length > index) {
                      var reaction =
                        chain[index++];
                      var handler = ok
                        ? reaction.ok
                        : reaction.fail;
                      var resolve =
                        reaction.resolve;
                      var reject =
                        reaction.reject;
                      var domain =
                        reaction.domain;
                      var result, then, exited;
                      try {
                        if (handler) {
                          if (!ok) {
                            if (
                              state.rejection ===
                              UNHANDLED
                            )
                              onHandleUnhandled(
                                state
                              );
                            state.rejection =
                              HANDLED;
                          }
                          if (handler === true)
                            result = value;
                          else {
                            if (domain)
                              domain.enter();
                            result =
                              handler(value);
                            if (domain) {
                              domain.exit();
                              exited = true;
                            }
                          }
                          if (
                            result ===
                            reaction.promise
                          ) {
                            reject(
                              TypeError(
                                "Promise-chain cycle"
                              )
                            );
                          } else if (
                            (then =
                              isThenable(result))
                          ) {
                            then.call(
                              result,
                              resolve,
                              reject
                            );
                          } else resolve(result);
                        } else reject(value);
                      } catch (error) {
                        if (domain && !exited)
                          domain.exit();
                        reject(error);
                      }
                    }
                    state.reactions = [];
                    state.notified = false;
                    if (
                      isReject &&
                      !state.rejection
                    )
                      onUnhandled(state);
                  });
                };
                var dispatchEvent = function (
                  name,
                  promise,
                  reason
                ) {
                  var event, handler;
                  if (DISPATCH_EVENT) {
                    event =
                      document.createEvent(
                        "Event"
                      );
                    event.promise = promise;
                    event.reason = reason;
                    event.initEvent(
                      name,
                      false,
                      true
                    );
                    global.dispatchEvent(event);
                  } else
                    event = {
                      promise: promise,
                      reason: reason,
                    };
                  if (
                    !NATIVE_REJECTION_EVENT &&
                    (handler =
                      global["on" + name])
                  )
                    handler(event);
                  else if (
                    name === UNHANDLED_REJECTION
                  )
                    hostReportErrors(
                      "Unhandled promise rejection",
                      reason
                    );
                };
                var onUnhandled = function (
                  state
                ) {
                  task.call(global, function () {
                    var promise = state.facade;
                    var value = state.value;
                    var IS_UNHANDLED =
                      isUnhandled(state);
                    var result;
                    if (IS_UNHANDLED) {
                      result = perform(
                        function () {
                          if (IS_NODE) {
                            process.emit(
                              "unhandledRejection",
                              value,
                              promise
                            );
                          } else
                            dispatchEvent(
                              UNHANDLED_REJECTION,
                              promise,
                              value
                            );
                        }
                      );
                      state.rejection =
                        IS_NODE ||
                        isUnhandled(state)
                          ? UNHANDLED
                          : HANDLED;
                      if (result.error)
                        throw result.value;
                    }
                  });
                };
                var isUnhandled = function (
                  state
                ) {
                  return (
                    state.rejection !== HANDLED &&
                    !state.parent
                  );
                };
                var onHandleUnhandled = function (
                  state
                ) {
                  task.call(global, function () {
                    var promise = state.facade;
                    if (IS_NODE) {
                      process.emit(
                        "rejectionHandled",
                        promise
                      );
                    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
                  });
                };
                var bind = function (
                  fn,
                  state,
                  unwrap
                ) {
                  return function (value) {
                    fn(state, value, unwrap);
                  };
                };
                var internalReject = function (
                  state,
                  value,
                  unwrap
                ) {
                  if (state.done) return;
                  state.done = true;
                  if (unwrap) state = unwrap;
                  state.value = value;
                  state.state = REJECTED;
                  notify(state, true);
                };
                var internalResolve = function (
                  state,
                  value,
                  unwrap
                ) {
                  if (state.done) return;
                  state.done = true;
                  if (unwrap) state = unwrap;
                  try {
                    if (state.facade === value)
                      throw TypeError(
                        "Promise can't be resolved itself"
                      );
                    var then = isThenable(value);
                    if (then) {
                      microtask(function () {
                        var wrapper = {
                          done: false,
                        };
                        try {
                          then.call(
                            value,
                            bind(
                              internalResolve,
                              wrapper,
                              state
                            ),
                            bind(
                              internalReject,
                              wrapper,
                              state
                            )
                          );
                        } catch (error) {
                          internalReject(
                            wrapper,
                            error,
                            state
                          );
                        }
                      });
                    } else {
                      state.value = value;
                      state.state = FULFILLED;
                      notify(state, false);
                    }
                  } catch (error) {
                    internalReject(
                      { done: false },
                      error,
                      state
                    );
                  }
                };
                if (FORCED) {
                  PromiseConstructor =
                    function Promise(executor) {
                      anInstance(
                        this,
                        PromiseConstructor,
                        PROMISE
                      );
                      aFunction(executor);
                      Internal.call(this);
                      var state =
                        getInternalState(this);
                      try {
                        executor(
                          bind(
                            internalResolve,
                            state
                          ),
                          bind(
                            internalReject,
                            state
                          )
                        );
                      } catch (error) {
                        internalReject(
                          state,
                          error
                        );
                      }
                    };
                  Internal = function Promise(
                    executor
                  ) {
                    setInternalState(this, {
                      type: PROMISE,
                      done: false,
                      notified: false,
                      parent: false,
                      reactions: [],
                      rejection: false,
                      state: PENDING,
                      value: undefined,
                    });
                  };
                  Internal.prototype =
                    redefineAll(
                      PromiseConstructor.prototype,
                      {
                        then: function then(
                          onFulfilled,
                          onRejected
                        ) {
                          var state =
                            getInternalPromiseState(
                              this
                            );
                          var reaction =
                            newPromiseCapability(
                              speciesConstructor(
                                this,
                                PromiseConstructor
                              )
                            );
                          reaction.ok =
                            typeof onFulfilled ==
                            "function"
                              ? onFulfilled
                              : true;
                          reaction.fail =
                            typeof onRejected ==
                              "function" &&
                            onRejected;
                          reaction.domain =
                            IS_NODE
                              ? process.domain
                              : undefined;
                          state.parent = true;
                          state.reactions.push(
                            reaction
                          );
                          if (
                            state.state != PENDING
                          )
                            notify(state, false);
                          return reaction.promise;
                        },
                        catch: function (
                          onRejected
                        ) {
                          return this.then(
                            undefined,
                            onRejected
                          );
                        },
                      }
                    );
                  OwnPromiseCapability =
                    function () {
                      var promise =
                        new Internal();
                      var state =
                        getInternalState(promise);
                      this.promise = promise;
                      this.resolve = bind(
                        internalResolve,
                        state
                      );
                      this.reject = bind(
                        internalReject,
                        state
                      );
                    };
                  newPromiseCapabilityModule.f =
                    newPromiseCapability =
                      function (C) {
                        return C ===
                          PromiseConstructor ||
                          C === PromiseWrapper
                          ? new OwnPromiseCapability(
                              C
                            )
                          : newGenericPromiseCapability(
                              C
                            );
                      };
                  if (
                    !IS_PURE &&
                    typeof NativePromise ==
                      "function"
                  ) {
                    nativeThen =
                      NativePromise.prototype
                        .then;
                    redefine(
                      NativePromise.prototype,
                      "then",
                      function then(
                        onFulfilled,
                        onRejected
                      ) {
                        var that = this;
                        return new PromiseConstructor(
                          function (
                            resolve,
                            reject
                          ) {
                            nativeThen.call(
                              that,
                              resolve,
                              reject
                            );
                          }
                        ).then(
                          onFulfilled,
                          onRejected
                        );
                      },
                      { unsafe: true }
                    );
                    if (
                      typeof $fetch == "function"
                    )
                      $(
                        {
                          global: true,
                          enumerable: true,
                          forced: true,
                        },
                        {
                          fetch: function fetch(
                            input
                          ) {
                            return promiseResolve(
                              PromiseConstructor,
                              $fetch.apply(
                                global,
                                arguments
                              )
                            );
                          },
                        }
                      );
                  }
                }
                $(
                  {
                    global: true,
                    wrap: true,
                    forced: FORCED,
                  },
                  { Promise: PromiseConstructor }
                );
                setToStringTag(
                  PromiseConstructor,
                  PROMISE,
                  false,
                  true
                );
                setSpecies(PROMISE);
                PromiseWrapper =
                  getBuiltIn(PROMISE);
                $(
                  {
                    target: PROMISE,
                    stat: true,
                    forced: FORCED,
                  },
                  {
                    reject: function reject(r) {
                      var capability =
                        newPromiseCapability(
                          this
                        );
                      capability.reject.call(
                        undefined,
                        r
                      );
                      return capability.promise;
                    },
                  }
                );
                $(
                  {
                    target: PROMISE,
                    stat: true,
                    forced: IS_PURE || FORCED,
                  },
                  {
                    resolve: function resolve(x) {
                      return promiseResolve(
                        IS_PURE &&
                          this === PromiseWrapper
                          ? PromiseConstructor
                          : this,
                        x
                      );
                    },
                  }
                );
                $(
                  {
                    target: PROMISE,
                    stat: true,
                    forced: INCORRECT_ITERATION,
                  },
                  {
                    all: function all(iterable) {
                      var C = this;
                      var capability =
                        newPromiseCapability(C);
                      var resolve =
                        capability.resolve;
                      var reject =
                        capability.reject;
                      var result = perform(
                        function () {
                          var $promiseResolve =
                            aFunction(C.resolve);
                          var values = [];
                          var counter = 0;
                          var remaining = 1;
                          iterate(
                            iterable,
                            function (promise) {
                              var index =
                                counter++;
                              var alreadyCalled = false;
                              values.push(
                                undefined
                              );
                              remaining++;
                              $promiseResolve
                                .call(C, promise)
                                .then(function (
                                  value
                                ) {
                                  if (
                                    alreadyCalled
                                  )
                                    return;
                                  alreadyCalled = true;
                                  values[index] =
                                    value;
                                  --remaining ||
                                    resolve(
                                      values
                                    );
                                },
                                reject);
                            }
                          );
                          --remaining ||
                            resolve(values);
                        }
                      );
                      if (result.error)
                        reject(result.value);
                      return capability.promise;
                    },
                    race: function race(
                      iterable
                    ) {
                      var C = this;
                      var capability =
                        newPromiseCapability(C);
                      var reject =
                        capability.reject;
                      var result = perform(
                        function () {
                          var $promiseResolve =
                            aFunction(C.resolve);
                          iterate(
                            iterable,
                            function (promise) {
                              $promiseResolve
                                .call(C, promise)
                                .then(
                                  capability.resolve,
                                  reject
                                );
                            }
                          );
                        }
                      );
                      if (result.error)
                        reject(result.value);
                      return capability.promise;
                    },
                  }
                );

                /***/
              },
              /* 87 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                module.exports = global.Promise;

                /***/
              },
              /* 88 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var redefine =
                  __w_pdfjs_require__(28);
                module.exports = function (
                  target,
                  src,
                  options
                ) {
                  for (var key in src)
                    redefine(
                      target,
                      key,
                      src[key],
                      options
                    );
                  return target;
                };

                /***/
              },
              /* 89 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var getBuiltIn =
                  __w_pdfjs_require__(41);
                var definePropertyModule =
                  __w_pdfjs_require__(26);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var DESCRIPTORS =
                  __w_pdfjs_require__(12);
                var SPECIES =
                  wellKnownSymbol("species");
                module.exports = function (
                  CONSTRUCTOR_NAME
                ) {
                  var Constructor = getBuiltIn(
                    CONSTRUCTOR_NAME
                  );
                  var defineProperty =
                    definePropertyModule.f;
                  if (
                    DESCRIPTORS &&
                    Constructor &&
                    !Constructor[SPECIES]
                  ) {
                    defineProperty(
                      Constructor,
                      SPECIES,
                      {
                        configurable: true,
                        get: function () {
                          return this;
                        },
                      }
                    );
                  }
                };

                /***/
              },
              /* 90 */
              /***/ function (module) {
                module.exports = function (
                  it,
                  Constructor,
                  name
                ) {
                  if (
                    !(it instanceof Constructor)
                  ) {
                    throw TypeError(
                      "Incorrect " +
                        (name ? name + " " : "") +
                        "invocation"
                    );
                  }
                  return it;
                };

                /***/
              },
              /* 91 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var ITERATOR =
                  wellKnownSymbol("iterator");
                var SAFE_CLOSING = false;
                try {
                  var called = 0;
                  var iteratorWithReturn = {
                    next: function () {
                      return { done: !!called++ };
                    },
                    return: function () {
                      SAFE_CLOSING = true;
                    },
                  };
                  iteratorWithReturn[ITERATOR] =
                    function () {
                      return this;
                    };
                  Array.from(
                    iteratorWithReturn,
                    function () {
                      throw 2;
                    }
                  );
                } catch (error) {}
                module.exports = function (
                  exec,
                  SKIP_CLOSING
                ) {
                  if (
                    !SKIP_CLOSING &&
                    !SAFE_CLOSING
                  )
                    return false;
                  var ITERATION_SUPPORT = false;
                  try {
                    var object = {};
                    object[ITERATOR] =
                      function () {
                        return {
                          next: function () {
                            return {
                              done: (ITERATION_SUPPORT = true),
                            };
                          },
                        };
                      };
                    exec(object);
                  } catch (error) {}
                  return ITERATION_SUPPORT;
                };

                /***/
              },
              /* 92 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var anObject =
                  __w_pdfjs_require__(27);
                var aFunction =
                  __w_pdfjs_require__(76);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var SPECIES =
                  wellKnownSymbol("species");
                module.exports = function (
                  O,
                  defaultConstructor
                ) {
                  var C = anObject(O).constructor;
                  var S;
                  return C === undefined ||
                    (S = anObject(C)[SPECIES]) ==
                      undefined
                    ? defaultConstructor
                    : aFunction(S);
                };

                /***/
              },
              /* 93 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var fails =
                  __w_pdfjs_require__(13);
                var bind =
                  __w_pdfjs_require__(75);
                var html =
                  __w_pdfjs_require__(61);
                var createElement =
                  __w_pdfjs_require__(24);
                var IS_IOS =
                  __w_pdfjs_require__(94);
                var IS_NODE =
                  __w_pdfjs_require__(96);
                var location = global.location;
                var set = global.setImmediate;
                var clear = global.clearImmediate;
                var process = global.process;
                var MessageChannel =
                  global.MessageChannel;
                var Dispatch = global.Dispatch;
                var counter = 0;
                var queue = {};
                var ONREADYSTATECHANGE =
                  "onreadystatechange";
                var defer, channel, port;
                var run = function (id) {
                  if (queue.hasOwnProperty(id)) {
                    var fn = queue[id];
                    delete queue[id];
                    fn();
                  }
                };
                var runner = function (id) {
                  return function () {
                    run(id);
                  };
                };
                var listener = function (event) {
                  run(event.data);
                };
                var post = function (id) {
                  global.postMessage(
                    id + "",
                    location.protocol +
                      "//" +
                      location.host
                  );
                };
                if (!set || !clear) {
                  set = function setImmediate(
                    fn
                  ) {
                    var args = [];
                    var i = 1;
                    while (arguments.length > i)
                      args.push(arguments[i++]);
                    queue[++counter] =
                      function () {
                        (typeof fn == "function"
                          ? fn
                          : Function(fn)
                        ).apply(undefined, args);
                      };
                    defer(counter);
                    return counter;
                  };
                  clear = function clearImmediate(
                    id
                  ) {
                    delete queue[id];
                  };
                  if (IS_NODE) {
                    defer = function (id) {
                      process.nextTick(
                        runner(id)
                      );
                    };
                  } else if (
                    Dispatch &&
                    Dispatch.now
                  ) {
                    defer = function (id) {
                      Dispatch.now(runner(id));
                    };
                  } else if (
                    MessageChannel &&
                    !IS_IOS
                  ) {
                    channel =
                      new MessageChannel();
                    port = channel.port2;
                    channel.port1.onmessage =
                      listener;
                    defer = bind(
                      port.postMessage,
                      port,
                      1
                    );
                  } else if (
                    global.addEventListener &&
                    typeof postMessage ==
                      "function" &&
                    !global.importScripts &&
                    location &&
                    location.protocol !==
                      "file:" &&
                    !fails(post)
                  ) {
                    defer = post;
                    global.addEventListener(
                      "message",
                      listener,
                      false
                    );
                  } else if (
                    ONREADYSTATECHANGE in
                    createElement("script")
                  ) {
                    defer = function (id) {
                      html.appendChild(
                        createElement("script")
                      )[ONREADYSTATECHANGE] =
                        function () {
                          html.removeChild(this);
                          run(id);
                        };
                    };
                  } else {
                    defer = function (id) {
                      setTimeout(runner(id), 0);
                    };
                  }
                }
                module.exports = {
                  set: set,
                  clear: clear,
                };

                /***/
              },
              /* 94 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var userAgent =
                  __w_pdfjs_require__(95);
                module.exports =
                  /(iphone|ipod|ipad).*applewebkit/i.test(
                    userAgent
                  );

                /***/
              },
              /* 95 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var getBuiltIn =
                  __w_pdfjs_require__(41);
                module.exports =
                  getBuiltIn(
                    "navigator",
                    "userAgent"
                  ) || "";

                /***/
              },
              /* 96 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var classof =
                  __w_pdfjs_require__(18);
                var global =
                  __w_pdfjs_require__(10);
                module.exports =
                  classof(global.process) ==
                  "process";

                /***/
              },
              /* 97 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var getOwnPropertyDescriptor =
                  __w_pdfjs_require__(11).f;
                var macrotask =
                  __w_pdfjs_require__(93).set;
                var IS_IOS =
                  __w_pdfjs_require__(94);
                var IS_WEBOS_WEBKIT =
                  __w_pdfjs_require__(98);
                var IS_NODE =
                  __w_pdfjs_require__(96);
                var MutationObserver =
                  global.MutationObserver ||
                  global.WebKitMutationObserver;
                var document = global.document;
                var process = global.process;
                var Promise = global.Promise;
                var queueMicrotaskDescriptor =
                  getOwnPropertyDescriptor(
                    global,
                    "queueMicrotask"
                  );
                var queueMicrotask =
                  queueMicrotaskDescriptor &&
                  queueMicrotaskDescriptor.value;
                var flush,
                  head,
                  last,
                  notify,
                  toggle,
                  node,
                  promise,
                  then;
                if (!queueMicrotask) {
                  flush = function () {
                    var parent, fn;
                    if (
                      IS_NODE &&
                      (parent = process.domain)
                    )
                      parent.exit();
                    while (head) {
                      fn = head.fn;
                      head = head.next;
                      try {
                        fn();
                      } catch (error) {
                        if (head) notify();
                        else last = undefined;
                        throw error;
                      }
                    }
                    last = undefined;
                    if (parent) parent.enter();
                  };
                  if (
                    !IS_IOS &&
                    !IS_NODE &&
                    !IS_WEBOS_WEBKIT &&
                    MutationObserver &&
                    document
                  ) {
                    toggle = true;
                    node =
                      document.createTextNode("");
                    new MutationObserver(
                      flush
                    ).observe(node, {
                      characterData: true,
                    });
                    notify = function () {
                      node.data = toggle =
                        !toggle;
                    };
                  } else if (
                    Promise &&
                    Promise.resolve
                  ) {
                    promise =
                      Promise.resolve(undefined);
                    then = promise.then;
                    notify = function () {
                      then.call(promise, flush);
                    };
                  } else if (IS_NODE) {
                    notify = function () {
                      process.nextTick(flush);
                    };
                  } else {
                    notify = function () {
                      macrotask.call(
                        global,
                        flush
                      );
                    };
                  }
                }
                module.exports =
                  queueMicrotask ||
                  function (fn) {
                    var task = {
                      fn: fn,
                      next: undefined,
                    };
                    if (last) last.next = task;
                    if (!head) {
                      head = task;
                      notify();
                    }
                    last = task;
                  };

                /***/
              },
              /* 98 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var userAgent =
                  __w_pdfjs_require__(95);
                module.exports =
                  /web0s(?!.*chrome)/i.test(
                    userAgent
                  );

                /***/
              },
              /* 99 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var anObject =
                  __w_pdfjs_require__(27);
                var isObject =
                  __w_pdfjs_require__(21);
                var newPromiseCapability =
                  __w_pdfjs_require__(100);
                module.exports = function (C, x) {
                  anObject(C);
                  if (
                    isObject(x) &&
                    x.constructor === C
                  )
                    return x;
                  var promiseCapability =
                    newPromiseCapability.f(C);
                  var resolve =
                    promiseCapability.resolve;
                  resolve(x);
                  return promiseCapability.promise;
                };

                /***/
              },
              /* 100 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var aFunction =
                  __w_pdfjs_require__(76);
                var PromiseCapability = function (
                  C
                ) {
                  var resolve, reject;
                  this.promise = new C(function (
                    $$resolve,
                    $$reject
                  ) {
                    if (
                      resolve !== undefined ||
                      reject !== undefined
                    )
                      throw TypeError(
                        "Bad Promise constructor"
                      );
                    resolve = $$resolve;
                    reject = $$reject;
                  });
                  this.resolve =
                    aFunction(resolve);
                  this.reject = aFunction(reject);
                };
                module.exports.f = function (C) {
                  return new PromiseCapability(C);
                };

                /***/
              },
              /* 101 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                module.exports = function (a, b) {
                  var console = global.console;
                  if (console && console.error) {
                    arguments.length === 1
                      ? console.error(a)
                      : console.error(a, b);
                  }
                };

                /***/
              },
              /* 102 */
              /***/ function (module) {
                module.exports = function (exec) {
                  try {
                    return {
                      error: false,
                      value: exec(),
                    };
                  } catch (error) {
                    return {
                      error: true,
                      value: error,
                    };
                  }
                };

                /***/
              },
              /* 103 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var userAgent =
                  __w_pdfjs_require__(95);
                var process = global.process;
                var versions =
                  process && process.versions;
                var v8 = versions && versions.v8;
                var match, version;
                if (v8) {
                  match = v8.split(".");
                  version = match[0] + match[1];
                } else if (userAgent) {
                  match =
                    userAgent.match(
                      /Edge\/(\d+)/
                    );
                  if (!match || match[1] >= 74) {
                    match = userAgent.match(
                      /Chrome\/(\d+)/
                    );
                    if (match) version = match[1];
                  }
                }
                module.exports =
                  version && +version;

                /***/
              },
              /* 104 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var $ = __w_pdfjs_require__(9);
                var aFunction =
                  __w_pdfjs_require__(76);
                var newPromiseCapabilityModule =
                  __w_pdfjs_require__(100);
                var perform =
                  __w_pdfjs_require__(102);
                var iterate =
                  __w_pdfjs_require__(73);
                $(
                  {
                    target: "Promise",
                    stat: true,
                  },
                  {
                    allSettled:
                      function allSettled(
                        iterable
                      ) {
                        var C = this;
                        var capability =
                          newPromiseCapabilityModule.f(
                            C
                          );
                        var resolve =
                          capability.resolve;
                        var reject =
                          capability.reject;
                        var result = perform(
                          function () {
                            var promiseResolve =
                              aFunction(
                                C.resolve
                              );
                            var values = [];
                            var counter = 0;
                            var remaining = 1;
                            iterate(
                              iterable,
                              function (promise) {
                                var index =
                                  counter++;
                                var alreadyCalled = false;
                                values.push(
                                  undefined
                                );
                                remaining++;
                                promiseResolve
                                  .call(
                                    C,
                                    promise
                                  )
                                  .then(
                                    function (
                                      value
                                    ) {
                                      if (
                                        alreadyCalled
                                      )
                                        return;
                                      alreadyCalled = true;
                                      values[
                                        index
                                      ] = {
                                        status:
                                          "fulfilled",
                                        value:
                                          value,
                                      };
                                      --remaining ||
                                        resolve(
                                          values
                                        );
                                    },
                                    function (
                                      error
                                    ) {
                                      if (
                                        alreadyCalled
                                      )
                                        return;
                                      alreadyCalled = true;
                                      values[
                                        index
                                      ] = {
                                        status:
                                          "rejected",
                                        reason:
                                          error,
                                      };
                                      --remaining ||
                                        resolve(
                                          values
                                        );
                                    }
                                  );
                              }
                            );
                            --remaining ||
                              resolve(values);
                          }
                        );
                        if (result.error)
                          reject(result.value);
                        return capability.promise;
                      },
                  }
                );

                /***/
              },
              /* 105 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var $ = __w_pdfjs_require__(9);
                var aFunction =
                  __w_pdfjs_require__(76);
                var getBuiltIn =
                  __w_pdfjs_require__(41);
                var newPromiseCapabilityModule =
                  __w_pdfjs_require__(100);
                var perform =
                  __w_pdfjs_require__(102);
                var iterate =
                  __w_pdfjs_require__(73);
                var PROMISE_ANY_ERROR =
                  "No one promise resolved";
                $(
                  {
                    target: "Promise",
                    stat: true,
                  },
                  {
                    any: function any(iterable) {
                      var C = this;
                      var capability =
                        newPromiseCapabilityModule.f(
                          C
                        );
                      var resolve =
                        capability.resolve;
                      var reject =
                        capability.reject;
                      var result = perform(
                        function () {
                          var promiseResolve =
                            aFunction(C.resolve);
                          var errors = [];
                          var counter = 0;
                          var remaining = 1;
                          var alreadyResolved = false;
                          iterate(
                            iterable,
                            function (promise) {
                              var index =
                                counter++;
                              var alreadyRejected = false;
                              errors.push(
                                undefined
                              );
                              remaining++;
                              promiseResolve
                                .call(C, promise)
                                .then(
                                  function (
                                    value
                                  ) {
                                    if (
                                      alreadyRejected ||
                                      alreadyResolved
                                    )
                                      return;
                                    alreadyResolved = true;
                                    resolve(
                                      value
                                    );
                                  },
                                  function (
                                    error
                                  ) {
                                    if (
                                      alreadyRejected ||
                                      alreadyResolved
                                    )
                                      return;
                                    alreadyRejected = true;
                                    errors[
                                      index
                                    ] = error;
                                    --remaining ||
                                      reject(
                                        new (getBuiltIn(
                                          "AggregateError"
                                        ))(
                                          errors,
                                          PROMISE_ANY_ERROR
                                        )
                                      );
                                  }
                                );
                            }
                          );
                          --remaining ||
                            reject(
                              new (getBuiltIn(
                                "AggregateError"
                              ))(
                                errors,
                                PROMISE_ANY_ERROR
                              )
                            );
                        }
                      );
                      if (result.error)
                        reject(result.value);
                      return capability.promise;
                    },
                  }
                );

                /***/
              },
              /* 106 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var $ = __w_pdfjs_require__(9);
                var IS_PURE =
                  __w_pdfjs_require__(36);
                var NativePromise =
                  __w_pdfjs_require__(87);
                var fails =
                  __w_pdfjs_require__(13);
                var getBuiltIn =
                  __w_pdfjs_require__(41);
                var speciesConstructor =
                  __w_pdfjs_require__(92);
                var promiseResolve =
                  __w_pdfjs_require__(99);
                var redefine =
                  __w_pdfjs_require__(28);
                var NON_GENERIC =
                  !!NativePromise &&
                  fails(function () {
                    NativePromise.prototype[
                      "finally"
                    ].call(
                      {
                        then: function () {},
                      },
                      function () {}
                    );
                  });
                $(
                  {
                    target: "Promise",
                    proto: true,
                    real: true,
                    forced: NON_GENERIC,
                  },
                  {
                    finally: function (
                      onFinally
                    ) {
                      var C = speciesConstructor(
                        this,
                        getBuiltIn("Promise")
                      );
                      var isFunction =
                        typeof onFinally ==
                        "function";
                      return this.then(
                        isFunction
                          ? function (x) {
                              return promiseResolve(
                                C,
                                onFinally()
                              ).then(function () {
                                return x;
                              });
                            }
                          : onFinally,
                        isFunction
                          ? function (e) {
                              return promiseResolve(
                                C,
                                onFinally()
                              ).then(function () {
                                throw e;
                              });
                            }
                          : onFinally
                      );
                    },
                  }
                );
                if (
                  !IS_PURE &&
                  typeof NativePromise ==
                    "function" &&
                  !NativePromise.prototype[
                    "finally"
                  ]
                ) {
                  redefine(
                    NativePromise.prototype,
                    "finally",
                    getBuiltIn("Promise")
                      .prototype["finally"]
                  );
                }

                /***/
              },
              /* 107 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var charAt =
                  __w_pdfjs_require__(108).charAt;
                var InternalStateModule =
                  __w_pdfjs_require__(32);
                var defineIterator =
                  __w_pdfjs_require__(63);
                var STRING_ITERATOR =
                  "String Iterator";
                var setInternalState =
                  InternalStateModule.set;
                var getInternalState =
                  InternalStateModule.getterFor(
                    STRING_ITERATOR
                  );
                defineIterator(
                  String,
                  "String",
                  function (iterated) {
                    setInternalState(this, {
                      type: STRING_ITERATOR,
                      string: String(iterated),
                      index: 0,
                    });
                  },
                  function next() {
                    var state =
                      getInternalState(this);
                    var string = state.string;
                    var index = state.index;
                    var point;
                    if (index >= string.length)
                      return {
                        value: undefined,
                        done: true,
                      };
                    point = charAt(string, index);
                    state.index += point.length;
                    return {
                      value: point,
                      done: false,
                    };
                  }
                );

                /***/
              },
              /* 108 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var toInteger =
                  __w_pdfjs_require__(47);
                var requireObjectCoercible =
                  __w_pdfjs_require__(19);
                var createMethod = function (
                  CONVERT_TO_STRING
                ) {
                  return function ($this, pos) {
                    var S = String(
                      requireObjectCoercible(
                        $this
                      )
                    );
                    var position = toInteger(pos);
                    var size = S.length;
                    var first, second;
                    if (
                      position < 0 ||
                      position >= size
                    )
                      return CONVERT_TO_STRING
                        ? ""
                        : undefined;
                    first =
                      S.charCodeAt(position);
                    return first < 0xd800 ||
                      first > 0xdbff ||
                      position + 1 === size ||
                      (second = S.charCodeAt(
                        position + 1
                      )) < 0xdc00 ||
                      second > 0xdfff
                      ? CONVERT_TO_STRING
                        ? S.charAt(position)
                        : first
                      : CONVERT_TO_STRING
                      ? S.slice(
                          position,
                          position + 2
                        )
                      : ((first - 0xd800) << 10) +
                        (second - 0xdc00) +
                        0x10000;
                  };
                };
                module.exports = {
                  codeAt: createMethod(false),
                  charAt: createMethod(true),
                };

                /***/
              },
              /* 109 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var DOMIterables =
                  __w_pdfjs_require__(110);
                var ArrayIteratorMethods =
                  __w_pdfjs_require__(53);
                var createNonEnumerableProperty =
                  __w_pdfjs_require__(25);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var ITERATOR =
                  wellKnownSymbol("iterator");
                var TO_STRING_TAG =
                  wellKnownSymbol("toStringTag");
                var ArrayValues =
                  ArrayIteratorMethods.values;
                for (var COLLECTION_NAME in DOMIterables) {
                  var Collection =
                    global[COLLECTION_NAME];
                  var CollectionPrototype =
                    Collection &&
                    Collection.prototype;
                  if (CollectionPrototype) {
                    if (
                      CollectionPrototype[
                        ITERATOR
                      ] !== ArrayValues
                    )
                      try {
                        createNonEnumerableProperty(
                          CollectionPrototype,
                          ITERATOR,
                          ArrayValues
                        );
                      } catch (error) {
                        CollectionPrototype[
                          ITERATOR
                        ] = ArrayValues;
                      }
                    if (
                      !CollectionPrototype[
                        TO_STRING_TAG
                      ]
                    ) {
                      createNonEnumerableProperty(
                        CollectionPrototype,
                        TO_STRING_TAG,
                        COLLECTION_NAME
                      );
                    }
                    if (
                      DOMIterables[
                        COLLECTION_NAME
                      ]
                    )
                      for (var METHOD_NAME in ArrayIteratorMethods) {
                        if (
                          CollectionPrototype[
                            METHOD_NAME
                          ] !==
                          ArrayIteratorMethods[
                            METHOD_NAME
                          ]
                        )
                          try {
                            createNonEnumerableProperty(
                              CollectionPrototype,
                              METHOD_NAME,
                              ArrayIteratorMethods[
                                METHOD_NAME
                              ]
                            );
                          } catch (error) {
                            CollectionPrototype[
                              METHOD_NAME
                            ] =
                              ArrayIteratorMethods[
                                METHOD_NAME
                              ];
                          }
                      }
                  }
                }

                /***/
              },
              /* 110 */
              /***/ function (module) {
                module.exports = {
                  CSSRuleList: 0,
                  CSSStyleDeclaration: 0,
                  CSSValueList: 0,
                  ClientRectList: 0,
                  DOMRectList: 0,
                  DOMStringList: 0,
                  DOMTokenList: 1,
                  DataTransferItemList: 0,
                  FileList: 0,
                  HTMLAllCollection: 0,
                  HTMLCollection: 0,
                  HTMLFormElement: 0,
                  HTMLSelectElement: 0,
                  MediaList: 0,
                  MimeTypeArray: 0,
                  NamedNodeMap: 0,
                  NodeList: 1,
                  PaintRequestList: 0,
                  Plugin: 0,
                  PluginArray: 0,
                  SVGLengthList: 0,
                  SVGNumberList: 0,
                  SVGPathSegList: 0,
                  SVGPointList: 0,
                  SVGStringList: 0,
                  SVGTransformList: 0,
                  SourceBufferList: 0,
                  StyleSheetList: 0,
                  TextTrackCueList: 0,
                  TextTrackList: 0,
                  TouchList: 0,
                };

                /***/
              },
              /* 111 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                __w_pdfjs_require__(112);
                __w_pdfjs_require__(120);
                __w_pdfjs_require__(118);
                var path =
                  __w_pdfjs_require__(42);
                module.exports = path.URL;

                /***/
              },
              /* 112 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                __w_pdfjs_require__(107);
                var $ = __w_pdfjs_require__(9);
                var DESCRIPTORS =
                  __w_pdfjs_require__(12);
                var USE_NATIVE_URL =
                  __w_pdfjs_require__(113);
                var global =
                  __w_pdfjs_require__(10);
                var defineProperties =
                  __w_pdfjs_require__(59);
                var redefine =
                  __w_pdfjs_require__(28);
                var anInstance =
                  __w_pdfjs_require__(90);
                var has = __w_pdfjs_require__(22);
                var assign =
                  __w_pdfjs_require__(114);
                var arrayFrom =
                  __w_pdfjs_require__(115);
                var codeAt =
                  __w_pdfjs_require__(108).codeAt;
                var toASCII =
                  __w_pdfjs_require__(117);
                var setToStringTag =
                  __w_pdfjs_require__(69);
                var URLSearchParamsModule =
                  __w_pdfjs_require__(118);
                var InternalStateModule =
                  __w_pdfjs_require__(32);
                var NativeURL = global.URL;
                var URLSearchParams =
                  URLSearchParamsModule.URLSearchParams;
                var getInternalSearchParamsState =
                  URLSearchParamsModule.getState;
                var setInternalState =
                  InternalStateModule.set;
                var getInternalURLState =
                  InternalStateModule.getterFor(
                    "URL"
                  );
                var floor = Math.floor;
                var pow = Math.pow;
                var INVALID_AUTHORITY =
                  "Invalid authority";
                var INVALID_SCHEME =
                  "Invalid scheme";
                var INVALID_HOST = "Invalid host";
                var INVALID_PORT = "Invalid port";
                var ALPHA = /[A-Za-z]/;
                var ALPHANUMERIC =
                  /[\d+-.A-Za-z]/;
                var DIGIT = /\d/;
                var HEX_START = /^(0x|0X)/;
                var OCT = /^[0-7]+$/;
                var DEC = /^\d+$/;
                var HEX = /^[\dA-Fa-f]+$/;
                var FORBIDDEN_HOST_CODE_POINT =
                  /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
                var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT =
                  /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
                var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE =
                  /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
                var TAB_AND_NEW_LINE =
                  /[\u0009\u000A\u000D]/g;
                var EOF;
                var parseHost = function (
                  url,
                  input
                ) {
                  var result, codePoints, index;
                  if (input.charAt(0) == "[") {
                    if (
                      input.charAt(
                        input.length - 1
                      ) != "]"
                    )
                      return INVALID_HOST;
                    result = parseIPv6(
                      input.slice(1, -1)
                    );
                    if (!result)
                      return INVALID_HOST;
                    url.host = result;
                  } else if (!isSpecial(url)) {
                    if (
                      FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(
                        input
                      )
                    )
                      return INVALID_HOST;
                    result = "";
                    codePoints = arrayFrom(input);
                    for (
                      index = 0;
                      index < codePoints.length;
                      index++
                    ) {
                      result += percentEncode(
                        codePoints[index],
                        C0ControlPercentEncodeSet
                      );
                    }
                    url.host = result;
                  } else {
                    input = toASCII(input);
                    if (
                      FORBIDDEN_HOST_CODE_POINT.test(
                        input
                      )
                    )
                      return INVALID_HOST;
                    result = parseIPv4(input);
                    if (result === null)
                      return INVALID_HOST;
                    url.host = result;
                  }
                };
                var parseIPv4 = function (input) {
                  var parts = input.split(".");
                  var partsLength,
                    numbers,
                    index,
                    part,
                    radix,
                    number,
                    ipv4;
                  if (
                    parts.length &&
                    parts[parts.length - 1] == ""
                  ) {
                    parts.pop();
                  }
                  partsLength = parts.length;
                  if (partsLength > 4)
                    return input;
                  numbers = [];
                  for (
                    index = 0;
                    index < partsLength;
                    index++
                  ) {
                    part = parts[index];
                    if (part == "") return input;
                    radix = 10;
                    if (
                      part.length > 1 &&
                      part.charAt(0) == "0"
                    ) {
                      radix = HEX_START.test(part)
                        ? 16
                        : 8;
                      part = part.slice(
                        radix == 8 ? 1 : 2
                      );
                    }
                    if (part === "") {
                      number = 0;
                    } else {
                      if (
                        !(
                          radix == 10
                            ? DEC
                            : radix == 8
                            ? OCT
                            : HEX
                        ).test(part)
                      )
                        return input;
                      number = parseInt(
                        part,
                        radix
                      );
                    }
                    numbers.push(number);
                  }
                  for (
                    index = 0;
                    index < partsLength;
                    index++
                  ) {
                    number = numbers[index];
                    if (
                      index ==
                      partsLength - 1
                    ) {
                      if (
                        number >=
                        pow(256, 5 - partsLength)
                      )
                        return null;
                    } else if (number > 255)
                      return null;
                  }
                  ipv4 = numbers.pop();
                  for (
                    index = 0;
                    index < numbers.length;
                    index++
                  ) {
                    ipv4 +=
                      numbers[index] *
                      pow(256, 3 - index);
                  }
                  return ipv4;
                };
                var parseIPv6 = function (input) {
                  var address = [
                    0, 0, 0, 0, 0, 0, 0, 0,
                  ];
                  var pieceIndex = 0;
                  var compress = null;
                  var pointer = 0;
                  var value,
                    length,
                    numbersSeen,
                    ipv4Piece,
                    number,
                    swaps,
                    swap;
                  var char = function () {
                    return input.charAt(pointer);
                  };
                  if (char() == ":") {
                    if (input.charAt(1) != ":")
                      return;
                    pointer += 2;
                    pieceIndex++;
                    compress = pieceIndex;
                  }
                  while (char()) {
                    if (pieceIndex == 8) return;
                    if (char() == ":") {
                      if (compress !== null)
                        return;
                      pointer++;
                      pieceIndex++;
                      compress = pieceIndex;
                      continue;
                    }
                    value = length = 0;
                    while (
                      length < 4 &&
                      HEX.test(char())
                    ) {
                      value =
                        value * 16 +
                        parseInt(char(), 16);
                      pointer++;
                      length++;
                    }
                    if (char() == ".") {
                      if (length == 0) return;
                      pointer -= length;
                      if (pieceIndex > 6) return;
                      numbersSeen = 0;
                      while (char()) {
                        ipv4Piece = null;
                        if (numbersSeen > 0) {
                          if (
                            char() == "." &&
                            numbersSeen < 4
                          )
                            pointer++;
                          else return;
                        }
                        if (!DIGIT.test(char()))
                          return;
                        while (
                          DIGIT.test(char())
                        ) {
                          number = parseInt(
                            char(),
                            10
                          );
                          if (ipv4Piece === null)
                            ipv4Piece = number;
                          else if (ipv4Piece == 0)
                            return;
                          else
                            ipv4Piece =
                              ipv4Piece * 10 +
                              number;
                          if (ipv4Piece > 255)
                            return;
                          pointer++;
                        }
                        address[pieceIndex] =
                          address[pieceIndex] *
                            256 +
                          ipv4Piece;
                        numbersSeen++;
                        if (
                          numbersSeen == 2 ||
                          numbersSeen == 4
                        )
                          pieceIndex++;
                      }
                      if (numbersSeen != 4)
                        return;
                      break;
                    } else if (char() == ":") {
                      pointer++;
                      if (!char()) return;
                    } else if (char()) return;
                    address[pieceIndex++] = value;
                  }
                  if (compress !== null) {
                    swaps = pieceIndex - compress;
                    pieceIndex = 7;
                    while (
                      pieceIndex != 0 &&
                      swaps > 0
                    ) {
                      swap = address[pieceIndex];
                      address[pieceIndex--] =
                        address[
                          compress + swaps - 1
                        ];
                      address[
                        compress + --swaps
                      ] = swap;
                    }
                  } else if (pieceIndex != 8)
                    return;
                  return address;
                };
                var findLongestZeroSequence =
                  function (ipv6) {
                    var maxIndex = null;
                    var maxLength = 1;
                    var currStart = null;
                    var currLength = 0;
                    var index = 0;
                    for (; index < 8; index++) {
                      if (ipv6[index] !== 0) {
                        if (
                          currLength > maxLength
                        ) {
                          maxIndex = currStart;
                          maxLength = currLength;
                        }
                        currStart = null;
                        currLength = 0;
                      } else {
                        if (currStart === null)
                          currStart = index;
                        ++currLength;
                      }
                    }
                    if (currLength > maxLength) {
                      maxIndex = currStart;
                      maxLength = currLength;
                    }
                    return maxIndex;
                  };
                var serializeHost = function (
                  host
                ) {
                  var result,
                    index,
                    compress,
                    ignore0;
                  if (typeof host == "number") {
                    result = [];
                    for (
                      index = 0;
                      index < 4;
                      index++
                    ) {
                      result.unshift(host % 256);
                      host = floor(host / 256);
                    }
                    return result.join(".");
                  } else if (
                    typeof host == "object"
                  ) {
                    result = "";
                    compress =
                      findLongestZeroSequence(
                        host
                      );
                    for (
                      index = 0;
                      index < 8;
                      index++
                    ) {
                      if (
                        ignore0 &&
                        host[index] === 0
                      )
                        continue;
                      if (ignore0)
                        ignore0 = false;
                      if (compress === index) {
                        result += index
                          ? ":"
                          : "::";
                        ignore0 = true;
                      } else {
                        result +=
                          host[index].toString(
                            16
                          );
                        if (index < 7)
                          result += ":";
                      }
                    }
                    return "[" + result + "]";
                  }
                  return host;
                };
                var C0ControlPercentEncodeSet =
                  {};
                var fragmentPercentEncodeSet =
                  assign(
                    {},
                    C0ControlPercentEncodeSet,
                    {
                      " ": 1,
                      '"': 1,
                      "<": 1,
                      ">": 1,
                      "`": 1,
                    }
                  );
                var pathPercentEncodeSet = assign(
                  {},
                  fragmentPercentEncodeSet,
                  {
                    "#": 1,
                    "?": 1,
                    "{": 1,
                    "}": 1,
                  }
                );
                var userinfoPercentEncodeSet =
                  assign(
                    {},
                    pathPercentEncodeSet,
                    {
                      "/": 1,
                      ":": 1,
                      ";": 1,
                      "=": 1,
                      "@": 1,
                      "[": 1,
                      "\\": 1,
                      "]": 1,
                      "^": 1,
                      "|": 1,
                    }
                  );
                var percentEncode = function (
                  char,
                  set
                ) {
                  var code = codeAt(char, 0);
                  return code > 0x20 &&
                    code < 0x7f &&
                    !has(set, char)
                    ? char
                    : encodeURIComponent(char);
                };
                var specialSchemes = {
                  ftp: 21,
                  file: null,
                  http: 80,
                  https: 443,
                  ws: 80,
                  wss: 443,
                };
                var isSpecial = function (url) {
                  return has(
                    specialSchemes,
                    url.scheme
                  );
                };
                var includesCredentials =
                  function (url) {
                    return (
                      url.username != "" ||
                      url.password != ""
                    );
                  };
                var cannotHaveUsernamePasswordPort =
                  function (url) {
                    return (
                      !url.host ||
                      url.cannotBeABaseURL ||
                      url.scheme == "file"
                    );
                  };
                var isWindowsDriveLetter =
                  function (string, normalized) {
                    var second;
                    return (
                      string.length == 2 &&
                      ALPHA.test(
                        string.charAt(0)
                      ) &&
                      ((second =
                        string.charAt(1)) ==
                        ":" ||
                        (!normalized &&
                          second == "|"))
                    );
                  };
                var startsWithWindowsDriveLetter =
                  function (string) {
                    var third;
                    return (
                      string.length > 1 &&
                      isWindowsDriveLetter(
                        string.slice(0, 2)
                      ) &&
                      (string.length == 2 ||
                        (third =
                          string.charAt(2)) ===
                          "/" ||
                        third === "\\" ||
                        third === "?" ||
                        third === "#")
                    );
                  };
                var shortenURLsPath = function (
                  url
                ) {
                  var path = url.path;
                  var pathSize = path.length;
                  if (
                    pathSize &&
                    (url.scheme != "file" ||
                      pathSize != 1 ||
                      !isWindowsDriveLetter(
                        path[0],
                        true
                      ))
                  ) {
                    path.pop();
                  }
                };
                var isSingleDot = function (
                  segment
                ) {
                  return (
                    segment === "." ||
                    segment.toLowerCase() ===
                      "%2e"
                  );
                };
                var isDoubleDot = function (
                  segment
                ) {
                  segment = segment.toLowerCase();
                  return (
                    segment === ".." ||
                    segment === "%2e." ||
                    segment === ".%2e" ||
                    segment === "%2e%2e"
                  );
                };
                var SCHEME_START = {};
                var SCHEME = {};
                var NO_SCHEME = {};
                var SPECIAL_RELATIVE_OR_AUTHORITY =
                  {};
                var PATH_OR_AUTHORITY = {};
                var RELATIVE = {};
                var RELATIVE_SLASH = {};
                var SPECIAL_AUTHORITY_SLASHES =
                  {};
                var SPECIAL_AUTHORITY_IGNORE_SLASHES =
                  {};
                var AUTHORITY = {};
                var HOST = {};
                var HOSTNAME = {};
                var PORT = {};
                var FILE = {};
                var FILE_SLASH = {};
                var FILE_HOST = {};
                var PATH_START = {};
                var PATH = {};
                var CANNOT_BE_A_BASE_URL_PATH =
                  {};
                var QUERY = {};
                var FRAGMENT = {};
                var parseURL = function (
                  url,
                  input,
                  stateOverride,
                  base
                ) {
                  var state =
                    stateOverride || SCHEME_START;
                  var pointer = 0;
                  var buffer = "";
                  var seenAt = false;
                  var seenBracket = false;
                  var seenPasswordToken = false;
                  var codePoints,
                    char,
                    bufferCodePoints,
                    failure;
                  if (!stateOverride) {
                    url.scheme = "";
                    url.username = "";
                    url.password = "";
                    url.host = null;
                    url.port = null;
                    url.path = [];
                    url.query = null;
                    url.fragment = null;
                    url.cannotBeABaseURL = false;
                    input = input.replace(
                      LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE,
                      ""
                    );
                  }
                  input = input.replace(
                    TAB_AND_NEW_LINE,
                    ""
                  );
                  codePoints = arrayFrom(input);
                  while (
                    pointer <= codePoints.length
                  ) {
                    char = codePoints[pointer];
                    switch (state) {
                      case SCHEME_START:
                        if (
                          char &&
                          ALPHA.test(char)
                        ) {
                          buffer +=
                            char.toLowerCase();
                          state = SCHEME;
                        } else if (
                          !stateOverride
                        ) {
                          state = NO_SCHEME;
                          continue;
                        } else
                          return INVALID_SCHEME;
                        break;
                      case SCHEME:
                        if (
                          char &&
                          (ALPHANUMERIC.test(
                            char
                          ) ||
                            char == "+" ||
                            char == "-" ||
                            char == ".")
                        ) {
                          buffer +=
                            char.toLowerCase();
                        } else if (char == ":") {
                          if (
                            stateOverride &&
                            (isSpecial(url) !=
                              has(
                                specialSchemes,
                                buffer
                              ) ||
                              (buffer == "file" &&
                                (includesCredentials(
                                  url
                                ) ||
                                  url.port !==
                                    null)) ||
                              (url.scheme ==
                                "file" &&
                                !url.host))
                          )
                            return;
                          url.scheme = buffer;
                          if (stateOverride) {
                            if (
                              isSpecial(url) &&
                              specialSchemes[
                                url.scheme
                              ] == url.port
                            )
                              url.port = null;
                            return;
                          }
                          buffer = "";
                          if (
                            url.scheme == "file"
                          ) {
                            state = FILE;
                          } else if (
                            isSpecial(url) &&
                            base &&
                            base.scheme ==
                              url.scheme
                          ) {
                            state =
                              SPECIAL_RELATIVE_OR_AUTHORITY;
                          } else if (
                            isSpecial(url)
                          ) {
                            state =
                              SPECIAL_AUTHORITY_SLASHES;
                          } else if (
                            codePoints[
                              pointer + 1
                            ] == "/"
                          ) {
                            state =
                              PATH_OR_AUTHORITY;
                            pointer++;
                          } else {
                            url.cannotBeABaseURL = true;
                            url.path.push("");
                            state =
                              CANNOT_BE_A_BASE_URL_PATH;
                          }
                        } else if (
                          !stateOverride
                        ) {
                          buffer = "";
                          state = NO_SCHEME;
                          pointer = 0;
                          continue;
                        } else
                          return INVALID_SCHEME;
                        break;
                      case NO_SCHEME:
                        if (
                          !base ||
                          (base.cannotBeABaseURL &&
                            char != "#")
                        )
                          return INVALID_SCHEME;
                        if (
                          base.cannotBeABaseURL &&
                          char == "#"
                        ) {
                          url.scheme =
                            base.scheme;
                          url.path =
                            base.path.slice();
                          url.query = base.query;
                          url.fragment = "";
                          url.cannotBeABaseURL = true;
                          state = FRAGMENT;
                          break;
                        }
                        state =
                          base.scheme == "file"
                            ? FILE
                            : RELATIVE;
                        continue;
                      case SPECIAL_RELATIVE_OR_AUTHORITY:
                        if (
                          char == "/" &&
                          codePoints[
                            pointer + 1
                          ] == "/"
                        ) {
                          state =
                            SPECIAL_AUTHORITY_IGNORE_SLASHES;
                          pointer++;
                        } else {
                          state = RELATIVE;
                          continue;
                        }
                        break;
                      case PATH_OR_AUTHORITY:
                        if (char == "/") {
                          state = AUTHORITY;
                          break;
                        } else {
                          state = PATH;
                          continue;
                        }
                      case RELATIVE:
                        url.scheme = base.scheme;
                        if (char == EOF) {
                          url.username =
                            base.username;
                          url.password =
                            base.password;
                          url.host = base.host;
                          url.port = base.port;
                          url.path =
                            base.path.slice();
                          url.query = base.query;
                        } else if (
                          char == "/" ||
                          (char == "\\" &&
                            isSpecial(url))
                        ) {
                          state = RELATIVE_SLASH;
                        } else if (char == "?") {
                          url.username =
                            base.username;
                          url.password =
                            base.password;
                          url.host = base.host;
                          url.port = base.port;
                          url.path =
                            base.path.slice();
                          url.query = "";
                          state = QUERY;
                        } else if (char == "#") {
                          url.username =
                            base.username;
                          url.password =
                            base.password;
                          url.host = base.host;
                          url.port = base.port;
                          url.path =
                            base.path.slice();
                          url.query = base.query;
                          url.fragment = "";
                          state = FRAGMENT;
                        } else {
                          url.username =
                            base.username;
                          url.password =
                            base.password;
                          url.host = base.host;
                          url.port = base.port;
                          url.path =
                            base.path.slice();
                          url.path.pop();
                          state = PATH;
                          continue;
                        }
                        break;
                      case RELATIVE_SLASH:
                        if (
                          isSpecial(url) &&
                          (char == "/" ||
                            char == "\\")
                        ) {
                          state =
                            SPECIAL_AUTHORITY_IGNORE_SLASHES;
                        } else if (char == "/") {
                          state = AUTHORITY;
                        } else {
                          url.username =
                            base.username;
                          url.password =
                            base.password;
                          url.host = base.host;
                          url.port = base.port;
                          state = PATH;
                          continue;
                        }
                        break;
                      case SPECIAL_AUTHORITY_SLASHES:
                        state =
                          SPECIAL_AUTHORITY_IGNORE_SLASHES;
                        if (
                          char != "/" ||
                          buffer.charAt(
                            pointer + 1
                          ) != "/"
                        )
                          continue;
                        pointer++;
                        break;
                      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                        if (
                          char != "/" &&
                          char != "\\"
                        ) {
                          state = AUTHORITY;
                          continue;
                        }
                        break;
                      case AUTHORITY:
                        if (char == "@") {
                          if (seenAt)
                            buffer =
                              "%40" + buffer;
                          seenAt = true;
                          bufferCodePoints =
                            arrayFrom(buffer);
                          for (
                            var i = 0;
                            i <
                            bufferCodePoints.length;
                            i++
                          ) {
                            var codePoint =
                              bufferCodePoints[i];
                            if (
                              codePoint == ":" &&
                              !seenPasswordToken
                            ) {
                              seenPasswordToken = true;
                              continue;
                            }
                            var encodedCodePoints =
                              percentEncode(
                                codePoint,
                                userinfoPercentEncodeSet
                              );
                            if (seenPasswordToken)
                              url.password +=
                                encodedCodePoints;
                            else
                              url.username +=
                                encodedCodePoints;
                          }
                          buffer = "";
                        } else if (
                          char == EOF ||
                          char == "/" ||
                          char == "?" ||
                          char == "#" ||
                          (char == "\\" &&
                            isSpecial(url))
                        ) {
                          if (
                            seenAt &&
                            buffer == ""
                          )
                            return INVALID_AUTHORITY;
                          pointer -=
                            arrayFrom(buffer)
                              .length + 1;
                          buffer = "";
                          state = HOST;
                        } else buffer += char;
                        break;
                      case HOST:
                      case HOSTNAME:
                        if (
                          stateOverride &&
                          url.scheme == "file"
                        ) {
                          state = FILE_HOST;
                          continue;
                        } else if (
                          char == ":" &&
                          !seenBracket
                        ) {
                          if (buffer == "")
                            return INVALID_HOST;
                          failure = parseHost(
                            url,
                            buffer
                          );
                          if (failure)
                            return failure;
                          buffer = "";
                          state = PORT;
                          if (
                            stateOverride ==
                            HOSTNAME
                          )
                            return;
                        } else if (
                          char == EOF ||
                          char == "/" ||
                          char == "?" ||
                          char == "#" ||
                          (char == "\\" &&
                            isSpecial(url))
                        ) {
                          if (
                            isSpecial(url) &&
                            buffer == ""
                          )
                            return INVALID_HOST;
                          if (
                            stateOverride &&
                            buffer == "" &&
                            (includesCredentials(
                              url
                            ) ||
                              url.port !== null)
                          )
                            return;
                          failure = parseHost(
                            url,
                            buffer
                          );
                          if (failure)
                            return failure;
                          buffer = "";
                          state = PATH_START;
                          if (stateOverride)
                            return;
                          continue;
                        } else {
                          if (char == "[")
                            seenBracket = true;
                          else if (char == "]")
                            seenBracket = false;
                          buffer += char;
                        }
                        break;
                      case PORT:
                        if (DIGIT.test(char)) {
                          buffer += char;
                        } else if (
                          char == EOF ||
                          char == "/" ||
                          char == "?" ||
                          char == "#" ||
                          (char == "\\" &&
                            isSpecial(url)) ||
                          stateOverride
                        ) {
                          if (buffer != "") {
                            var port = parseInt(
                              buffer,
                              10
                            );
                            if (port > 0xffff)
                              return INVALID_PORT;
                            url.port =
                              isSpecial(url) &&
                              port ===
                                specialSchemes[
                                  url.scheme
                                ]
                                ? null
                                : port;
                            buffer = "";
                          }
                          if (stateOverride)
                            return;
                          state = PATH_START;
                          continue;
                        } else
                          return INVALID_PORT;
                        break;
                      case FILE:
                        url.scheme = "file";
                        if (
                          char == "/" ||
                          char == "\\"
                        )
                          state = FILE_SLASH;
                        else if (
                          base &&
                          base.scheme == "file"
                        ) {
                          if (char == EOF) {
                            url.host = base.host;
                            url.path =
                              base.path.slice();
                            url.query =
                              base.query;
                          } else if (
                            char == "?"
                          ) {
                            url.host = base.host;
                            url.path =
                              base.path.slice();
                            url.query = "";
                            state = QUERY;
                          } else if (
                            char == "#"
                          ) {
                            url.host = base.host;
                            url.path =
                              base.path.slice();
                            url.query =
                              base.query;
                            url.fragment = "";
                            state = FRAGMENT;
                          } else {
                            if (
                              !startsWithWindowsDriveLetter(
                                codePoints
                                  .slice(pointer)
                                  .join("")
                              )
                            ) {
                              url.host =
                                base.host;
                              url.path =
                                base.path.slice();
                              shortenURLsPath(
                                url
                              );
                            }
                            state = PATH;
                            continue;
                          }
                        } else {
                          state = PATH;
                          continue;
                        }
                        break;
                      case FILE_SLASH:
                        if (
                          char == "/" ||
                          char == "\\"
                        ) {
                          state = FILE_HOST;
                          break;
                        }
                        if (
                          base &&
                          base.scheme == "file" &&
                          !startsWithWindowsDriveLetter(
                            codePoints
                              .slice(pointer)
                              .join("")
                          )
                        ) {
                          if (
                            isWindowsDriveLetter(
                              base.path[0],
                              true
                            )
                          )
                            url.path.push(
                              base.path[0]
                            );
                          else
                            url.host = base.host;
                        }
                        state = PATH;
                        continue;
                      case FILE_HOST:
                        if (
                          char == EOF ||
                          char == "/" ||
                          char == "\\" ||
                          char == "?" ||
                          char == "#"
                        ) {
                          if (
                            !stateOverride &&
                            isWindowsDriveLetter(
                              buffer
                            )
                          ) {
                            state = PATH;
                          } else if (
                            buffer == ""
                          ) {
                            url.host = "";
                            if (stateOverride)
                              return;
                            state = PATH_START;
                          } else {
                            failure = parseHost(
                              url,
                              buffer
                            );
                            if (failure)
                              return failure;
                            if (
                              url.host ==
                              "localhost"
                            )
                              url.host = "";
                            if (stateOverride)
                              return;
                            buffer = "";
                            state = PATH_START;
                          }
                          continue;
                        } else buffer += char;
                        break;
                      case PATH_START:
                        if (isSpecial(url)) {
                          state = PATH;
                          if (
                            char != "/" &&
                            char != "\\"
                          )
                            continue;
                        } else if (
                          !stateOverride &&
                          char == "?"
                        ) {
                          url.query = "";
                          state = QUERY;
                        } else if (
                          !stateOverride &&
                          char == "#"
                        ) {
                          url.fragment = "";
                          state = FRAGMENT;
                        } else if (char != EOF) {
                          state = PATH;
                          if (char != "/")
                            continue;
                        }
                        break;
                      case PATH:
                        if (
                          char == EOF ||
                          char == "/" ||
                          (char == "\\" &&
                            isSpecial(url)) ||
                          (!stateOverride &&
                            (char == "?" ||
                              char == "#"))
                        ) {
                          if (
                            isDoubleDot(buffer)
                          ) {
                            shortenURLsPath(url);
                            if (
                              char != "/" &&
                              !(
                                char == "\\" &&
                                isSpecial(url)
                              )
                            ) {
                              url.path.push("");
                            }
                          } else if (
                            isSingleDot(buffer)
                          ) {
                            if (
                              char != "/" &&
                              !(
                                char == "\\" &&
                                isSpecial(url)
                              )
                            ) {
                              url.path.push("");
                            }
                          } else {
                            if (
                              url.scheme ==
                                "file" &&
                              !url.path.length &&
                              isWindowsDriveLetter(
                                buffer
                              )
                            ) {
                              if (url.host)
                                url.host = "";
                              buffer =
                                buffer.charAt(0) +
                                ":";
                            }
                            url.path.push(buffer);
                          }
                          buffer = "";
                          if (
                            url.scheme ==
                              "file" &&
                            (char == EOF ||
                              char == "?" ||
                              char == "#")
                          ) {
                            while (
                              url.path.length >
                                1 &&
                              url.path[0] === ""
                            ) {
                              url.path.shift();
                            }
                          }
                          if (char == "?") {
                            url.query = "";
                            state = QUERY;
                          } else if (
                            char == "#"
                          ) {
                            url.fragment = "";
                            state = FRAGMENT;
                          }
                        } else {
                          buffer += percentEncode(
                            char,
                            pathPercentEncodeSet
                          );
                        }
                        break;
                      case CANNOT_BE_A_BASE_URL_PATH:
                        if (char == "?") {
                          url.query = "";
                          state = QUERY;
                        } else if (char == "#") {
                          url.fragment = "";
                          state = FRAGMENT;
                        } else if (char != EOF) {
                          url.path[0] +=
                            percentEncode(
                              char,
                              C0ControlPercentEncodeSet
                            );
                        }
                        break;
                      case QUERY:
                        if (
                          !stateOverride &&
                          char == "#"
                        ) {
                          url.fragment = "";
                          state = FRAGMENT;
                        } else if (char != EOF) {
                          if (
                            char == "'" &&
                            isSpecial(url)
                          )
                            url.query += "%27";
                          else if (char == "#")
                            url.query += "%23";
                          else
                            url.query +=
                              percentEncode(
                                char,
                                C0ControlPercentEncodeSet
                              );
                        }
                        break;
                      case FRAGMENT:
                        if (char != EOF)
                          url.fragment +=
                            percentEncode(
                              char,
                              fragmentPercentEncodeSet
                            );
                        break;
                    }
                    pointer++;
                  }
                };
                var URLConstructor = function URL(
                  url
                ) {
                  var that = anInstance(
                    this,
                    URLConstructor,
                    "URL"
                  );
                  var base =
                    arguments.length > 1
                      ? arguments[1]
                      : undefined;
                  var urlString = String(url);
                  var state = setInternalState(
                    that,
                    { type: "URL" }
                  );
                  var baseState, failure;
                  if (base !== undefined) {
                    if (
                      base instanceof
                      URLConstructor
                    )
                      baseState =
                        getInternalURLState(base);
                    else {
                      failure = parseURL(
                        (baseState = {}),
                        String(base)
                      );
                      if (failure)
                        throw TypeError(failure);
                    }
                  }
                  failure = parseURL(
                    state,
                    urlString,
                    null,
                    baseState
                  );
                  if (failure)
                    throw TypeError(failure);
                  var searchParams =
                    (state.searchParams =
                      new URLSearchParams());
                  var searchParamsState =
                    getInternalSearchParamsState(
                      searchParams
                    );
                  searchParamsState.updateSearchParams(
                    state.query
                  );
                  searchParamsState.updateURL =
                    function () {
                      state.query =
                        String(searchParams) ||
                        null;
                    };
                  if (!DESCRIPTORS) {
                    that.href =
                      serializeURL.call(that);
                    that.origin =
                      getOrigin.call(that);
                    that.protocol =
                      getProtocol.call(that);
                    that.username =
                      getUsername.call(that);
                    that.password =
                      getPassword.call(that);
                    that.host =
                      getHost.call(that);
                    that.hostname =
                      getHostname.call(that);
                    that.port =
                      getPort.call(that);
                    that.pathname =
                      getPathname.call(that);
                    that.search =
                      getSearch.call(that);
                    that.searchParams =
                      getSearchParams.call(that);
                    that.hash =
                      getHash.call(that);
                  }
                };
                var URLPrototype =
                  URLConstructor.prototype;
                var serializeURL = function () {
                  var url =
                    getInternalURLState(this);
                  var scheme = url.scheme;
                  var username = url.username;
                  var password = url.password;
                  var host = url.host;
                  var port = url.port;
                  var path = url.path;
                  var query = url.query;
                  var fragment = url.fragment;
                  var output = scheme + ":";
                  if (host !== null) {
                    output += "//";
                    if (
                      includesCredentials(url)
                    ) {
                      output +=
                        username +
                        (password
                          ? ":" + password
                          : "") +
                        "@";
                    }
                    output += serializeHost(host);
                    if (port !== null)
                      output += ":" + port;
                  } else if (scheme == "file")
                    output += "//";
                  output += url.cannotBeABaseURL
                    ? path[0]
                    : path.length
                    ? "/" + path.join("/")
                    : "";
                  if (query !== null)
                    output += "?" + query;
                  if (fragment !== null)
                    output += "#" + fragment;
                  return output;
                };
                var getOrigin = function () {
                  var url =
                    getInternalURLState(this);
                  var scheme = url.scheme;
                  var port = url.port;
                  if (scheme == "blob")
                    try {
                      return new URL(
                        scheme.path[0]
                      ).origin;
                    } catch (error) {
                      return "null";
                    }
                  if (
                    scheme == "file" ||
                    !isSpecial(url)
                  )
                    return "null";
                  return (
                    scheme +
                    "://" +
                    serializeHost(url.host) +
                    (port !== null
                      ? ":" + port
                      : "")
                  );
                };
                var getProtocol = function () {
                  return (
                    getInternalURLState(this)
                      .scheme + ":"
                  );
                };
                var getUsername = function () {
                  return getInternalURLState(this)
                    .username;
                };
                var getPassword = function () {
                  return getInternalURLState(this)
                    .password;
                };
                var getHost = function () {
                  var url =
                    getInternalURLState(this);
                  var host = url.host;
                  var port = url.port;
                  return host === null
                    ? ""
                    : port === null
                    ? serializeHost(host)
                    : serializeHost(host) +
                      ":" +
                      port;
                };
                var getHostname = function () {
                  var host =
                    getInternalURLState(
                      this
                    ).host;
                  return host === null
                    ? ""
                    : serializeHost(host);
                };
                var getPort = function () {
                  var port =
                    getInternalURLState(
                      this
                    ).port;
                  return port === null
                    ? ""
                    : String(port);
                };
                var getPathname = function () {
                  var url =
                    getInternalURLState(this);
                  var path = url.path;
                  return url.cannotBeABaseURL
                    ? path[0]
                    : path.length
                    ? "/" + path.join("/")
                    : "";
                };
                var getSearch = function () {
                  var query =
                    getInternalURLState(
                      this
                    ).query;
                  return query ? "?" + query : "";
                };
                var getSearchParams =
                  function () {
                    return getInternalURLState(
                      this
                    ).searchParams;
                  };
                var getHash = function () {
                  var fragment =
                    getInternalURLState(
                      this
                    ).fragment;
                  return fragment
                    ? "#" + fragment
                    : "";
                };
                var accessorDescriptor =
                  function (getter, setter) {
                    return {
                      get: getter,
                      set: setter,
                      configurable: true,
                      enumerable: true,
                    };
                  };
                if (DESCRIPTORS) {
                  defineProperties(URLPrototype, {
                    href: accessorDescriptor(
                      serializeURL,
                      function (href) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        var urlString =
                          String(href);
                        var failure = parseURL(
                          url,
                          urlString
                        );
                        if (failure)
                          throw TypeError(
                            failure
                          );
                        getInternalSearchParamsState(
                          url.searchParams
                        ).updateSearchParams(
                          url.query
                        );
                      }
                    ),
                    origin:
                      accessorDescriptor(
                        getOrigin
                      ),
                    protocol: accessorDescriptor(
                      getProtocol,
                      function (protocol) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        parseURL(
                          url,
                          String(protocol) + ":",
                          SCHEME_START
                        );
                      }
                    ),
                    username: accessorDescriptor(
                      getUsername,
                      function (username) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        var codePoints =
                          arrayFrom(
                            String(username)
                          );
                        if (
                          cannotHaveUsernamePasswordPort(
                            url
                          )
                        )
                          return;
                        url.username = "";
                        for (
                          var i = 0;
                          i < codePoints.length;
                          i++
                        ) {
                          url.username +=
                            percentEncode(
                              codePoints[i],
                              userinfoPercentEncodeSet
                            );
                        }
                      }
                    ),
                    password: accessorDescriptor(
                      getPassword,
                      function (password) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        var codePoints =
                          arrayFrom(
                            String(password)
                          );
                        if (
                          cannotHaveUsernamePasswordPort(
                            url
                          )
                        )
                          return;
                        url.password = "";
                        for (
                          var i = 0;
                          i < codePoints.length;
                          i++
                        ) {
                          url.password +=
                            percentEncode(
                              codePoints[i],
                              userinfoPercentEncodeSet
                            );
                        }
                      }
                    ),
                    host: accessorDescriptor(
                      getHost,
                      function (host) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        if (url.cannotBeABaseURL)
                          return;
                        parseURL(
                          url,
                          String(host),
                          HOST
                        );
                      }
                    ),
                    hostname: accessorDescriptor(
                      getHostname,
                      function (hostname) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        if (url.cannotBeABaseURL)
                          return;
                        parseURL(
                          url,
                          String(hostname),
                          HOSTNAME
                        );
                      }
                    ),
                    port: accessorDescriptor(
                      getPort,
                      function (port) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        if (
                          cannotHaveUsernamePasswordPort(
                            url
                          )
                        )
                          return;
                        port = String(port);
                        if (port == "")
                          url.port = null;
                        else
                          parseURL(
                            url,
                            port,
                            PORT
                          );
                      }
                    ),
                    pathname: accessorDescriptor(
                      getPathname,
                      function (pathname) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        if (url.cannotBeABaseURL)
                          return;
                        url.path = [];
                        parseURL(
                          url,
                          pathname + "",
                          PATH_START
                        );
                      }
                    ),
                    search: accessorDescriptor(
                      getSearch,
                      function (search) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        search = String(search);
                        if (search == "") {
                          url.query = null;
                        } else {
                          if (
                            "?" ==
                            search.charAt(0)
                          )
                            search =
                              search.slice(1);
                          url.query = "";
                          parseURL(
                            url,
                            search,
                            QUERY
                          );
                        }
                        getInternalSearchParamsState(
                          url.searchParams
                        ).updateSearchParams(
                          url.query
                        );
                      }
                    ),
                    searchParams:
                      accessorDescriptor(
                        getSearchParams
                      ),
                    hash: accessorDescriptor(
                      getHash,
                      function (hash) {
                        var url =
                          getInternalURLState(
                            this
                          );
                        hash = String(hash);
                        if (hash == "") {
                          url.fragment = null;
                          return;
                        }
                        if ("#" == hash.charAt(0))
                          hash = hash.slice(1);
                        url.fragment = "";
                        parseURL(
                          url,
                          hash,
                          FRAGMENT
                        );
                      }
                    ),
                  });
                }
                redefine(
                  URLPrototype,
                  "toJSON",
                  function toJSON() {
                    return serializeURL.call(
                      this
                    );
                  },
                  { enumerable: true }
                );
                redefine(
                  URLPrototype,
                  "toString",
                  function toString() {
                    return serializeURL.call(
                      this
                    );
                  },
                  { enumerable: true }
                );
                if (NativeURL) {
                  var nativeCreateObjectURL =
                    NativeURL.createObjectURL;
                  var nativeRevokeObjectURL =
                    NativeURL.revokeObjectURL;
                  if (nativeCreateObjectURL)
                    redefine(
                      URLConstructor,
                      "createObjectURL",
                      function createObjectURL(
                        blob
                      ) {
                        return nativeCreateObjectURL.apply(
                          NativeURL,
                          arguments
                        );
                      }
                    );
                  if (nativeRevokeObjectURL)
                    redefine(
                      URLConstructor,
                      "revokeObjectURL",
                      function revokeObjectURL(
                        url
                      ) {
                        return nativeRevokeObjectURL.apply(
                          NativeURL,
                          arguments
                        );
                      }
                    );
                }
                setToStringTag(
                  URLConstructor,
                  "URL"
                );
                $(
                  {
                    global: true,
                    forced: !USE_NATIVE_URL,
                    sham: !DESCRIPTORS,
                  },
                  { URL: URLConstructor }
                );

                /***/
              },
              /* 113 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var fails =
                  __w_pdfjs_require__(13);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var IS_PURE =
                  __w_pdfjs_require__(36);
                var ITERATOR =
                  wellKnownSymbol("iterator");
                module.exports = !fails(
                  function () {
                    var url = new URL(
                      "b?a=1&b=2&c=3",
                      "http://a"
                    );
                    var searchParams =
                      url.searchParams;
                    var result = "";
                    url.pathname = "c%20d";
                    searchParams.forEach(
                      function (value, key) {
                        searchParams["delete"](
                          "b"
                        );
                        result += key + value;
                      }
                    );
                    return (
                      (IS_PURE && !url.toJSON) ||
                      !searchParams.sort ||
                      url.href !==
                        "http://a/c%20d?a=1&c=3" ||
                      searchParams.get("c") !==
                        "3" ||
                      String(
                        new URLSearchParams(
                          "?a=1"
                        )
                      ) !== "a=1" ||
                      !searchParams[ITERATOR] ||
                      new URL("https://a@b")
                        .username !== "a" ||
                      new URLSearchParams(
                        new URLSearchParams("a=b")
                      ).get("a") !== "b" ||
                      new URL("http://тест")
                        .host !== "xn--e1aybc" ||
                      new URL("http://a#б")
                        .hash !== "#%D0%B1" ||
                      result !== "a1c3" ||
                      new URL(
                        "http://x",
                        undefined
                      ).host !== "x"
                    );
                  }
                );

                /***/
              },
              /* 114 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var DESCRIPTORS =
                  __w_pdfjs_require__(12);
                var fails =
                  __w_pdfjs_require__(13);
                var objectKeys =
                  __w_pdfjs_require__(60);
                var getOwnPropertySymbolsModule =
                  __w_pdfjs_require__(50);
                var propertyIsEnumerableModule =
                  __w_pdfjs_require__(14);
                var toObject =
                  __w_pdfjs_require__(67);
                var IndexedObject =
                  __w_pdfjs_require__(17);
                var nativeAssign = Object.assign;
                var defineProperty =
                  Object.defineProperty;
                module.exports =
                  !nativeAssign ||
                  fails(function () {
                    if (
                      DESCRIPTORS &&
                      nativeAssign(
                        { b: 1 },
                        nativeAssign(
                          defineProperty(
                            {},
                            "a",
                            {
                              enumerable: true,
                              get: function () {
                                defineProperty(
                                  this,
                                  "b",
                                  {
                                    value: 3,
                                    enumerable: false,
                                  }
                                );
                              },
                            }
                          ),
                          { b: 2 }
                        )
                      ).b !== 1
                    )
                      return true;
                    var A = {};
                    var B = {};
                    var symbol = Symbol();
                    var alphabet =
                      "abcdefghijklmnopqrst";
                    A[symbol] = 7;
                    alphabet
                      .split("")
                      .forEach(function (chr) {
                        B[chr] = chr;
                      });
                    return (
                      nativeAssign({}, A)[
                        symbol
                      ] != 7 ||
                      objectKeys(
                        nativeAssign({}, B)
                      ).join("") != alphabet
                    );
                  })
                    ? function assign(
                        target,
                        source
                      ) {
                        var T = toObject(target);
                        var argumentsLength =
                          arguments.length;
                        var index = 1;
                        var getOwnPropertySymbols =
                          getOwnPropertySymbolsModule.f;
                        var propertyIsEnumerable =
                          propertyIsEnumerableModule.f;
                        while (
                          argumentsLength > index
                        ) {
                          var S = IndexedObject(
                            arguments[index++]
                          );
                          var keys =
                            getOwnPropertySymbols
                              ? objectKeys(
                                  S
                                ).concat(
                                  getOwnPropertySymbols(
                                    S
                                  )
                                )
                              : objectKeys(S);
                          var length =
                            keys.length;
                          var j = 0;
                          var key;
                          while (length > j) {
                            key = keys[j++];
                            if (
                              !DESCRIPTORS ||
                              propertyIsEnumerable.call(
                                S,
                                key
                              )
                            )
                              T[key] = S[key];
                          }
                        }
                        return T;
                      }
                    : nativeAssign;

                /***/
              },
              /* 115 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var bind =
                  __w_pdfjs_require__(75);
                var toObject =
                  __w_pdfjs_require__(67);
                var callWithSafeIterationClosing =
                  __w_pdfjs_require__(116);
                var isArrayIteratorMethod =
                  __w_pdfjs_require__(74);
                var toLength =
                  __w_pdfjs_require__(46);
                var createProperty =
                  __w_pdfjs_require__(81);
                var getIteratorMethod =
                  __w_pdfjs_require__(77);
                module.exports = function from(
                  arrayLike
                ) {
                  var O = toObject(arrayLike);
                  var C =
                    typeof this == "function"
                      ? this
                      : Array;
                  var argumentsLength =
                    arguments.length;
                  var mapfn =
                    argumentsLength > 1
                      ? arguments[1]
                      : undefined;
                  var mapping =
                    mapfn !== undefined;
                  var iteratorMethod =
                    getIteratorMethod(O);
                  var index = 0;
                  var length,
                    result,
                    step,
                    iterator,
                    next,
                    value;
                  if (mapping)
                    mapfn = bind(
                      mapfn,
                      argumentsLength > 2
                        ? arguments[2]
                        : undefined,
                      2
                    );
                  if (
                    iteratorMethod != undefined &&
                    !(
                      C == Array &&
                      isArrayIteratorMethod(
                        iteratorMethod
                      )
                    )
                  ) {
                    iterator =
                      iteratorMethod.call(O);
                    next = iterator.next;
                    result = new C();
                    for (
                      ;
                      !(step =
                        next.call(iterator)).done;
                      index++
                    ) {
                      value = mapping
                        ? callWithSafeIterationClosing(
                            iterator,
                            mapfn,
                            [step.value, index],
                            true
                          )
                        : step.value;
                      createProperty(
                        result,
                        index,
                        value
                      );
                    }
                  } else {
                    length = toLength(O.length);
                    result = new C(length);
                    for (
                      ;
                      length > index;
                      index++
                    ) {
                      value = mapping
                        ? mapfn(O[index], index)
                        : O[index];
                      createProperty(
                        result,
                        index,
                        value
                      );
                    }
                  }
                  result.length = index;
                  return result;
                };

                /***/
              },
              /* 116 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var anObject =
                  __w_pdfjs_require__(27);
                var iteratorClose =
                  __w_pdfjs_require__(80);
                module.exports = function (
                  iterator,
                  fn,
                  value,
                  ENTRIES
                ) {
                  try {
                    return ENTRIES
                      ? fn(
                          anObject(value)[0],
                          value[1]
                        )
                      : fn(value);
                  } catch (error) {
                    iteratorClose(iterator);
                    throw error;
                  }
                };

                /***/
              },
              /* 117 */
              /***/ function (module) {
                "use strict";

                var maxInt = 2147483647;
                var base = 36;
                var tMin = 1;
                var tMax = 26;
                var skew = 38;
                var damp = 700;
                var initialBias = 72;
                var initialN = 128;
                var delimiter = "-";
                var regexNonASCII =
                  /[^\0-\u007E]/;
                var regexSeparators =
                  /[.\u3002\uFF0E\uFF61]/g;
                var OVERFLOW_ERROR =
                  "Overflow: input needs wider integers to process";
                var baseMinusTMin = base - tMin;
                var floor = Math.floor;
                var stringFromCharCode =
                  String.fromCharCode;
                var ucs2decode = function (
                  string
                ) {
                  var output = [];
                  var counter = 0;
                  var length = string.length;
                  while (counter < length) {
                    var value = string.charCodeAt(
                      counter++
                    );
                    if (
                      value >= 0xd800 &&
                      value <= 0xdbff &&
                      counter < length
                    ) {
                      var extra =
                        string.charCodeAt(
                          counter++
                        );
                      if (
                        (extra & 0xfc00) ==
                        0xdc00
                      ) {
                        output.push(
                          ((value & 0x3ff) <<
                            10) +
                            (extra & 0x3ff) +
                            0x10000
                        );
                      } else {
                        output.push(value);
                        counter--;
                      }
                    } else {
                      output.push(value);
                    }
                  }
                  return output;
                };
                var digitToBasic = function (
                  digit
                ) {
                  return (
                    digit + 22 + 75 * (digit < 26)
                  );
                };
                var adapt = function (
                  delta,
                  numPoints,
                  firstTime
                ) {
                  var k = 0;
                  delta = firstTime
                    ? floor(delta / damp)
                    : delta >> 1;
                  delta += floor(
                    delta / numPoints
                  );
                  for (
                    ;
                    delta >
                    (baseMinusTMin * tMax) >> 1;
                    k += base
                  ) {
                    delta = floor(
                      delta / baseMinusTMin
                    );
                  }
                  return floor(
                    k +
                      ((baseMinusTMin + 1) *
                        delta) /
                        (delta + skew)
                  );
                };
                var encode = function (input) {
                  var output = [];
                  input = ucs2decode(input);
                  var inputLength = input.length;
                  var n = initialN;
                  var delta = 0;
                  var bias = initialBias;
                  var i, currentValue;
                  for (
                    i = 0;
                    i < input.length;
                    i++
                  ) {
                    currentValue = input[i];
                    if (currentValue < 0x80) {
                      output.push(
                        stringFromCharCode(
                          currentValue
                        )
                      );
                    }
                  }
                  var basicLength = output.length;
                  var handledCPCount =
                    basicLength;
                  if (basicLength) {
                    output.push(delimiter);
                  }
                  while (
                    handledCPCount < inputLength
                  ) {
                    var m = maxInt;
                    for (
                      i = 0;
                      i < input.length;
                      i++
                    ) {
                      currentValue = input[i];
                      if (
                        currentValue >= n &&
                        currentValue < m
                      ) {
                        m = currentValue;
                      }
                    }
                    var handledCPCountPlusOne =
                      handledCPCount + 1;
                    if (
                      m - n >
                      floor(
                        (maxInt - delta) /
                          handledCPCountPlusOne
                      )
                    ) {
                      throw RangeError(
                        OVERFLOW_ERROR
                      );
                    }
                    delta +=
                      (m - n) *
                      handledCPCountPlusOne;
                    n = m;
                    for (
                      i = 0;
                      i < input.length;
                      i++
                    ) {
                      currentValue = input[i];
                      if (
                        currentValue < n &&
                        ++delta > maxInt
                      ) {
                        throw RangeError(
                          OVERFLOW_ERROR
                        );
                      }
                      if (currentValue == n) {
                        var q = delta;
                        for (
                          var k = base;
                          ;
                          k += base
                        ) {
                          var t =
                            k <= bias
                              ? tMin
                              : k >= bias + tMax
                              ? tMax
                              : k - bias;
                          if (q < t) break;
                          var qMinusT = q - t;
                          var baseMinusT =
                            base - t;
                          output.push(
                            stringFromCharCode(
                              digitToBasic(
                                t +
                                  (qMinusT %
                                    baseMinusT)
                              )
                            )
                          );
                          q = floor(
                            qMinusT / baseMinusT
                          );
                        }
                        output.push(
                          stringFromCharCode(
                            digitToBasic(q)
                          )
                        );
                        bias = adapt(
                          delta,
                          handledCPCountPlusOne,
                          handledCPCount ==
                            basicLength
                        );
                        delta = 0;
                        ++handledCPCount;
                      }
                    }
                    ++delta;
                    ++n;
                  }
                  return output.join("");
                };
                module.exports = function (
                  input
                ) {
                  var encoded = [];
                  var labels = input
                    .toLowerCase()
                    .replace(
                      regexSeparators,
                      "\u002E"
                    )
                    .split(".");
                  var i, label;
                  for (
                    i = 0;
                    i < labels.length;
                    i++
                  ) {
                    label = labels[i];
                    encoded.push(
                      regexNonASCII.test(label)
                        ? "xn--" + encode(label)
                        : label
                    );
                  }
                  return encoded.join(".");
                };

                /***/
              },
              /* 118 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                __w_pdfjs_require__(53);
                var $ = __w_pdfjs_require__(9);
                var getBuiltIn =
                  __w_pdfjs_require__(41);
                var USE_NATIVE_URL =
                  __w_pdfjs_require__(113);
                var redefine =
                  __w_pdfjs_require__(28);
                var redefineAll =
                  __w_pdfjs_require__(88);
                var setToStringTag =
                  __w_pdfjs_require__(69);
                var createIteratorConstructor =
                  __w_pdfjs_require__(64);
                var InternalStateModule =
                  __w_pdfjs_require__(32);
                var anInstance =
                  __w_pdfjs_require__(90);
                var hasOwn =
                  __w_pdfjs_require__(22);
                var bind =
                  __w_pdfjs_require__(75);
                var classof =
                  __w_pdfjs_require__(78);
                var anObject =
                  __w_pdfjs_require__(27);
                var isObject =
                  __w_pdfjs_require__(21);
                var create =
                  __w_pdfjs_require__(58);
                var createPropertyDescriptor =
                  __w_pdfjs_require__(15);
                var getIterator =
                  __w_pdfjs_require__(119);
                var getIteratorMethod =
                  __w_pdfjs_require__(77);
                var wellKnownSymbol =
                  __w_pdfjs_require__(55);
                var $fetch = getBuiltIn("fetch");
                var Headers =
                  getBuiltIn("Headers");
                var ITERATOR =
                  wellKnownSymbol("iterator");
                var URL_SEARCH_PARAMS =
                  "URLSearchParams";
                var URL_SEARCH_PARAMS_ITERATOR =
                  URL_SEARCH_PARAMS + "Iterator";
                var setInternalState =
                  InternalStateModule.set;
                var getInternalParamsState =
                  InternalStateModule.getterFor(
                    URL_SEARCH_PARAMS
                  );
                var getInternalIteratorState =
                  InternalStateModule.getterFor(
                    URL_SEARCH_PARAMS_ITERATOR
                  );
                var plus = /\+/g;
                var sequences = Array(4);
                var percentSequence = function (
                  bytes
                ) {
                  return (
                    sequences[bytes - 1] ||
                    (sequences[bytes - 1] =
                      RegExp(
                        "((?:%[\\da-f]{2}){" +
                          bytes +
                          "})",
                        "gi"
                      ))
                  );
                };
                var percentDecode = function (
                  sequence
                ) {
                  try {
                    return decodeURIComponent(
                      sequence
                    );
                  } catch (error) {
                    return sequence;
                  }
                };
                var deserialize = function (it) {
                  var result = it.replace(
                    plus,
                    " "
                  );
                  var bytes = 4;
                  try {
                    return decodeURIComponent(
                      result
                    );
                  } catch (error) {
                    while (bytes) {
                      result = result.replace(
                        percentSequence(bytes--),
                        percentDecode
                      );
                    }
                    return result;
                  }
                };
                var find = /[!'()~]|%20/g;
                var replace = {
                  "!": "%21",
                  "'": "%27",
                  "(": "%28",
                  ")": "%29",
                  "~": "%7E",
                  "%20": "+",
                };
                var replacer = function (match) {
                  return replace[match];
                };
                var serialize = function (it) {
                  return encodeURIComponent(
                    it
                  ).replace(find, replacer);
                };
                var parseSearchParams = function (
                  result,
                  query
                ) {
                  if (query) {
                    var attributes =
                      query.split("&");
                    var index = 0;
                    var attribute, entry;
                    while (
                      index < attributes.length
                    ) {
                      attribute =
                        attributes[index++];
                      if (attribute.length) {
                        entry =
                          attribute.split("=");
                        result.push({
                          key: deserialize(
                            entry.shift()
                          ),
                          value: deserialize(
                            entry.join("=")
                          ),
                        });
                      }
                    }
                  }
                };
                var updateSearchParams =
                  function (query) {
                    this.entries.length = 0;
                    parseSearchParams(
                      this.entries,
                      query
                    );
                  };
                var validateArgumentsLength =
                  function (passed, required) {
                    if (passed < required)
                      throw TypeError(
                        "Not enough arguments"
                      );
                  };
                var URLSearchParamsIterator =
                  createIteratorConstructor(
                    function Iterator(
                      params,
                      kind
                    ) {
                      setInternalState(this, {
                        type: URL_SEARCH_PARAMS_ITERATOR,
                        iterator: getIterator(
                          getInternalParamsState(
                            params
                          ).entries
                        ),
                        kind: kind,
                      });
                    },
                    "Iterator",
                    function next() {
                      var state =
                        getInternalIteratorState(
                          this
                        );
                      var kind = state.kind;
                      var step =
                        state.iterator.next();
                      var entry = step.value;
                      if (!step.done) {
                        step.value =
                          kind === "keys"
                            ? entry.key
                            : kind === "values"
                            ? entry.value
                            : [
                                entry.key,
                                entry.value,
                              ];
                      }
                      return step;
                    }
                  );
                var URLSearchParamsConstructor =
                  function URLSearchParams() {
                    anInstance(
                      this,
                      URLSearchParamsConstructor,
                      URL_SEARCH_PARAMS
                    );
                    var init =
                      arguments.length > 0
                        ? arguments[0]
                        : undefined;
                    var that = this;
                    var entries = [];
                    var iteratorMethod,
                      iterator,
                      next,
                      step,
                      entryIterator,
                      entryNext,
                      first,
                      second,
                      key;
                    setInternalState(that, {
                      type: URL_SEARCH_PARAMS,
                      entries: entries,
                      updateURL: function () {},
                      updateSearchParams:
                        updateSearchParams,
                    });
                    if (init !== undefined) {
                      if (isObject(init)) {
                        iteratorMethod =
                          getIteratorMethod(init);
                        if (
                          typeof iteratorMethod ===
                          "function"
                        ) {
                          iterator =
                            iteratorMethod.call(
                              init
                            );
                          next = iterator.next;
                          while (
                            !(step =
                              next.call(iterator))
                              .done
                          ) {
                            entryIterator =
                              getIterator(
                                anObject(
                                  step.value
                                )
                              );
                            entryNext =
                              entryIterator.next;
                            if (
                              (first =
                                entryNext.call(
                                  entryIterator
                                )).done ||
                              (second =
                                entryNext.call(
                                  entryIterator
                                )).done ||
                              !entryNext.call(
                                entryIterator
                              ).done
                            )
                              throw TypeError(
                                "Expected sequence with length 2"
                              );
                            entries.push({
                              key:
                                first.value + "",
                              value:
                                second.value + "",
                            });
                          }
                        } else
                          for (key in init)
                            if (hasOwn(init, key))
                              entries.push({
                                key: key,
                                value:
                                  init[key] + "",
                              });
                      } else {
                        parseSearchParams(
                          entries,
                          typeof init === "string"
                            ? init.charAt(0) ===
                              "?"
                              ? init.slice(1)
                              : init
                            : init + ""
                        );
                      }
                    }
                  };
                var URLSearchParamsPrototype =
                  URLSearchParamsConstructor.prototype;
                redefineAll(
                  URLSearchParamsPrototype,
                  {
                    append: function append(
                      name,
                      value
                    ) {
                      validateArgumentsLength(
                        arguments.length,
                        2
                      );
                      var state =
                        getInternalParamsState(
                          this
                        );
                      state.entries.push({
                        key: name + "",
                        value: value + "",
                      });
                      state.updateURL();
                    },
                    delete: function (name) {
                      validateArgumentsLength(
                        arguments.length,
                        1
                      );
                      var state =
                        getInternalParamsState(
                          this
                        );
                      var entries = state.entries;
                      var key = name + "";
                      var index = 0;
                      while (
                        index < entries.length
                      ) {
                        if (
                          entries[index].key ===
                          key
                        )
                          entries.splice(
                            index,
                            1
                          );
                        else index++;
                      }
                      state.updateURL();
                    },
                    get: function get(name) {
                      validateArgumentsLength(
                        arguments.length,
                        1
                      );
                      var entries =
                        getInternalParamsState(
                          this
                        ).entries;
                      var key = name + "";
                      var index = 0;
                      for (
                        ;
                        index < entries.length;
                        index++
                      ) {
                        if (
                          entries[index].key ===
                          key
                        )
                          return entries[index]
                            .value;
                      }
                      return null;
                    },
                    getAll: function getAll(
                      name
                    ) {
                      validateArgumentsLength(
                        arguments.length,
                        1
                      );
                      var entries =
                        getInternalParamsState(
                          this
                        ).entries;
                      var key = name + "";
                      var result = [];
                      var index = 0;
                      for (
                        ;
                        index < entries.length;
                        index++
                      ) {
                        if (
                          entries[index].key ===
                          key
                        )
                          result.push(
                            entries[index].value
                          );
                      }
                      return result;
                    },
                    has: function has(name) {
                      validateArgumentsLength(
                        arguments.length,
                        1
                      );
                      var entries =
                        getInternalParamsState(
                          this
                        ).entries;
                      var key = name + "";
                      var index = 0;
                      while (
                        index < entries.length
                      ) {
                        if (
                          entries[index++].key ===
                          key
                        )
                          return true;
                      }
                      return false;
                    },
                    set: function set(
                      name,
                      value
                    ) {
                      validateArgumentsLength(
                        arguments.length,
                        1
                      );
                      var state =
                        getInternalParamsState(
                          this
                        );
                      var entries = state.entries;
                      var found = false;
                      var key = name + "";
                      var val = value + "";
                      var index = 0;
                      var entry;
                      for (
                        ;
                        index < entries.length;
                        index++
                      ) {
                        entry = entries[index];
                        if (entry.key === key) {
                          if (found)
                            entries.splice(
                              index--,
                              1
                            );
                          else {
                            found = true;
                            entry.value = val;
                          }
                        }
                      }
                      if (!found)
                        entries.push({
                          key: key,
                          value: val,
                        });
                      state.updateURL();
                    },
                    sort: function sort() {
                      var state =
                        getInternalParamsState(
                          this
                        );
                      var entries = state.entries;
                      var slice = entries.slice();
                      var entry,
                        entriesIndex,
                        sliceIndex;
                      entries.length = 0;
                      for (
                        sliceIndex = 0;
                        sliceIndex < slice.length;
                        sliceIndex++
                      ) {
                        entry = slice[sliceIndex];
                        for (
                          entriesIndex = 0;
                          entriesIndex <
                          sliceIndex;
                          entriesIndex++
                        ) {
                          if (
                            entries[entriesIndex]
                              .key > entry.key
                          ) {
                            entries.splice(
                              entriesIndex,
                              0,
                              entry
                            );
                            break;
                          }
                        }
                        if (
                          entriesIndex ===
                          sliceIndex
                        )
                          entries.push(entry);
                      }
                      state.updateURL();
                    },
                    forEach: function forEach(
                      callback
                    ) {
                      var entries =
                        getInternalParamsState(
                          this
                        ).entries;
                      var boundFunction = bind(
                        callback,
                        arguments.length > 1
                          ? arguments[1]
                          : undefined,
                        3
                      );
                      var index = 0;
                      var entry;
                      while (
                        index < entries.length
                      ) {
                        entry = entries[index++];
                        boundFunction(
                          entry.value,
                          entry.key,
                          this
                        );
                      }
                    },
                    keys: function keys() {
                      return new URLSearchParamsIterator(
                        this,
                        "keys"
                      );
                    },
                    values: function values() {
                      return new URLSearchParamsIterator(
                        this,
                        "values"
                      );
                    },
                    entries: function entries() {
                      return new URLSearchParamsIterator(
                        this,
                        "entries"
                      );
                    },
                  },
                  { enumerable: true }
                );
                redefine(
                  URLSearchParamsPrototype,
                  ITERATOR,
                  URLSearchParamsPrototype.entries
                );
                redefine(
                  URLSearchParamsPrototype,
                  "toString",
                  function toString() {
                    var entries =
                      getInternalParamsState(
                        this
                      ).entries;
                    var result = [];
                    var index = 0;
                    var entry;
                    while (
                      index < entries.length
                    ) {
                      entry = entries[index++];
                      result.push(
                        serialize(entry.key) +
                          "=" +
                          serialize(entry.value)
                      );
                    }
                    return result.join("&");
                  },
                  { enumerable: true }
                );
                setToStringTag(
                  URLSearchParamsConstructor,
                  URL_SEARCH_PARAMS
                );
                $(
                  {
                    global: true,
                    forced: !USE_NATIVE_URL,
                  },
                  {
                    URLSearchParams:
                      URLSearchParamsConstructor,
                  }
                );
                if (
                  !USE_NATIVE_URL &&
                  typeof $fetch == "function" &&
                  typeof Headers == "function"
                ) {
                  $(
                    {
                      global: true,
                      enumerable: true,
                      forced: true,
                    },
                    {
                      fetch: function fetch(
                        input
                      ) {
                        var args = [input];
                        var init, body, headers;
                        if (
                          arguments.length > 1
                        ) {
                          init = arguments[1];
                          if (isObject(init)) {
                            body = init.body;
                            if (
                              classof(body) ===
                              URL_SEARCH_PARAMS
                            ) {
                              headers =
                                init.headers
                                  ? new Headers(
                                      init.headers
                                    )
                                  : new Headers();
                              if (
                                !headers.has(
                                  "content-type"
                                )
                              ) {
                                headers.set(
                                  "content-type",
                                  "application/x-www-form-urlencoded;charset=UTF-8"
                                );
                              }
                              init = create(
                                init,
                                {
                                  body: createPropertyDescriptor(
                                    0,
                                    String(body)
                                  ),
                                  headers:
                                    createPropertyDescriptor(
                                      0,
                                      headers
                                    ),
                                }
                              );
                            }
                          }
                          args.push(init);
                        }
                        return $fetch.apply(
                          this,
                          args
                        );
                      },
                    }
                  );
                }
                module.exports = {
                  URLSearchParams:
                    URLSearchParamsConstructor,
                  getState:
                    getInternalParamsState,
                };

                /***/
              },
              /* 119 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var anObject =
                  __w_pdfjs_require__(27);
                var getIteratorMethod =
                  __w_pdfjs_require__(77);
                module.exports = function (it) {
                  var iteratorMethod =
                    getIteratorMethod(it);
                  if (
                    typeof iteratorMethod !=
                    "function"
                  ) {
                    throw TypeError(
                      String(it) +
                        " is not iterable"
                    );
                  }
                  return anObject(
                    iteratorMethod.call(it)
                  );
                };

                /***/
              },
              /* 120 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var $ = __w_pdfjs_require__(9);
                $(
                  {
                    target: "URL",
                    proto: true,
                    enumerable: true,
                  },
                  {
                    toJSON: function toJSON() {
                      return URL.prototype.toString.call(
                        this
                      );
                    },
                  }
                );

                /***/
              },
              /* 121 */
              /***/ function (
                __unused_webpack_module,
                exports
              ) {
                (function (global, factory) {
                  true ? factory(exports) : 0;
                })(this, function (exports) {
                  "use strict";
                  var SymbolPolyfill =
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                      ? Symbol
                      : function (description) {
                          return (
                            "Symbol(" +
                            description +
                            ")"
                          );
                        };
                  function noop() {}
                  function getGlobals() {
                    if (
                      typeof self !== "undefined"
                    ) {
                      return self;
                    } else if (
                      typeof window !==
                      "undefined"
                    ) {
                      return window;
                    } else if (
                      typeof __webpack_require__.g !==
                      "undefined"
                    ) {
                      return __webpack_require__.g;
                    }
                    return undefined;
                  }
                  var globals = getGlobals();
                  function typeIsObject(x) {
                    return (
                      (typeof x === "object" &&
                        x !== null) ||
                      typeof x === "function"
                    );
                  }
                  var rethrowAssertionErrorRejection =
                    noop;
                  var originalPromise = Promise;
                  var originalPromiseThen =
                    Promise.prototype.then;
                  var originalPromiseResolve =
                    Promise.resolve.bind(
                      originalPromise
                    );
                  var originalPromiseReject =
                    Promise.reject.bind(
                      originalPromise
                    );
                  function newPromise(executor) {
                    return new originalPromise(
                      executor
                    );
                  }
                  function promiseResolvedWith(
                    value
                  ) {
                    return originalPromiseResolve(
                      value
                    );
                  }
                  function promiseRejectedWith(
                    reason
                  ) {
                    return originalPromiseReject(
                      reason
                    );
                  }
                  function PerformPromiseThen(
                    promise,
                    onFulfilled,
                    onRejected
                  ) {
                    return originalPromiseThen.call(
                      promise,
                      onFulfilled,
                      onRejected
                    );
                  }
                  function uponPromise(
                    promise,
                    onFulfilled,
                    onRejected
                  ) {
                    PerformPromiseThen(
                      PerformPromiseThen(
                        promise,
                        onFulfilled,
                        onRejected
                      ),
                      undefined,
                      rethrowAssertionErrorRejection
                    );
                  }
                  function uponFulfillment(
                    promise,
                    onFulfilled
                  ) {
                    uponPromise(
                      promise,
                      onFulfilled
                    );
                  }
                  function uponRejection(
                    promise,
                    onRejected
                  ) {
                    uponPromise(
                      promise,
                      undefined,
                      onRejected
                    );
                  }
                  function transformPromiseWith(
                    promise,
                    fulfillmentHandler,
                    rejectionHandler
                  ) {
                    return PerformPromiseThen(
                      promise,
                      fulfillmentHandler,
                      rejectionHandler
                    );
                  }
                  function setPromiseIsHandledToTrue(
                    promise
                  ) {
                    PerformPromiseThen(
                      promise,
                      undefined,
                      rethrowAssertionErrorRejection
                    );
                  }
                  var queueMicrotask =
                    (function () {
                      var globalQueueMicrotask =
                        globals &&
                        globals.queueMicrotask;
                      if (
                        typeof globalQueueMicrotask ===
                        "function"
                      ) {
                        return globalQueueMicrotask;
                      }
                      var resolvedPromise =
                        promiseResolvedWith(
                          undefined
                        );
                      return function (fn) {
                        return PerformPromiseThen(
                          resolvedPromise,
                          fn
                        );
                      };
                    })();
                  function reflectCall(
                    F,
                    V,
                    args
                  ) {
                    if (typeof F !== "function") {
                      throw new TypeError(
                        "Argument is not a function"
                      );
                    }
                    return Function.prototype.apply.call(
                      F,
                      V,
                      args
                    );
                  }
                  function promiseCall(
                    F,
                    V,
                    args
                  ) {
                    try {
                      return promiseResolvedWith(
                        reflectCall(F, V, args)
                      );
                    } catch (value) {
                      return promiseRejectedWith(
                        value
                      );
                    }
                  }
                  var QUEUE_MAX_ARRAY_SIZE = 16384;
                  var SimpleQueue = (function () {
                    function SimpleQueue() {
                      this._cursor = 0;
                      this._size = 0;
                      this._front = {
                        _elements: [],
                        _next: undefined,
                      };
                      this._back = this._front;
                      this._cursor = 0;
                      this._size = 0;
                    }
                    Object.defineProperty(
                      SimpleQueue.prototype,
                      "length",
                      {
                        get: function () {
                          return this._size;
                        },
                        enumerable: false,
                        configurable: true,
                      }
                    );
                    SimpleQueue.prototype.push =
                      function (element) {
                        var oldBack = this._back;
                        var newBack = oldBack;
                        if (
                          oldBack._elements
                            .length ===
                          QUEUE_MAX_ARRAY_SIZE - 1
                        ) {
                          newBack = {
                            _elements: [],
                            _next: undefined,
                          };
                        }
                        oldBack._elements.push(
                          element
                        );
                        if (newBack !== oldBack) {
                          this._back = newBack;
                          oldBack._next = newBack;
                        }
                        ++this._size;
                      };
                    SimpleQueue.prototype.shift =
                      function () {
                        var oldFront =
                          this._front;
                        var newFront = oldFront;
                        var oldCursor =
                          this._cursor;
                        var newCursor =
                          oldCursor + 1;
                        var elements =
                          oldFront._elements;
                        var element =
                          elements[oldCursor];
                        if (
                          newCursor ===
                          QUEUE_MAX_ARRAY_SIZE
                        ) {
                          newFront =
                            oldFront._next;
                          newCursor = 0;
                        }
                        --this._size;
                        this._cursor = newCursor;
                        if (
                          oldFront !== newFront
                        ) {
                          this._front = newFront;
                        }
                        elements[oldCursor] =
                          undefined;
                        return element;
                      };
                    SimpleQueue.prototype.forEach =
                      function (callback) {
                        var i = this._cursor;
                        var node = this._front;
                        var elements =
                          node._elements;
                        while (
                          i !== elements.length ||
                          node._next !== undefined
                        ) {
                          if (
                            i === elements.length
                          ) {
                            node = node._next;
                            elements =
                              node._elements;
                            i = 0;
                            if (
                              elements.length ===
                              0
                            ) {
                              break;
                            }
                          }
                          callback(elements[i]);
                          ++i;
                        }
                      };
                    SimpleQueue.prototype.peek =
                      function () {
                        var front = this._front;
                        var cursor = this._cursor;
                        return front._elements[
                          cursor
                        ];
                      };
                    return SimpleQueue;
                  })();
                  function ReadableStreamReaderGenericInitialize(
                    reader,
                    stream
                  ) {
                    reader._ownerReadableStream =
                      stream;
                    stream._reader = reader;
                    if (
                      stream._state === "readable"
                    ) {
                      defaultReaderClosedPromiseInitialize(
                        reader
                      );
                    } else if (
                      stream._state === "closed"
                    ) {
                      defaultReaderClosedPromiseInitializeAsResolved(
                        reader
                      );
                    } else {
                      defaultReaderClosedPromiseInitializeAsRejected(
                        reader,
                        stream._storedError
                      );
                    }
                  }
                  function ReadableStreamReaderGenericCancel(
                    reader,
                    reason
                  ) {
                    var stream =
                      reader._ownerReadableStream;
                    return ReadableStreamCancel(
                      stream,
                      reason
                    );
                  }
                  function ReadableStreamReaderGenericRelease(
                    reader
                  ) {
                    if (
                      reader._ownerReadableStream
                        ._state === "readable"
                    ) {
                      defaultReaderClosedPromiseReject(
                        reader,
                        new TypeError(
                          "Reader was released and can no longer be used to monitor the stream's closedness"
                        )
                      );
                    } else {
                      defaultReaderClosedPromiseResetToRejected(
                        reader,
                        new TypeError(
                          "Reader was released and can no longer be used to monitor the stream's closedness"
                        )
                      );
                    }
                    reader._ownerReadableStream._reader =
                      undefined;
                    reader._ownerReadableStream =
                      undefined;
                  }
                  function readerLockException(
                    name
                  ) {
                    return new TypeError(
                      "Cannot " +
                        name +
                        " a stream using a released reader"
                    );
                  }
                  function defaultReaderClosedPromiseInitialize(
                    reader
                  ) {
                    reader._closedPromise =
                      newPromise(function (
                        resolve,
                        reject
                      ) {
                        reader._closedPromise_resolve =
                          resolve;
                        reader._closedPromise_reject =
                          reject;
                      });
                  }
                  function defaultReaderClosedPromiseInitializeAsRejected(
                    reader,
                    reason
                  ) {
                    defaultReaderClosedPromiseInitialize(
                      reader
                    );
                    defaultReaderClosedPromiseReject(
                      reader,
                      reason
                    );
                  }
                  function defaultReaderClosedPromiseInitializeAsResolved(
                    reader
                  ) {
                    defaultReaderClosedPromiseInitialize(
                      reader
                    );
                    defaultReaderClosedPromiseResolve(
                      reader
                    );
                  }
                  function defaultReaderClosedPromiseReject(
                    reader,
                    reason
                  ) {
                    if (
                      reader._closedPromise_reject ===
                      undefined
                    ) {
                      return;
                    }
                    setPromiseIsHandledToTrue(
                      reader._closedPromise
                    );
                    reader._closedPromise_reject(
                      reason
                    );
                    reader._closedPromise_resolve =
                      undefined;
                    reader._closedPromise_reject =
                      undefined;
                  }
                  function defaultReaderClosedPromiseResetToRejected(
                    reader,
                    reason
                  ) {
                    defaultReaderClosedPromiseInitializeAsRejected(
                      reader,
                      reason
                    );
                  }
                  function defaultReaderClosedPromiseResolve(
                    reader
                  ) {
                    if (
                      reader._closedPromise_resolve ===
                      undefined
                    ) {
                      return;
                    }
                    reader._closedPromise_resolve(
                      undefined
                    );
                    reader._closedPromise_resolve =
                      undefined;
                    reader._closedPromise_reject =
                      undefined;
                  }
                  var AbortSteps = SymbolPolyfill(
                    "[[AbortSteps]]"
                  );
                  var ErrorSteps = SymbolPolyfill(
                    "[[ErrorSteps]]"
                  );
                  var CancelSteps =
                    SymbolPolyfill(
                      "[[CancelSteps]]"
                    );
                  var PullSteps = SymbolPolyfill(
                    "[[PullSteps]]"
                  );
                  var NumberIsFinite =
                    Number.isFinite ||
                    function (x) {
                      return (
                        typeof x === "number" &&
                        isFinite(x)
                      );
                    };
                  var MathTrunc =
                    Math.trunc ||
                    function (v) {
                      return v < 0
                        ? Math.ceil(v)
                        : Math.floor(v);
                    };
                  function isDictionary(x) {
                    return (
                      typeof x === "object" ||
                      typeof x === "function"
                    );
                  }
                  function assertDictionary(
                    obj,
                    context
                  ) {
                    if (
                      obj !== undefined &&
                      !isDictionary(obj)
                    ) {
                      throw new TypeError(
                        context +
                          " is not an object."
                      );
                    }
                  }
                  function assertFunction(
                    x,
                    context
                  ) {
                    if (typeof x !== "function") {
                      throw new TypeError(
                        context +
                          " is not a function."
                      );
                    }
                  }
                  function isObject(x) {
                    return (
                      (typeof x === "object" &&
                        x !== null) ||
                      typeof x === "function"
                    );
                  }
                  function assertObject(
                    x,
                    context
                  ) {
                    if (!isObject(x)) {
                      throw new TypeError(
                        context +
                          " is not an object."
                      );
                    }
                  }
                  function assertRequiredArgument(
                    x,
                    position,
                    context
                  ) {
                    if (x === undefined) {
                      throw new TypeError(
                        "Parameter " +
                          position +
                          " is required in '" +
                          context +
                          "'."
                      );
                    }
                  }
                  function assertRequiredField(
                    x,
                    field,
                    context
                  ) {
                    if (x === undefined) {
                      throw new TypeError(
                        field +
                          " is required in '" +
                          context +
                          "'."
                      );
                    }
                  }
                  function convertUnrestrictedDouble(
                    value
                  ) {
                    return Number(value);
                  }
                  function censorNegativeZero(x) {
                    return x === 0 ? 0 : x;
                  }
                  function integerPart(x) {
                    return censorNegativeZero(
                      MathTrunc(x)
                    );
                  }
                  function convertUnsignedLongLongWithEnforceRange(
                    value,
                    context
                  ) {
                    var lowerBound = 0;
                    var upperBound =
                      Number.MAX_SAFE_INTEGER;
                    var x = Number(value);
                    x = censorNegativeZero(x);
                    if (!NumberIsFinite(x)) {
                      throw new TypeError(
                        context +
                          " is not a finite number"
                      );
                    }
                    x = integerPart(x);
                    if (
                      x < lowerBound ||
                      x > upperBound
                    ) {
                      throw new TypeError(
                        context +
                          " is outside the accepted range of " +
                          lowerBound +
                          " to " +
                          upperBound +
                          ", inclusive"
                      );
                    }
                    if (
                      !NumberIsFinite(x) ||
                      x === 0
                    ) {
                      return 0;
                    }
                    return x;
                  }
                  function assertReadableStream(
                    x,
                    context
                  ) {
                    if (!IsReadableStream(x)) {
                      throw new TypeError(
                        context +
                          " is not a ReadableStream."
                      );
                    }
                  }
                  function AcquireReadableStreamDefaultReader(
                    stream
                  ) {
                    return new ReadableStreamDefaultReader(
                      stream
                    );
                  }
                  function ReadableStreamAddReadRequest(
                    stream,
                    readRequest
                  ) {
                    stream._reader._readRequests.push(
                      readRequest
                    );
                  }
                  function ReadableStreamFulfillReadRequest(
                    stream,
                    chunk,
                    done
                  ) {
                    var reader = stream._reader;
                    var readRequest =
                      reader._readRequests.shift();
                    if (done) {
                      readRequest._closeSteps();
                    } else {
                      readRequest._chunkSteps(
                        chunk
                      );
                    }
                  }
                  function ReadableStreamGetNumReadRequests(
                    stream
                  ) {
                    return stream
                      ._reader._readRequests.length;
                  }
                  function ReadableStreamHasDefaultReader(
                    stream
                  ) {
                    var reader = stream._reader;
                    if (reader === undefined) {
                      return false;
                    }
                    if (
                      !IsReadableStreamDefaultReader(
                        reader
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  var ReadableStreamDefaultReader =
                    (function () {
                      function ReadableStreamDefaultReader(
                        stream
                      ) {
                        assertRequiredArgument(
                          stream,
                          1,
                          "ReadableStreamDefaultReader"
                        );
                        assertReadableStream(
                          stream,
                          "First parameter"
                        );
                        if (
                          IsReadableStreamLocked(
                            stream
                          )
                        ) {
                          throw new TypeError(
                            "This stream has already been locked for exclusive reading by another reader"
                          );
                        }
                        ReadableStreamReaderGenericInitialize(
                          this,
                          stream
                        );
                        this._readRequests =
                          new SimpleQueue();
                      }
                      Object.defineProperty(
                        ReadableStreamDefaultReader.prototype,
                        "closed",
                        {
                          get: function () {
                            if (
                              !IsReadableStreamDefaultReader(
                                this
                              )
                            ) {
                              return promiseRejectedWith(
                                defaultReaderBrandCheckException(
                                  "closed"
                                )
                              );
                            }
                            return this
                              ._closedPromise;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      ReadableStreamDefaultReader.prototype.cancel =
                        function (reason) {
                          if (reason === void 0) {
                            reason = undefined;
                          }
                          if (
                            !IsReadableStreamDefaultReader(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              defaultReaderBrandCheckException(
                                "cancel"
                              )
                            );
                          }
                          if (
                            this
                              ._ownerReadableStream ===
                            undefined
                          ) {
                            return promiseRejectedWith(
                              readerLockException(
                                "cancel"
                              )
                            );
                          }
                          return ReadableStreamReaderGenericCancel(
                            this,
                            reason
                          );
                        };
                      ReadableStreamDefaultReader.prototype.read =
                        function () {
                          if (
                            !IsReadableStreamDefaultReader(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              defaultReaderBrandCheckException(
                                "read"
                              )
                            );
                          }
                          if (
                            this
                              ._ownerReadableStream ===
                            undefined
                          ) {
                            return promiseRejectedWith(
                              readerLockException(
                                "read from"
                              )
                            );
                          }
                          var resolvePromise;
                          var rejectPromise;
                          var promise =
                            newPromise(function (
                              resolve,
                              reject
                            ) {
                              resolvePromise =
                                resolve;
                              rejectPromise =
                                reject;
                            });
                          var readRequest = {
                            _chunkSteps:
                              function (chunk) {
                                return resolvePromise(
                                  {
                                    value: chunk,
                                    done: false,
                                  }
                                );
                              },
                            _closeSteps:
                              function () {
                                return resolvePromise(
                                  {
                                    value:
                                      undefined,
                                    done: true,
                                  }
                                );
                              },
                            _errorSteps:
                              function (e) {
                                return rejectPromise(
                                  e
                                );
                              },
                          };
                          ReadableStreamDefaultReaderRead(
                            this,
                            readRequest
                          );
                          return promise;
                        };
                      ReadableStreamDefaultReader.prototype.releaseLock =
                        function () {
                          if (
                            !IsReadableStreamDefaultReader(
                              this
                            )
                          ) {
                            throw defaultReaderBrandCheckException(
                              "releaseLock"
                            );
                          }
                          if (
                            this
                              ._ownerReadableStream ===
                            undefined
                          ) {
                            return;
                          }
                          if (
                            this._readRequests
                              .length > 0
                          ) {
                            throw new TypeError(
                              "Tried to release a reader lock when that reader has pending read() calls un-settled"
                            );
                          }
                          ReadableStreamReaderGenericRelease(
                            this
                          );
                        };
                      return ReadableStreamDefaultReader;
                    })();
                  Object.defineProperties(
                    ReadableStreamDefaultReader.prototype,
                    {
                      cancel: {
                        enumerable: true,
                      },
                      read: { enumerable: true },
                      releaseLock: {
                        enumerable: true,
                      },
                      closed: {
                        enumerable: true,
                      },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      ReadableStreamDefaultReader.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "ReadableStreamDefaultReader",
                        configurable: true,
                      }
                    );
                  }
                  function IsReadableStreamDefaultReader(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_readRequests"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamDefaultReaderRead(
                    reader,
                    readRequest
                  ) {
                    var stream =
                      reader._ownerReadableStream;
                    stream._disturbed = true;
                    if (
                      stream._state === "closed"
                    ) {
                      readRequest._closeSteps();
                    } else if (
                      stream._state === "errored"
                    ) {
                      readRequest._errorSteps(
                        stream._storedError
                      );
                    } else {
                      stream._readableStreamController[
                        PullSteps
                      ](readRequest);
                    }
                  }
                  function defaultReaderBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "ReadableStreamDefaultReader.prototype." +
                        name +
                        " can only be used on a ReadableStreamDefaultReader"
                    );
                  }
                  var _a;
                  var AsyncIteratorPrototype;
                  if (
                    typeof SymbolPolyfill.asyncIterator ===
                    "symbol"
                  ) {
                    AsyncIteratorPrototype =
                      ((_a = {}),
                      (_a[
                        SymbolPolyfill.asyncIterator
                      ] = function () {
                        return this;
                      }),
                      _a);
                    Object.defineProperty(
                      AsyncIteratorPrototype,
                      SymbolPolyfill.asyncIterator,
                      { enumerable: false }
                    );
                  }
                  var ReadableStreamAsyncIteratorImpl =
                    (function () {
                      function ReadableStreamAsyncIteratorImpl(
                        reader,
                        preventCancel
                      ) {
                        this._ongoingPromise =
                          undefined;
                        this._isFinished = false;
                        this._reader = reader;
                        this._preventCancel =
                          preventCancel;
                      }
                      ReadableStreamAsyncIteratorImpl.prototype.next =
                        function () {
                          var _this = this;
                          var nextSteps =
                            function () {
                              return _this._nextSteps();
                            };
                          this._ongoingPromise =
                            this._ongoingPromise
                              ? transformPromiseWith(
                                  this
                                    ._ongoingPromise,
                                  nextSteps,
                                  nextSteps
                                )
                              : nextSteps();
                          return this
                            ._ongoingPromise;
                        };
                      ReadableStreamAsyncIteratorImpl.prototype.return =
                        function (value) {
                          var _this = this;
                          var returnSteps =
                            function () {
                              return _this._returnSteps(
                                value
                              );
                            };
                          return this
                            ._ongoingPromise
                            ? transformPromiseWith(
                                this
                                  ._ongoingPromise,
                                returnSteps,
                                returnSteps
                              )
                            : returnSteps();
                        };
                      ReadableStreamAsyncIteratorImpl.prototype._nextSteps =
                        function () {
                          var _this = this;
                          if (this._isFinished) {
                            return Promise.resolve(
                              {
                                value: undefined,
                                done: true,
                              }
                            );
                          }
                          var reader =
                            this._reader;
                          if (
                            reader._ownerReadableStream ===
                            undefined
                          ) {
                            return promiseRejectedWith(
                              readerLockException(
                                "iterate"
                              )
                            );
                          }
                          var resolvePromise;
                          var rejectPromise;
                          var promise =
                            newPromise(function (
                              resolve,
                              reject
                            ) {
                              resolvePromise =
                                resolve;
                              rejectPromise =
                                reject;
                            });
                          var readRequest = {
                            _chunkSteps:
                              function (chunk) {
                                _this._ongoingPromise =
                                  undefined;
                                queueMicrotask(
                                  function () {
                                    return resolvePromise(
                                      {
                                        value:
                                          chunk,
                                        done: false,
                                      }
                                    );
                                  }
                                );
                              },
                            _closeSteps:
                              function () {
                                _this._ongoingPromise =
                                  undefined;
                                _this._isFinished = true;
                                ReadableStreamReaderGenericRelease(
                                  reader
                                );
                                resolvePromise({
                                  value:
                                    undefined,
                                  done: true,
                                });
                              },
                            _errorSteps:
                              function (reason) {
                                _this._ongoingPromise =
                                  undefined;
                                _this._isFinished = true;
                                ReadableStreamReaderGenericRelease(
                                  reader
                                );
                                rejectPromise(
                                  reason
                                );
                              },
                          };
                          ReadableStreamDefaultReaderRead(
                            reader,
                            readRequest
                          );
                          return promise;
                        };
                      ReadableStreamAsyncIteratorImpl.prototype._returnSteps =
                        function (value) {
                          if (this._isFinished) {
                            return Promise.resolve(
                              {
                                value: value,
                                done: true,
                              }
                            );
                          }
                          this._isFinished = true;
                          var reader =
                            this._reader;
                          if (
                            reader._ownerReadableStream ===
                            undefined
                          ) {
                            return promiseRejectedWith(
                              readerLockException(
                                "finish iterating"
                              )
                            );
                          }
                          if (
                            !this._preventCancel
                          ) {
                            var result =
                              ReadableStreamReaderGenericCancel(
                                reader,
                                value
                              );
                            ReadableStreamReaderGenericRelease(
                              reader
                            );
                            return transformPromiseWith(
                              result,
                              function () {
                                return {
                                  value: value,
                                  done: true,
                                };
                              }
                            );
                          }
                          ReadableStreamReaderGenericRelease(
                            reader
                          );
                          return promiseResolvedWith(
                            {
                              value: value,
                              done: true,
                            }
                          );
                        };
                      return ReadableStreamAsyncIteratorImpl;
                    })();
                  var ReadableStreamAsyncIteratorPrototype =
                    {
                      next: function () {
                        if (
                          !IsReadableStreamAsyncIterator(
                            this
                          )
                        ) {
                          return promiseRejectedWith(
                            streamAsyncIteratorBrandCheckException(
                              "next"
                            )
                          );
                        }
                        return this._asyncIteratorImpl.next();
                      },
                      return: function (value) {
                        if (
                          !IsReadableStreamAsyncIterator(
                            this
                          )
                        ) {
                          return promiseRejectedWith(
                            streamAsyncIteratorBrandCheckException(
                              "return"
                            )
                          );
                        }
                        return this._asyncIteratorImpl.return(
                          value
                        );
                      },
                    };
                  if (
                    AsyncIteratorPrototype !==
                    undefined
                  ) {
                    Object.setPrototypeOf(
                      ReadableStreamAsyncIteratorPrototype,
                      AsyncIteratorPrototype
                    );
                  }
                  function AcquireReadableStreamAsyncIterator(
                    stream,
                    preventCancel
                  ) {
                    var reader =
                      AcquireReadableStreamDefaultReader(
                        stream
                      );
                    var impl =
                      new ReadableStreamAsyncIteratorImpl(
                        reader,
                        preventCancel
                      );
                    var iterator = Object.create(
                      ReadableStreamAsyncIteratorPrototype
                    );
                    iterator._asyncIteratorImpl =
                      impl;
                    return iterator;
                  }
                  function IsReadableStreamAsyncIterator(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_asyncIteratorImpl"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function streamAsyncIteratorBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "ReadableStreamAsyncIterator." +
                        name +
                        " can only be used on a ReadableSteamAsyncIterator"
                    );
                  }
                  var NumberIsNaN =
                    Number.isNaN ||
                    function (x) {
                      return x !== x;
                    };
                  function IsFiniteNonNegativeNumber(
                    v
                  ) {
                    if (!IsNonNegativeNumber(v)) {
                      return false;
                    }
                    if (v === Infinity) {
                      return false;
                    }
                    return true;
                  }
                  function IsNonNegativeNumber(
                    v
                  ) {
                    if (typeof v !== "number") {
                      return false;
                    }
                    if (NumberIsNaN(v)) {
                      return false;
                    }
                    if (v < 0) {
                      return false;
                    }
                    return true;
                  }
                  function DequeueValue(
                    container
                  ) {
                    var pair =
                      container._queue.shift();
                    container._queueTotalSize -=
                      pair.size;
                    if (
                      container._queueTotalSize <
                      0
                    ) {
                      container._queueTotalSize = 0;
                    }
                    return pair.value;
                  }
                  function EnqueueValueWithSize(
                    container,
                    value,
                    size
                  ) {
                    size = Number(size);
                    if (
                      !IsFiniteNonNegativeNumber(
                        size
                      )
                    ) {
                      throw new RangeError(
                        "Size must be a finite, non-NaN, non-negative number."
                      );
                    }
                    container._queue.push({
                      value: value,
                      size: size,
                    });
                    container._queueTotalSize +=
                      size;
                  }
                  function PeekQueueValue(
                    container
                  ) {
                    var pair =
                      container._queue.peek();
                    return pair.value;
                  }
                  function ResetQueue(container) {
                    container._queue =
                      new SimpleQueue();
                    container._queueTotalSize = 0;
                  }
                  function CreateArrayFromList(
                    elements
                  ) {
                    return elements.slice();
                  }
                  function CopyDataBlockBytes(
                    dest,
                    destOffset,
                    src,
                    srcOffset,
                    n
                  ) {
                    new Uint8Array(dest).set(
                      new Uint8Array(
                        src,
                        srcOffset,
                        n
                      ),
                      destOffset
                    );
                  }
                  function TransferArrayBuffer(
                    O
                  ) {
                    return O;
                  }
                  function IsDetachedBuffer(O) {
                    return false;
                  }
                  var ReadableStreamBYOBRequest =
                    (function () {
                      function ReadableStreamBYOBRequest() {
                        throw new TypeError(
                          "Illegal constructor"
                        );
                      }
                      Object.defineProperty(
                        ReadableStreamBYOBRequest.prototype,
                        "view",
                        {
                          get: function () {
                            if (
                              !IsReadableStreamBYOBRequest(
                                this
                              )
                            ) {
                              throw byobRequestBrandCheckException(
                                "view"
                              );
                            }
                            return this._view;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      ReadableStreamBYOBRequest.prototype.respond =
                        function (bytesWritten) {
                          if (
                            !IsReadableStreamBYOBRequest(
                              this
                            )
                          ) {
                            throw byobRequestBrandCheckException(
                              "respond"
                            );
                          }
                          assertRequiredArgument(
                            bytesWritten,
                            1,
                            "respond"
                          );
                          bytesWritten =
                            convertUnsignedLongLongWithEnforceRange(
                              bytesWritten,
                              "First parameter"
                            );
                          if (
                            this
                              ._associatedReadableByteStreamController ===
                            undefined
                          ) {
                            throw new TypeError(
                              "This BYOB request has been invalidated"
                            );
                          }
                          if (
                            IsDetachedBuffer(
                              this._view.buffer
                            )
                          );
                          ReadableByteStreamControllerRespond(
                            this
                              ._associatedReadableByteStreamController,
                            bytesWritten
                          );
                        };
                      ReadableStreamBYOBRequest.prototype.respondWithNewView =
                        function (view) {
                          if (
                            !IsReadableStreamBYOBRequest(
                              this
                            )
                          ) {
                            throw byobRequestBrandCheckException(
                              "respondWithNewView"
                            );
                          }
                          assertRequiredArgument(
                            view,
                            1,
                            "respondWithNewView"
                          );
                          if (
                            !ArrayBuffer.isView(
                              view
                            )
                          ) {
                            throw new TypeError(
                              "You can only respond with array buffer views"
                            );
                          }
                          if (
                            view.byteLength === 0
                          ) {
                            throw new TypeError(
                              "chunk must have non-zero byteLength"
                            );
                          }
                          if (
                            view.buffer
                              .byteLength === 0
                          ) {
                            throw new TypeError(
                              "chunk's buffer must have non-zero byteLength"
                            );
                          }
                          if (
                            this
                              ._associatedReadableByteStreamController ===
                            undefined
                          ) {
                            throw new TypeError(
                              "This BYOB request has been invalidated"
                            );
                          }
                          ReadableByteStreamControllerRespondWithNewView(
                            this
                              ._associatedReadableByteStreamController,
                            view
                          );
                        };
                      return ReadableStreamBYOBRequest;
                    })();
                  Object.defineProperties(
                    ReadableStreamBYOBRequest.prototype,
                    {
                      respond: {
                        enumerable: true,
                      },
                      respondWithNewView: {
                        enumerable: true,
                      },
                      view: { enumerable: true },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      ReadableStreamBYOBRequest.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "ReadableStreamBYOBRequest",
                        configurable: true,
                      }
                    );
                  }
                  var ReadableByteStreamController =
                    (function () {
                      function ReadableByteStreamController() {
                        throw new TypeError(
                          "Illegal constructor"
                        );
                      }
                      Object.defineProperty(
                        ReadableByteStreamController.prototype,
                        "byobRequest",
                        {
                          get: function () {
                            if (
                              !IsReadableByteStreamController(
                                this
                              )
                            ) {
                              throw byteStreamControllerBrandCheckException(
                                "byobRequest"
                              );
                            }
                            if (
                              this
                                ._byobRequest ===
                                null &&
                              this
                                ._pendingPullIntos
                                .length > 0
                            ) {
                              var firstDescriptor =
                                this._pendingPullIntos.peek();
                              var view =
                                new Uint8Array(
                                  firstDescriptor.buffer,
                                  firstDescriptor.byteOffset +
                                    firstDescriptor.bytesFilled,
                                  firstDescriptor.byteLength -
                                    firstDescriptor.bytesFilled
                                );
                              var byobRequest =
                                Object.create(
                                  ReadableStreamBYOBRequest.prototype
                                );
                              SetUpReadableStreamBYOBRequest(
                                byobRequest,
                                this,
                                view
                              );
                              this._byobRequest =
                                byobRequest;
                            }
                            return this
                              ._byobRequest;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      Object.defineProperty(
                        ReadableByteStreamController.prototype,
                        "desiredSize",
                        {
                          get: function () {
                            if (
                              !IsReadableByteStreamController(
                                this
                              )
                            ) {
                              throw byteStreamControllerBrandCheckException(
                                "desiredSize"
                              );
                            }
                            return ReadableByteStreamControllerGetDesiredSize(
                              this
                            );
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      ReadableByteStreamController.prototype.close =
                        function () {
                          if (
                            !IsReadableByteStreamController(
                              this
                            )
                          ) {
                            throw byteStreamControllerBrandCheckException(
                              "close"
                            );
                          }
                          if (
                            this._closeRequested
                          ) {
                            throw new TypeError(
                              "The stream has already been closed; do not close it again!"
                            );
                          }
                          var state =
                            this
                              ._controlledReadableByteStream
                              ._state;
                          if (
                            state !== "readable"
                          ) {
                            throw new TypeError(
                              "The stream (in " +
                                state +
                                " state) is not in the readable state and cannot be closed"
                            );
                          }
                          ReadableByteStreamControllerClose(
                            this
                          );
                        };
                      ReadableByteStreamController.prototype.enqueue =
                        function (chunk) {
                          if (
                            !IsReadableByteStreamController(
                              this
                            )
                          ) {
                            throw byteStreamControllerBrandCheckException(
                              "enqueue"
                            );
                          }
                          assertRequiredArgument(
                            chunk,
                            1,
                            "enqueue"
                          );
                          if (
                            !ArrayBuffer.isView(
                              chunk
                            )
                          ) {
                            throw new TypeError(
                              "chunk must be an array buffer view"
                            );
                          }
                          if (
                            chunk.byteLength === 0
                          ) {
                            throw new TypeError(
                              "chunk must have non-zero byteLength"
                            );
                          }
                          if (
                            chunk.buffer
                              .byteLength === 0
                          ) {
                            throw new TypeError(
                              "chunk's buffer must have non-zero byteLength"
                            );
                          }
                          if (
                            this._closeRequested
                          ) {
                            throw new TypeError(
                              "stream is closed or draining"
                            );
                          }
                          var state =
                            this
                              ._controlledReadableByteStream
                              ._state;
                          if (
                            state !== "readable"
                          ) {
                            throw new TypeError(
                              "The stream (in " +
                                state +
                                " state) is not in the readable state and cannot be enqueued to"
                            );
                          }
                          ReadableByteStreamControllerEnqueue(
                            this,
                            chunk
                          );
                        };
                      ReadableByteStreamController.prototype.error =
                        function (e) {
                          if (e === void 0) {
                            e = undefined;
                          }
                          if (
                            !IsReadableByteStreamController(
                              this
                            )
                          ) {
                            throw byteStreamControllerBrandCheckException(
                              "error"
                            );
                          }
                          ReadableByteStreamControllerError(
                            this,
                            e
                          );
                        };
                      ReadableByteStreamController.prototype[
                        CancelSteps
                      ] = function (reason) {
                        if (
                          this._pendingPullIntos
                            .length > 0
                        ) {
                          var firstDescriptor =
                            this._pendingPullIntos.peek();
                          firstDescriptor.bytesFilled = 0;
                        }
                        ResetQueue(this);
                        var result =
                          this._cancelAlgorithm(
                            reason
                          );
                        ReadableByteStreamControllerClearAlgorithms(
                          this
                        );
                        return result;
                      };
                      ReadableByteStreamController.prototype[
                        PullSteps
                      ] = function (readRequest) {
                        var stream =
                          this
                            ._controlledReadableByteStream;
                        if (
                          this._queueTotalSize > 0
                        ) {
                          var entry =
                            this._queue.shift();
                          this._queueTotalSize -=
                            entry.byteLength;
                          ReadableByteStreamControllerHandleQueueDrain(
                            this
                          );
                          var view =
                            new Uint8Array(
                              entry.buffer,
                              entry.byteOffset,
                              entry.byteLength
                            );
                          readRequest._chunkSteps(
                            view
                          );
                          return;
                        }
                        var autoAllocateChunkSize =
                          this
                            ._autoAllocateChunkSize;
                        if (
                          autoAllocateChunkSize !==
                          undefined
                        ) {
                          var buffer = void 0;
                          try {
                            buffer =
                              new ArrayBuffer(
                                autoAllocateChunkSize
                              );
                          } catch (bufferE) {
                            readRequest._errorSteps(
                              bufferE
                            );
                            return;
                          }
                          var pullIntoDescriptor =
                            {
                              buffer: buffer,
                              byteOffset: 0,
                              byteLength:
                                autoAllocateChunkSize,
                              bytesFilled: 0,
                              elementSize: 1,
                              viewConstructor:
                                Uint8Array,
                              readerType:
                                "default",
                            };
                          this._pendingPullIntos.push(
                            pullIntoDescriptor
                          );
                        }
                        ReadableStreamAddReadRequest(
                          stream,
                          readRequest
                        );
                        ReadableByteStreamControllerCallPullIfNeeded(
                          this
                        );
                      };
                      return ReadableByteStreamController;
                    })();
                  Object.defineProperties(
                    ReadableByteStreamController.prototype,
                    {
                      close: { enumerable: true },
                      enqueue: {
                        enumerable: true,
                      },
                      error: { enumerable: true },
                      byobRequest: {
                        enumerable: true,
                      },
                      desiredSize: {
                        enumerable: true,
                      },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      ReadableByteStreamController.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "ReadableByteStreamController",
                        configurable: true,
                      }
                    );
                  }
                  function IsReadableByteStreamController(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_controlledReadableByteStream"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function IsReadableStreamBYOBRequest(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_associatedReadableByteStreamController"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableByteStreamControllerCallPullIfNeeded(
                    controller
                  ) {
                    var shouldPull =
                      ReadableByteStreamControllerShouldCallPull(
                        controller
                      );
                    if (!shouldPull) {
                      return;
                    }
                    if (controller._pulling) {
                      controller._pullAgain = true;
                      return;
                    }
                    controller._pulling = true;
                    var pullPromise =
                      controller._pullAlgorithm();
                    uponPromise(
                      pullPromise,
                      function () {
                        controller._pulling = false;
                        if (
                          controller._pullAgain
                        ) {
                          controller._pullAgain = false;
                          ReadableByteStreamControllerCallPullIfNeeded(
                            controller
                          );
                        }
                      },
                      function (e) {
                        ReadableByteStreamControllerError(
                          controller,
                          e
                        );
                      }
                    );
                  }
                  function ReadableByteStreamControllerClearPendingPullIntos(
                    controller
                  ) {
                    ReadableByteStreamControllerInvalidateBYOBRequest(
                      controller
                    );
                    controller._pendingPullIntos =
                      new SimpleQueue();
                  }
                  function ReadableByteStreamControllerCommitPullIntoDescriptor(
                    stream,
                    pullIntoDescriptor
                  ) {
                    var done = false;
                    if (
                      stream._state === "closed"
                    ) {
                      done = true;
                    }
                    var filledView =
                      ReadableByteStreamControllerConvertPullIntoDescriptor(
                        pullIntoDescriptor
                      );
                    if (
                      pullIntoDescriptor.readerType ===
                      "default"
                    ) {
                      ReadableStreamFulfillReadRequest(
                        stream,
                        filledView,
                        done
                      );
                    } else {
                      ReadableStreamFulfillReadIntoRequest(
                        stream,
                        filledView,
                        done
                      );
                    }
                  }
                  function ReadableByteStreamControllerConvertPullIntoDescriptor(
                    pullIntoDescriptor
                  ) {
                    var bytesFilled =
                      pullIntoDescriptor.bytesFilled;
                    var elementSize =
                      pullIntoDescriptor.elementSize;
                    return new pullIntoDescriptor.viewConstructor(
                      pullIntoDescriptor.buffer,
                      pullIntoDescriptor.byteOffset,
                      bytesFilled / elementSize
                    );
                  }
                  function ReadableByteStreamControllerEnqueueChunkToQueue(
                    controller,
                    buffer,
                    byteOffset,
                    byteLength
                  ) {
                    controller._queue.push({
                      buffer: buffer,
                      byteOffset: byteOffset,
                      byteLength: byteLength,
                    });
                    controller._queueTotalSize +=
                      byteLength;
                  }
                  function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(
                    controller,
                    pullIntoDescriptor
                  ) {
                    var elementSize =
                      pullIntoDescriptor.elementSize;
                    var currentAlignedBytes =
                      pullIntoDescriptor.bytesFilled -
                      (pullIntoDescriptor.bytesFilled %
                        elementSize);
                    var maxBytesToCopy = Math.min(
                      controller._queueTotalSize,
                      pullIntoDescriptor.byteLength -
                        pullIntoDescriptor.bytesFilled
                    );
                    var maxBytesFilled =
                      pullIntoDescriptor.bytesFilled +
                      maxBytesToCopy;
                    var maxAlignedBytes =
                      maxBytesFilled -
                      (maxBytesFilled %
                        elementSize);
                    var totalBytesToCopyRemaining =
                      maxBytesToCopy;
                    var ready = false;
                    if (
                      maxAlignedBytes >
                      currentAlignedBytes
                    ) {
                      totalBytesToCopyRemaining =
                        maxAlignedBytes -
                        pullIntoDescriptor.bytesFilled;
                      ready = true;
                    }
                    var queue = controller._queue;
                    while (
                      totalBytesToCopyRemaining >
                      0
                    ) {
                      var headOfQueue =
                        queue.peek();
                      var bytesToCopy = Math.min(
                        totalBytesToCopyRemaining,
                        headOfQueue.byteLength
                      );
                      var destStart =
                        pullIntoDescriptor.byteOffset +
                        pullIntoDescriptor.bytesFilled;
                      CopyDataBlockBytes(
                        pullIntoDescriptor.buffer,
                        destStart,
                        headOfQueue.buffer,
                        headOfQueue.byteOffset,
                        bytesToCopy
                      );
                      if (
                        headOfQueue.byteLength ===
                        bytesToCopy
                      ) {
                        queue.shift();
                      } else {
                        headOfQueue.byteOffset +=
                          bytesToCopy;
                        headOfQueue.byteLength -=
                          bytesToCopy;
                      }
                      controller._queueTotalSize -=
                        bytesToCopy;
                      ReadableByteStreamControllerFillHeadPullIntoDescriptor(
                        controller,
                        bytesToCopy,
                        pullIntoDescriptor
                      );
                      totalBytesToCopyRemaining -=
                        bytesToCopy;
                    }
                    return ready;
                  }
                  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(
                    controller,
                    size,
                    pullIntoDescriptor
                  ) {
                    ReadableByteStreamControllerInvalidateBYOBRequest(
                      controller
                    );
                    pullIntoDescriptor.bytesFilled +=
                      size;
                  }
                  function ReadableByteStreamControllerHandleQueueDrain(
                    controller
                  ) {
                    if (
                      controller._queueTotalSize ===
                        0 &&
                      controller._closeRequested
                    ) {
                      ReadableByteStreamControllerClearAlgorithms(
                        controller
                      );
                      ReadableStreamClose(
                        controller._controlledReadableByteStream
                      );
                    } else {
                      ReadableByteStreamControllerCallPullIfNeeded(
                        controller
                      );
                    }
                  }
                  function ReadableByteStreamControllerInvalidateBYOBRequest(
                    controller
                  ) {
                    if (
                      controller._byobRequest ===
                      null
                    ) {
                      return;
                    }
                    controller._byobRequest._associatedReadableByteStreamController =
                      undefined;
                    controller._byobRequest._view =
                      null;
                    controller._byobRequest =
                      null;
                  }
                  function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(
                    controller
                  ) {
                    while (
                      controller._pendingPullIntos
                        .length > 0
                    ) {
                      if (
                        controller._queueTotalSize ===
                        0
                      ) {
                        return;
                      }
                      var pullIntoDescriptor =
                        controller._pendingPullIntos.peek();
                      if (
                        ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(
                          controller,
                          pullIntoDescriptor
                        )
                      ) {
                        ReadableByteStreamControllerShiftPendingPullInto(
                          controller
                        );
                        ReadableByteStreamControllerCommitPullIntoDescriptor(
                          controller._controlledReadableByteStream,
                          pullIntoDescriptor
                        );
                      }
                    }
                  }
                  function ReadableByteStreamControllerPullInto(
                    controller,
                    view,
                    readIntoRequest
                  ) {
                    var stream =
                      controller._controlledReadableByteStream;
                    var elementSize = 1;
                    if (
                      view.constructor !==
                      DataView
                    ) {
                      elementSize =
                        view.constructor
                          .BYTES_PER_ELEMENT;
                    }
                    var ctor = view.constructor;
                    var buffer =
                      TransferArrayBuffer(
                        view.buffer
                      );
                    var pullIntoDescriptor = {
                      buffer: buffer,
                      byteOffset: view.byteOffset,
                      byteLength: view.byteLength,
                      bytesFilled: 0,
                      elementSize: elementSize,
                      viewConstructor: ctor,
                      readerType: "byob",
                    };
                    if (
                      controller._pendingPullIntos
                        .length > 0
                    ) {
                      controller._pendingPullIntos.push(
                        pullIntoDescriptor
                      );
                      ReadableStreamAddReadIntoRequest(
                        stream,
                        readIntoRequest
                      );
                      return;
                    }
                    if (
                      stream._state === "closed"
                    ) {
                      var emptyView = new ctor(
                        pullIntoDescriptor.buffer,
                        pullIntoDescriptor.byteOffset,
                        0
                      );
                      readIntoRequest._closeSteps(
                        emptyView
                      );
                      return;
                    }
                    if (
                      controller._queueTotalSize >
                      0
                    ) {
                      if (
                        ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(
                          controller,
                          pullIntoDescriptor
                        )
                      ) {
                        var filledView =
                          ReadableByteStreamControllerConvertPullIntoDescriptor(
                            pullIntoDescriptor
                          );
                        ReadableByteStreamControllerHandleQueueDrain(
                          controller
                        );
                        readIntoRequest._chunkSteps(
                          filledView
                        );
                        return;
                      }
                      if (
                        controller._closeRequested
                      ) {
                        var e = new TypeError(
                          "Insufficient bytes to fill elements in the given buffer"
                        );
                        ReadableByteStreamControllerError(
                          controller,
                          e
                        );
                        readIntoRequest._errorSteps(
                          e
                        );
                        return;
                      }
                    }
                    controller._pendingPullIntos.push(
                      pullIntoDescriptor
                    );
                    ReadableStreamAddReadIntoRequest(
                      stream,
                      readIntoRequest
                    );
                    ReadableByteStreamControllerCallPullIfNeeded(
                      controller
                    );
                  }
                  function ReadableByteStreamControllerRespondInClosedState(
                    controller,
                    firstDescriptor
                  ) {
                    firstDescriptor.buffer =
                      TransferArrayBuffer(
                        firstDescriptor.buffer
                      );
                    var stream =
                      controller._controlledReadableByteStream;
                    if (
                      ReadableStreamHasBYOBReader(
                        stream
                      )
                    ) {
                      while (
                        ReadableStreamGetNumReadIntoRequests(
                          stream
                        ) > 0
                      ) {
                        var pullIntoDescriptor =
                          ReadableByteStreamControllerShiftPendingPullInto(
                            controller
                          );
                        ReadableByteStreamControllerCommitPullIntoDescriptor(
                          stream,
                          pullIntoDescriptor
                        );
                      }
                    }
                  }
                  function ReadableByteStreamControllerRespondInReadableState(
                    controller,
                    bytesWritten,
                    pullIntoDescriptor
                  ) {
                    if (
                      pullIntoDescriptor.bytesFilled +
                        bytesWritten >
                      pullIntoDescriptor.byteLength
                    ) {
                      throw new RangeError(
                        "bytesWritten out of range"
                      );
                    }
                    ReadableByteStreamControllerFillHeadPullIntoDescriptor(
                      controller,
                      bytesWritten,
                      pullIntoDescriptor
                    );
                    if (
                      pullIntoDescriptor.bytesFilled <
                      pullIntoDescriptor.elementSize
                    ) {
                      return;
                    }
                    ReadableByteStreamControllerShiftPendingPullInto(
                      controller
                    );
                    var remainderSize =
                      pullIntoDescriptor.bytesFilled %
                      pullIntoDescriptor.elementSize;
                    if (remainderSize > 0) {
                      var end =
                        pullIntoDescriptor.byteOffset +
                        pullIntoDescriptor.bytesFilled;
                      var remainder =
                        pullIntoDescriptor.buffer.slice(
                          end - remainderSize,
                          end
                        );
                      ReadableByteStreamControllerEnqueueChunkToQueue(
                        controller,
                        remainder,
                        0,
                        remainder.byteLength
                      );
                    }
                    pullIntoDescriptor.buffer =
                      TransferArrayBuffer(
                        pullIntoDescriptor.buffer
                      );
                    pullIntoDescriptor.bytesFilled -=
                      remainderSize;
                    ReadableByteStreamControllerCommitPullIntoDescriptor(
                      controller._controlledReadableByteStream,
                      pullIntoDescriptor
                    );
                    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(
                      controller
                    );
                  }
                  function ReadableByteStreamControllerRespondInternal(
                    controller,
                    bytesWritten
                  ) {
                    var firstDescriptor =
                      controller._pendingPullIntos.peek();
                    var state =
                      controller
                        ._controlledReadableByteStream
                        ._state;
                    if (state === "closed") {
                      if (bytesWritten !== 0) {
                        throw new TypeError(
                          "bytesWritten must be 0 when calling respond() on a closed stream"
                        );
                      }
                      ReadableByteStreamControllerRespondInClosedState(
                        controller,
                        firstDescriptor
                      );
                    } else {
                      ReadableByteStreamControllerRespondInReadableState(
                        controller,
                        bytesWritten,
                        firstDescriptor
                      );
                    }
                    ReadableByteStreamControllerCallPullIfNeeded(
                      controller
                    );
                  }
                  function ReadableByteStreamControllerShiftPendingPullInto(
                    controller
                  ) {
                    var descriptor =
                      controller._pendingPullIntos.shift();
                    ReadableByteStreamControllerInvalidateBYOBRequest(
                      controller
                    );
                    return descriptor;
                  }
                  function ReadableByteStreamControllerShouldCallPull(
                    controller
                  ) {
                    var stream =
                      controller._controlledReadableByteStream;
                    if (
                      stream._state !== "readable"
                    ) {
                      return false;
                    }
                    if (
                      controller._closeRequested
                    ) {
                      return false;
                    }
                    if (!controller._started) {
                      return false;
                    }
                    if (
                      ReadableStreamHasDefaultReader(
                        stream
                      ) &&
                      ReadableStreamGetNumReadRequests(
                        stream
                      ) > 0
                    ) {
                      return true;
                    }
                    if (
                      ReadableStreamHasBYOBReader(
                        stream
                      ) &&
                      ReadableStreamGetNumReadIntoRequests(
                        stream
                      ) > 0
                    ) {
                      return true;
                    }
                    var desiredSize =
                      ReadableByteStreamControllerGetDesiredSize(
                        controller
                      );
                    if (desiredSize > 0) {
                      return true;
                    }
                    return false;
                  }
                  function ReadableByteStreamControllerClearAlgorithms(
                    controller
                  ) {
                    controller._pullAlgorithm =
                      undefined;
                    controller._cancelAlgorithm =
                      undefined;
                  }
                  function ReadableByteStreamControllerClose(
                    controller
                  ) {
                    var stream =
                      controller._controlledReadableByteStream;
                    if (
                      controller._closeRequested ||
                      stream._state !== "readable"
                    ) {
                      return;
                    }
                    if (
                      controller._queueTotalSize >
                      0
                    ) {
                      controller._closeRequested = true;
                      return;
                    }
                    if (
                      controller._pendingPullIntos
                        .length > 0
                    ) {
                      var firstPendingPullInto =
                        controller._pendingPullIntos.peek();
                      if (
                        firstPendingPullInto.bytesFilled >
                        0
                      ) {
                        var e = new TypeError(
                          "Insufficient bytes to fill elements in the given buffer"
                        );
                        ReadableByteStreamControllerError(
                          controller,
                          e
                        );
                        throw e;
                      }
                    }
                    ReadableByteStreamControllerClearAlgorithms(
                      controller
                    );
                    ReadableStreamClose(stream);
                  }
                  function ReadableByteStreamControllerEnqueue(
                    controller,
                    chunk
                  ) {
                    var stream =
                      controller._controlledReadableByteStream;
                    if (
                      controller._closeRequested ||
                      stream._state !== "readable"
                    ) {
                      return;
                    }
                    var buffer = chunk.buffer;
                    var byteOffset =
                      chunk.byteOffset;
                    var byteLength =
                      chunk.byteLength;
                    var transferredBuffer =
                      TransferArrayBuffer(buffer);
                    if (
                      ReadableStreamHasDefaultReader(
                        stream
                      )
                    ) {
                      if (
                        ReadableStreamGetNumReadRequests(
                          stream
                        ) === 0
                      ) {
                        ReadableByteStreamControllerEnqueueChunkToQueue(
                          controller,
                          transferredBuffer,
                          byteOffset,
                          byteLength
                        );
                      } else {
                        var transferredView =
                          new Uint8Array(
                            transferredBuffer,
                            byteOffset,
                            byteLength
                          );
                        ReadableStreamFulfillReadRequest(
                          stream,
                          transferredView,
                          false
                        );
                      }
                    } else if (
                      ReadableStreamHasBYOBReader(
                        stream
                      )
                    ) {
                      ReadableByteStreamControllerEnqueueChunkToQueue(
                        controller,
                        transferredBuffer,
                        byteOffset,
                        byteLength
                      );
                      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(
                        controller
                      );
                    } else {
                      ReadableByteStreamControllerEnqueueChunkToQueue(
                        controller,
                        transferredBuffer,
                        byteOffset,
                        byteLength
                      );
                    }
                    ReadableByteStreamControllerCallPullIfNeeded(
                      controller
                    );
                  }
                  function ReadableByteStreamControllerError(
                    controller,
                    e
                  ) {
                    var stream =
                      controller._controlledReadableByteStream;
                    if (
                      stream._state !== "readable"
                    ) {
                      return;
                    }
                    ReadableByteStreamControllerClearPendingPullIntos(
                      controller
                    );
                    ResetQueue(controller);
                    ReadableByteStreamControllerClearAlgorithms(
                      controller
                    );
                    ReadableStreamError(
                      stream,
                      e
                    );
                  }
                  function ReadableByteStreamControllerGetDesiredSize(
                    controller
                  ) {
                    var state =
                      controller
                        ._controlledReadableByteStream
                        ._state;
                    if (state === "errored") {
                      return null;
                    }
                    if (state === "closed") {
                      return 0;
                    }
                    return (
                      controller._strategyHWM -
                      controller._queueTotalSize
                    );
                  }
                  function ReadableByteStreamControllerRespond(
                    controller,
                    bytesWritten
                  ) {
                    bytesWritten =
                      Number(bytesWritten);
                    if (
                      !IsFiniteNonNegativeNumber(
                        bytesWritten
                      )
                    ) {
                      throw new RangeError(
                        "bytesWritten must be a finite"
                      );
                    }
                    ReadableByteStreamControllerRespondInternal(
                      controller,
                      bytesWritten
                    );
                  }
                  function ReadableByteStreamControllerRespondWithNewView(
                    controller,
                    view
                  ) {
                    var firstDescriptor =
                      controller._pendingPullIntos.peek();
                    if (
                      firstDescriptor.byteOffset +
                        firstDescriptor.bytesFilled !==
                      view.byteOffset
                    ) {
                      throw new RangeError(
                        "The region specified by view does not match byobRequest"
                      );
                    }
                    if (
                      firstDescriptor.byteLength !==
                      view.byteLength
                    ) {
                      throw new RangeError(
                        "The buffer of view has different capacity than byobRequest"
                      );
                    }
                    firstDescriptor.buffer =
                      view.buffer;
                    ReadableByteStreamControllerRespondInternal(
                      controller,
                      view.byteLength
                    );
                  }
                  function SetUpReadableByteStreamController(
                    stream,
                    controller,
                    startAlgorithm,
                    pullAlgorithm,
                    cancelAlgorithm,
                    highWaterMark,
                    autoAllocateChunkSize
                  ) {
                    controller._controlledReadableByteStream =
                      stream;
                    controller._pullAgain = false;
                    controller._pulling = false;
                    controller._byobRequest =
                      null;
                    controller._queue =
                      controller._queueTotalSize =
                        undefined;
                    ResetQueue(controller);
                    controller._closeRequested = false;
                    controller._started = false;
                    controller._strategyHWM =
                      highWaterMark;
                    controller._pullAlgorithm =
                      pullAlgorithm;
                    controller._cancelAlgorithm =
                      cancelAlgorithm;
                    controller._autoAllocateChunkSize =
                      autoAllocateChunkSize;
                    controller._pendingPullIntos =
                      new SimpleQueue();
                    stream._readableStreamController =
                      controller;
                    var startResult =
                      startAlgorithm();
                    uponPromise(
                      promiseResolvedWith(
                        startResult
                      ),
                      function () {
                        controller._started = true;
                        ReadableByteStreamControllerCallPullIfNeeded(
                          controller
                        );
                      },
                      function (r) {
                        ReadableByteStreamControllerError(
                          controller,
                          r
                        );
                      }
                    );
                  }
                  function SetUpReadableByteStreamControllerFromUnderlyingSource(
                    stream,
                    underlyingByteSource,
                    highWaterMark
                  ) {
                    var controller =
                      Object.create(
                        ReadableByteStreamController.prototype
                      );
                    var startAlgorithm =
                      function () {
                        return undefined;
                      };
                    var pullAlgorithm =
                      function () {
                        return promiseResolvedWith(
                          undefined
                        );
                      };
                    var cancelAlgorithm =
                      function () {
                        return promiseResolvedWith(
                          undefined
                        );
                      };
                    if (
                      underlyingByteSource.start !==
                      undefined
                    ) {
                      startAlgorithm =
                        function () {
                          return underlyingByteSource.start(
                            controller
                          );
                        };
                    }
                    if (
                      underlyingByteSource.pull !==
                      undefined
                    ) {
                      pullAlgorithm =
                        function () {
                          return underlyingByteSource.pull(
                            controller
                          );
                        };
                    }
                    if (
                      underlyingByteSource.cancel !==
                      undefined
                    ) {
                      cancelAlgorithm = function (
                        reason
                      ) {
                        return underlyingByteSource.cancel(
                          reason
                        );
                      };
                    }
                    var autoAllocateChunkSize =
                      underlyingByteSource.autoAllocateChunkSize;
                    if (
                      autoAllocateChunkSize === 0
                    ) {
                      throw new TypeError(
                        "autoAllocateChunkSize must be greater than 0"
                      );
                    }
                    SetUpReadableByteStreamController(
                      stream,
                      controller,
                      startAlgorithm,
                      pullAlgorithm,
                      cancelAlgorithm,
                      highWaterMark,
                      autoAllocateChunkSize
                    );
                  }
                  function SetUpReadableStreamBYOBRequest(
                    request,
                    controller,
                    view
                  ) {
                    request._associatedReadableByteStreamController =
                      controller;
                    request._view = view;
                  }
                  function byobRequestBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "ReadableStreamBYOBRequest.prototype." +
                        name +
                        " can only be used on a ReadableStreamBYOBRequest"
                    );
                  }
                  function byteStreamControllerBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "ReadableByteStreamController.prototype." +
                        name +
                        " can only be used on a ReadableByteStreamController"
                    );
                  }
                  function AcquireReadableStreamBYOBReader(
                    stream
                  ) {
                    return new ReadableStreamBYOBReader(
                      stream
                    );
                  }
                  function ReadableStreamAddReadIntoRequest(
                    stream,
                    readIntoRequest
                  ) {
                    stream._reader._readIntoRequests.push(
                      readIntoRequest
                    );
                  }
                  function ReadableStreamFulfillReadIntoRequest(
                    stream,
                    chunk,
                    done
                  ) {
                    var reader = stream._reader;
                    var readIntoRequest =
                      reader._readIntoRequests.shift();
                    if (done) {
                      readIntoRequest._closeSteps(
                        chunk
                      );
                    } else {
                      readIntoRequest._chunkSteps(
                        chunk
                      );
                    }
                  }
                  function ReadableStreamGetNumReadIntoRequests(
                    stream
                  ) {
                    return stream
                      ._reader._readIntoRequests.length;
                  }
                  function ReadableStreamHasBYOBReader(
                    stream
                  ) {
                    var reader = stream._reader;
                    if (reader === undefined) {
                      return false;
                    }
                    if (
                      !IsReadableStreamBYOBReader(
                        reader
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  var ReadableStreamBYOBReader =
                    (function () {
                      function ReadableStreamBYOBReader(
                        stream
                      ) {
                        assertRequiredArgument(
                          stream,
                          1,
                          "ReadableStreamBYOBReader"
                        );
                        assertReadableStream(
                          stream,
                          "First parameter"
                        );
                        if (
                          IsReadableStreamLocked(
                            stream
                          )
                        ) {
                          throw new TypeError(
                            "This stream has already been locked for exclusive reading by another reader"
                          );
                        }
                        if (
                          !IsReadableByteStreamController(
                            stream._readableStreamController
                          )
                        ) {
                          throw new TypeError(
                            "Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte " +
                              "source"
                          );
                        }
                        ReadableStreamReaderGenericInitialize(
                          this,
                          stream
                        );
                        this._readIntoRequests =
                          new SimpleQueue();
                      }
                      Object.defineProperty(
                        ReadableStreamBYOBReader.prototype,
                        "closed",
                        {
                          get: function () {
                            if (
                              !IsReadableStreamBYOBReader(
                                this
                              )
                            ) {
                              return promiseRejectedWith(
                                byobReaderBrandCheckException(
                                  "closed"
                                )
                              );
                            }
                            return this
                              ._closedPromise;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      ReadableStreamBYOBReader.prototype.cancel =
                        function (reason) {
                          if (reason === void 0) {
                            reason = undefined;
                          }
                          if (
                            !IsReadableStreamBYOBReader(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              byobReaderBrandCheckException(
                                "cancel"
                              )
                            );
                          }
                          if (
                            this
                              ._ownerReadableStream ===
                            undefined
                          ) {
                            return promiseRejectedWith(
                              readerLockException(
                                "cancel"
                              )
                            );
                          }
                          return ReadableStreamReaderGenericCancel(
                            this,
                            reason
                          );
                        };
                      ReadableStreamBYOBReader.prototype.read =
                        function (view) {
                          if (
                            !IsReadableStreamBYOBReader(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              byobReaderBrandCheckException(
                                "read"
                              )
                            );
                          }
                          if (
                            !ArrayBuffer.isView(
                              view
                            )
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "view must be an array buffer view"
                              )
                            );
                          }
                          if (
                            view.byteLength === 0
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "view must have non-zero byteLength"
                              )
                            );
                          }
                          if (
                            view.buffer
                              .byteLength === 0
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "view's buffer must have non-zero byteLength"
                              )
                            );
                          }
                          if (
                            this
                              ._ownerReadableStream ===
                            undefined
                          ) {
                            return promiseRejectedWith(
                              readerLockException(
                                "read from"
                              )
                            );
                          }
                          var resolvePromise;
                          var rejectPromise;
                          var promise =
                            newPromise(function (
                              resolve,
                              reject
                            ) {
                              resolvePromise =
                                resolve;
                              rejectPromise =
                                reject;
                            });
                          var readIntoRequest = {
                            _chunkSteps:
                              function (chunk) {
                                return resolvePromise(
                                  {
                                    value: chunk,
                                    done: false,
                                  }
                                );
                              },
                            _closeSteps:
                              function (chunk) {
                                return resolvePromise(
                                  {
                                    value: chunk,
                                    done: true,
                                  }
                                );
                              },
                            _errorSteps:
                              function (e) {
                                return rejectPromise(
                                  e
                                );
                              },
                          };
                          ReadableStreamBYOBReaderRead(
                            this,
                            view,
                            readIntoRequest
                          );
                          return promise;
                        };
                      ReadableStreamBYOBReader.prototype.releaseLock =
                        function () {
                          if (
                            !IsReadableStreamBYOBReader(
                              this
                            )
                          ) {
                            throw byobReaderBrandCheckException(
                              "releaseLock"
                            );
                          }
                          if (
                            this
                              ._ownerReadableStream ===
                            undefined
                          ) {
                            return;
                          }
                          if (
                            this._readIntoRequests
                              .length > 0
                          ) {
                            throw new TypeError(
                              "Tried to release a reader lock when that reader has pending read() calls un-settled"
                            );
                          }
                          ReadableStreamReaderGenericRelease(
                            this
                          );
                        };
                      return ReadableStreamBYOBReader;
                    })();
                  Object.defineProperties(
                    ReadableStreamBYOBReader.prototype,
                    {
                      cancel: {
                        enumerable: true,
                      },
                      read: { enumerable: true },
                      releaseLock: {
                        enumerable: true,
                      },
                      closed: {
                        enumerable: true,
                      },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      ReadableStreamBYOBReader.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "ReadableStreamBYOBReader",
                        configurable: true,
                      }
                    );
                  }
                  function IsReadableStreamBYOBReader(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_readIntoRequests"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamBYOBReaderRead(
                    reader,
                    view,
                    readIntoRequest
                  ) {
                    var stream =
                      reader._ownerReadableStream;
                    stream._disturbed = true;
                    if (
                      stream._state === "errored"
                    ) {
                      readIntoRequest._errorSteps(
                        stream._storedError
                      );
                    } else {
                      ReadableByteStreamControllerPullInto(
                        stream._readableStreamController,
                        view,
                        readIntoRequest
                      );
                    }
                  }
                  function byobReaderBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "ReadableStreamBYOBReader.prototype." +
                        name +
                        " can only be used on a ReadableStreamBYOBReader"
                    );
                  }
                  function ExtractHighWaterMark(
                    strategy,
                    defaultHWM
                  ) {
                    var highWaterMark =
                      strategy.highWaterMark;
                    if (
                      highWaterMark === undefined
                    ) {
                      return defaultHWM;
                    }
                    if (
                      NumberIsNaN(
                        highWaterMark
                      ) ||
                      highWaterMark < 0
                    ) {
                      throw new RangeError(
                        "Invalid highWaterMark"
                      );
                    }
                    return highWaterMark;
                  }
                  function ExtractSizeAlgorithm(
                    strategy
                  ) {
                    var size = strategy.size;
                    if (!size) {
                      return function () {
                        return 1;
                      };
                    }
                    return size;
                  }
                  function convertQueuingStrategy(
                    init,
                    context
                  ) {
                    assertDictionary(
                      init,
                      context
                    );
                    var highWaterMark =
                      init === null ||
                      init === void 0
                        ? void 0
                        : init.highWaterMark;
                    var size =
                      init === null ||
                      init === void 0
                        ? void 0
                        : init.size;
                    return {
                      highWaterMark:
                        highWaterMark ===
                        undefined
                          ? undefined
                          : convertUnrestrictedDouble(
                              highWaterMark
                            ),
                      size:
                        size === undefined
                          ? undefined
                          : convertQueuingStrategySize(
                              size,
                              context +
                                " has member 'size' that"
                            ),
                    };
                  }
                  function convertQueuingStrategySize(
                    fn,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (chunk) {
                      return convertUnrestrictedDouble(
                        fn(chunk)
                      );
                    };
                  }
                  function convertUnderlyingSink(
                    original,
                    context
                  ) {
                    assertDictionary(
                      original,
                      context
                    );
                    var abort =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.abort;
                    var close =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.close;
                    var start =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.start;
                    var type =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.type;
                    var write =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.write;
                    return {
                      abort:
                        abort === undefined
                          ? undefined
                          : convertUnderlyingSinkAbortCallback(
                              abort,
                              original,
                              context +
                                " has member 'abort' that"
                            ),
                      close:
                        close === undefined
                          ? undefined
                          : convertUnderlyingSinkCloseCallback(
                              close,
                              original,
                              context +
                                " has member 'close' that"
                            ),
                      start:
                        start === undefined
                          ? undefined
                          : convertUnderlyingSinkStartCallback(
                              start,
                              original,
                              context +
                                " has member 'start' that"
                            ),
                      write:
                        write === undefined
                          ? undefined
                          : convertUnderlyingSinkWriteCallback(
                              write,
                              original,
                              context +
                                " has member 'write' that"
                            ),
                      type: type,
                    };
                  }
                  function convertUnderlyingSinkAbortCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (reason) {
                      return promiseCall(
                        fn,
                        original,
                        [reason]
                      );
                    };
                  }
                  function convertUnderlyingSinkCloseCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function () {
                      return promiseCall(
                        fn,
                        original,
                        []
                      );
                    };
                  }
                  function convertUnderlyingSinkStartCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (controller) {
                      return reflectCall(
                        fn,
                        original,
                        [controller]
                      );
                    };
                  }
                  function convertUnderlyingSinkWriteCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (
                      chunk,
                      controller
                    ) {
                      return promiseCall(
                        fn,
                        original,
                        [chunk, controller]
                      );
                    };
                  }
                  function assertWritableStream(
                    x,
                    context
                  ) {
                    if (!IsWritableStream(x)) {
                      throw new TypeError(
                        context +
                          " is not a WritableStream."
                      );
                    }
                  }
                  var WritableStream =
                    (function () {
                      function WritableStream(
                        rawUnderlyingSink,
                        rawStrategy
                      ) {
                        if (
                          rawUnderlyingSink ===
                          void 0
                        ) {
                          rawUnderlyingSink = {};
                        }
                        if (
                          rawStrategy === void 0
                        ) {
                          rawStrategy = {};
                        }
                        if (
                          rawUnderlyingSink ===
                          undefined
                        ) {
                          rawUnderlyingSink =
                            null;
                        } else {
                          assertObject(
                            rawUnderlyingSink,
                            "First parameter"
                          );
                        }
                        var strategy =
                          convertQueuingStrategy(
                            rawStrategy,
                            "Second parameter"
                          );
                        var underlyingSink =
                          convertUnderlyingSink(
                            rawUnderlyingSink,
                            "First parameter"
                          );
                        InitializeWritableStream(
                          this
                        );
                        var type =
                          underlyingSink.type;
                        if (type !== undefined) {
                          throw new RangeError(
                            "Invalid type is specified"
                          );
                        }
                        var sizeAlgorithm =
                          ExtractSizeAlgorithm(
                            strategy
                          );
                        var highWaterMark =
                          ExtractHighWaterMark(
                            strategy,
                            1
                          );
                        SetUpWritableStreamDefaultControllerFromUnderlyingSink(
                          this,
                          underlyingSink,
                          highWaterMark,
                          sizeAlgorithm
                        );
                      }
                      Object.defineProperty(
                        WritableStream.prototype,
                        "locked",
                        {
                          get: function () {
                            if (
                              !IsWritableStream(
                                this
                              )
                            ) {
                              throw streamBrandCheckException(
                                "locked"
                              );
                            }
                            return IsWritableStreamLocked(
                              this
                            );
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      WritableStream.prototype.abort =
                        function (reason) {
                          if (reason === void 0) {
                            reason = undefined;
                          }
                          if (
                            !IsWritableStream(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              streamBrandCheckException(
                                "abort"
                              )
                            );
                          }
                          if (
                            IsWritableStreamLocked(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "Cannot abort a stream that already has a writer"
                              )
                            );
                          }
                          return WritableStreamAbort(
                            this,
                            reason
                          );
                        };
                      WritableStream.prototype.close =
                        function () {
                          if (
                            !IsWritableStream(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              streamBrandCheckException(
                                "close"
                              )
                            );
                          }
                          if (
                            IsWritableStreamLocked(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "Cannot close a stream that already has a writer"
                              )
                            );
                          }
                          if (
                            WritableStreamCloseQueuedOrInFlight(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "Cannot close an already-closing stream"
                              )
                            );
                          }
                          return WritableStreamClose(
                            this
                          );
                        };
                      WritableStream.prototype.getWriter =
                        function () {
                          if (
                            !IsWritableStream(
                              this
                            )
                          ) {
                            throw streamBrandCheckException(
                              "getWriter"
                            );
                          }
                          return AcquireWritableStreamDefaultWriter(
                            this
                          );
                        };
                      return WritableStream;
                    })();
                  Object.defineProperties(
                    WritableStream.prototype,
                    {
                      abort: { enumerable: true },
                      close: { enumerable: true },
                      getWriter: {
                        enumerable: true,
                      },
                      locked: {
                        enumerable: true,
                      },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      WritableStream.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value: "WritableStream",
                        configurable: true,
                      }
                    );
                  }
                  function AcquireWritableStreamDefaultWriter(
                    stream
                  ) {
                    return new WritableStreamDefaultWriter(
                      stream
                    );
                  }
                  function CreateWritableStream(
                    startAlgorithm,
                    writeAlgorithm,
                    closeAlgorithm,
                    abortAlgorithm,
                    highWaterMark,
                    sizeAlgorithm
                  ) {
                    if (
                      highWaterMark === void 0
                    ) {
                      highWaterMark = 1;
                    }
                    if (
                      sizeAlgorithm === void 0
                    ) {
                      sizeAlgorithm =
                        function () {
                          return 1;
                        };
                    }
                    var stream = Object.create(
                      WritableStream.prototype
                    );
                    InitializeWritableStream(
                      stream
                    );
                    var controller =
                      Object.create(
                        WritableStreamDefaultController.prototype
                      );
                    SetUpWritableStreamDefaultController(
                      stream,
                      controller,
                      startAlgorithm,
                      writeAlgorithm,
                      closeAlgorithm,
                      abortAlgorithm,
                      highWaterMark,
                      sizeAlgorithm
                    );
                    return stream;
                  }
                  function InitializeWritableStream(
                    stream
                  ) {
                    stream._state = "writable";
                    stream._storedError =
                      undefined;
                    stream._writer = undefined;
                    stream._writableStreamController =
                      undefined;
                    stream._writeRequests =
                      new SimpleQueue();
                    stream._inFlightWriteRequest =
                      undefined;
                    stream._closeRequest =
                      undefined;
                    stream._inFlightCloseRequest =
                      undefined;
                    stream._pendingAbortRequest =
                      undefined;
                    stream._backpressure = false;
                  }
                  function IsWritableStream(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_writableStreamController"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function IsWritableStreamLocked(
                    stream
                  ) {
                    if (
                      stream._writer === undefined
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function WritableStreamAbort(
                    stream,
                    reason
                  ) {
                    var state = stream._state;
                    if (
                      state === "closed" ||
                      state === "errored"
                    ) {
                      return promiseResolvedWith(
                        undefined
                      );
                    }
                    if (
                      stream._pendingAbortRequest !==
                      undefined
                    ) {
                      return stream
                        ._pendingAbortRequest
                        ._promise;
                    }
                    var wasAlreadyErroring = false;
                    if (state === "erroring") {
                      wasAlreadyErroring = true;
                      reason = undefined;
                    }
                    var promise = newPromise(
                      function (resolve, reject) {
                        stream._pendingAbortRequest =
                          {
                            _promise: undefined,
                            _resolve: resolve,
                            _reject: reject,
                            _reason: reason,
                            _wasAlreadyErroring:
                              wasAlreadyErroring,
                          };
                      }
                    );
                    stream._pendingAbortRequest._promise =
                      promise;
                    if (!wasAlreadyErroring) {
                      WritableStreamStartErroring(
                        stream,
                        reason
                      );
                    }
                    return promise;
                  }
                  function WritableStreamClose(
                    stream
                  ) {
                    var state = stream._state;
                    if (
                      state === "closed" ||
                      state === "errored"
                    ) {
                      return promiseRejectedWith(
                        new TypeError(
                          "The stream (in " +
                            state +
                            " state) is not in the writable state and cannot be closed"
                        )
                      );
                    }
                    var promise = newPromise(
                      function (resolve, reject) {
                        var closeRequest = {
                          _resolve: resolve,
                          _reject: reject,
                        };
                        stream._closeRequest =
                          closeRequest;
                      }
                    );
                    var writer = stream._writer;
                    if (
                      writer !== undefined &&
                      stream._backpressure &&
                      state === "writable"
                    ) {
                      defaultWriterReadyPromiseResolve(
                        writer
                      );
                    }
                    WritableStreamDefaultControllerClose(
                      stream._writableStreamController
                    );
                    return promise;
                  }
                  function WritableStreamAddWriteRequest(
                    stream
                  ) {
                    var promise = newPromise(
                      function (resolve, reject) {
                        var writeRequest = {
                          _resolve: resolve,
                          _reject: reject,
                        };
                        stream._writeRequests.push(
                          writeRequest
                        );
                      }
                    );
                    return promise;
                  }
                  function WritableStreamDealWithRejection(
                    stream,
                    error
                  ) {
                    var state = stream._state;
                    if (state === "writable") {
                      WritableStreamStartErroring(
                        stream,
                        error
                      );
                      return;
                    }
                    WritableStreamFinishErroring(
                      stream
                    );
                  }
                  function WritableStreamStartErroring(
                    stream,
                    reason
                  ) {
                    var controller =
                      stream._writableStreamController;
                    stream._state = "erroring";
                    stream._storedError = reason;
                    var writer = stream._writer;
                    if (writer !== undefined) {
                      WritableStreamDefaultWriterEnsureReadyPromiseRejected(
                        writer,
                        reason
                      );
                    }
                    if (
                      !WritableStreamHasOperationMarkedInFlight(
                        stream
                      ) &&
                      controller._started
                    ) {
                      WritableStreamFinishErroring(
                        stream
                      );
                    }
                  }
                  function WritableStreamFinishErroring(
                    stream
                  ) {
                    stream._state = "errored";
                    stream._writableStreamController[
                      ErrorSteps
                    ]();
                    var storedError =
                      stream._storedError;
                    stream._writeRequests.forEach(
                      function (writeRequest) {
                        writeRequest._reject(
                          storedError
                        );
                      }
                    );
                    stream._writeRequests =
                      new SimpleQueue();
                    if (
                      stream._pendingAbortRequest ===
                      undefined
                    ) {
                      WritableStreamRejectCloseAndClosedPromiseIfNeeded(
                        stream
                      );
                      return;
                    }
                    var abortRequest =
                      stream._pendingAbortRequest;
                    stream._pendingAbortRequest =
                      undefined;
                    if (
                      abortRequest._wasAlreadyErroring
                    ) {
                      abortRequest._reject(
                        storedError
                      );
                      WritableStreamRejectCloseAndClosedPromiseIfNeeded(
                        stream
                      );
                      return;
                    }
                    var promise =
                      stream._writableStreamController[
                        AbortSteps
                      ](abortRequest._reason);
                    uponPromise(
                      promise,
                      function () {
                        abortRequest._resolve();
                        WritableStreamRejectCloseAndClosedPromiseIfNeeded(
                          stream
                        );
                      },
                      function (reason) {
                        abortRequest._reject(
                          reason
                        );
                        WritableStreamRejectCloseAndClosedPromiseIfNeeded(
                          stream
                        );
                      }
                    );
                  }
                  function WritableStreamFinishInFlightWrite(
                    stream
                  ) {
                    stream._inFlightWriteRequest._resolve(
                      undefined
                    );
                    stream._inFlightWriteRequest =
                      undefined;
                  }
                  function WritableStreamFinishInFlightWriteWithError(
                    stream,
                    error
                  ) {
                    stream._inFlightWriteRequest._reject(
                      error
                    );
                    stream._inFlightWriteRequest =
                      undefined;
                    WritableStreamDealWithRejection(
                      stream,
                      error
                    );
                  }
                  function WritableStreamFinishInFlightClose(
                    stream
                  ) {
                    stream._inFlightCloseRequest._resolve(
                      undefined
                    );
                    stream._inFlightCloseRequest =
                      undefined;
                    var state = stream._state;
                    if (state === "erroring") {
                      stream._storedError =
                        undefined;
                      if (
                        stream._pendingAbortRequest !==
                        undefined
                      ) {
                        stream._pendingAbortRequest._resolve();
                        stream._pendingAbortRequest =
                          undefined;
                      }
                    }
                    stream._state = "closed";
                    var writer = stream._writer;
                    if (writer !== undefined) {
                      defaultWriterClosedPromiseResolve(
                        writer
                      );
                    }
                  }
                  function WritableStreamFinishInFlightCloseWithError(
                    stream,
                    error
                  ) {
                    stream._inFlightCloseRequest._reject(
                      error
                    );
                    stream._inFlightCloseRequest =
                      undefined;
                    if (
                      stream._pendingAbortRequest !==
                      undefined
                    ) {
                      stream._pendingAbortRequest._reject(
                        error
                      );
                      stream._pendingAbortRequest =
                        undefined;
                    }
                    WritableStreamDealWithRejection(
                      stream,
                      error
                    );
                  }
                  function WritableStreamCloseQueuedOrInFlight(
                    stream
                  ) {
                    if (
                      stream._closeRequest ===
                        undefined &&
                      stream._inFlightCloseRequest ===
                        undefined
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function WritableStreamHasOperationMarkedInFlight(
                    stream
                  ) {
                    if (
                      stream._inFlightWriteRequest ===
                        undefined &&
                      stream._inFlightCloseRequest ===
                        undefined
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function WritableStreamMarkCloseRequestInFlight(
                    stream
                  ) {
                    stream._inFlightCloseRequest =
                      stream._closeRequest;
                    stream._closeRequest =
                      undefined;
                  }
                  function WritableStreamMarkFirstWriteRequestInFlight(
                    stream
                  ) {
                    stream._inFlightWriteRequest =
                      stream._writeRequests.shift();
                  }
                  function WritableStreamRejectCloseAndClosedPromiseIfNeeded(
                    stream
                  ) {
                    if (
                      stream._closeRequest !==
                      undefined
                    ) {
                      stream._closeRequest._reject(
                        stream._storedError
                      );
                      stream._closeRequest =
                        undefined;
                    }
                    var writer = stream._writer;
                    if (writer !== undefined) {
                      defaultWriterClosedPromiseReject(
                        writer,
                        stream._storedError
                      );
                    }
                  }
                  function WritableStreamUpdateBackpressure(
                    stream,
                    backpressure
                  ) {
                    var writer = stream._writer;
                    if (
                      writer !== undefined &&
                      backpressure !==
                        stream._backpressure
                    ) {
                      if (backpressure) {
                        defaultWriterReadyPromiseReset(
                          writer
                        );
                      } else {
                        defaultWriterReadyPromiseResolve(
                          writer
                        );
                      }
                    }
                    stream._backpressure =
                      backpressure;
                  }
                  var WritableStreamDefaultWriter =
                    (function () {
                      function WritableStreamDefaultWriter(
                        stream
                      ) {
                        assertRequiredArgument(
                          stream,
                          1,
                          "WritableStreamDefaultWriter"
                        );
                        assertWritableStream(
                          stream,
                          "First parameter"
                        );
                        if (
                          IsWritableStreamLocked(
                            stream
                          )
                        ) {
                          throw new TypeError(
                            "This stream has already been locked for exclusive writing by another writer"
                          );
                        }
                        this._ownerWritableStream =
                          stream;
                        stream._writer = this;
                        var state = stream._state;
                        if (
                          state === "writable"
                        ) {
                          if (
                            !WritableStreamCloseQueuedOrInFlight(
                              stream
                            ) &&
                            stream._backpressure
                          ) {
                            defaultWriterReadyPromiseInitialize(
                              this
                            );
                          } else {
                            defaultWriterReadyPromiseInitializeAsResolved(
                              this
                            );
                          }
                          defaultWriterClosedPromiseInitialize(
                            this
                          );
                        } else if (
                          state === "erroring"
                        ) {
                          defaultWriterReadyPromiseInitializeAsRejected(
                            this,
                            stream._storedError
                          );
                          defaultWriterClosedPromiseInitialize(
                            this
                          );
                        } else if (
                          state === "closed"
                        ) {
                          defaultWriterReadyPromiseInitializeAsResolved(
                            this
                          );
                          defaultWriterClosedPromiseInitializeAsResolved(
                            this
                          );
                        } else {
                          var storedError =
                            stream._storedError;
                          defaultWriterReadyPromiseInitializeAsRejected(
                            this,
                            storedError
                          );
                          defaultWriterClosedPromiseInitializeAsRejected(
                            this,
                            storedError
                          );
                        }
                      }
                      Object.defineProperty(
                        WritableStreamDefaultWriter.prototype,
                        "closed",
                        {
                          get: function () {
                            if (
                              !IsWritableStreamDefaultWriter(
                                this
                              )
                            ) {
                              return promiseRejectedWith(
                                defaultWriterBrandCheckException(
                                  "closed"
                                )
                              );
                            }
                            return this
                              ._closedPromise;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      Object.defineProperty(
                        WritableStreamDefaultWriter.prototype,
                        "desiredSize",
                        {
                          get: function () {
                            if (
                              !IsWritableStreamDefaultWriter(
                                this
                              )
                            ) {
                              throw defaultWriterBrandCheckException(
                                "desiredSize"
                              );
                            }
                            if (
                              this
                                ._ownerWritableStream ===
                              undefined
                            ) {
                              throw defaultWriterLockException(
                                "desiredSize"
                              );
                            }
                            return WritableStreamDefaultWriterGetDesiredSize(
                              this
                            );
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      Object.defineProperty(
                        WritableStreamDefaultWriter.prototype,
                        "ready",
                        {
                          get: function () {
                            if (
                              !IsWritableStreamDefaultWriter(
                                this
                              )
                            ) {
                              return promiseRejectedWith(
                                defaultWriterBrandCheckException(
                                  "ready"
                                )
                              );
                            }
                            return this
                              ._readyPromise;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      WritableStreamDefaultWriter.prototype.abort =
                        function (reason) {
                          if (reason === void 0) {
                            reason = undefined;
                          }
                          if (
                            !IsWritableStreamDefaultWriter(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              defaultWriterBrandCheckException(
                                "abort"
                              )
                            );
                          }
                          if (
                            this
                              ._ownerWritableStream ===
                            undefined
                          ) {
                            return promiseRejectedWith(
                              defaultWriterLockException(
                                "abort"
                              )
                            );
                          }
                          return WritableStreamDefaultWriterAbort(
                            this,
                            reason
                          );
                        };
                      WritableStreamDefaultWriter.prototype.close =
                        function () {
                          if (
                            !IsWritableStreamDefaultWriter(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              defaultWriterBrandCheckException(
                                "close"
                              )
                            );
                          }
                          var stream =
                            this
                              ._ownerWritableStream;
                          if (
                            stream === undefined
                          ) {
                            return promiseRejectedWith(
                              defaultWriterLockException(
                                "close"
                              )
                            );
                          }
                          if (
                            WritableStreamCloseQueuedOrInFlight(
                              stream
                            )
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "Cannot close an already-closing stream"
                              )
                            );
                          }
                          return WritableStreamDefaultWriterClose(
                            this
                          );
                        };
                      WritableStreamDefaultWriter.prototype.releaseLock =
                        function () {
                          if (
                            !IsWritableStreamDefaultWriter(
                              this
                            )
                          ) {
                            throw defaultWriterBrandCheckException(
                              "releaseLock"
                            );
                          }
                          var stream =
                            this
                              ._ownerWritableStream;
                          if (
                            stream === undefined
                          ) {
                            return;
                          }
                          WritableStreamDefaultWriterRelease(
                            this
                          );
                        };
                      WritableStreamDefaultWriter.prototype.write =
                        function (chunk) {
                          if (chunk === void 0) {
                            chunk = undefined;
                          }
                          if (
                            !IsWritableStreamDefaultWriter(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              defaultWriterBrandCheckException(
                                "write"
                              )
                            );
                          }
                          if (
                            this
                              ._ownerWritableStream ===
                            undefined
                          ) {
                            return promiseRejectedWith(
                              defaultWriterLockException(
                                "write to"
                              )
                            );
                          }
                          return WritableStreamDefaultWriterWrite(
                            this,
                            chunk
                          );
                        };
                      return WritableStreamDefaultWriter;
                    })();
                  Object.defineProperties(
                    WritableStreamDefaultWriter.prototype,
                    {
                      abort: { enumerable: true },
                      close: { enumerable: true },
                      releaseLock: {
                        enumerable: true,
                      },
                      write: { enumerable: true },
                      closed: {
                        enumerable: true,
                      },
                      desiredSize: {
                        enumerable: true,
                      },
                      ready: { enumerable: true },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      WritableStreamDefaultWriter.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "WritableStreamDefaultWriter",
                        configurable: true,
                      }
                    );
                  }
                  function IsWritableStreamDefaultWriter(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_ownerWritableStream"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function WritableStreamDefaultWriterAbort(
                    writer,
                    reason
                  ) {
                    var stream =
                      writer._ownerWritableStream;
                    return WritableStreamAbort(
                      stream,
                      reason
                    );
                  }
                  function WritableStreamDefaultWriterClose(
                    writer
                  ) {
                    var stream =
                      writer._ownerWritableStream;
                    return WritableStreamClose(
                      stream
                    );
                  }
                  function WritableStreamDefaultWriterCloseWithErrorPropagation(
                    writer
                  ) {
                    var stream =
                      writer._ownerWritableStream;
                    var state = stream._state;
                    if (
                      WritableStreamCloseQueuedOrInFlight(
                        stream
                      ) ||
                      state === "closed"
                    ) {
                      return promiseResolvedWith(
                        undefined
                      );
                    }
                    if (state === "errored") {
                      return promiseRejectedWith(
                        stream._storedError
                      );
                    }
                    return WritableStreamDefaultWriterClose(
                      writer
                    );
                  }
                  function WritableStreamDefaultWriterEnsureClosedPromiseRejected(
                    writer,
                    error
                  ) {
                    if (
                      writer._closedPromiseState ===
                      "pending"
                    ) {
                      defaultWriterClosedPromiseReject(
                        writer,
                        error
                      );
                    } else {
                      defaultWriterClosedPromiseResetToRejected(
                        writer,
                        error
                      );
                    }
                  }
                  function WritableStreamDefaultWriterEnsureReadyPromiseRejected(
                    writer,
                    error
                  ) {
                    if (
                      writer._readyPromiseState ===
                      "pending"
                    ) {
                      defaultWriterReadyPromiseReject(
                        writer,
                        error
                      );
                    } else {
                      defaultWriterReadyPromiseResetToRejected(
                        writer,
                        error
                      );
                    }
                  }
                  function WritableStreamDefaultWriterGetDesiredSize(
                    writer
                  ) {
                    var stream =
                      writer._ownerWritableStream;
                    var state = stream._state;
                    if (
                      state === "errored" ||
                      state === "erroring"
                    ) {
                      return null;
                    }
                    if (state === "closed") {
                      return 0;
                    }
                    return WritableStreamDefaultControllerGetDesiredSize(
                      stream._writableStreamController
                    );
                  }
                  function WritableStreamDefaultWriterRelease(
                    writer
                  ) {
                    var stream =
                      writer._ownerWritableStream;
                    var releasedError =
                      new TypeError(
                        "Writer was released and can no longer be used to monitor the stream's closedness"
                      );
                    WritableStreamDefaultWriterEnsureReadyPromiseRejected(
                      writer,
                      releasedError
                    );
                    WritableStreamDefaultWriterEnsureClosedPromiseRejected(
                      writer,
                      releasedError
                    );
                    stream._writer = undefined;
                    writer._ownerWritableStream =
                      undefined;
                  }
                  function WritableStreamDefaultWriterWrite(
                    writer,
                    chunk
                  ) {
                    var stream =
                      writer._ownerWritableStream;
                    var controller =
                      stream._writableStreamController;
                    var chunkSize =
                      WritableStreamDefaultControllerGetChunkSize(
                        controller,
                        chunk
                      );
                    if (
                      stream !==
                      writer._ownerWritableStream
                    ) {
                      return promiseRejectedWith(
                        defaultWriterLockException(
                          "write to"
                        )
                      );
                    }
                    var state = stream._state;
                    if (state === "errored") {
                      return promiseRejectedWith(
                        stream._storedError
                      );
                    }
                    if (
                      WritableStreamCloseQueuedOrInFlight(
                        stream
                      ) ||
                      state === "closed"
                    ) {
                      return promiseRejectedWith(
                        new TypeError(
                          "The stream is closing or closed and cannot be written to"
                        )
                      );
                    }
                    if (state === "erroring") {
                      return promiseRejectedWith(
                        stream._storedError
                      );
                    }
                    var promise =
                      WritableStreamAddWriteRequest(
                        stream
                      );
                    WritableStreamDefaultControllerWrite(
                      controller,
                      chunk,
                      chunkSize
                    );
                    return promise;
                  }
                  var closeSentinel = {};
                  var WritableStreamDefaultController =
                    (function () {
                      function WritableStreamDefaultController() {
                        throw new TypeError(
                          "Illegal constructor"
                        );
                      }
                      WritableStreamDefaultController.prototype.error =
                        function (e) {
                          if (e === void 0) {
                            e = undefined;
                          }
                          if (
                            !IsWritableStreamDefaultController(
                              this
                            )
                          ) {
                            throw new TypeError(
                              "WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController"
                            );
                          }
                          var state =
                            this
                              ._controlledWritableStream
                              ._state;
                          if (
                            state !== "writable"
                          ) {
                            return;
                          }
                          WritableStreamDefaultControllerError(
                            this,
                            e
                          );
                        };
                      WritableStreamDefaultController.prototype[
                        AbortSteps
                      ] = function (reason) {
                        var result =
                          this._abortAlgorithm(
                            reason
                          );
                        WritableStreamDefaultControllerClearAlgorithms(
                          this
                        );
                        return result;
                      };
                      WritableStreamDefaultController.prototype[
                        ErrorSteps
                      ] = function () {
                        ResetQueue(this);
                      };
                      return WritableStreamDefaultController;
                    })();
                  Object.defineProperties(
                    WritableStreamDefaultController.prototype,
                    {
                      error: { enumerable: true },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      WritableStreamDefaultController.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "WritableStreamDefaultController",
                        configurable: true,
                      }
                    );
                  }
                  function IsWritableStreamDefaultController(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_controlledWritableStream"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function SetUpWritableStreamDefaultController(
                    stream,
                    controller,
                    startAlgorithm,
                    writeAlgorithm,
                    closeAlgorithm,
                    abortAlgorithm,
                    highWaterMark,
                    sizeAlgorithm
                  ) {
                    controller._controlledWritableStream =
                      stream;
                    stream._writableStreamController =
                      controller;
                    controller._queue = undefined;
                    controller._queueTotalSize =
                      undefined;
                    ResetQueue(controller);
                    controller._started = false;
                    controller._strategySizeAlgorithm =
                      sizeAlgorithm;
                    controller._strategyHWM =
                      highWaterMark;
                    controller._writeAlgorithm =
                      writeAlgorithm;
                    controller._closeAlgorithm =
                      closeAlgorithm;
                    controller._abortAlgorithm =
                      abortAlgorithm;
                    var backpressure =
                      WritableStreamDefaultControllerGetBackpressure(
                        controller
                      );
                    WritableStreamUpdateBackpressure(
                      stream,
                      backpressure
                    );
                    var startResult =
                      startAlgorithm();
                    var startPromise =
                      promiseResolvedWith(
                        startResult
                      );
                    uponPromise(
                      startPromise,
                      function () {
                        controller._started = true;
                        WritableStreamDefaultControllerAdvanceQueueIfNeeded(
                          controller
                        );
                      },
                      function (r) {
                        controller._started = true;
                        WritableStreamDealWithRejection(
                          stream,
                          r
                        );
                      }
                    );
                  }
                  function SetUpWritableStreamDefaultControllerFromUnderlyingSink(
                    stream,
                    underlyingSink,
                    highWaterMark,
                    sizeAlgorithm
                  ) {
                    var controller =
                      Object.create(
                        WritableStreamDefaultController.prototype
                      );
                    var startAlgorithm =
                      function () {
                        return undefined;
                      };
                    var writeAlgorithm =
                      function () {
                        return promiseResolvedWith(
                          undefined
                        );
                      };
                    var closeAlgorithm =
                      function () {
                        return promiseResolvedWith(
                          undefined
                        );
                      };
                    var abortAlgorithm =
                      function () {
                        return promiseResolvedWith(
                          undefined
                        );
                      };
                    if (
                      underlyingSink.start !==
                      undefined
                    ) {
                      startAlgorithm =
                        function () {
                          return underlyingSink.start(
                            controller
                          );
                        };
                    }
                    if (
                      underlyingSink.write !==
                      undefined
                    ) {
                      writeAlgorithm = function (
                        chunk
                      ) {
                        return underlyingSink.write(
                          chunk,
                          controller
                        );
                      };
                    }
                    if (
                      underlyingSink.close !==
                      undefined
                    ) {
                      closeAlgorithm =
                        function () {
                          return underlyingSink.close();
                        };
                    }
                    if (
                      underlyingSink.abort !==
                      undefined
                    ) {
                      abortAlgorithm = function (
                        reason
                      ) {
                        return underlyingSink.abort(
                          reason
                        );
                      };
                    }
                    SetUpWritableStreamDefaultController(
                      stream,
                      controller,
                      startAlgorithm,
                      writeAlgorithm,
                      closeAlgorithm,
                      abortAlgorithm,
                      highWaterMark,
                      sizeAlgorithm
                    );
                  }
                  function WritableStreamDefaultControllerClearAlgorithms(
                    controller
                  ) {
                    controller._writeAlgorithm =
                      undefined;
                    controller._closeAlgorithm =
                      undefined;
                    controller._abortAlgorithm =
                      undefined;
                    controller._strategySizeAlgorithm =
                      undefined;
                  }
                  function WritableStreamDefaultControllerClose(
                    controller
                  ) {
                    EnqueueValueWithSize(
                      controller,
                      closeSentinel,
                      0
                    );
                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(
                      controller
                    );
                  }
                  function WritableStreamDefaultControllerGetChunkSize(
                    controller,
                    chunk
                  ) {
                    try {
                      return controller._strategySizeAlgorithm(
                        chunk
                      );
                    } catch (chunkSizeE) {
                      WritableStreamDefaultControllerErrorIfNeeded(
                        controller,
                        chunkSizeE
                      );
                      return 1;
                    }
                  }
                  function WritableStreamDefaultControllerGetDesiredSize(
                    controller
                  ) {
                    return (
                      controller._strategyHWM -
                      controller._queueTotalSize
                    );
                  }
                  function WritableStreamDefaultControllerWrite(
                    controller,
                    chunk,
                    chunkSize
                  ) {
                    try {
                      EnqueueValueWithSize(
                        controller,
                        chunk,
                        chunkSize
                      );
                    } catch (enqueueE) {
                      WritableStreamDefaultControllerErrorIfNeeded(
                        controller,
                        enqueueE
                      );
                      return;
                    }
                    var stream =
                      controller._controlledWritableStream;
                    if (
                      !WritableStreamCloseQueuedOrInFlight(
                        stream
                      ) &&
                      stream._state === "writable"
                    ) {
                      var backpressure =
                        WritableStreamDefaultControllerGetBackpressure(
                          controller
                        );
                      WritableStreamUpdateBackpressure(
                        stream,
                        backpressure
                      );
                    }
                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(
                      controller
                    );
                  }
                  function WritableStreamDefaultControllerAdvanceQueueIfNeeded(
                    controller
                  ) {
                    var stream =
                      controller._controlledWritableStream;
                    if (!controller._started) {
                      return;
                    }
                    if (
                      stream._inFlightWriteRequest !==
                      undefined
                    ) {
                      return;
                    }
                    var state = stream._state;
                    if (state === "erroring") {
                      WritableStreamFinishErroring(
                        stream
                      );
                      return;
                    }
                    if (
                      controller._queue.length ===
                      0
                    ) {
                      return;
                    }
                    var value =
                      PeekQueueValue(controller);
                    if (value === closeSentinel) {
                      WritableStreamDefaultControllerProcessClose(
                        controller
                      );
                    } else {
                      WritableStreamDefaultControllerProcessWrite(
                        controller,
                        value
                      );
                    }
                  }
                  function WritableStreamDefaultControllerErrorIfNeeded(
                    controller,
                    error
                  ) {
                    if (
                      controller
                        ._controlledWritableStream
                        ._state === "writable"
                    ) {
                      WritableStreamDefaultControllerError(
                        controller,
                        error
                      );
                    }
                  }
                  function WritableStreamDefaultControllerProcessClose(
                    controller
                  ) {
                    var stream =
                      controller._controlledWritableStream;
                    WritableStreamMarkCloseRequestInFlight(
                      stream
                    );
                    DequeueValue(controller);
                    var sinkClosePromise =
                      controller._closeAlgorithm();
                    WritableStreamDefaultControllerClearAlgorithms(
                      controller
                    );
                    uponPromise(
                      sinkClosePromise,
                      function () {
                        WritableStreamFinishInFlightClose(
                          stream
                        );
                      },
                      function (reason) {
                        WritableStreamFinishInFlightCloseWithError(
                          stream,
                          reason
                        );
                      }
                    );
                  }
                  function WritableStreamDefaultControllerProcessWrite(
                    controller,
                    chunk
                  ) {
                    var stream =
                      controller._controlledWritableStream;
                    WritableStreamMarkFirstWriteRequestInFlight(
                      stream
                    );
                    var sinkWritePromise =
                      controller._writeAlgorithm(
                        chunk
                      );
                    uponPromise(
                      sinkWritePromise,
                      function () {
                        WritableStreamFinishInFlightWrite(
                          stream
                        );
                        var state = stream._state;
                        DequeueValue(controller);
                        if (
                          !WritableStreamCloseQueuedOrInFlight(
                            stream
                          ) &&
                          state === "writable"
                        ) {
                          var backpressure =
                            WritableStreamDefaultControllerGetBackpressure(
                              controller
                            );
                          WritableStreamUpdateBackpressure(
                            stream,
                            backpressure
                          );
                        }
                        WritableStreamDefaultControllerAdvanceQueueIfNeeded(
                          controller
                        );
                      },
                      function (reason) {
                        if (
                          stream._state ===
                          "writable"
                        ) {
                          WritableStreamDefaultControllerClearAlgorithms(
                            controller
                          );
                        }
                        WritableStreamFinishInFlightWriteWithError(
                          stream,
                          reason
                        );
                      }
                    );
                  }
                  function WritableStreamDefaultControllerGetBackpressure(
                    controller
                  ) {
                    var desiredSize =
                      WritableStreamDefaultControllerGetDesiredSize(
                        controller
                      );
                    return desiredSize <= 0;
                  }
                  function WritableStreamDefaultControllerError(
                    controller,
                    error
                  ) {
                    var stream =
                      controller._controlledWritableStream;
                    WritableStreamDefaultControllerClearAlgorithms(
                      controller
                    );
                    WritableStreamStartErroring(
                      stream,
                      error
                    );
                  }
                  function streamBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "WritableStream.prototype." +
                        name +
                        " can only be used on a WritableStream"
                    );
                  }
                  function defaultWriterBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "WritableStreamDefaultWriter.prototype." +
                        name +
                        " can only be used on a WritableStreamDefaultWriter"
                    );
                  }
                  function defaultWriterLockException(
                    name
                  ) {
                    return new TypeError(
                      "Cannot " +
                        name +
                        " a stream using a released writer"
                    );
                  }
                  function defaultWriterClosedPromiseInitialize(
                    writer
                  ) {
                    writer._closedPromise =
                      newPromise(function (
                        resolve,
                        reject
                      ) {
                        writer._closedPromise_resolve =
                          resolve;
                        writer._closedPromise_reject =
                          reject;
                        writer._closedPromiseState =
                          "pending";
                      });
                  }
                  function defaultWriterClosedPromiseInitializeAsRejected(
                    writer,
                    reason
                  ) {
                    defaultWriterClosedPromiseInitialize(
                      writer
                    );
                    defaultWriterClosedPromiseReject(
                      writer,
                      reason
                    );
                  }
                  function defaultWriterClosedPromiseInitializeAsResolved(
                    writer
                  ) {
                    defaultWriterClosedPromiseInitialize(
                      writer
                    );
                    defaultWriterClosedPromiseResolve(
                      writer
                    );
                  }
                  function defaultWriterClosedPromiseReject(
                    writer,
                    reason
                  ) {
                    if (
                      writer._closedPromise_reject ===
                      undefined
                    ) {
                      return;
                    }
                    setPromiseIsHandledToTrue(
                      writer._closedPromise
                    );
                    writer._closedPromise_reject(
                      reason
                    );
                    writer._closedPromise_resolve =
                      undefined;
                    writer._closedPromise_reject =
                      undefined;
                    writer._closedPromiseState =
                      "rejected";
                  }
                  function defaultWriterClosedPromiseResetToRejected(
                    writer,
                    reason
                  ) {
                    defaultWriterClosedPromiseInitializeAsRejected(
                      writer,
                      reason
                    );
                  }
                  function defaultWriterClosedPromiseResolve(
                    writer
                  ) {
                    if (
                      writer._closedPromise_resolve ===
                      undefined
                    ) {
                      return;
                    }
                    writer._closedPromise_resolve(
                      undefined
                    );
                    writer._closedPromise_resolve =
                      undefined;
                    writer._closedPromise_reject =
                      undefined;
                    writer._closedPromiseState =
                      "resolved";
                  }
                  function defaultWriterReadyPromiseInitialize(
                    writer
                  ) {
                    writer._readyPromise =
                      newPromise(function (
                        resolve,
                        reject
                      ) {
                        writer._readyPromise_resolve =
                          resolve;
                        writer._readyPromise_reject =
                          reject;
                      });
                    writer._readyPromiseState =
                      "pending";
                  }
                  function defaultWriterReadyPromiseInitializeAsRejected(
                    writer,
                    reason
                  ) {
                    defaultWriterReadyPromiseInitialize(
                      writer
                    );
                    defaultWriterReadyPromiseReject(
                      writer,
                      reason
                    );
                  }
                  function defaultWriterReadyPromiseInitializeAsResolved(
                    writer
                  ) {
                    defaultWriterReadyPromiseInitialize(
                      writer
                    );
                    defaultWriterReadyPromiseResolve(
                      writer
                    );
                  }
                  function defaultWriterReadyPromiseReject(
                    writer,
                    reason
                  ) {
                    if (
                      writer._readyPromise_reject ===
                      undefined
                    ) {
                      return;
                    }
                    setPromiseIsHandledToTrue(
                      writer._readyPromise
                    );
                    writer._readyPromise_reject(
                      reason
                    );
                    writer._readyPromise_resolve =
                      undefined;
                    writer._readyPromise_reject =
                      undefined;
                    writer._readyPromiseState =
                      "rejected";
                  }
                  function defaultWriterReadyPromiseReset(
                    writer
                  ) {
                    defaultWriterReadyPromiseInitialize(
                      writer
                    );
                  }
                  function defaultWriterReadyPromiseResetToRejected(
                    writer,
                    reason
                  ) {
                    defaultWriterReadyPromiseInitializeAsRejected(
                      writer,
                      reason
                    );
                  }
                  function defaultWriterReadyPromiseResolve(
                    writer
                  ) {
                    if (
                      writer._readyPromise_resolve ===
                      undefined
                    ) {
                      return;
                    }
                    writer._readyPromise_resolve(
                      undefined
                    );
                    writer._readyPromise_resolve =
                      undefined;
                    writer._readyPromise_reject =
                      undefined;
                    writer._readyPromiseState =
                      "fulfilled";
                  }
                  function isAbortSignal(value) {
                    if (
                      typeof value !== "object" ||
                      value === null
                    ) {
                      return false;
                    }
                    try {
                      return (
                        typeof value.aborted ===
                        "boolean"
                      );
                    } catch (_a) {
                      return false;
                    }
                  }
                  var NativeDOMException =
                    typeof DOMException !==
                    "undefined"
                      ? DOMException
                      : undefined;
                  function isDOMExceptionConstructor(
                    ctor
                  ) {
                    if (
                      !(
                        typeof ctor ===
                          "function" ||
                        typeof ctor === "object"
                      )
                    ) {
                      return false;
                    }
                    try {
                      new ctor();
                      return true;
                    } catch (_a) {
                      return false;
                    }
                  }
                  function createDOMExceptionPolyfill() {
                    var ctor =
                      function DOMException(
                        message,
                        name
                      ) {
                        this.message =
                          message || "";
                        this.name =
                          name || "Error";
                        if (
                          Error.captureStackTrace
                        ) {
                          Error.captureStackTrace(
                            this,
                            this.constructor
                          );
                        }
                      };
                    ctor.prototype =
                      Object.create(
                        Error.prototype
                      );
                    Object.defineProperty(
                      ctor.prototype,
                      "constructor",
                      {
                        value: ctor,
                        writable: true,
                        configurable: true,
                      }
                    );
                    return ctor;
                  }
                  var DOMException$1 =
                    isDOMExceptionConstructor(
                      NativeDOMException
                    )
                      ? NativeDOMException
                      : createDOMExceptionPolyfill();
                  function ReadableStreamPipeTo(
                    source,
                    dest,
                    preventClose,
                    preventAbort,
                    preventCancel,
                    signal
                  ) {
                    var reader =
                      AcquireReadableStreamDefaultReader(
                        source
                      );
                    var writer =
                      AcquireWritableStreamDefaultWriter(
                        dest
                      );
                    source._disturbed = true;
                    var shuttingDown = false;
                    var currentWrite =
                      promiseResolvedWith(
                        undefined
                      );
                    return newPromise(function (
                      resolve,
                      reject
                    ) {
                      var abortAlgorithm;
                      if (signal !== undefined) {
                        abortAlgorithm =
                          function () {
                            var error =
                              new DOMException$1(
                                "Aborted",
                                "AbortError"
                              );
                            var actions = [];
                            if (!preventAbort) {
                              actions.push(
                                function () {
                                  if (
                                    dest._state ===
                                    "writable"
                                  ) {
                                    return WritableStreamAbort(
                                      dest,
                                      error
                                    );
                                  }
                                  return promiseResolvedWith(
                                    undefined
                                  );
                                }
                              );
                            }
                            if (!preventCancel) {
                              actions.push(
                                function () {
                                  if (
                                    source._state ===
                                    "readable"
                                  ) {
                                    return ReadableStreamCancel(
                                      source,
                                      error
                                    );
                                  }
                                  return promiseResolvedWith(
                                    undefined
                                  );
                                }
                              );
                            }
                            shutdownWithAction(
                              function () {
                                return Promise.all(
                                  actions.map(
                                    function (
                                      action
                                    ) {
                                      return action();
                                    }
                                  )
                                );
                              },
                              true,
                              error
                            );
                          };
                        if (signal.aborted) {
                          abortAlgorithm();
                          return;
                        }
                        signal.addEventListener(
                          "abort",
                          abortAlgorithm
                        );
                      }
                      function pipeLoop() {
                        return newPromise(
                          function (
                            resolveLoop,
                            rejectLoop
                          ) {
                            function next(done) {
                              if (done) {
                                resolveLoop();
                              } else {
                                PerformPromiseThen(
                                  pipeStep(),
                                  next,
                                  rejectLoop
                                );
                              }
                            }
                            next(false);
                          }
                        );
                      }
                      function pipeStep() {
                        if (shuttingDown) {
                          return promiseResolvedWith(
                            true
                          );
                        }
                        return PerformPromiseThen(
                          writer._readyPromise,
                          function () {
                            return newPromise(
                              function (
                                resolveRead,
                                rejectRead
                              ) {
                                ReadableStreamDefaultReaderRead(
                                  reader,
                                  {
                                    _chunkSteps:
                                      function (
                                        chunk
                                      ) {
                                        currentWrite =
                                          PerformPromiseThen(
                                            WritableStreamDefaultWriterWrite(
                                              writer,
                                              chunk
                                            ),
                                            undefined,
                                            noop
                                          );
                                        resolveRead(
                                          false
                                        );
                                      },
                                    _closeSteps:
                                      function () {
                                        return resolveRead(
                                          true
                                        );
                                      },
                                    _errorSteps:
                                      rejectRead,
                                  }
                                );
                              }
                            );
                          }
                        );
                      }
                      isOrBecomesErrored(
                        source,
                        reader._closedPromise,
                        function (storedError) {
                          if (!preventAbort) {
                            shutdownWithAction(
                              function () {
                                return WritableStreamAbort(
                                  dest,
                                  storedError
                                );
                              },
                              true,
                              storedError
                            );
                          } else {
                            shutdown(
                              true,
                              storedError
                            );
                          }
                        }
                      );
                      isOrBecomesErrored(
                        dest,
                        writer._closedPromise,
                        function (storedError) {
                          if (!preventCancel) {
                            shutdownWithAction(
                              function () {
                                return ReadableStreamCancel(
                                  source,
                                  storedError
                                );
                              },
                              true,
                              storedError
                            );
                          } else {
                            shutdown(
                              true,
                              storedError
                            );
                          }
                        }
                      );
                      isOrBecomesClosed(
                        source,
                        reader._closedPromise,
                        function () {
                          if (!preventClose) {
                            shutdownWithAction(
                              function () {
                                return WritableStreamDefaultWriterCloseWithErrorPropagation(
                                  writer
                                );
                              }
                            );
                          } else {
                            shutdown();
                          }
                        }
                      );
                      if (
                        WritableStreamCloseQueuedOrInFlight(
                          dest
                        ) ||
                        dest._state === "closed"
                      ) {
                        var destClosed_1 =
                          new TypeError(
                            "the destination writable stream closed before all data could be piped to it"
                          );
                        if (!preventCancel) {
                          shutdownWithAction(
                            function () {
                              return ReadableStreamCancel(
                                source,
                                destClosed_1
                              );
                            },
                            true,
                            destClosed_1
                          );
                        } else {
                          shutdown(
                            true,
                            destClosed_1
                          );
                        }
                      }
                      setPromiseIsHandledToTrue(
                        pipeLoop()
                      );
                      function waitForWritesToFinish() {
                        var oldCurrentWrite =
                          currentWrite;
                        return PerformPromiseThen(
                          currentWrite,
                          function () {
                            return oldCurrentWrite !==
                              currentWrite
                              ? waitForWritesToFinish()
                              : undefined;
                          }
                        );
                      }
                      function isOrBecomesErrored(
                        stream,
                        promise,
                        action
                      ) {
                        if (
                          stream._state ===
                          "errored"
                        ) {
                          action(
                            stream._storedError
                          );
                        } else {
                          uponRejection(
                            promise,
                            action
                          );
                        }
                      }
                      function isOrBecomesClosed(
                        stream,
                        promise,
                        action
                      ) {
                        if (
                          stream._state ===
                          "closed"
                        ) {
                          action();
                        } else {
                          uponFulfillment(
                            promise,
                            action
                          );
                        }
                      }
                      function shutdownWithAction(
                        action,
                        originalIsError,
                        originalError
                      ) {
                        if (shuttingDown) {
                          return;
                        }
                        shuttingDown = true;
                        if (
                          dest._state ===
                            "writable" &&
                          !WritableStreamCloseQueuedOrInFlight(
                            dest
                          )
                        ) {
                          uponFulfillment(
                            waitForWritesToFinish(),
                            doTheRest
                          );
                        } else {
                          doTheRest();
                        }
                        function doTheRest() {
                          uponPromise(
                            action(),
                            function () {
                              return finalize(
                                originalIsError,
                                originalError
                              );
                            },
                            function (newError) {
                              return finalize(
                                true,
                                newError
                              );
                            }
                          );
                        }
                      }
                      function shutdown(
                        isError,
                        error
                      ) {
                        if (shuttingDown) {
                          return;
                        }
                        shuttingDown = true;
                        if (
                          dest._state ===
                            "writable" &&
                          !WritableStreamCloseQueuedOrInFlight(
                            dest
                          )
                        ) {
                          uponFulfillment(
                            waitForWritesToFinish(),
                            function () {
                              return finalize(
                                isError,
                                error
                              );
                            }
                          );
                        } else {
                          finalize(
                            isError,
                            error
                          );
                        }
                      }
                      function finalize(
                        isError,
                        error
                      ) {
                        WritableStreamDefaultWriterRelease(
                          writer
                        );
                        ReadableStreamReaderGenericRelease(
                          reader
                        );
                        if (
                          signal !== undefined
                        ) {
                          signal.removeEventListener(
                            "abort",
                            abortAlgorithm
                          );
                        }
                        if (isError) {
                          reject(error);
                        } else {
                          resolve(undefined);
                        }
                      }
                    });
                  }
                  var ReadableStreamDefaultController =
                    (function () {
                      function ReadableStreamDefaultController() {
                        throw new TypeError(
                          "Illegal constructor"
                        );
                      }
                      Object.defineProperty(
                        ReadableStreamDefaultController.prototype,
                        "desiredSize",
                        {
                          get: function () {
                            if (
                              !IsReadableStreamDefaultController(
                                this
                              )
                            ) {
                              throw defaultControllerBrandCheckException(
                                "desiredSize"
                              );
                            }
                            return ReadableStreamDefaultControllerGetDesiredSize(
                              this
                            );
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      ReadableStreamDefaultController.prototype.close =
                        function () {
                          if (
                            !IsReadableStreamDefaultController(
                              this
                            )
                          ) {
                            throw defaultControllerBrandCheckException(
                              "close"
                            );
                          }
                          if (
                            !ReadableStreamDefaultControllerCanCloseOrEnqueue(
                              this
                            )
                          ) {
                            throw new TypeError(
                              "The stream is not in a state that permits close"
                            );
                          }
                          ReadableStreamDefaultControllerClose(
                            this
                          );
                        };
                      ReadableStreamDefaultController.prototype.enqueue =
                        function (chunk) {
                          if (chunk === void 0) {
                            chunk = undefined;
                          }
                          if (
                            !IsReadableStreamDefaultController(
                              this
                            )
                          ) {
                            throw defaultControllerBrandCheckException(
                              "enqueue"
                            );
                          }
                          if (
                            !ReadableStreamDefaultControllerCanCloseOrEnqueue(
                              this
                            )
                          ) {
                            throw new TypeError(
                              "The stream is not in a state that permits enqueue"
                            );
                          }
                          return ReadableStreamDefaultControllerEnqueue(
                            this,
                            chunk
                          );
                        };
                      ReadableStreamDefaultController.prototype.error =
                        function (e) {
                          if (e === void 0) {
                            e = undefined;
                          }
                          if (
                            !IsReadableStreamDefaultController(
                              this
                            )
                          ) {
                            throw defaultControllerBrandCheckException(
                              "error"
                            );
                          }
                          ReadableStreamDefaultControllerError(
                            this,
                            e
                          );
                        };
                      ReadableStreamDefaultController.prototype[
                        CancelSteps
                      ] = function (reason) {
                        ResetQueue(this);
                        var result =
                          this._cancelAlgorithm(
                            reason
                          );
                        ReadableStreamDefaultControllerClearAlgorithms(
                          this
                        );
                        return result;
                      };
                      ReadableStreamDefaultController.prototype[
                        PullSteps
                      ] = function (readRequest) {
                        var stream =
                          this
                            ._controlledReadableStream;
                        if (
                          this._queue.length > 0
                        ) {
                          var chunk =
                            DequeueValue(this);
                          if (
                            this
                              ._closeRequested &&
                            this._queue.length ===
                              0
                          ) {
                            ReadableStreamDefaultControllerClearAlgorithms(
                              this
                            );
                            ReadableStreamClose(
                              stream
                            );
                          } else {
                            ReadableStreamDefaultControllerCallPullIfNeeded(
                              this
                            );
                          }
                          readRequest._chunkSteps(
                            chunk
                          );
                        } else {
                          ReadableStreamAddReadRequest(
                            stream,
                            readRequest
                          );
                          ReadableStreamDefaultControllerCallPullIfNeeded(
                            this
                          );
                        }
                      };
                      return ReadableStreamDefaultController;
                    })();
                  Object.defineProperties(
                    ReadableStreamDefaultController.prototype,
                    {
                      close: { enumerable: true },
                      enqueue: {
                        enumerable: true,
                      },
                      error: { enumerable: true },
                      desiredSize: {
                        enumerable: true,
                      },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      ReadableStreamDefaultController.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "ReadableStreamDefaultController",
                        configurable: true,
                      }
                    );
                  }
                  function IsReadableStreamDefaultController(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_controlledReadableStream"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamDefaultControllerCallPullIfNeeded(
                    controller
                  ) {
                    var shouldPull =
                      ReadableStreamDefaultControllerShouldCallPull(
                        controller
                      );
                    if (!shouldPull) {
                      return;
                    }
                    if (controller._pulling) {
                      controller._pullAgain = true;
                      return;
                    }
                    controller._pulling = true;
                    var pullPromise =
                      controller._pullAlgorithm();
                    uponPromise(
                      pullPromise,
                      function () {
                        controller._pulling = false;
                        if (
                          controller._pullAgain
                        ) {
                          controller._pullAgain = false;
                          ReadableStreamDefaultControllerCallPullIfNeeded(
                            controller
                          );
                        }
                      },
                      function (e) {
                        ReadableStreamDefaultControllerError(
                          controller,
                          e
                        );
                      }
                    );
                  }
                  function ReadableStreamDefaultControllerShouldCallPull(
                    controller
                  ) {
                    var stream =
                      controller._controlledReadableStream;
                    if (
                      !ReadableStreamDefaultControllerCanCloseOrEnqueue(
                        controller
                      )
                    ) {
                      return false;
                    }
                    if (!controller._started) {
                      return false;
                    }
                    if (
                      IsReadableStreamLocked(
                        stream
                      ) &&
                      ReadableStreamGetNumReadRequests(
                        stream
                      ) > 0
                    ) {
                      return true;
                    }
                    var desiredSize =
                      ReadableStreamDefaultControllerGetDesiredSize(
                        controller
                      );
                    if (desiredSize > 0) {
                      return true;
                    }
                    return false;
                  }
                  function ReadableStreamDefaultControllerClearAlgorithms(
                    controller
                  ) {
                    controller._pullAlgorithm =
                      undefined;
                    controller._cancelAlgorithm =
                      undefined;
                    controller._strategySizeAlgorithm =
                      undefined;
                  }
                  function ReadableStreamDefaultControllerClose(
                    controller
                  ) {
                    if (
                      !ReadableStreamDefaultControllerCanCloseOrEnqueue(
                        controller
                      )
                    ) {
                      return;
                    }
                    var stream =
                      controller._controlledReadableStream;
                    controller._closeRequested = true;
                    if (
                      controller._queue.length ===
                      0
                    ) {
                      ReadableStreamDefaultControllerClearAlgorithms(
                        controller
                      );
                      ReadableStreamClose(stream);
                    }
                  }
                  function ReadableStreamDefaultControllerEnqueue(
                    controller,
                    chunk
                  ) {
                    if (
                      !ReadableStreamDefaultControllerCanCloseOrEnqueue(
                        controller
                      )
                    ) {
                      return;
                    }
                    var stream =
                      controller._controlledReadableStream;
                    if (
                      IsReadableStreamLocked(
                        stream
                      ) &&
                      ReadableStreamGetNumReadRequests(
                        stream
                      ) > 0
                    ) {
                      ReadableStreamFulfillReadRequest(
                        stream,
                        chunk,
                        false
                      );
                    } else {
                      var chunkSize = void 0;
                      try {
                        chunkSize =
                          controller._strategySizeAlgorithm(
                            chunk
                          );
                      } catch (chunkSizeE) {
                        ReadableStreamDefaultControllerError(
                          controller,
                          chunkSizeE
                        );
                        throw chunkSizeE;
                      }
                      try {
                        EnqueueValueWithSize(
                          controller,
                          chunk,
                          chunkSize
                        );
                      } catch (enqueueE) {
                        ReadableStreamDefaultControllerError(
                          controller,
                          enqueueE
                        );
                        throw enqueueE;
                      }
                    }
                    ReadableStreamDefaultControllerCallPullIfNeeded(
                      controller
                    );
                  }
                  function ReadableStreamDefaultControllerError(
                    controller,
                    e
                  ) {
                    var stream =
                      controller._controlledReadableStream;
                    if (
                      stream._state !== "readable"
                    ) {
                      return;
                    }
                    ResetQueue(controller);
                    ReadableStreamDefaultControllerClearAlgorithms(
                      controller
                    );
                    ReadableStreamError(
                      stream,
                      e
                    );
                  }
                  function ReadableStreamDefaultControllerGetDesiredSize(
                    controller
                  ) {
                    var state =
                      controller
                        ._controlledReadableStream
                        ._state;
                    if (state === "errored") {
                      return null;
                    }
                    if (state === "closed") {
                      return 0;
                    }
                    return (
                      controller._strategyHWM -
                      controller._queueTotalSize
                    );
                  }
                  function ReadableStreamDefaultControllerHasBackpressure(
                    controller
                  ) {
                    if (
                      ReadableStreamDefaultControllerShouldCallPull(
                        controller
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamDefaultControllerCanCloseOrEnqueue(
                    controller
                  ) {
                    var state =
                      controller
                        ._controlledReadableStream
                        ._state;
                    if (
                      !controller._closeRequested &&
                      state === "readable"
                    ) {
                      return true;
                    }
                    return false;
                  }
                  function SetUpReadableStreamDefaultController(
                    stream,
                    controller,
                    startAlgorithm,
                    pullAlgorithm,
                    cancelAlgorithm,
                    highWaterMark,
                    sizeAlgorithm
                  ) {
                    controller._controlledReadableStream =
                      stream;
                    controller._queue = undefined;
                    controller._queueTotalSize =
                      undefined;
                    ResetQueue(controller);
                    controller._started = false;
                    controller._closeRequested = false;
                    controller._pullAgain = false;
                    controller._pulling = false;
                    controller._strategySizeAlgorithm =
                      sizeAlgorithm;
                    controller._strategyHWM =
                      highWaterMark;
                    controller._pullAlgorithm =
                      pullAlgorithm;
                    controller._cancelAlgorithm =
                      cancelAlgorithm;
                    stream._readableStreamController =
                      controller;
                    var startResult =
                      startAlgorithm();
                    uponPromise(
                      promiseResolvedWith(
                        startResult
                      ),
                      function () {
                        controller._started = true;
                        ReadableStreamDefaultControllerCallPullIfNeeded(
                          controller
                        );
                      },
                      function (r) {
                        ReadableStreamDefaultControllerError(
                          controller,
                          r
                        );
                      }
                    );
                  }
                  function SetUpReadableStreamDefaultControllerFromUnderlyingSource(
                    stream,
                    underlyingSource,
                    highWaterMark,
                    sizeAlgorithm
                  ) {
                    var controller =
                      Object.create(
                        ReadableStreamDefaultController.prototype
                      );
                    var startAlgorithm =
                      function () {
                        return undefined;
                      };
                    var pullAlgorithm =
                      function () {
                        return promiseResolvedWith(
                          undefined
                        );
                      };
                    var cancelAlgorithm =
                      function () {
                        return promiseResolvedWith(
                          undefined
                        );
                      };
                    if (
                      underlyingSource.start !==
                      undefined
                    ) {
                      startAlgorithm =
                        function () {
                          return underlyingSource.start(
                            controller
                          );
                        };
                    }
                    if (
                      underlyingSource.pull !==
                      undefined
                    ) {
                      pullAlgorithm =
                        function () {
                          return underlyingSource.pull(
                            controller
                          );
                        };
                    }
                    if (
                      underlyingSource.cancel !==
                      undefined
                    ) {
                      cancelAlgorithm = function (
                        reason
                      ) {
                        return underlyingSource.cancel(
                          reason
                        );
                      };
                    }
                    SetUpReadableStreamDefaultController(
                      stream,
                      controller,
                      startAlgorithm,
                      pullAlgorithm,
                      cancelAlgorithm,
                      highWaterMark,
                      sizeAlgorithm
                    );
                  }
                  function defaultControllerBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "ReadableStreamDefaultController.prototype." +
                        name +
                        " can only be used on a ReadableStreamDefaultController"
                    );
                  }
                  function ReadableStreamTee(
                    stream,
                    cloneForBranch2
                  ) {
                    var reader =
                      AcquireReadableStreamDefaultReader(
                        stream
                      );
                    var reading = false;
                    var canceled1 = false;
                    var canceled2 = false;
                    var reason1;
                    var reason2;
                    var branch1;
                    var branch2;
                    var resolveCancelPromise;
                    var cancelPromise =
                      newPromise(function (
                        resolve
                      ) {
                        resolveCancelPromise =
                          resolve;
                      });
                    function pullAlgorithm() {
                      if (reading) {
                        return promiseResolvedWith(
                          undefined
                        );
                      }
                      reading = true;
                      var readRequest = {
                        _chunkSteps: function (
                          value
                        ) {
                          queueMicrotask(
                            function () {
                              reading = false;
                              var value1 = value;
                              var value2 = value;
                              if (!canceled1) {
                                ReadableStreamDefaultControllerEnqueue(
                                  branch1._readableStreamController,
                                  value1
                                );
                              }
                              if (!canceled2) {
                                ReadableStreamDefaultControllerEnqueue(
                                  branch2._readableStreamController,
                                  value2
                                );
                              }
                              resolveCancelPromise(
                                undefined
                              );
                            }
                          );
                        },
                        _closeSteps: function () {
                          reading = false;
                          if (!canceled1) {
                            ReadableStreamDefaultControllerClose(
                              branch1._readableStreamController
                            );
                          }
                          if (!canceled2) {
                            ReadableStreamDefaultControllerClose(
                              branch2._readableStreamController
                            );
                          }
                        },
                        _errorSteps: function () {
                          reading = false;
                        },
                      };
                      ReadableStreamDefaultReaderRead(
                        reader,
                        readRequest
                      );
                      return promiseResolvedWith(
                        undefined
                      );
                    }
                    function cancel1Algorithm(
                      reason
                    ) {
                      canceled1 = true;
                      reason1 = reason;
                      if (canceled2) {
                        var compositeReason =
                          CreateArrayFromList([
                            reason1,
                            reason2,
                          ]);
                        var cancelResult =
                          ReadableStreamCancel(
                            stream,
                            compositeReason
                          );
                        resolveCancelPromise(
                          cancelResult
                        );
                      }
                      return cancelPromise;
                    }
                    function cancel2Algorithm(
                      reason
                    ) {
                      canceled2 = true;
                      reason2 = reason;
                      if (canceled1) {
                        var compositeReason =
                          CreateArrayFromList([
                            reason1,
                            reason2,
                          ]);
                        var cancelResult =
                          ReadableStreamCancel(
                            stream,
                            compositeReason
                          );
                        resolveCancelPromise(
                          cancelResult
                        );
                      }
                      return cancelPromise;
                    }
                    function startAlgorithm() {}
                    branch1 =
                      CreateReadableStream(
                        startAlgorithm,
                        pullAlgorithm,
                        cancel1Algorithm
                      );
                    branch2 =
                      CreateReadableStream(
                        startAlgorithm,
                        pullAlgorithm,
                        cancel2Algorithm
                      );
                    uponRejection(
                      reader._closedPromise,
                      function (r) {
                        ReadableStreamDefaultControllerError(
                          branch1._readableStreamController,
                          r
                        );
                        ReadableStreamDefaultControllerError(
                          branch2._readableStreamController,
                          r
                        );
                        resolveCancelPromise(
                          undefined
                        );
                      }
                    );
                    return [branch1, branch2];
                  }
                  function convertUnderlyingDefaultOrByteSource(
                    source,
                    context
                  ) {
                    assertDictionary(
                      source,
                      context
                    );
                    var original = source;
                    var autoAllocateChunkSize =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.autoAllocateChunkSize;
                    var cancel =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.cancel;
                    var pull =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.pull;
                    var start =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.start;
                    var type =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.type;
                    return {
                      autoAllocateChunkSize:
                        autoAllocateChunkSize ===
                        undefined
                          ? undefined
                          : convertUnsignedLongLongWithEnforceRange(
                              autoAllocateChunkSize,
                              context +
                                " has member 'autoAllocateChunkSize' that"
                            ),
                      cancel:
                        cancel === undefined
                          ? undefined
                          : convertUnderlyingSourceCancelCallback(
                              cancel,
                              original,
                              context +
                                " has member 'cancel' that"
                            ),
                      pull:
                        pull === undefined
                          ? undefined
                          : convertUnderlyingSourcePullCallback(
                              pull,
                              original,
                              context +
                                " has member 'pull' that"
                            ),
                      start:
                        start === undefined
                          ? undefined
                          : convertUnderlyingSourceStartCallback(
                              start,
                              original,
                              context +
                                " has member 'start' that"
                            ),
                      type:
                        type === undefined
                          ? undefined
                          : convertReadableStreamType(
                              type,
                              context +
                                " has member 'type' that"
                            ),
                    };
                  }
                  function convertUnderlyingSourceCancelCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (reason) {
                      return promiseCall(
                        fn,
                        original,
                        [reason]
                      );
                    };
                  }
                  function convertUnderlyingSourcePullCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (controller) {
                      return promiseCall(
                        fn,
                        original,
                        [controller]
                      );
                    };
                  }
                  function convertUnderlyingSourceStartCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (controller) {
                      return reflectCall(
                        fn,
                        original,
                        [controller]
                      );
                    };
                  }
                  function convertReadableStreamType(
                    type,
                    context
                  ) {
                    type = "" + type;
                    if (type !== "bytes") {
                      throw new TypeError(
                        context +
                          " '" +
                          type +
                          "' is not a valid enumeration value for ReadableStreamType"
                      );
                    }
                    return type;
                  }
                  function convertReaderOptions(
                    options,
                    context
                  ) {
                    assertDictionary(
                      options,
                      context
                    );
                    var mode =
                      options === null ||
                      options === void 0
                        ? void 0
                        : options.mode;
                    return {
                      mode:
                        mode === undefined
                          ? undefined
                          : convertReadableStreamReaderMode(
                              mode,
                              context +
                                " has member 'mode' that"
                            ),
                    };
                  }
                  function convertReadableStreamReaderMode(
                    mode,
                    context
                  ) {
                    mode = "" + mode;
                    if (mode !== "byob") {
                      throw new TypeError(
                        context +
                          " '" +
                          mode +
                          "' is not a valid enumeration value for ReadableStreamReaderMode"
                      );
                    }
                    return mode;
                  }
                  function convertIteratorOptions(
                    options,
                    context
                  ) {
                    assertDictionary(
                      options,
                      context
                    );
                    var preventCancel =
                      options === null ||
                      options === void 0
                        ? void 0
                        : options.preventCancel;
                    return {
                      preventCancel: Boolean(
                        preventCancel
                      ),
                    };
                  }
                  function convertPipeOptions(
                    options,
                    context
                  ) {
                    assertDictionary(
                      options,
                      context
                    );
                    var preventAbort =
                      options === null ||
                      options === void 0
                        ? void 0
                        : options.preventAbort;
                    var preventCancel =
                      options === null ||
                      options === void 0
                        ? void 0
                        : options.preventCancel;
                    var preventClose =
                      options === null ||
                      options === void 0
                        ? void 0
                        : options.preventClose;
                    var signal =
                      options === null ||
                      options === void 0
                        ? void 0
                        : options.signal;
                    if (signal !== undefined) {
                      assertAbortSignal(
                        signal,
                        context +
                          " has member 'signal' that"
                      );
                    }
                    return {
                      preventAbort:
                        Boolean(preventAbort),
                      preventCancel: Boolean(
                        preventCancel
                      ),
                      preventClose:
                        Boolean(preventClose),
                      signal: signal,
                    };
                  }
                  function assertAbortSignal(
                    signal,
                    context
                  ) {
                    if (!isAbortSignal(signal)) {
                      throw new TypeError(
                        context +
                          " is not an AbortSignal."
                      );
                    }
                  }
                  function convertReadableWritablePair(
                    pair,
                    context
                  ) {
                    assertDictionary(
                      pair,
                      context
                    );
                    var readable =
                      pair === null ||
                      pair === void 0
                        ? void 0
                        : pair.readable;
                    assertRequiredField(
                      readable,
                      "readable",
                      "ReadableWritablePair"
                    );
                    assertReadableStream(
                      readable,
                      context +
                        " has member 'readable' that"
                    );
                    var writable =
                      pair === null ||
                      pair === void 0
                        ? void 0
                        : pair.writable;
                    assertRequiredField(
                      writable,
                      "writable",
                      "ReadableWritablePair"
                    );
                    assertWritableStream(
                      writable,
                      context +
                        " has member 'writable' that"
                    );
                    return {
                      readable: readable,
                      writable: writable,
                    };
                  }
                  var ReadableStream =
                    (function () {
                      function ReadableStream(
                        rawUnderlyingSource,
                        rawStrategy
                      ) {
                        if (
                          rawUnderlyingSource ===
                          void 0
                        ) {
                          rawUnderlyingSource =
                            {};
                        }
                        if (
                          rawStrategy === void 0
                        ) {
                          rawStrategy = {};
                        }
                        if (
                          rawUnderlyingSource ===
                          undefined
                        ) {
                          rawUnderlyingSource =
                            null;
                        } else {
                          assertObject(
                            rawUnderlyingSource,
                            "First parameter"
                          );
                        }
                        var strategy =
                          convertQueuingStrategy(
                            rawStrategy,
                            "Second parameter"
                          );
                        var underlyingSource =
                          convertUnderlyingDefaultOrByteSource(
                            rawUnderlyingSource,
                            "First parameter"
                          );
                        InitializeReadableStream(
                          this
                        );
                        if (
                          underlyingSource.type ===
                          "bytes"
                        ) {
                          if (
                            strategy.size !==
                            undefined
                          ) {
                            throw new RangeError(
                              "The strategy for a byte stream cannot have a size function"
                            );
                          }
                          var highWaterMark =
                            ExtractHighWaterMark(
                              strategy,
                              0
                            );
                          SetUpReadableByteStreamControllerFromUnderlyingSource(
                            this,
                            underlyingSource,
                            highWaterMark
                          );
                        } else {
                          var sizeAlgorithm =
                            ExtractSizeAlgorithm(
                              strategy
                            );
                          var highWaterMark =
                            ExtractHighWaterMark(
                              strategy,
                              1
                            );
                          SetUpReadableStreamDefaultControllerFromUnderlyingSource(
                            this,
                            underlyingSource,
                            highWaterMark,
                            sizeAlgorithm
                          );
                        }
                      }
                      Object.defineProperty(
                        ReadableStream.prototype,
                        "locked",
                        {
                          get: function () {
                            if (
                              !IsReadableStream(
                                this
                              )
                            ) {
                              throw streamBrandCheckException$1(
                                "locked"
                              );
                            }
                            return IsReadableStreamLocked(
                              this
                            );
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      ReadableStream.prototype.cancel =
                        function (reason) {
                          if (reason === void 0) {
                            reason = undefined;
                          }
                          if (
                            !IsReadableStream(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              streamBrandCheckException$1(
                                "cancel"
                              )
                            );
                          }
                          if (
                            IsReadableStreamLocked(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "Cannot cancel a stream that already has a reader"
                              )
                            );
                          }
                          return ReadableStreamCancel(
                            this,
                            reason
                          );
                        };
                      ReadableStream.prototype.getReader =
                        function (rawOptions) {
                          if (
                            rawOptions === void 0
                          ) {
                            rawOptions =
                              undefined;
                          }
                          if (
                            !IsReadableStream(
                              this
                            )
                          ) {
                            throw streamBrandCheckException$1(
                              "getReader"
                            );
                          }
                          var options =
                            convertReaderOptions(
                              rawOptions,
                              "First parameter"
                            );
                          if (
                            options.mode ===
                            undefined
                          ) {
                            return AcquireReadableStreamDefaultReader(
                              this
                            );
                          }
                          return AcquireReadableStreamBYOBReader(
                            this
                          );
                        };
                      ReadableStream.prototype.pipeThrough =
                        function (
                          rawTransform,
                          rawOptions
                        ) {
                          if (
                            rawOptions === void 0
                          ) {
                            rawOptions = {};
                          }
                          if (
                            !IsReadableStream(
                              this
                            )
                          ) {
                            throw streamBrandCheckException$1(
                              "pipeThrough"
                            );
                          }
                          assertRequiredArgument(
                            rawTransform,
                            1,
                            "pipeThrough"
                          );
                          var transform =
                            convertReadableWritablePair(
                              rawTransform,
                              "First parameter"
                            );
                          var options =
                            convertPipeOptions(
                              rawOptions,
                              "Second parameter"
                            );
                          if (
                            IsReadableStreamLocked(
                              this
                            )
                          ) {
                            throw new TypeError(
                              "ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream"
                            );
                          }
                          if (
                            IsWritableStreamLocked(
                              transform.writable
                            )
                          ) {
                            throw new TypeError(
                              "ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream"
                            );
                          }
                          var promise =
                            ReadableStreamPipeTo(
                              this,
                              transform.writable,
                              options.preventClose,
                              options.preventAbort,
                              options.preventCancel,
                              options.signal
                            );
                          setPromiseIsHandledToTrue(
                            promise
                          );
                          return transform.readable;
                        };
                      ReadableStream.prototype.pipeTo =
                        function (
                          destination,
                          rawOptions
                        ) {
                          if (
                            rawOptions === void 0
                          ) {
                            rawOptions = {};
                          }
                          if (
                            !IsReadableStream(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              streamBrandCheckException$1(
                                "pipeTo"
                              )
                            );
                          }
                          if (
                            destination ===
                            undefined
                          ) {
                            return promiseRejectedWith(
                              "Parameter 1 is required in 'pipeTo'."
                            );
                          }
                          if (
                            !IsWritableStream(
                              destination
                            )
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "ReadableStream.prototype.pipeTo's first argument must be a WritableStream"
                              )
                            );
                          }
                          var options;
                          try {
                            options =
                              convertPipeOptions(
                                rawOptions,
                                "Second parameter"
                              );
                          } catch (e) {
                            return promiseRejectedWith(
                              e
                            );
                          }
                          if (
                            IsReadableStreamLocked(
                              this
                            )
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"
                              )
                            );
                          }
                          if (
                            IsWritableStreamLocked(
                              destination
                            )
                          ) {
                            return promiseRejectedWith(
                              new TypeError(
                                "ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"
                              )
                            );
                          }
                          return ReadableStreamPipeTo(
                            this,
                            destination,
                            options.preventClose,
                            options.preventAbort,
                            options.preventCancel,
                            options.signal
                          );
                        };
                      ReadableStream.prototype.tee =
                        function () {
                          if (
                            !IsReadableStream(
                              this
                            )
                          ) {
                            throw streamBrandCheckException$1(
                              "tee"
                            );
                          }
                          var branches =
                            ReadableStreamTee(
                              this
                            );
                          return CreateArrayFromList(
                            branches
                          );
                        };
                      ReadableStream.prototype.values =
                        function (rawOptions) {
                          if (
                            rawOptions === void 0
                          ) {
                            rawOptions =
                              undefined;
                          }
                          if (
                            !IsReadableStream(
                              this
                            )
                          ) {
                            throw streamBrandCheckException$1(
                              "values"
                            );
                          }
                          var options =
                            convertIteratorOptions(
                              rawOptions,
                              "First parameter"
                            );
                          return AcquireReadableStreamAsyncIterator(
                            this,
                            options.preventCancel
                          );
                        };
                      return ReadableStream;
                    })();
                  Object.defineProperties(
                    ReadableStream.prototype,
                    {
                      cancel: {
                        enumerable: true,
                      },
                      getReader: {
                        enumerable: true,
                      },
                      pipeThrough: {
                        enumerable: true,
                      },
                      pipeTo: {
                        enumerable: true,
                      },
                      tee: { enumerable: true },
                      values: {
                        enumerable: true,
                      },
                      locked: {
                        enumerable: true,
                      },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      ReadableStream.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value: "ReadableStream",
                        configurable: true,
                      }
                    );
                  }
                  if (
                    typeof SymbolPolyfill.asyncIterator ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      ReadableStream.prototype,
                      SymbolPolyfill.asyncIterator,
                      {
                        value:
                          ReadableStream.prototype
                            .values,
                        writable: true,
                        configurable: true,
                      }
                    );
                  }
                  function CreateReadableStream(
                    startAlgorithm,
                    pullAlgorithm,
                    cancelAlgorithm,
                    highWaterMark,
                    sizeAlgorithm
                  ) {
                    if (
                      highWaterMark === void 0
                    ) {
                      highWaterMark = 1;
                    }
                    if (
                      sizeAlgorithm === void 0
                    ) {
                      sizeAlgorithm =
                        function () {
                          return 1;
                        };
                    }
                    var stream = Object.create(
                      ReadableStream.prototype
                    );
                    InitializeReadableStream(
                      stream
                    );
                    var controller =
                      Object.create(
                        ReadableStreamDefaultController.prototype
                      );
                    SetUpReadableStreamDefaultController(
                      stream,
                      controller,
                      startAlgorithm,
                      pullAlgorithm,
                      cancelAlgorithm,
                      highWaterMark,
                      sizeAlgorithm
                    );
                    return stream;
                  }
                  function InitializeReadableStream(
                    stream
                  ) {
                    stream._state = "readable";
                    stream._reader = undefined;
                    stream._storedError =
                      undefined;
                    stream._disturbed = false;
                  }
                  function IsReadableStream(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_readableStreamController"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function IsReadableStreamLocked(
                    stream
                  ) {
                    if (
                      stream._reader === undefined
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamCancel(
                    stream,
                    reason
                  ) {
                    stream._disturbed = true;
                    if (
                      stream._state === "closed"
                    ) {
                      return promiseResolvedWith(
                        undefined
                      );
                    }
                    if (
                      stream._state === "errored"
                    ) {
                      return promiseRejectedWith(
                        stream._storedError
                      );
                    }
                    ReadableStreamClose(stream);
                    var sourceCancelPromise =
                      stream._readableStreamController[
                        CancelSteps
                      ](reason);
                    return transformPromiseWith(
                      sourceCancelPromise,
                      noop
                    );
                  }
                  function ReadableStreamClose(
                    stream
                  ) {
                    stream._state = "closed";
                    var reader = stream._reader;
                    if (reader === undefined) {
                      return;
                    }
                    defaultReaderClosedPromiseResolve(
                      reader
                    );
                    if (
                      IsReadableStreamDefaultReader(
                        reader
                      )
                    ) {
                      reader._readRequests.forEach(
                        function (readRequest) {
                          readRequest._closeSteps();
                        }
                      );
                      reader._readRequests =
                        new SimpleQueue();
                    }
                  }
                  function ReadableStreamError(
                    stream,
                    e
                  ) {
                    stream._state = "errored";
                    stream._storedError = e;
                    var reader = stream._reader;
                    if (reader === undefined) {
                      return;
                    }
                    defaultReaderClosedPromiseReject(
                      reader,
                      e
                    );
                    if (
                      IsReadableStreamDefaultReader(
                        reader
                      )
                    ) {
                      reader._readRequests.forEach(
                        function (readRequest) {
                          readRequest._errorSteps(
                            e
                          );
                        }
                      );
                      reader._readRequests =
                        new SimpleQueue();
                    } else {
                      reader._readIntoRequests.forEach(
                        function (
                          readIntoRequest
                        ) {
                          readIntoRequest._errorSteps(
                            e
                          );
                        }
                      );
                      reader._readIntoRequests =
                        new SimpleQueue();
                    }
                  }
                  function streamBrandCheckException$1(
                    name
                  ) {
                    return new TypeError(
                      "ReadableStream.prototype." +
                        name +
                        " can only be used on a ReadableStream"
                    );
                  }
                  function convertQueuingStrategyInit(
                    init,
                    context
                  ) {
                    assertDictionary(
                      init,
                      context
                    );
                    var highWaterMark =
                      init === null ||
                      init === void 0
                        ? void 0
                        : init.highWaterMark;
                    assertRequiredField(
                      highWaterMark,
                      "highWaterMark",
                      "QueuingStrategyInit"
                    );
                    return {
                      highWaterMark:
                        convertUnrestrictedDouble(
                          highWaterMark
                        ),
                    };
                  }
                  var byteLengthSizeFunction =
                    function size(chunk) {
                      return chunk.byteLength;
                    };
                  var ByteLengthQueuingStrategy =
                    (function () {
                      function ByteLengthQueuingStrategy(
                        options
                      ) {
                        assertRequiredArgument(
                          options,
                          1,
                          "ByteLengthQueuingStrategy"
                        );
                        options =
                          convertQueuingStrategyInit(
                            options,
                            "First parameter"
                          );
                        this._byteLengthQueuingStrategyHighWaterMark =
                          options.highWaterMark;
                      }
                      Object.defineProperty(
                        ByteLengthQueuingStrategy.prototype,
                        "highWaterMark",
                        {
                          get: function () {
                            if (
                              !IsByteLengthQueuingStrategy(
                                this
                              )
                            ) {
                              throw byteLengthBrandCheckException(
                                "highWaterMark"
                              );
                            }
                            return this
                              ._byteLengthQueuingStrategyHighWaterMark;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      Object.defineProperty(
                        ByteLengthQueuingStrategy.prototype,
                        "size",
                        {
                          get: function () {
                            if (
                              !IsByteLengthQueuingStrategy(
                                this
                              )
                            ) {
                              throw byteLengthBrandCheckException(
                                "size"
                              );
                            }
                            return byteLengthSizeFunction;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      return ByteLengthQueuingStrategy;
                    })();
                  Object.defineProperties(
                    ByteLengthQueuingStrategy.prototype,
                    {
                      highWaterMark: {
                        enumerable: true,
                      },
                      size: { enumerable: true },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      ByteLengthQueuingStrategy.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "ByteLengthQueuingStrategy",
                        configurable: true,
                      }
                    );
                  }
                  function byteLengthBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "ByteLengthQueuingStrategy.prototype." +
                        name +
                        " can only be used on a ByteLengthQueuingStrategy"
                    );
                  }
                  function IsByteLengthQueuingStrategy(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_byteLengthQueuingStrategyHighWaterMark"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  var countSizeFunction =
                    function size() {
                      return 1;
                    };
                  var CountQueuingStrategy =
                    (function () {
                      function CountQueuingStrategy(
                        options
                      ) {
                        assertRequiredArgument(
                          options,
                          1,
                          "CountQueuingStrategy"
                        );
                        options =
                          convertQueuingStrategyInit(
                            options,
                            "First parameter"
                          );
                        this._countQueuingStrategyHighWaterMark =
                          options.highWaterMark;
                      }
                      Object.defineProperty(
                        CountQueuingStrategy.prototype,
                        "highWaterMark",
                        {
                          get: function () {
                            if (
                              !IsCountQueuingStrategy(
                                this
                              )
                            ) {
                              throw countBrandCheckException(
                                "highWaterMark"
                              );
                            }
                            return this
                              ._countQueuingStrategyHighWaterMark;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      Object.defineProperty(
                        CountQueuingStrategy.prototype,
                        "size",
                        {
                          get: function () {
                            if (
                              !IsCountQueuingStrategy(
                                this
                              )
                            ) {
                              throw countBrandCheckException(
                                "size"
                              );
                            }
                            return countSizeFunction;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      return CountQueuingStrategy;
                    })();
                  Object.defineProperties(
                    CountQueuingStrategy.prototype,
                    {
                      highWaterMark: {
                        enumerable: true,
                      },
                      size: { enumerable: true },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      CountQueuingStrategy.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "CountQueuingStrategy",
                        configurable: true,
                      }
                    );
                  }
                  function countBrandCheckException(
                    name
                  ) {
                    return new TypeError(
                      "CountQueuingStrategy.prototype." +
                        name +
                        " can only be used on a CountQueuingStrategy"
                    );
                  }
                  function IsCountQueuingStrategy(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_countQueuingStrategyHighWaterMark"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function convertTransformer(
                    original,
                    context
                  ) {
                    assertDictionary(
                      original,
                      context
                    );
                    var flush =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.flush;
                    var readableType =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.readableType;
                    var start =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.start;
                    var transform =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.transform;
                    var writableType =
                      original === null ||
                      original === void 0
                        ? void 0
                        : original.writableType;
                    return {
                      flush:
                        flush === undefined
                          ? undefined
                          : convertTransformerFlushCallback(
                              flush,
                              original,
                              context +
                                " has member 'flush' that"
                            ),
                      readableType: readableType,
                      start:
                        start === undefined
                          ? undefined
                          : convertTransformerStartCallback(
                              start,
                              original,
                              context +
                                " has member 'start' that"
                            ),
                      transform:
                        transform === undefined
                          ? undefined
                          : convertTransformerTransformCallback(
                              transform,
                              original,
                              context +
                                " has member 'transform' that"
                            ),
                      writableType: writableType,
                    };
                  }
                  function convertTransformerFlushCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (controller) {
                      return promiseCall(
                        fn,
                        original,
                        [controller]
                      );
                    };
                  }
                  function convertTransformerStartCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (controller) {
                      return reflectCall(
                        fn,
                        original,
                        [controller]
                      );
                    };
                  }
                  function convertTransformerTransformCallback(
                    fn,
                    original,
                    context
                  ) {
                    assertFunction(fn, context);
                    return function (
                      chunk,
                      controller
                    ) {
                      return promiseCall(
                        fn,
                        original,
                        [chunk, controller]
                      );
                    };
                  }
                  var TransformStream =
                    (function () {
                      function TransformStream(
                        rawTransformer,
                        rawWritableStrategy,
                        rawReadableStrategy
                      ) {
                        if (
                          rawTransformer ===
                          void 0
                        ) {
                          rawTransformer = {};
                        }
                        if (
                          rawWritableStrategy ===
                          void 0
                        ) {
                          rawWritableStrategy =
                            {};
                        }
                        if (
                          rawReadableStrategy ===
                          void 0
                        ) {
                          rawReadableStrategy =
                            {};
                        }
                        if (
                          rawTransformer ===
                          undefined
                        ) {
                          rawTransformer = null;
                        }
                        var writableStrategy =
                          convertQueuingStrategy(
                            rawWritableStrategy,
                            "Second parameter"
                          );
                        var readableStrategy =
                          convertQueuingStrategy(
                            rawReadableStrategy,
                            "Third parameter"
                          );
                        var transformer =
                          convertTransformer(
                            rawTransformer,
                            "First parameter"
                          );
                        if (
                          transformer.readableType !==
                          undefined
                        ) {
                          throw new RangeError(
                            "Invalid readableType specified"
                          );
                        }
                        if (
                          transformer.writableType !==
                          undefined
                        ) {
                          throw new RangeError(
                            "Invalid writableType specified"
                          );
                        }
                        var readableHighWaterMark =
                          ExtractHighWaterMark(
                            readableStrategy,
                            0
                          );
                        var readableSizeAlgorithm =
                          ExtractSizeAlgorithm(
                            readableStrategy
                          );
                        var writableHighWaterMark =
                          ExtractHighWaterMark(
                            writableStrategy,
                            1
                          );
                        var writableSizeAlgorithm =
                          ExtractSizeAlgorithm(
                            writableStrategy
                          );
                        var startPromise_resolve;
                        var startPromise =
                          newPromise(function (
                            resolve
                          ) {
                            startPromise_resolve =
                              resolve;
                          });
                        InitializeTransformStream(
                          this,
                          startPromise,
                          writableHighWaterMark,
                          writableSizeAlgorithm,
                          readableHighWaterMark,
                          readableSizeAlgorithm
                        );
                        SetUpTransformStreamDefaultControllerFromTransformer(
                          this,
                          transformer
                        );
                        if (
                          transformer.start !==
                          undefined
                        ) {
                          startPromise_resolve(
                            transformer.start(
                              this
                                ._transformStreamController
                            )
                          );
                        } else {
                          startPromise_resolve(
                            undefined
                          );
                        }
                      }
                      Object.defineProperty(
                        TransformStream.prototype,
                        "readable",
                        {
                          get: function () {
                            if (
                              !IsTransformStream(
                                this
                              )
                            ) {
                              throw streamBrandCheckException$2(
                                "readable"
                              );
                            }
                            return this._readable;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      Object.defineProperty(
                        TransformStream.prototype,
                        "writable",
                        {
                          get: function () {
                            if (
                              !IsTransformStream(
                                this
                              )
                            ) {
                              throw streamBrandCheckException$2(
                                "writable"
                              );
                            }
                            return this._writable;
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      return TransformStream;
                    })();
                  Object.defineProperties(
                    TransformStream.prototype,
                    {
                      readable: {
                        enumerable: true,
                      },
                      writable: {
                        enumerable: true,
                      },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      TransformStream.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value: "TransformStream",
                        configurable: true,
                      }
                    );
                  }
                  function InitializeTransformStream(
                    stream,
                    startPromise,
                    writableHighWaterMark,
                    writableSizeAlgorithm,
                    readableHighWaterMark,
                    readableSizeAlgorithm
                  ) {
                    function startAlgorithm() {
                      return startPromise;
                    }
                    function writeAlgorithm(
                      chunk
                    ) {
                      return TransformStreamDefaultSinkWriteAlgorithm(
                        stream,
                        chunk
                      );
                    }
                    function abortAlgorithm(
                      reason
                    ) {
                      return TransformStreamDefaultSinkAbortAlgorithm(
                        stream,
                        reason
                      );
                    }
                    function closeAlgorithm() {
                      return TransformStreamDefaultSinkCloseAlgorithm(
                        stream
                      );
                    }
                    stream._writable =
                      CreateWritableStream(
                        startAlgorithm,
                        writeAlgorithm,
                        closeAlgorithm,
                        abortAlgorithm,
                        writableHighWaterMark,
                        writableSizeAlgorithm
                      );
                    function pullAlgorithm() {
                      return TransformStreamDefaultSourcePullAlgorithm(
                        stream
                      );
                    }
                    function cancelAlgorithm(
                      reason
                    ) {
                      TransformStreamErrorWritableAndUnblockWrite(
                        stream,
                        reason
                      );
                      return promiseResolvedWith(
                        undefined
                      );
                    }
                    stream._readable =
                      CreateReadableStream(
                        startAlgorithm,
                        pullAlgorithm,
                        cancelAlgorithm,
                        readableHighWaterMark,
                        readableSizeAlgorithm
                      );
                    stream._backpressure =
                      undefined;
                    stream._backpressureChangePromise =
                      undefined;
                    stream._backpressureChangePromise_resolve =
                      undefined;
                    TransformStreamSetBackpressure(
                      stream,
                      true
                    );
                    stream._transformStreamController =
                      undefined;
                  }
                  function IsTransformStream(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_transformStreamController"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function TransformStreamError(
                    stream,
                    e
                  ) {
                    ReadableStreamDefaultControllerError(
                      stream._readable
                        ._readableStreamController,
                      e
                    );
                    TransformStreamErrorWritableAndUnblockWrite(
                      stream,
                      e
                    );
                  }
                  function TransformStreamErrorWritableAndUnblockWrite(
                    stream,
                    e
                  ) {
                    TransformStreamDefaultControllerClearAlgorithms(
                      stream._transformStreamController
                    );
                    WritableStreamDefaultControllerErrorIfNeeded(
                      stream._writable
                        ._writableStreamController,
                      e
                    );
                    if (stream._backpressure) {
                      TransformStreamSetBackpressure(
                        stream,
                        false
                      );
                    }
                  }
                  function TransformStreamSetBackpressure(
                    stream,
                    backpressure
                  ) {
                    if (
                      stream._backpressureChangePromise !==
                      undefined
                    ) {
                      stream._backpressureChangePromise_resolve();
                    }
                    stream._backpressureChangePromise =
                      newPromise(function (
                        resolve
                      ) {
                        stream._backpressureChangePromise_resolve =
                          resolve;
                      });
                    stream._backpressure =
                      backpressure;
                  }
                  var TransformStreamDefaultController =
                    (function () {
                      function TransformStreamDefaultController() {
                        throw new TypeError(
                          "Illegal constructor"
                        );
                      }
                      Object.defineProperty(
                        TransformStreamDefaultController.prototype,
                        "desiredSize",
                        {
                          get: function () {
                            if (
                              !IsTransformStreamDefaultController(
                                this
                              )
                            ) {
                              throw defaultControllerBrandCheckException$1(
                                "desiredSize"
                              );
                            }
                            var readableController =
                              this
                                ._controlledTransformStream
                                ._readable
                                ._readableStreamController;
                            return ReadableStreamDefaultControllerGetDesiredSize(
                              readableController
                            );
                          },
                          enumerable: false,
                          configurable: true,
                        }
                      );
                      TransformStreamDefaultController.prototype.enqueue =
                        function (chunk) {
                          if (chunk === void 0) {
                            chunk = undefined;
                          }
                          if (
                            !IsTransformStreamDefaultController(
                              this
                            )
                          ) {
                            throw defaultControllerBrandCheckException$1(
                              "enqueue"
                            );
                          }
                          TransformStreamDefaultControllerEnqueue(
                            this,
                            chunk
                          );
                        };
                      TransformStreamDefaultController.prototype.error =
                        function (reason) {
                          if (reason === void 0) {
                            reason = undefined;
                          }
                          if (
                            !IsTransformStreamDefaultController(
                              this
                            )
                          ) {
                            throw defaultControllerBrandCheckException$1(
                              "error"
                            );
                          }
                          TransformStreamDefaultControllerError(
                            this,
                            reason
                          );
                        };
                      TransformStreamDefaultController.prototype.terminate =
                        function () {
                          if (
                            !IsTransformStreamDefaultController(
                              this
                            )
                          ) {
                            throw defaultControllerBrandCheckException$1(
                              "terminate"
                            );
                          }
                          TransformStreamDefaultControllerTerminate(
                            this
                          );
                        };
                      return TransformStreamDefaultController;
                    })();
                  Object.defineProperties(
                    TransformStreamDefaultController.prototype,
                    {
                      enqueue: {
                        enumerable: true,
                      },
                      error: { enumerable: true },
                      terminate: {
                        enumerable: true,
                      },
                      desiredSize: {
                        enumerable: true,
                      },
                    }
                  );
                  if (
                    typeof SymbolPolyfill.toStringTag ===
                    "symbol"
                  ) {
                    Object.defineProperty(
                      TransformStreamDefaultController.prototype,
                      SymbolPolyfill.toStringTag,
                      {
                        value:
                          "TransformStreamDefaultController",
                        configurable: true,
                      }
                    );
                  }
                  function IsTransformStreamDefaultController(
                    x
                  ) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (
                      !Object.prototype.hasOwnProperty.call(
                        x,
                        "_controlledTransformStream"
                      )
                    ) {
                      return false;
                    }
                    return true;
                  }
                  function SetUpTransformStreamDefaultController(
                    stream,
                    controller,
                    transformAlgorithm,
                    flushAlgorithm
                  ) {
                    controller._controlledTransformStream =
                      stream;
                    stream._transformStreamController =
                      controller;
                    controller._transformAlgorithm =
                      transformAlgorithm;
                    controller._flushAlgorithm =
                      flushAlgorithm;
                  }
                  function SetUpTransformStreamDefaultControllerFromTransformer(
                    stream,
                    transformer
                  ) {
                    var controller =
                      Object.create(
                        TransformStreamDefaultController.prototype
                      );
                    var transformAlgorithm =
                      function (chunk) {
                        try {
                          TransformStreamDefaultControllerEnqueue(
                            controller,
                            chunk
                          );
                          return promiseResolvedWith(
                            undefined
                          );
                        } catch (transformResultE) {
                          return promiseRejectedWith(
                            transformResultE
                          );
                        }
                      };
                    var flushAlgorithm =
                      function () {
                        return promiseResolvedWith(
                          undefined
                        );
                      };
                    if (
                      transformer.transform !==
                      undefined
                    ) {
                      transformAlgorithm =
                        function (chunk) {
                          return transformer.transform(
                            chunk,
                            controller
                          );
                        };
                    }
                    if (
                      transformer.flush !==
                      undefined
                    ) {
                      flushAlgorithm =
                        function () {
                          return transformer.flush(
                            controller
                          );
                        };
                    }
                    SetUpTransformStreamDefaultController(
                      stream,
                      controller,
                      transformAlgorithm,
                      flushAlgorithm
                    );
                  }
                  function TransformStreamDefaultControllerClearAlgorithms(
                    controller
                  ) {
                    controller._transformAlgorithm =
                      undefined;
                    controller._flushAlgorithm =
                      undefined;
                  }
                  function TransformStreamDefaultControllerEnqueue(
                    controller,
                    chunk
                  ) {
                    var stream =
                      controller._controlledTransformStream;
                    var readableController =
                      stream._readable
                        ._readableStreamController;
                    if (
                      !ReadableStreamDefaultControllerCanCloseOrEnqueue(
                        readableController
                      )
                    ) {
                      throw new TypeError(
                        "Readable side is not in a state that permits enqueue"
                      );
                    }
                    try {
                      ReadableStreamDefaultControllerEnqueue(
                        readableController,
                        chunk
                      );
                    } catch (e) {
                      TransformStreamErrorWritableAndUnblockWrite(
                        stream,
                        e
                      );
                      throw stream
                        ._readable._storedError;
                    }
                    var backpressure =
                      ReadableStreamDefaultControllerHasBackpressure(
                        readableController
                      );
                    if (
                      backpressure !==
                      stream._backpressure
                    ) {
                      TransformStreamSetBackpressure(
                        stream,
                        true
                      );
                    }
                  }
                  function TransformStreamDefaultControllerError(
                    controller,
                    e
                  ) {
                    TransformStreamError(
                      controller._controlledTransformStream,
                      e
                    );
                  }
                  function TransformStreamDefaultControllerPerformTransform(
                    controller,
                    chunk
                  ) {
                    var transformPromise =
                      controller._transformAlgorithm(
                        chunk
                      );
                    return transformPromiseWith(
                      transformPromise,
                      undefined,
                      function (r) {
                        TransformStreamError(
                          controller._controlledTransformStream,
                          r
                        );
                        throw r;
                      }
                    );
                  }
                  function TransformStreamDefaultControllerTerminate(
                    controller
                  ) {
                    var stream =
                      controller._controlledTransformStream;
                    var readableController =
                      stream._readable
                        ._readableStreamController;
                    ReadableStreamDefaultControllerClose(
                      readableController
                    );
                    var error = new TypeError(
                      "TransformStream terminated"
                    );
                    TransformStreamErrorWritableAndUnblockWrite(
                      stream,
                      error
                    );
                  }
                  function TransformStreamDefaultSinkWriteAlgorithm(
                    stream,
                    chunk
                  ) {
                    var controller =
                      stream._transformStreamController;
                    if (stream._backpressure) {
                      var backpressureChangePromise =
                        stream._backpressureChangePromise;
                      return transformPromiseWith(
                        backpressureChangePromise,
                        function () {
                          var writable =
                            stream._writable;
                          var state =
                            writable._state;
                          if (
                            state === "erroring"
                          ) {
                            throw writable._storedError;
                          }
                          return TransformStreamDefaultControllerPerformTransform(
                            controller,
                            chunk
                          );
                        }
                      );
                    }
                    return TransformStreamDefaultControllerPerformTransform(
                      controller,
                      chunk
                    );
                  }
                  function TransformStreamDefaultSinkAbortAlgorithm(
                    stream,
                    reason
                  ) {
                    TransformStreamError(
                      stream,
                      reason
                    );
                    return promiseResolvedWith(
                      undefined
                    );
                  }
                  function TransformStreamDefaultSinkCloseAlgorithm(
                    stream
                  ) {
                    var readable =
                      stream._readable;
                    var controller =
                      stream._transformStreamController;
                    var flushPromise =
                      controller._flushAlgorithm();
                    TransformStreamDefaultControllerClearAlgorithms(
                      controller
                    );
                    return transformPromiseWith(
                      flushPromise,
                      function () {
                        if (
                          readable._state ===
                          "errored"
                        ) {
                          throw readable._storedError;
                        }
                        ReadableStreamDefaultControllerClose(
                          readable._readableStreamController
                        );
                      },
                      function (r) {
                        TransformStreamError(
                          stream,
                          r
                        );
                        throw readable._storedError;
                      }
                    );
                  }
                  function TransformStreamDefaultSourcePullAlgorithm(
                    stream
                  ) {
                    TransformStreamSetBackpressure(
                      stream,
                      false
                    );
                    return stream._backpressureChangePromise;
                  }
                  function defaultControllerBrandCheckException$1(
                    name
                  ) {
                    return new TypeError(
                      "TransformStreamDefaultController.prototype." +
                        name +
                        " can only be used on a TransformStreamDefaultController"
                    );
                  }
                  function streamBrandCheckException$2(
                    name
                  ) {
                    return new TypeError(
                      "TransformStream.prototype." +
                        name +
                        " can only be used on a TransformStream"
                    );
                  }
                  exports.ByteLengthQueuingStrategy =
                    ByteLengthQueuingStrategy;
                  exports.CountQueuingStrategy =
                    CountQueuingStrategy;
                  exports.ReadableByteStreamController =
                    ReadableByteStreamController;
                  exports.ReadableStream =
                    ReadableStream;
                  exports.ReadableStreamBYOBReader =
                    ReadableStreamBYOBReader;
                  exports.ReadableStreamBYOBRequest =
                    ReadableStreamBYOBRequest;
                  exports.ReadableStreamDefaultController =
                    ReadableStreamDefaultController;
                  exports.ReadableStreamDefaultReader =
                    ReadableStreamDefaultReader;
                  exports.TransformStream =
                    TransformStream;
                  exports.TransformStreamDefaultController =
                    TransformStreamDefaultController;
                  exports.WritableStream =
                    WritableStream;
                  exports.WritableStreamDefaultController =
                    WritableStreamDefaultController;
                  exports.WritableStreamDefaultWriter =
                    WritableStreamDefaultWriter;
                  Object.defineProperty(
                    exports,
                    "__esModule",
                    { value: true }
                  );
                });

                /***/
              },
              /* 122 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                __w_pdfjs_require__(123);
                var entryUnbind =
                  __w_pdfjs_require__(127);
                module.exports = entryUnbind(
                  "String",
                  "padStart"
                );

                /***/
              },
              /* 123 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var $ = __w_pdfjs_require__(9);
                var $padStart =
                  __w_pdfjs_require__(124).start;
                var WEBKIT_BUG =
                  __w_pdfjs_require__(126);
                $(
                  {
                    target: "String",
                    proto: true,
                    forced: WEBKIT_BUG,
                  },
                  {
                    padStart: function padStart(
                      maxLength
                    ) {
                      return $padStart(
                        this,
                        maxLength,
                        arguments.length > 1
                          ? arguments[1]
                          : undefined
                      );
                    },
                  }
                );

                /***/
              },
              /* 124 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var toLength =
                  __w_pdfjs_require__(46);
                var repeat =
                  __w_pdfjs_require__(125);
                var requireObjectCoercible =
                  __w_pdfjs_require__(19);
                var ceil = Math.ceil;
                var createMethod = function (
                  IS_END
                ) {
                  return function (
                    $this,
                    maxLength,
                    fillString
                  ) {
                    var S = String(
                      requireObjectCoercible(
                        $this
                      )
                    );
                    var stringLength = S.length;
                    var fillStr =
                      fillString === undefined
                        ? " "
                        : String(fillString);
                    var intMaxLength =
                      toLength(maxLength);
                    var fillLen, stringFiller;
                    if (
                      intMaxLength <=
                        stringLength ||
                      fillStr == ""
                    )
                      return S;
                    fillLen =
                      intMaxLength - stringLength;
                    stringFiller = repeat.call(
                      fillStr,
                      ceil(
                        fillLen / fillStr.length
                      )
                    );
                    if (
                      stringFiller.length >
                      fillLen
                    )
                      stringFiller =
                        stringFiller.slice(
                          0,
                          fillLen
                        );
                    return IS_END
                      ? S + stringFiller
                      : stringFiller + S;
                  };
                };
                module.exports = {
                  start: createMethod(false),
                  end: createMethod(true),
                };

                /***/
              },
              /* 125 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var toInteger =
                  __w_pdfjs_require__(47);
                var requireObjectCoercible =
                  __w_pdfjs_require__(19);
                module.exports =
                  "".repeat ||
                  function repeat(count) {
                    var str = String(
                      requireObjectCoercible(this)
                    );
                    var result = "";
                    var n = toInteger(count);
                    if (n < 0 || n == Infinity)
                      throw RangeError(
                        "Wrong number of repetitions"
                      );
                    for (
                      ;
                      n > 0;
                      (n >>>= 1) && (str += str)
                    )
                      if (n & 1) result += str;
                    return result;
                  };

                /***/
              },
              /* 126 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var userAgent =
                  __w_pdfjs_require__(95);
                module.exports =
                  /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(
                    userAgent
                  );

                /***/
              },
              /* 127 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var global =
                  __w_pdfjs_require__(10);
                var bind =
                  __w_pdfjs_require__(75);
                var call = Function.call;
                module.exports = function (
                  CONSTRUCTOR,
                  METHOD,
                  length
                ) {
                  return bind(
                    call,
                    global[CONSTRUCTOR].prototype[
                      METHOD
                    ],
                    length
                  );
                };

                /***/
              },
              /* 128 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                __w_pdfjs_require__(129);
                var entryUnbind =
                  __w_pdfjs_require__(127);
                module.exports = entryUnbind(
                  "String",
                  "padEnd"
                );

                /***/
              },
              /* 129 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                var $ = __w_pdfjs_require__(9);
                var $padEnd =
                  __w_pdfjs_require__(124).end;
                var WEBKIT_BUG =
                  __w_pdfjs_require__(126);
                $(
                  {
                    target: "String",
                    proto: true,
                    forced: WEBKIT_BUG,
                  },
                  {
                    padEnd: function padEnd(
                      maxLength
                    ) {
                      return $padEnd(
                        this,
                        maxLength,
                        arguments.length > 1
                          ? arguments[1]
                          : undefined
                      );
                    },
                  }
                );

                /***/
              },
              /* 130 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                __w_pdfjs_require__(131);
                var path =
                  __w_pdfjs_require__(42);
                module.exports =
                  path.Object.values;

                /***/
              },
              /* 131 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var $ = __w_pdfjs_require__(9);
                var $values =
                  __w_pdfjs_require__(132).values;
                $(
                  {
                    target: "Object",
                    stat: true,
                  },
                  {
                    values: function values(O) {
                      return $values(O);
                    },
                  }
                );

                /***/
              },
              /* 132 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var DESCRIPTORS =
                  __w_pdfjs_require__(12);
                var objectKeys =
                  __w_pdfjs_require__(60);
                var toIndexedObject =
                  __w_pdfjs_require__(16);
                var propertyIsEnumerable =
                  __w_pdfjs_require__(14).f;
                var createMethod = function (
                  TO_ENTRIES
                ) {
                  return function (it) {
                    var O = toIndexedObject(it);
                    var keys = objectKeys(O);
                    var length = keys.length;
                    var i = 0;
                    var result = [];
                    var key;
                    while (length > i) {
                      key = keys[i++];
                      if (
                        !DESCRIPTORS ||
                        propertyIsEnumerable.call(
                          O,
                          key
                        )
                      ) {
                        result.push(
                          TO_ENTRIES
                            ? [key, O[key]]
                            : O[key]
                        );
                      }
                    }
                    return result;
                  };
                };
                module.exports = {
                  entries: createMethod(true),
                  values: createMethod(false),
                };

                /***/
              },
              /* 133 */
              /***/ function (
                module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                __w_pdfjs_require__(134);
                var path =
                  __w_pdfjs_require__(42);
                module.exports =
                  path.Object.entries;

                /***/
              },
              /* 134 */
              /***/ function (
                __unused_webpack_module,
                __unused_webpack_exports,
                __w_pdfjs_require__
              ) {
                var $ = __w_pdfjs_require__(9);
                var $entries =
                  __w_pdfjs_require__(
                    132
                  ).entries;
                $(
                  {
                    target: "Object",
                    stat: true,
                  },
                  {
                    entries: function entries(O) {
                      return $entries(O);
                    },
                  }
                );

                /***/
              },
              /* 135 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.getDocument = getDocument;
                exports.setPDFNetworkStreamFactory =
                  setPDFNetworkStreamFactory;
                exports.version =
                  exports.PDFWorker =
                  exports.PDFPageProxy =
                  exports.PDFDocumentProxy =
                  exports.PDFDataRangeTransport =
                  exports.LoopbackPort =
                  exports.putBinaryImageData =
                  exports.DefaultCMapReaderFactory =
                  exports.DefaultCanvasFactory =
                  exports.build =
                    void 0;

                var _regenerator =
                  _interopRequireDefault(
                    __w_pdfjs_require__(2)
                  );

                var _util =
                  __w_pdfjs_require__(4);

                var _display_utils =
                  __w_pdfjs_require__(1);

                var _font_loader =
                  __w_pdfjs_require__(136);

                var _node_utils =
                  __w_pdfjs_require__(137);

                var _annotation_storage =
                  __w_pdfjs_require__(138);

                var _api_compatibility =
                  __w_pdfjs_require__(139);

                var _canvas =
                  __w_pdfjs_require__(140);

                var _worker_options =
                  __w_pdfjs_require__(142);

                var _is_node =
                  __w_pdfjs_require__(6);

                var _message_handler =
                  __w_pdfjs_require__(143);

                var _metadata =
                  __w_pdfjs_require__(144);

                var _optional_content_config =
                  __w_pdfjs_require__(146);

                var _transport_stream =
                  __w_pdfjs_require__(147);

                var _webgl =
                  __w_pdfjs_require__(148);

                function _interopRequireDefault(
                  obj
                ) {
                  return obj && obj.__esModule
                    ? obj
                    : { default: obj };
                }

                function asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  key,
                  arg
                ) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(
                      _next,
                      _throw
                    );
                  }
                }

                function _asyncToGenerator(fn) {
                  return function () {
                    var self = this,
                      args = arguments;
                    return new Promise(function (
                      resolve,
                      reject
                    ) {
                      var gen = fn.apply(
                        self,
                        args
                      );
                      function _next(value) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "next",
                          value
                        );
                      }
                      function _throw(err) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "throw",
                          err
                        );
                      }
                      _next(undefined);
                    });
                  };
                }

                function _toConsumableArray(arr) {
                  return (
                    _arrayWithoutHoles(arr) ||
                    _iterableToArray(arr) ||
                    _unsupportedIterableToArray(
                      arr
                    ) ||
                    _nonIterableSpread()
                  );
                }

                function _nonIterableSpread() {
                  throw new TypeError(
                    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _iterableToArray(iter) {
                  if (
                    typeof Symbol !==
                      "undefined" &&
                    Symbol.iterator in
                      Object(iter)
                  )
                    return Array.from(iter);
                }

                function _arrayWithoutHoles(arr) {
                  if (Array.isArray(arr))
                    return _arrayLikeToArray(arr);
                }

                function _createForOfIteratorHelper(
                  o,
                  allowArrayLike
                ) {
                  var it;
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    o[Symbol.iterator] == null
                  ) {
                    if (
                      Array.isArray(o) ||
                      (it =
                        _unsupportedIterableToArray(
                          o
                        )) ||
                      (allowArrayLike &&
                        o &&
                        typeof o.length ===
                          "number")
                    ) {
                      if (it) o = it;
                      var i = 0;
                      var F = function F() {};
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return { done: true };
                          return {
                            done: false,
                            value: o[i++],
                          };
                        },
                        e: function e(_e2) {
                          throw _e2;
                        },
                        f: F,
                      };
                    }
                    throw new TypeError(
                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  }
                  var normalCompletion = true,
                    didErr = false,
                    err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion =
                        step.done;
                      return step;
                    },
                    e: function e(_e3) {
                      didErr = true;
                      err = _e3;
                    },
                    f: function f() {
                      try {
                        if (
                          !normalCompletion &&
                          it["return"] != null
                        )
                          it["return"]();
                      } finally {
                        if (didErr) throw err;
                      }
                    },
                  };
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                function _slicedToArray(arr, i) {
                  return (
                    _arrayWithHoles(arr) ||
                    _iterableToArrayLimit(
                      arr,
                      i
                    ) ||
                    _unsupportedIterableToArray(
                      arr,
                      i
                    ) ||
                    _nonIterableRest()
                  );
                }

                function _nonIterableRest() {
                  throw new TypeError(
                    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _iterableToArrayLimit(
                  arr,
                  i
                ) {
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    !(
                      Symbol.iterator in
                      Object(arr)
                    )
                  )
                    return;
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (
                      var _i =
                          arr[Symbol.iterator](),
                        _s;
                      !(_n = (_s = _i.next())
                        .done);
                      _n = true
                    ) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (
                        !_n &&
                        _i["return"] != null
                      )
                        _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }

                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                var DEFAULT_RANGE_CHUNK_SIZE = 65536;
                var RENDERING_CANCELLED_TIMEOUT = 100;
                var DefaultCanvasFactory =
                  _is_node.isNodeJS
                    ? _node_utils.NodeCanvasFactory
                    : _display_utils.DOMCanvasFactory;
                exports.DefaultCanvasFactory =
                  DefaultCanvasFactory;
                var DefaultCMapReaderFactory =
                  _is_node.isNodeJS
                    ? _node_utils.NodeCMapReaderFactory
                    : _display_utils.DOMCMapReaderFactory;
                exports.DefaultCMapReaderFactory =
                  DefaultCMapReaderFactory;
                var createPDFNetworkStream;

                function setPDFNetworkStreamFactory(
                  pdfNetworkStreamFactory
                ) {
                  createPDFNetworkStream =
                    pdfNetworkStreamFactory;
                }

                function getDocument(src) {
                  var task =
                    new PDFDocumentLoadingTask();
                  var source;

                  if (typeof src === "string") {
                    source = {
                      url: src,
                    };
                  } else if (
                    (0, _util.isArrayBuffer)(src)
                  ) {
                    source = {
                      data: src,
                    };
                  } else if (
                    src instanceof
                    PDFDataRangeTransport
                  ) {
                    source = {
                      range: src,
                    };
                  } else {
                    if (
                      _typeof(src) !== "object"
                    ) {
                      throw new Error(
                        "Invalid parameter in getDocument, " +
                          "need either Uint8Array, string or a parameter object"
                      );
                    }

                    if (
                      !src.url &&
                      !src.data &&
                      !src.range
                    ) {
                      throw new Error(
                        "Invalid parameter object: need either .data, .range or .url"
                      );
                    }

                    source = src;
                  }

                  var params =
                    Object.create(null);
                  var rangeTransport = null,
                    worker = null;

                  for (var key in source) {
                    if (
                      key === "url" &&
                      typeof window !==
                        "undefined"
                    ) {
                      params[key] = new URL(
                        source[key],
                        window.location
                      ).href;
                      continue;
                    } else if (key === "range") {
                      rangeTransport =
                        source[key];
                      continue;
                    } else if (key === "worker") {
                      worker = source[key];
                      continue;
                    } else if (
                      key === "data" &&
                      !(
                        source[key] instanceof
                        Uint8Array
                      )
                    ) {
                      var pdfBytes = source[key];

                      if (
                        typeof pdfBytes ===
                        "string"
                      ) {
                        params[key] = (0,
                        _util.stringToBytes)(
                          pdfBytes
                        );
                      } else if (
                        _typeof(pdfBytes) ===
                          "object" &&
                        pdfBytes !== null &&
                        !isNaN(pdfBytes.length)
                      ) {
                        params[key] =
                          new Uint8Array(
                            pdfBytes
                          );
                      } else if (
                        (0, _util.isArrayBuffer)(
                          pdfBytes
                        )
                      ) {
                        params[key] =
                          new Uint8Array(
                            pdfBytes
                          );
                      } else {
                        throw new Error(
                          "Invalid PDF binary data: either typed array, " +
                            "string or array-like object is expected in the " +
                            "data property."
                        );
                      }

                      continue;
                    }

                    params[key] = source[key];
                  }

                  params.rangeChunkSize =
                    params.rangeChunkSize ||
                    DEFAULT_RANGE_CHUNK_SIZE;
                  params.CMapReaderFactory =
                    params.CMapReaderFactory ||
                    DefaultCMapReaderFactory;
                  params.ignoreErrors =
                    params.stopAtErrors !== true;
                  params.fontExtraProperties =
                    params.fontExtraProperties ===
                    true;
                  params.pdfBug =
                    params.pdfBug === true;

                  if (
                    !Number.isInteger(
                      params.maxImageSize
                    )
                  ) {
                    params.maxImageSize = -1;
                  }

                  if (
                    typeof params.isEvalSupported !==
                    "boolean"
                  ) {
                    params.isEvalSupported = true;
                  }

                  if (
                    typeof params.disableFontFace !==
                    "boolean"
                  ) {
                    params.disableFontFace =
                      _api_compatibility
                        .apiCompatibilityParams
                        .disableFontFace || false;
                  }

                  if (
                    typeof params.ownerDocument ===
                    "undefined"
                  ) {
                    params.ownerDocument =
                      globalThis.document;
                  }

                  if (
                    typeof params.disableRange !==
                    "boolean"
                  ) {
                    params.disableRange = false;
                  }

                  if (
                    typeof params.disableStream !==
                    "boolean"
                  ) {
                    params.disableStream = false;
                  }

                  if (
                    typeof params.disableAutoFetch !==
                    "boolean"
                  ) {
                    params.disableAutoFetch = false;
                  }

                  (0, _util.setVerbosityLevel)(
                    params.verbosity
                  );

                  if (!worker) {
                    var workerParams = {
                      verbosity: params.verbosity,
                      port: _worker_options
                        .GlobalWorkerOptions
                        .workerPort,
                    };
                    worker = workerParams.port
                      ? PDFWorker.fromPort(
                          workerParams
                        )
                      : new PDFWorker(
                          workerParams
                        );
                    task._worker = worker;
                  }

                  var docId = task.docId;
                  worker.promise
                    .then(function () {
                      if (task.destroyed) {
                        throw new Error(
                          "Loading aborted"
                        );
                      }

                      var workerIdPromise =
                        _fetchDocument(
                          worker,
                          params,
                          rangeTransport,
                          docId
                        );

                      var networkStreamPromise =
                        new Promise(function (
                          resolve
                        ) {
                          var networkStream;

                          if (rangeTransport) {
                            networkStream =
                              new _transport_stream.PDFDataTransportStream(
                                {
                                  length:
                                    params.length,
                                  initialData:
                                    params.initialData,
                                  progressiveDone:
                                    params.progressiveDone,
                                  disableRange:
                                    params.disableRange,
                                  disableStream:
                                    params.disableStream,
                                },
                                rangeTransport
                              );
                          } else if (
                            !params.data
                          ) {
                            networkStream =
                              createPDFNetworkStream(
                                {
                                  url: params.url,
                                  length:
                                    params.length,
                                  httpHeaders:
                                    params.httpHeaders,
                                  withCredentials:
                                    params.withCredentials,
                                  rangeChunkSize:
                                    params.rangeChunkSize,
                                  disableRange:
                                    params.disableRange,
                                  disableStream:
                                    params.disableStream,
                                }
                              );
                          }

                          resolve(networkStream);
                        });
                      return Promise.all([
                        workerIdPromise,
                        networkStreamPromise,
                      ]).then(function (_ref) {
                        var _ref2 =
                            _slicedToArray(
                              _ref,
                              2
                            ),
                          workerId = _ref2[0],
                          networkStream =
                            _ref2[1];

                        if (task.destroyed) {
                          throw new Error(
                            "Loading aborted"
                          );
                        }

                        var messageHandler =
                          new _message_handler.MessageHandler(
                            docId,
                            workerId,
                            worker.port
                          );
                        messageHandler.postMessageTransfers =
                          worker.postMessageTransfers;
                        var transport =
                          new WorkerTransport(
                            messageHandler,
                            task,
                            networkStream,
                            params
                          );
                        task._transport =
                          transport;
                        messageHandler.send(
                          "Ready",
                          null
                        );
                      });
                    })
                    ["catch"](
                      task._capability.reject
                    );
                  return task;
                }

                function _fetchDocument(
                  worker,
                  source,
                  pdfDataRangeTransport,
                  docId
                ) {
                  if (worker.destroyed) {
                    return Promise.reject(
                      new Error(
                        "Worker was destroyed"
                      )
                    );
                  }

                  if (pdfDataRangeTransport) {
                    source.length =
                      pdfDataRangeTransport.length;
                    source.initialData =
                      pdfDataRangeTransport.initialData;
                    source.progressiveDone =
                      pdfDataRangeTransport.progressiveDone;
                  }

                  return worker.messageHandler
                    .sendWithPromise(
                      "GetDocRequest",
                      {
                        docId: docId,
                        apiVersion: "2.8.164",
                        source: {
                          data: source.data,
                          url: source.url,
                          password:
                            source.password,
                          disableAutoFetch:
                            source.disableAutoFetch,
                          rangeChunkSize:
                            source.rangeChunkSize,
                          length: source.length,
                        },
                        maxImageSize:
                          source.maxImageSize,
                        disableFontFace:
                          source.disableFontFace,
                        postMessageTransfers:
                          worker.postMessageTransfers,
                        docBaseUrl:
                          source.docBaseUrl,
                        ignoreErrors:
                          source.ignoreErrors,
                        isEvalSupported:
                          source.isEvalSupported,
                        fontExtraProperties:
                          source.fontExtraProperties,
                      }
                    )
                    .then(function (workerId) {
                      if (worker.destroyed) {
                        throw new Error(
                          "Worker was destroyed"
                        );
                      }

                      return workerId;
                    });
                }

                var PDFDocumentLoadingTask =
                  (function PDFDocumentLoadingTaskClosure() {
                    var nextDocumentId = 0;

                    var PDFDocumentLoadingTask =
                      /*#__PURE__*/ (function () {
                        function PDFDocumentLoadingTask() {
                          _classCallCheck(
                            this,
                            PDFDocumentLoadingTask
                          );

                          this._capability = (0,
                          _util.createPromiseCapability)();
                          this._transport = null;
                          this._worker = null;
                          this.docId =
                            "d" +
                            nextDocumentId++;
                          this.destroyed = false;
                          this.onPassword = null;
                          this.onProgress = null;
                          this.onUnsupportedFeature =
                            null;
                        }

                        _createClass(
                          PDFDocumentLoadingTask,
                          [
                            {
                              key: "promise",
                              get: function get() {
                                return this
                                  ._capability
                                  .promise;
                              },
                            },
                            {
                              key: "destroy",
                              value:
                                function destroy() {
                                  var _this =
                                    this;

                                  this.destroyed = true;
                                  var transportDestroyed =
                                    !this
                                      ._transport
                                      ? Promise.resolve()
                                      : this._transport.destroy();
                                  return transportDestroyed.then(
                                    function () {
                                      _this._transport =
                                        null;

                                      if (
                                        _this._worker
                                      ) {
                                        _this._worker.destroy();

                                        _this._worker =
                                          null;
                                      }
                                    }
                                  );
                                },
                            },
                          ]
                        );

                        return PDFDocumentLoadingTask;
                      })();

                    return PDFDocumentLoadingTask;
                  })();

                var PDFDataRangeTransport =
                  /*#__PURE__*/ (function () {
                    function PDFDataRangeTransport(
                      length,
                      initialData
                    ) {
                      var progressiveDone =
                        arguments.length > 2 &&
                        arguments[2] !== undefined
                          ? arguments[2]
                          : false;

                      _classCallCheck(
                        this,
                        PDFDataRangeTransport
                      );

                      this.length = length;
                      this.initialData =
                        initialData;
                      this.progressiveDone =
                        progressiveDone;
                      this._rangeListeners = [];
                      this._progressListeners =
                        [];
                      this._progressiveReadListeners =
                        [];
                      this._progressiveDoneListeners =
                        [];
                      this._readyCapability = (0,
                      _util.createPromiseCapability)();
                    }

                    _createClass(
                      PDFDataRangeTransport,
                      [
                        {
                          key: "addRangeListener",
                          value:
                            function addRangeListener(
                              listener
                            ) {
                              this._rangeListeners.push(
                                listener
                              );
                            },
                        },
                        {
                          key: "addProgressListener",
                          value:
                            function addProgressListener(
                              listener
                            ) {
                              this._progressListeners.push(
                                listener
                              );
                            },
                        },
                        {
                          key: "addProgressiveReadListener",
                          value:
                            function addProgressiveReadListener(
                              listener
                            ) {
                              this._progressiveReadListeners.push(
                                listener
                              );
                            },
                        },
                        {
                          key: "addProgressiveDoneListener",
                          value:
                            function addProgressiveDoneListener(
                              listener
                            ) {
                              this._progressiveDoneListeners.push(
                                listener
                              );
                            },
                        },
                        {
                          key: "onDataRange",
                          value:
                            function onDataRange(
                              begin,
                              chunk
                            ) {
                              var _iterator =
                                  _createForOfIteratorHelper(
                                    this
                                      ._rangeListeners
                                  ),
                                _step;

                              try {
                                for (
                                  _iterator.s();
                                  !(_step =
                                    _iterator.n())
                                    .done;

                                ) {
                                  var listener =
                                    _step.value;
                                  listener(
                                    begin,
                                    chunk
                                  );
                                }
                              } catch (err) {
                                _iterator.e(err);
                              } finally {
                                _iterator.f();
                              }
                            },
                        },
                        {
                          key: "onDataProgress",
                          value:
                            function onDataProgress(
                              loaded,
                              total
                            ) {
                              var _this2 = this;

                              this._readyCapability.promise.then(
                                function () {
                                  var _iterator2 =
                                      _createForOfIteratorHelper(
                                        _this2._progressListeners
                                      ),
                                    _step2;

                                  try {
                                    for (
                                      _iterator2.s();
                                      !(_step2 =
                                        _iterator2.n())
                                        .done;

                                    ) {
                                      var listener =
                                        _step2.value;
                                      listener(
                                        loaded,
                                        total
                                      );
                                    }
                                  } catch (err) {
                                    _iterator2.e(
                                      err
                                    );
                                  } finally {
                                    _iterator2.f();
                                  }
                                }
                              );
                            },
                        },
                        {
                          key: "onDataProgressiveRead",
                          value:
                            function onDataProgressiveRead(
                              chunk
                            ) {
                              var _this3 = this;

                              this._readyCapability.promise.then(
                                function () {
                                  var _iterator3 =
                                      _createForOfIteratorHelper(
                                        _this3._progressiveReadListeners
                                      ),
                                    _step3;

                                  try {
                                    for (
                                      _iterator3.s();
                                      !(_step3 =
                                        _iterator3.n())
                                        .done;

                                    ) {
                                      var listener =
                                        _step3.value;
                                      listener(
                                        chunk
                                      );
                                    }
                                  } catch (err) {
                                    _iterator3.e(
                                      err
                                    );
                                  } finally {
                                    _iterator3.f();
                                  }
                                }
                              );
                            },
                        },
                        {
                          key: "onDataProgressiveDone",
                          value:
                            function onDataProgressiveDone() {
                              var _this4 = this;

                              this._readyCapability.promise.then(
                                function () {
                                  var _iterator4 =
                                      _createForOfIteratorHelper(
                                        _this4._progressiveDoneListeners
                                      ),
                                    _step4;

                                  try {
                                    for (
                                      _iterator4.s();
                                      !(_step4 =
                                        _iterator4.n())
                                        .done;

                                    ) {
                                      var listener =
                                        _step4.value;
                                      listener();
                                    }
                                  } catch (err) {
                                    _iterator4.e(
                                      err
                                    );
                                  } finally {
                                    _iterator4.f();
                                  }
                                }
                              );
                            },
                        },
                        {
                          key: "transportReady",
                          value:
                            function transportReady() {
                              this._readyCapability.resolve();
                            },
                        },
                        {
                          key: "requestDataRange",
                          value:
                            function requestDataRange(
                              begin,
                              end
                            ) {
                              (0,
                              _util.unreachable)(
                                "Abstract method PDFDataRangeTransport.requestDataRange"
                              );
                            },
                        },
                        {
                          key: "abort",
                          value:
                            function abort() {},
                        },
                      ]
                    );

                    return PDFDataRangeTransport;
                  })();

                exports.PDFDataRangeTransport =
                  PDFDataRangeTransport;

                var PDFDocumentProxy =
                  /*#__PURE__*/ (function () {
                    function PDFDocumentProxy(
                      pdfInfo,
                      transport
                    ) {
                      _classCallCheck(
                        this,
                        PDFDocumentProxy
                      );

                      this._pdfInfo = pdfInfo;
                      this._transport = transport;
                    }

                    _createClass(
                      PDFDocumentProxy,
                      [
                        {
                          key: "annotationStorage",
                          get: function get() {
                            return (0,
                            _util.shadow)(
                              this,
                              "annotationStorage",
                              new _annotation_storage.AnnotationStorage()
                            );
                          },
                        },
                        {
                          key: "numPages",
                          get: function get() {
                            return this._pdfInfo
                              .numPages;
                          },
                        },
                        {
                          key: "fingerprint",
                          get: function get() {
                            return this._pdfInfo
                              .fingerprint;
                          },
                        },
                        {
                          key: "getPage",
                          value: function getPage(
                            pageNumber
                          ) {
                            return this._transport.getPage(
                              pageNumber
                            );
                          },
                        },
                        {
                          key: "getPageIndex",
                          value:
                            function getPageIndex(
                              ref
                            ) {
                              return this._transport.getPageIndex(
                                ref
                              );
                            },
                        },
                        {
                          key: "getPageOCGNames",
                          value:
                            function getPageOCGNames(
                              ref
                            ) {
                              return this._transport.getPageOCGNames(
                                ref
                              );
                            },
                        },
                        {
                          key: "getObject",
                          value:
                            function getObject(
                              ref
                            ) {
                              return this._transport.getObject(
                                ref
                              );
                            },
                        },
                        {
                          key: "getDestinations",
                          value:
                            function getDestinations() {
                              return this._transport.getDestinations();
                            },
                        },
                        {
                          key: "getDestination",
                          value:
                            function getDestination(
                              id
                            ) {
                              return this._transport.getDestination(
                                id
                              );
                            },
                        },
                        {
                          key: "getPageLabels",
                          value:
                            function getPageLabels() {
                              return this._transport.getPageLabels();
                            },
                        },
                        {
                          key: "getPageLayout",
                          value:
                            function getPageLayout() {
                              return this._transport.getPageLayout();
                            },
                        },
                        {
                          key: "getPageMode",
                          value:
                            function getPageMode() {
                              return this._transport.getPageMode();
                            },
                        },
                        {
                          key: "getViewerPreferences",
                          value:
                            function getViewerPreferences() {
                              return this._transport.getViewerPreferences();
                            },
                        },
                        {
                          key: "getOpenAction",
                          value:
                            function getOpenAction() {
                              return this._transport.getOpenAction();
                            },
                        },
                        {
                          key: "getAttachments",
                          value:
                            function getAttachments() {
                              return this._transport.getAttachments();
                            },
                        },
                        {
                          key: "getJavaScript",
                          value:
                            function getJavaScript() {
                              return this._transport.getJavaScript();
                            },
                        },
                        {
                          key: "getJSActions",
                          value:
                            function getJSActions() {
                              return this._transport.getDocJSActions();
                            },
                        },
                        {
                          key: "getOutline",
                          value:
                            function getOutline() {
                              return this._transport.getOutline();
                            },
                        },
                        {
                          key: "getOptionalContentConfig",
                          value:
                            function getOptionalContentConfig() {
                              return this._transport.getOptionalContentConfig();
                            },
                        },
                        {
                          key: "getPermissions",
                          value:
                            function getPermissions() {
                              return this._transport.getPermissions();
                            },
                        },
                        {
                          key: "getMetadata",
                          value:
                            function getMetadata() {
                              return this._transport.getMetadata();
                            },
                        },
                        {
                          key: "getMarkInfo",
                          value:
                            function getMarkInfo() {
                              return this._transport.getMarkInfo();
                            },
                        },
                        {
                          key: "getData",
                          value:
                            function getData() {
                              return this._transport.getData();
                            },
                        },
                        {
                          key: "getDownloadInfo",
                          value:
                            function getDownloadInfo() {
                              return this
                                ._transport
                                .downloadInfoCapability
                                .promise;
                            },
                        },
                        {
                          key: "getStats",
                          value:
                            function getStats() {
                              return this._transport.getStats();
                            },
                        },
                        {
                          key: "cleanup",
                          value:
                            function cleanup() {
                              return this._transport.startCleanup();
                            },
                        },
                        {
                          key: "destroy",
                          value:
                            function destroy() {
                              return this.loadingTask.destroy();
                            },
                        },
                        {
                          key: "loadingParams",
                          get: function get() {
                            return this._transport
                              .loadingParams;
                          },
                        },
                        {
                          key: "loadingTask",
                          get: function get() {
                            return this._transport
                              .loadingTask;
                          },
                        },
                        {
                          key: "saveDocument",
                          value:
                            function saveDocument(
                              annotationStorage
                            ) {
                              return this._transport.saveDocument(
                                annotationStorage
                              );
                            },
                        },
                        {
                          key: "getFieldObjects",
                          value:
                            function getFieldObjects() {
                              return this._transport.getFieldObjects();
                            },
                        },
                        {
                          key: "hasJSActions",
                          value:
                            function hasJSActions() {
                              return this._transport.hasJSActions();
                            },
                        },
                        {
                          key: "getCalculationOrderIds",
                          value:
                            function getCalculationOrderIds() {
                              return this._transport.getCalculationOrderIds();
                            },
                        },
                      ]
                    );

                    return PDFDocumentProxy;
                  })();

                exports.PDFDocumentProxy =
                  PDFDocumentProxy;

                var PDFPageProxy =
                  /*#__PURE__*/ (function () {
                    function PDFPageProxy(
                      pageIndex,
                      pageInfo,
                      transport,
                      ownerDocument
                    ) {
                      var pdfBug =
                        arguments.length > 4 &&
                        arguments[4] !== undefined
                          ? arguments[4]
                          : false;

                      _classCallCheck(
                        this,
                        PDFPageProxy
                      );

                      this._pageIndex = pageIndex;
                      this._pageInfo = pageInfo;
                      this._ownerDocument =
                        ownerDocument;
                      this._transport = transport;
                      this._stats = pdfBug
                        ? new _display_utils.StatTimer()
                        : null;
                      this._pdfBug = pdfBug;
                      this.commonObjs =
                        transport.commonObjs;
                      this.objs =
                        new PDFObjects();
                      this.cleanupAfterRender = false;
                      this.pendingCleanup = false;
                      this._intentStates =
                        new Map();
                      this.destroyed = false;
                    }

                    _createClass(PDFPageProxy, [
                      {
                        key: "pageNumber",
                        get: function get() {
                          return (
                            this._pageIndex + 1
                          );
                        },
                      },
                      {
                        key: "rotate",
                        get: function get() {
                          return this._pageInfo
                            .rotate;
                        },
                      },
                      {
                        key: "ref",
                        get: function get() {
                          return this._pageInfo
                            .ref;
                        },
                      },
                      {
                        key: "userUnit",
                        get: function get() {
                          return this._pageInfo
                            .userUnit;
                        },
                      },
                      {
                        key: "view",
                        get: function get() {
                          return this._pageInfo
                            .view;
                        },
                      },
                      {
                        key: "getViewport",
                        value:
                          function getViewport() {
                            var _ref3 =
                                arguments.length >
                                  0 &&
                                arguments[0] !==
                                  undefined
                                  ? arguments[0]
                                  : {},
                              scale = _ref3.scale,
                              _ref3$rotation =
                                _ref3.rotation,
                              rotation =
                                _ref3$rotation ===
                                void 0
                                  ? this.rotate
                                  : _ref3$rotation,
                              _ref3$offsetX =
                                _ref3.offsetX,
                              offsetX =
                                _ref3$offsetX ===
                                void 0
                                  ? 0
                                  : _ref3$offsetX,
                              _ref3$offsetY =
                                _ref3.offsetY,
                              offsetY =
                                _ref3$offsetY ===
                                void 0
                                  ? 0
                                  : _ref3$offsetY,
                              _ref3$dontFlip =
                                _ref3.dontFlip,
                              dontFlip =
                                _ref3$dontFlip ===
                                void 0
                                  ? false
                                  : _ref3$dontFlip;

                            return new _display_utils.PageViewport(
                              {
                                viewBox:
                                  this.view,
                                scale: scale,
                                rotation:
                                  rotation,
                                offsetX: offsetX,
                                offsetY: offsetY,
                                dontFlip:
                                  dontFlip,
                              }
                            );
                          },
                      },
                      {
                        key: "getAnnotations",
                        value:
                          function getAnnotations() {
                            var _ref4 =
                                arguments.length >
                                  0 &&
                                arguments[0] !==
                                  undefined
                                  ? arguments[0]
                                  : {},
                              _ref4$intent =
                                _ref4.intent,
                              intent =
                                _ref4$intent ===
                                void 0
                                  ? null
                                  : _ref4$intent;

                            if (
                              !this
                                .annotationsPromise ||
                              this
                                .annotationsIntent !==
                                intent
                            ) {
                              this.annotationsPromise =
                                this._transport.getAnnotations(
                                  this._pageIndex,
                                  intent
                                );
                              this.annotationsIntent =
                                intent;
                            }

                            return this
                              .annotationsPromise;
                          },
                      },
                      {
                        key: "getJSActions",
                        value:
                          function getJSActions() {
                            return (
                              this
                                ._jsActionsPromise ||
                              (this._jsActionsPromise =
                                this._transport.getPageJSActions(
                                  this._pageIndex
                                ))
                            );
                          },
                      },
                      {
                        key: "render",
                        value: function render(
                          _ref5
                        ) {
                          var _this5 = this;

                          var canvasContext =
                              _ref5.canvasContext,
                            viewport =
                              _ref5.viewport,
                            _ref5$intent =
                              _ref5.intent,
                            intent =
                              _ref5$intent ===
                              void 0
                                ? "display"
                                : _ref5$intent,
                            _ref5$enableWebGL =
                              _ref5.enableWebGL,
                            enableWebGL =
                              _ref5$enableWebGL ===
                              void 0
                                ? false
                                : _ref5$enableWebGL,
                            _ref5$renderInteracti =
                              _ref5.renderInteractiveForms,
                            renderInteractiveForms =
                              _ref5$renderInteracti ===
                              void 0
                                ? false
                                : _ref5$renderInteracti,
                            _ref5$transform =
                              _ref5.transform,
                            transform =
                              _ref5$transform ===
                              void 0
                                ? null
                                : _ref5$transform,
                            _ref5$imageLayer =
                              _ref5.imageLayer,
                            imageLayer =
                              _ref5$imageLayer ===
                              void 0
                                ? null
                                : _ref5$imageLayer,
                            _ref5$canvasFactory =
                              _ref5.canvasFactory,
                            canvasFactory =
                              _ref5$canvasFactory ===
                              void 0
                                ? null
                                : _ref5$canvasFactory,
                            _ref5$background =
                              _ref5.background,
                            background =
                              _ref5$background ===
                              void 0
                                ? null
                                : _ref5$background,
                            _ref5$annotationStora =
                              _ref5.annotationStorage,
                            annotationStorage =
                              _ref5$annotationStora ===
                              void 0
                                ? null
                                : _ref5$annotationStora,
                            _ref5$optionalContent =
                              _ref5.optionalContentConfigPromise,
                            optionalContentConfigPromise =
                              _ref5$optionalContent ===
                              void 0
                                ? null
                                : _ref5$optionalContent;

                          if (this._stats) {
                            this._stats.time(
                              "Overall"
                            );
                          }

                          var renderingIntent =
                            intent === "print"
                              ? "print"
                              : "display";
                          this.pendingCleanup = false;

                          if (
                            !optionalContentConfigPromise
                          ) {
                            optionalContentConfigPromise =
                              this._transport.getOptionalContentConfig();
                          }

                          var intentState =
                            this._intentStates.get(
                              renderingIntent
                            );

                          if (!intentState) {
                            intentState =
                              Object.create(null);

                            this._intentStates.set(
                              renderingIntent,
                              intentState
                            );
                          }

                          if (
                            intentState.streamReaderCancelTimeout
                          ) {
                            clearTimeout(
                              intentState.streamReaderCancelTimeout
                            );
                            intentState.streamReaderCancelTimeout =
                              null;
                          }

                          var canvasFactoryInstance =
                            canvasFactory ||
                            new DefaultCanvasFactory(
                              {
                                ownerDocument:
                                  this
                                    ._ownerDocument,
                              }
                            );
                          var webGLContext =
                            new _webgl.WebGLContext(
                              {
                                enable:
                                  enableWebGL,
                              }
                            );

                          if (
                            !intentState.displayReadyCapability
                          ) {
                            intentState.displayReadyCapability =
                              (0,
                              _util.createPromiseCapability)();
                            intentState.operatorList =
                              {
                                fnArray: [],
                                argsArray: [],
                                lastChunk: false,
                              };

                            if (this._stats) {
                              this._stats.time(
                                "Page Request"
                              );
                            }

                            this._pumpOperatorList(
                              {
                                pageIndex:
                                  this._pageIndex,
                                intent:
                                  renderingIntent,
                                renderInteractiveForms:
                                  renderInteractiveForms ===
                                  true,
                                annotationStorage:
                                  (annotationStorage ===
                                    null ||
                                  annotationStorage ===
                                    void 0
                                    ? void 0
                                    : annotationStorage.getAll()) ||
                                  null,
                              }
                            );
                          }

                          var complete =
                            function complete(
                              error
                            ) {
                              var i =
                                intentState.renderTasks.indexOf(
                                  internalRenderTask
                                );

                              if (i >= 0) {
                                intentState.renderTasks.splice(
                                  i,
                                  1
                                );
                              }

                              if (
                                _this5.cleanupAfterRender ||
                                renderingIntent ===
                                  "print"
                              ) {
                                _this5.pendingCleanup = true;
                              }

                              _this5._tryCleanup();

                              if (error) {
                                internalRenderTask.capability.reject(
                                  error
                                );

                                _this5._abortOperatorList(
                                  {
                                    intentState:
                                      intentState,
                                    reason: error,
                                  }
                                );
                              } else {
                                internalRenderTask.capability.resolve();
                              }

                              if (_this5._stats) {
                                _this5._stats.timeEnd(
                                  "Rendering"
                                );

                                _this5._stats.timeEnd(
                                  "Overall"
                                );
                              }
                            };

                          var internalRenderTask =
                            new InternalRenderTask(
                              {
                                callback:
                                  complete,
                                params: {
                                  canvasContext:
                                    canvasContext,
                                  viewport:
                                    viewport,
                                  transform:
                                    transform,
                                  imageLayer:
                                    imageLayer,
                                  background:
                                    background,
                                },
                                objs: this.objs,
                                commonObjs:
                                  this.commonObjs,
                                operatorList:
                                  intentState.operatorList,
                                pageIndex:
                                  this._pageIndex,
                                canvasFactory:
                                  canvasFactoryInstance,
                                webGLContext:
                                  webGLContext,
                                useRequestAnimationFrame:
                                  renderingIntent !==
                                  "print",
                                pdfBug:
                                  this._pdfBug,
                              }
                            );

                          if (
                            !intentState.renderTasks
                          ) {
                            intentState.renderTasks =
                              [];
                          }

                          intentState.renderTasks.push(
                            internalRenderTask
                          );
                          var renderTask =
                            internalRenderTask.task;
                          Promise.all([
                            intentState
                              .displayReadyCapability
                              .promise,
                            optionalContentConfigPromise,
                          ])
                            .then(function (
                              _ref6
                            ) {
                              var _ref7 =
                                  _slicedToArray(
                                    _ref6,
                                    2
                                  ),
                                transparency =
                                  _ref7[0],
                                optionalContentConfig =
                                  _ref7[1];

                              if (
                                _this5.pendingCleanup
                              ) {
                                complete();
                                return;
                              }

                              if (_this5._stats) {
                                _this5._stats.time(
                                  "Rendering"
                                );
                              }

                              internalRenderTask.initializeGraphics(
                                {
                                  transparency:
                                    transparency,
                                  optionalContentConfig:
                                    optionalContentConfig,
                                }
                              );
                              internalRenderTask.operatorListChanged();
                            })
                            ["catch"](complete);
                          return renderTask;
                        },
                      },
                      {
                        key: "getOperatorList",
                        value:
                          function getOperatorList(
                            intent
                          ) {
                            function operatorListChanged() {
                              if (
                                intentState
                                  .operatorList
                                  .lastChunk
                              ) {
                                intentState.opListReadCapability.resolve(
                                  intentState.operatorList
                                );
                                var i =
                                  intentState.renderTasks.indexOf(
                                    opListTask
                                  );

                                if (i >= 0) {
                                  intentState.renderTasks.splice(
                                    i,
                                    1
                                  );
                                }
                              }
                            }

                            var renderingIntent =
                              intent || "oplist";

                            var intentState =
                              this._intentStates.get(
                                renderingIntent
                              );

                            if (!intentState) {
                              intentState =
                                Object.create(
                                  null
                                );

                              this._intentStates.set(
                                renderingIntent,
                                intentState
                              );
                            }

                            var opListTask;

                            if (
                              !intentState.displayReadyCapability
                            ) {
                              intentState.displayReadyCapability =
                                (0,
                                _util.createPromiseCapability)();
                              intentState.operatorList =
                                {
                                  fnArray: [],
                                  argsArray: [],
                                  lastChunk: false,
                                };

                              if (this._stats) {
                                this._stats.time(
                                  "Page Request"
                                );
                              }

                              this._pumpOperatorList(
                                {
                                  pageIndex:
                                    this
                                      ._pageIndex,
                                  intent:
                                    renderingIntent,
                                }
                              );
                            }

                            if (
                              !intentState.opListReadCapability
                            ) {
                              intentState.opListReadCapability =
                                (0,
                                _util.createPromiseCapability)();

                              if (
                                !intentState.renderTasks
                              ) {
                                intentState.renderTasks =
                                  [];
                              }

                              opListTask =
                                Object.create(
                                  null
                                );
                              opListTask.operatorListChanged =
                                operatorListChanged;
                              intentState.renderTasks.push(
                                opListTask
                              );
                              operatorListChanged();
                            }

                            return intentState
                              .opListReadCapability
                              .promise;
                          },
                      },
                      {
                        key: "streamTextContent",
                        value:
                          function streamTextContent() {
                            var _ref8 =
                                arguments.length >
                                  0 &&
                                arguments[0] !==
                                  undefined
                                  ? arguments[0]
                                  : {},
                              _ref8$normalizeWhites =
                                _ref8.normalizeWhitespace,
                              normalizeWhitespace =
                                _ref8$normalizeWhites ===
                                void 0
                                  ? false
                                  : _ref8$normalizeWhites,
                              _ref8$disableCombineT =
                                _ref8.disableCombineTextItems,
                              disableCombineTextItems =
                                _ref8$disableCombineT ===
                                void 0
                                  ? false
                                  : _ref8$disableCombineT;

                            var TEXT_CONTENT_CHUNK_SIZE = 100;
                            return this._transport.messageHandler.sendWithStream(
                              "GetTextContent",
                              {
                                pageIndex:
                                  this._pageIndex,
                                normalizeWhitespace:
                                  normalizeWhitespace ===
                                  true,
                                combineTextItems:
                                  disableCombineTextItems !==
                                  true,
                              },
                              {
                                highWaterMark:
                                  TEXT_CONTENT_CHUNK_SIZE,
                                size: function size(
                                  textContent
                                ) {
                                  return textContent
                                    .items.length;
                                },
                              }
                            );
                          },
                      },
                      {
                        key: "getTextContent",
                        value:
                          function getTextContent() {
                            var params =
                              arguments.length >
                                0 &&
                              arguments[0] !==
                                undefined
                                ? arguments[0]
                                : {};
                            var readableStream =
                              this.streamTextContent(
                                params
                              );
                            return new Promise(
                              function (
                                resolve,
                                reject
                              ) {
                                function pump() {
                                  reader
                                    .read()
                                    .then(
                                      function (
                                        _ref9
                                      ) {
                                        var _textContent$items;

                                        var value =
                                            _ref9.value,
                                          done =
                                            _ref9.done;

                                        if (
                                          done
                                        ) {
                                          resolve(
                                            textContent
                                          );
                                          return;
                                        }

                                        Object.assign(
                                          textContent.styles,
                                          value.styles
                                        );

                                        (_textContent$items =
                                          textContent.items).push.apply(
                                          _textContent$items,
                                          _toConsumableArray(
                                            value.items
                                          )
                                        );

                                        pump();
                                      },
                                      reject
                                    );
                                }

                                var reader =
                                  readableStream.getReader();
                                var textContent =
                                  {
                                    items: [],
                                    styles:
                                      Object.create(
                                        null
                                      ),
                                  };
                                pump();
                              }
                            );
                          },
                      },
                      {
                        key: "_destroy",
                        value:
                          function _destroy() {
                            this.destroyed = true;
                            this._transport.pageCache[
                              this._pageIndex
                            ] = null;
                            var waitOn = [];

                            var _iterator5 =
                                _createForOfIteratorHelper(
                                  this
                                    ._intentStates
                                ),
                              _step5;

                            try {
                              for (
                                _iterator5.s();
                                !(_step5 =
                                  _iterator5.n())
                                  .done;

                              ) {
                                var _step5$value =
                                    _slicedToArray(
                                      _step5.value,
                                      2
                                    ),
                                  intent =
                                    _step5$value[0],
                                  intentState =
                                    _step5$value[1];

                                this._abortOperatorList(
                                  {
                                    intentState:
                                      intentState,
                                    reason:
                                      new Error(
                                        "Page was destroyed."
                                      ),
                                    force: true,
                                  }
                                );

                                if (
                                  intent ===
                                  "oplist"
                                ) {
                                  continue;
                                }

                                var _iterator6 =
                                    _createForOfIteratorHelper(
                                      intentState.renderTasks
                                    ),
                                  _step6;

                                try {
                                  for (
                                    _iterator6.s();
                                    !(_step6 =
                                      _iterator6.n())
                                      .done;

                                  ) {
                                    var internalRenderTask =
                                      _step6.value;
                                    waitOn.push(
                                      internalRenderTask.completed
                                    );
                                    internalRenderTask.cancel();
                                  }
                                } catch (err) {
                                  _iterator6.e(
                                    err
                                  );
                                } finally {
                                  _iterator6.f();
                                }
                              }
                            } catch (err) {
                              _iterator5.e(err);
                            } finally {
                              _iterator5.f();
                            }

                            this.objs.clear();
                            this.annotationsPromise =
                              null;
                            this._jsActionsPromise =
                              null;
                            this.pendingCleanup = false;
                            return Promise.all(
                              waitOn
                            );
                          },
                      },
                      {
                        key: "cleanup",
                        value:
                          function cleanup() {
                            var resetStats =
                              arguments.length >
                                0 &&
                              arguments[0] !==
                                undefined
                                ? arguments[0]
                                : false;
                            this.pendingCleanup = true;
                            return this._tryCleanup(
                              resetStats
                            );
                          },
                      },
                      {
                        key: "_tryCleanup",
                        value:
                          function _tryCleanup() {
                            var resetStats =
                              arguments.length >
                                0 &&
                              arguments[0] !==
                                undefined
                                ? arguments[0]
                                : false;

                            if (
                              !this.pendingCleanup
                            ) {
                              return false;
                            }

                            var _iterator7 =
                                _createForOfIteratorHelper(
                                  this._intentStates.values()
                                ),
                              _step7;

                            try {
                              for (
                                _iterator7.s();
                                !(_step7 =
                                  _iterator7.n())
                                  .done;

                              ) {
                                var _step7$value =
                                    _step7.value,
                                  renderTasks =
                                    _step7$value.renderTasks,
                                  operatorList =
                                    _step7$value.operatorList;

                                if (
                                  renderTasks.length !==
                                    0 ||
                                  !operatorList.lastChunk
                                ) {
                                  return false;
                                }
                              }
                            } catch (err) {
                              _iterator7.e(err);
                            } finally {
                              _iterator7.f();
                            }

                            this._intentStates.clear();

                            this.objs.clear();
                            this.annotationsPromise =
                              null;
                            this._jsActionsPromise =
                              null;

                            if (
                              resetStats &&
                              this._stats
                            ) {
                              this._stats =
                                new _display_utils.StatTimer();
                            }

                            this.pendingCleanup = false;
                            return true;
                          },
                      },
                      {
                        key: "_startRenderPage",
                        value:
                          function _startRenderPage(
                            transparency,
                            intent
                          ) {
                            var intentState =
                              this._intentStates.get(
                                intent
                              );

                            if (!intentState) {
                              return;
                            }

                            if (this._stats) {
                              this._stats.timeEnd(
                                "Page Request"
                              );
                            }

                            if (
                              intentState.displayReadyCapability
                            ) {
                              intentState.displayReadyCapability.resolve(
                                transparency
                              );
                            }
                          },
                      },
                      {
                        key: "_renderPageChunk",
                        value:
                          function _renderPageChunk(
                            operatorListChunk,
                            intentState
                          ) {
                            for (
                              var i = 0,
                                ii =
                                  operatorListChunk.length;
                              i < ii;
                              i++
                            ) {
                              intentState.operatorList.fnArray.push(
                                operatorListChunk
                                  .fnArray[i]
                              );
                              intentState.operatorList.argsArray.push(
                                operatorListChunk
                                  .argsArray[i]
                              );
                            }

                            intentState.operatorList.lastChunk =
                              operatorListChunk.lastChunk;

                            for (
                              var _i2 = 0;
                              _i2 <
                              intentState
                                .renderTasks
                                .length;
                              _i2++
                            ) {
                              intentState.renderTasks[
                                _i2
                              ].operatorListChanged();
                            }

                            if (
                              operatorListChunk.lastChunk
                            ) {
                              this._tryCleanup();
                            }
                          },
                      },
                      {
                        key: "_pumpOperatorList",
                        value:
                          function _pumpOperatorList(
                            args
                          ) {
                            var _this6 = this;

                            (0, _util.assert)(
                              args.intent,
                              'PDFPageProxy._pumpOperatorList: Expected "intent" argument.'
                            );

                            var readableStream =
                              this._transport.messageHandler.sendWithStream(
                                "GetOperatorList",
                                args
                              );

                            var reader =
                              readableStream.getReader();

                            var intentState =
                              this._intentStates.get(
                                args.intent
                              );

                            intentState.streamReader =
                              reader;

                            var pump =
                              function pump() {
                                reader
                                  .read()
                                  .then(
                                    function (
                                      _ref10
                                    ) {
                                      var value =
                                          _ref10.value,
                                        done =
                                          _ref10.done;

                                      if (done) {
                                        intentState.streamReader =
                                          null;
                                        return;
                                      }

                                      if (
                                        _this6
                                          ._transport
                                          .destroyed
                                      ) {
                                        return;
                                      }

                                      _this6._renderPageChunk(
                                        value,
                                        intentState
                                      );

                                      pump();
                                    },
                                    function (
                                      reason
                                    ) {
                                      intentState.streamReader =
                                        null;

                                      if (
                                        _this6
                                          ._transport
                                          .destroyed
                                      ) {
                                        return;
                                      }

                                      if (
                                        intentState.operatorList
                                      ) {
                                        intentState.operatorList.lastChunk = true;

                                        for (
                                          var i = 0;
                                          i <
                                          intentState
                                            .renderTasks
                                            .length;
                                          i++
                                        ) {
                                          intentState.renderTasks[
                                            i
                                          ].operatorListChanged();
                                        }

                                        _this6._tryCleanup();
                                      }

                                      if (
                                        intentState.displayReadyCapability
                                      ) {
                                        intentState.displayReadyCapability.reject(
                                          reason
                                        );
                                      } else if (
                                        intentState.opListReadCapability
                                      ) {
                                        intentState.opListReadCapability.reject(
                                          reason
                                        );
                                      } else {
                                        throw reason;
                                      }
                                    }
                                  );
                              };

                            pump();
                          },
                      },
                      {
                        key: "_abortOperatorList",
                        value:
                          function _abortOperatorList(
                            _ref11
                          ) {
                            var _this7 = this;

                            var intentState =
                                _ref11.intentState,
                              reason =
                                _ref11.reason,
                              _ref11$force =
                                _ref11.force,
                              force =
                                _ref11$force ===
                                void 0
                                  ? false
                                  : _ref11$force;
                            (0, _util.assert)(
                              reason instanceof
                                Error ||
                                (_typeof(
                                  reason
                                ) === "object" &&
                                  reason !==
                                    null),
                              'PDFPageProxy._abortOperatorList: Expected "reason" argument.'
                            );

                            if (
                              !intentState.streamReader
                            ) {
                              return;
                            }

                            if (!force) {
                              if (
                                intentState
                                  .renderTasks
                                  .length !== 0
                              ) {
                                return;
                              }

                              if (
                                reason instanceof
                                _display_utils.RenderingCancelledException
                              ) {
                                intentState.streamReaderCancelTimeout =
                                  setTimeout(
                                    function () {
                                      _this7._abortOperatorList(
                                        {
                                          intentState:
                                            intentState,
                                          reason:
                                            reason,
                                          force: true,
                                        }
                                      );

                                      intentState.streamReaderCancelTimeout =
                                        null;
                                    },
                                    RENDERING_CANCELLED_TIMEOUT
                                  );
                                return;
                              }
                            }

                            intentState.streamReader.cancel(
                              new _util.AbortException(
                                reason === null ||
                                reason === void 0
                                  ? void 0
                                  : reason.message
                              )
                            );
                            intentState.streamReader =
                              null;

                            if (
                              this._transport
                                .destroyed
                            ) {
                              return;
                            }

                            var _iterator8 =
                                _createForOfIteratorHelper(
                                  this
                                    ._intentStates
                                ),
                              _step8;

                            try {
                              for (
                                _iterator8.s();
                                !(_step8 =
                                  _iterator8.n())
                                  .done;

                              ) {
                                var _step8$value =
                                    _slicedToArray(
                                      _step8.value,
                                      2
                                    ),
                                  intent =
                                    _step8$value[0],
                                  curIntentState =
                                    _step8$value[1];

                                if (
                                  curIntentState ===
                                  intentState
                                ) {
                                  this._intentStates[
                                    "delete"
                                  ](intent);

                                  break;
                                }
                              }
                            } catch (err) {
                              _iterator8.e(err);
                            } finally {
                              _iterator8.f();
                            }

                            this.cleanup();
                          },
                      },
                      {
                        key: "stats",
                        get: function get() {
                          return this._stats;
                        },
                      },
                    ]);

                    return PDFPageProxy;
                  })();

                exports.PDFPageProxy =
                  PDFPageProxy;

                var LoopbackPort =
                  /*#__PURE__*/ (function () {
                    function LoopbackPort() {
                      var defer =
                        arguments.length > 0 &&
                        arguments[0] !== undefined
                          ? arguments[0]
                          : true;

                      _classCallCheck(
                        this,
                        LoopbackPort
                      );

                      this._listeners = [];
                      this._defer = defer;
                      this._deferred =
                        Promise.resolve(
                          undefined
                        );
                    }

                    _createClass(LoopbackPort, [
                      {
                        key: "postMessage",
                        value:
                          function postMessage(
                            obj,
                            transfers
                          ) {
                            var _this8 = this;

                            function cloneValue(
                              value
                            ) {
                              if (
                                _typeof(value) !==
                                  "object" ||
                                value === null
                              ) {
                                return value;
                              }

                              if (
                                cloned.has(value)
                              ) {
                                return cloned.get(
                                  value
                                );
                              }

                              var buffer, result;

                              if (
                                (buffer =
                                  value.buffer) &&
                                (0,
                                _util.isArrayBuffer)(
                                  buffer
                                )
                              ) {
                                if (
                                  transfers !==
                                    null &&
                                  transfers !==
                                    void 0 &&
                                  transfers.includes(
                                    buffer
                                  )
                                ) {
                                  result =
                                    new value.constructor(
                                      buffer,
                                      value.byteOffset,
                                      value.byteLength
                                    );
                                } else {
                                  result =
                                    new value.constructor(
                                      value
                                    );
                                }

                                cloned.set(
                                  value,
                                  result
                                );
                                return result;
                              }

                              result =
                                Array.isArray(
                                  value
                                )
                                  ? []
                                  : {};
                              cloned.set(
                                value,
                                result
                              );

                              for (var i in value) {
                                var desc = void 0,
                                  p = value;

                                while (
                                  !(desc =
                                    Object.getOwnPropertyDescriptor(
                                      p,
                                      i
                                    ))
                                ) {
                                  p =
                                    Object.getPrototypeOf(
                                      p
                                    );
                                }

                                if (
                                  typeof desc.value ===
                                  "undefined"
                                ) {
                                  continue;
                                }

                                if (
                                  typeof desc.value ===
                                  "function"
                                ) {
                                  if (
                                    value.hasOwnProperty &&
                                    value.hasOwnProperty(
                                      i
                                    )
                                  ) {
                                    throw new Error(
                                      "LoopbackPort.postMessage - cannot clone: ".concat(
                                        value[i]
                                      )
                                    );
                                  }

                                  continue;
                                }

                                result[i] =
                                  cloneValue(
                                    desc.value
                                  );
                              }

                              return result;
                            }

                            if (!this._defer) {
                              this._listeners.forEach(
                                function (
                                  listener
                                ) {
                                  listener.call(
                                    _this8,
                                    {
                                      data: obj,
                                    }
                                  );
                                }
                              );

                              return;
                            }

                            var cloned =
                              new WeakMap();
                            var e = {
                              data: cloneValue(
                                obj
                              ),
                            };

                            this._deferred.then(
                              function () {
                                _this8._listeners.forEach(
                                  function (
                                    listener
                                  ) {
                                    listener.call(
                                      _this8,
                                      e
                                    );
                                  }
                                );
                              }
                            );
                          },
                      },
                      {
                        key: "addEventListener",
                        value:
                          function addEventListener(
                            name,
                            listener
                          ) {
                            this._listeners.push(
                              listener
                            );
                          },
                      },
                      {
                        key: "removeEventListener",
                        value:
                          function removeEventListener(
                            name,
                            listener
                          ) {
                            var i =
                              this._listeners.indexOf(
                                listener
                              );

                            this._listeners.splice(
                              i,
                              1
                            );
                          },
                      },
                      {
                        key: "terminate",
                        value:
                          function terminate() {
                            this._listeners.length = 0;
                          },
                      },
                    ]);

                    return LoopbackPort;
                  })();

                exports.LoopbackPort =
                  LoopbackPort;

                var PDFWorker =
                  (function PDFWorkerClosure() {
                    var pdfWorkerPorts =
                      new WeakMap();
                    var isWorkerDisabled = false;
                    var fallbackWorkerSrc;
                    var nextFakeWorkerId = 0;
                    var fakeWorkerCapability;

                    if (
                      _is_node.isNodeJS &&
                      "function" === "function"
                    ) {
                      isWorkerDisabled = true;
                      fallbackWorkerSrc =
                        "./pdf.worker.js";
                    } else if (
                      (typeof document ===
                      "undefined"
                        ? "undefined"
                        : _typeof(document)) ===
                        "object" &&
                      "currentScript" in document
                    ) {
                      var _document$currentScri;

                      var pdfjsFilePath =
                        (_document$currentScri =
                          document.currentScript) ===
                          null ||
                        _document$currentScri ===
                          void 0
                          ? void 0
                          : _document$currentScri.src;

                      if (pdfjsFilePath) {
                        fallbackWorkerSrc =
                          pdfjsFilePath.replace(
                            /(\.(?:min\.)?js)(\?.*)?$/i,
                            ".worker$1$2"
                          );
                      }
                    }

                    function _getWorkerSrc() {
                      if (
                        _worker_options
                          .GlobalWorkerOptions
                          .workerSrc
                      ) {
                        return _worker_options
                          .GlobalWorkerOptions
                          .workerSrc;
                      }

                      if (
                        typeof fallbackWorkerSrc !==
                        "undefined"
                      ) {
                        if (!_is_node.isNodeJS) {
                          (0,
                          _display_utils.deprecated)(
                            'No "GlobalWorkerOptions.workerSrc" specified.'
                          );
                        }

                        return fallbackWorkerSrc;
                      }

                      throw new Error(
                        'No "GlobalWorkerOptions.workerSrc" specified.'
                      );
                    }

                    function getMainThreadWorkerMessageHandler() {
                      var mainWorkerMessageHandler;

                      try {
                        var _globalThis$pdfjsWork;

                        mainWorkerMessageHandler =
                          (_globalThis$pdfjsWork =
                            globalThis.pdfjsWorker) ===
                            null ||
                          _globalThis$pdfjsWork ===
                            void 0
                            ? void 0
                            : _globalThis$pdfjsWork.WorkerMessageHandler;
                      } catch (ex) {}

                      return (
                        mainWorkerMessageHandler ||
                        null
                      );
                    }

                    function setupFakeWorkerGlobal() {
                      if (fakeWorkerCapability) {
                        return fakeWorkerCapability.promise;
                      }

                      fakeWorkerCapability = (0,
                      _util.createPromiseCapability)();

                      var loader =
                        /*#__PURE__*/ (function () {
                          var _ref12 =
                            _asyncToGenerator(
                              /*#__PURE__*/ _regenerator[
                                "default"
                              ].mark(
                                function _callee() {
                                  var mainWorkerMessageHandler,
                                    worker;
                                  return _regenerator[
                                    "default"
                                  ].wrap(
                                    function _callee$(
                                      _context
                                    ) {
                                      while (1) {
                                        switch (
                                          (_context.prev =
                                            _context.next)
                                        ) {
                                          case 0:
                                            mainWorkerMessageHandler =
                                              getMainThreadWorkerMessageHandler();

                                            if (
                                              !mainWorkerMessageHandler
                                            ) {
                                              _context.next = 3;
                                              break;
                                            }

                                            return _context.abrupt(
                                              "return",
                                              mainWorkerMessageHandler
                                            );

                                          case 3:
                                            if (
                                              !(
                                                _is_node.isNodeJS &&
                                                "function" ===
                                                  "function"
                                              )
                                            ) {
                                              _context.next = 6;
                                              break;
                                            }

                                            worker =
                                              eval(
                                                "require"
                                              )(
                                                _getWorkerSrc()
                                              );
                                            return _context.abrupt(
                                              "return",
                                              worker.WorkerMessageHandler
                                            );

                                          case 6:
                                            _context.next = 8;
                                            return (0,
                                            _display_utils.loadScript)(
                                              _getWorkerSrc()
                                            );

                                          case 8:
                                            return _context.abrupt(
                                              "return",
                                              window
                                                .pdfjsWorker
                                                .WorkerMessageHandler
                                            );

                                          case 9:
                                          case "end":
                                            return _context.stop();
                                        }
                                      }
                                    },
                                    _callee
                                  );
                                }
                              )
                            );

                          return function loader() {
                            return _ref12.apply(
                              this,
                              arguments
                            );
                          };
                        })();

                      loader().then(
                        fakeWorkerCapability.resolve,
                        fakeWorkerCapability.reject
                      );
                      return fakeWorkerCapability.promise;
                    }

                    function createCDNWrapper(
                      url
                    ) {
                      var wrapper =
                        "importScripts('" +
                        url +
                        "');";
                      return URL.createObjectURL(
                        new Blob([wrapper])
                      );
                    }

                    var PDFWorker =
                      /*#__PURE__*/ (function () {
                        function PDFWorker() {
                          var _ref13 =
                              arguments.length >
                                0 &&
                              arguments[0] !==
                                undefined
                                ? arguments[0]
                                : {},
                            _ref13$name =
                              _ref13.name,
                            name =
                              _ref13$name ===
                              void 0
                                ? null
                                : _ref13$name,
                            _ref13$port =
                              _ref13.port,
                            port =
                              _ref13$port ===
                              void 0
                                ? null
                                : _ref13$port,
                            _ref13$verbosity =
                              _ref13.verbosity,
                            verbosity =
                              _ref13$verbosity ===
                              void 0
                                ? (0,
                                  _util.getVerbosityLevel)()
                                : _ref13$verbosity;

                          _classCallCheck(
                            this,
                            PDFWorker
                          );

                          if (
                            port &&
                            pdfWorkerPorts.has(
                              port
                            )
                          ) {
                            throw new Error(
                              "Cannot use more than one PDFWorker per port"
                            );
                          }

                          this.name = name;
                          this.destroyed = false;
                          this.postMessageTransfers = true;
                          this.verbosity =
                            verbosity;
                          this._readyCapability =
                            (0,
                            _util.createPromiseCapability)();
                          this._port = null;
                          this._webWorker = null;
                          this._messageHandler =
                            null;

                          if (port) {
                            pdfWorkerPorts.set(
                              port,
                              this
                            );

                            this._initializeFromPort(
                              port
                            );

                            return;
                          }

                          this._initialize();
                        }

                        _createClass(
                          PDFWorker,
                          [
                            {
                              key: "promise",
                              get: function get() {
                                return this
                                  ._readyCapability
                                  .promise;
                              },
                            },
                            {
                              key: "port",
                              get: function get() {
                                return this._port;
                              },
                            },
                            {
                              key: "messageHandler",
                              get: function get() {
                                return this
                                  ._messageHandler;
                              },
                            },
                            {
                              key: "_initializeFromPort",
                              value:
                                function _initializeFromPort(
                                  port
                                ) {
                                  this._port =
                                    port;
                                  this._messageHandler =
                                    new _message_handler.MessageHandler(
                                      "main",
                                      "worker",
                                      port
                                    );

                                  this._messageHandler.on(
                                    "ready",
                                    function () {}
                                  );

                                  this._readyCapability.resolve();
                                },
                            },
                            {
                              key: "_initialize",
                              value:
                                function _initialize() {
                                  var _this9 =
                                    this;

                                  if (
                                    typeof Worker !==
                                      "undefined" &&
                                    !isWorkerDisabled &&
                                    !getMainThreadWorkerMessageHandler()
                                  ) {
                                    var workerSrc =
                                      _getWorkerSrc();

                                    try {
                                      if (
                                        !(0,
                                        _util.isSameOrigin)(
                                          window
                                            .location
                                            .href,
                                          workerSrc
                                        )
                                      ) {
                                        workerSrc =
                                          createCDNWrapper(
                                            new URL(
                                              workerSrc,
                                              window.location
                                            ).href
                                          );
                                      }

                                      var worker =
                                        new Worker(
                                          workerSrc
                                        );
                                      var messageHandler =
                                        new _message_handler.MessageHandler(
                                          "main",
                                          "worker",
                                          worker
                                        );

                                      var terminateEarly =
                                        function terminateEarly() {
                                          worker.removeEventListener(
                                            "error",
                                            onWorkerError
                                          );
                                          messageHandler.destroy();
                                          worker.terminate();

                                          if (
                                            _this9.destroyed
                                          ) {
                                            _this9._readyCapability.reject(
                                              new Error(
                                                "Worker was destroyed"
                                              )
                                            );
                                          } else {
                                            _this9._setupFakeWorker();
                                          }
                                        };

                                      var onWorkerError =
                                        function onWorkerError() {
                                          if (
                                            !_this9._webWorker
                                          ) {
                                            terminateEarly();
                                          }
                                        };

                                      worker.addEventListener(
                                        "error",
                                        onWorkerError
                                      );
                                      messageHandler.on(
                                        "test",
                                        function (
                                          data
                                        ) {
                                          worker.removeEventListener(
                                            "error",
                                            onWorkerError
                                          );

                                          if (
                                            _this9.destroyed
                                          ) {
                                            terminateEarly();
                                            return;
                                          }

                                          if (
                                            data
                                          ) {
                                            _this9._messageHandler =
                                              messageHandler;
                                            _this9._port =
                                              worker;
                                            _this9._webWorker =
                                              worker;

                                            if (
                                              !data.supportTransfers
                                            ) {
                                              _this9.postMessageTransfers = false;
                                            }

                                            _this9._readyCapability.resolve();

                                            messageHandler.send(
                                              "configure",
                                              {
                                                verbosity:
                                                  _this9.verbosity,
                                              }
                                            );
                                          } else {
                                            _this9._setupFakeWorker();

                                            messageHandler.destroy();
                                            worker.terminate();
                                          }
                                        }
                                      );
                                      messageHandler.on(
                                        "ready",
                                        function (
                                          data
                                        ) {
                                          worker.removeEventListener(
                                            "error",
                                            onWorkerError
                                          );

                                          if (
                                            _this9.destroyed
                                          ) {
                                            terminateEarly();
                                            return;
                                          }

                                          try {
                                            sendTest();
                                          } catch (e) {
                                            _this9._setupFakeWorker();
                                          }
                                        }
                                      );

                                      var sendTest =
                                        function sendTest() {
                                          var testObj =
                                            new Uint8Array(
                                              [
                                                _this9.postMessageTransfers
                                                  ? 255
                                                  : 0,
                                              ]
                                            );

                                          try {
                                            messageHandler.send(
                                              "test",
                                              testObj,
                                              [
                                                testObj.buffer,
                                              ]
                                            );
                                          } catch (ex) {
                                            (0,
                                            _util.warn)(
                                              "Cannot use postMessage transfers."
                                            );
                                            testObj[0] = 0;
                                            messageHandler.send(
                                              "test",
                                              testObj
                                            );
                                          }
                                        };

                                      sendTest();
                                      return;
                                    } catch (e) {
                                      (0,
                                      _util.info)(
                                        "The worker has been disabled."
                                      );
                                    }
                                  }

                                  this._setupFakeWorker();
                                },
                            },
                            {
                              key: "_setupFakeWorker",
                              value:
                                function _setupFakeWorker() {
                                  var _this10 =
                                    this;

                                  if (
                                    !isWorkerDisabled
                                  ) {
                                    (0,
                                    _util.warn)(
                                      "Setting up fake worker."
                                    );
                                    isWorkerDisabled = true;
                                  }

                                  setupFakeWorkerGlobal()
                                    .then(
                                      function (
                                        WorkerMessageHandler
                                      ) {
                                        if (
                                          _this10.destroyed
                                        ) {
                                          _this10._readyCapability.reject(
                                            new Error(
                                              "Worker was destroyed"
                                            )
                                          );

                                          return;
                                        }

                                        var port =
                                          new LoopbackPort();
                                        _this10._port =
                                          port;
                                        var id =
                                          "fake" +
                                          nextFakeWorkerId++;
                                        var workerHandler =
                                          new _message_handler.MessageHandler(
                                            id +
                                              "_worker",
                                            id,
                                            port
                                          );
                                        WorkerMessageHandler.setup(
                                          workerHandler,
                                          port
                                        );
                                        var messageHandler =
                                          new _message_handler.MessageHandler(
                                            id,
                                            id +
                                              "_worker",
                                            port
                                          );
                                        _this10._messageHandler =
                                          messageHandler;

                                        _this10._readyCapability.resolve();

                                        messageHandler.send(
                                          "configure",
                                          {
                                            verbosity:
                                              _this10.verbosity,
                                          }
                                        );
                                      }
                                    )
                                    ["catch"](
                                      function (
                                        reason
                                      ) {
                                        _this10._readyCapability.reject(
                                          new Error(
                                            'Setting up fake worker failed: "'.concat(
                                              reason.message,
                                              '".'
                                            )
                                          )
                                        );
                                      }
                                    );
                                },
                            },
                            {
                              key: "destroy",
                              value:
                                function destroy() {
                                  this.destroyed = true;

                                  if (
                                    this
                                      ._webWorker
                                  ) {
                                    this._webWorker.terminate();

                                    this._webWorker =
                                      null;
                                  }

                                  pdfWorkerPorts[
                                    "delete"
                                  ](this._port);
                                  this._port =
                                    null;

                                  if (
                                    this
                                      ._messageHandler
                                  ) {
                                    this._messageHandler.destroy();

                                    this._messageHandler =
                                      null;
                                  }
                                },
                            },
                          ],
                          [
                            {
                              key: "fromPort",
                              value:
                                function fromPort(
                                  params
                                ) {
                                  if (
                                    !params ||
                                    !params.port
                                  ) {
                                    throw new Error(
                                      "PDFWorker.fromPort - invalid method signature."
                                    );
                                  }

                                  if (
                                    pdfWorkerPorts.has(
                                      params.port
                                    )
                                  ) {
                                    return pdfWorkerPorts.get(
                                      params.port
                                    );
                                  }

                                  return new PDFWorker(
                                    params
                                  );
                                },
                            },
                            {
                              key: "getWorkerSrc",
                              value:
                                function getWorkerSrc() {
                                  return _getWorkerSrc();
                                },
                            },
                          ]
                        );

                        return PDFWorker;
                      })();

                    return PDFWorker;
                  })();

                exports.PDFWorker = PDFWorker;

                var WorkerTransport =
                  /*#__PURE__*/ (function () {
                    function WorkerTransport(
                      messageHandler,
                      loadingTask,
                      networkStream,
                      params
                    ) {
                      _classCallCheck(
                        this,
                        WorkerTransport
                      );

                      this.messageHandler =
                        messageHandler;
                      this.loadingTask =
                        loadingTask;
                      this.commonObjs =
                        new PDFObjects();
                      this.fontLoader =
                        new _font_loader.FontLoader(
                          {
                            docId:
                              loadingTask.docId,
                            onUnsupportedFeature:
                              this._onUnsupportedFeature.bind(
                                this
                              ),
                            ownerDocument:
                              params.ownerDocument,
                          }
                        );
                      this._params = params;
                      this.CMapReaderFactory =
                        new params.CMapReaderFactory(
                          {
                            baseUrl:
                              params.cMapUrl,
                            isCompressed:
                              params.cMapPacked,
                          }
                        );
                      this.destroyed = false;
                      this.destroyCapability =
                        null;
                      this._passwordCapability =
                        null;
                      this._networkStream =
                        networkStream;
                      this._fullReader = null;
                      this._lastProgress = null;
                      this.pageCache = [];
                      this.pagePromises = [];
                      this.downloadInfoCapability =
                        (0,
                        _util.createPromiseCapability)();
                      this.setupMessageHandler();
                    }

                    _createClass(
                      WorkerTransport,
                      [
                        {
                          key: "loadingTaskSettled",
                          get: function get() {
                            return this
                              .loadingTask
                              ._capability
                              .settled;
                          },
                        },
                        {
                          key: "destroy",
                          value:
                            function destroy() {
                              var _this11 = this;

                              if (
                                this
                                  .destroyCapability
                              ) {
                                return this
                                  .destroyCapability
                                  .promise;
                              }

                              this.destroyed = true;
                              this.destroyCapability =
                                (0,
                                _util.createPromiseCapability)();

                              if (
                                this
                                  ._passwordCapability
                              ) {
                                this._passwordCapability.reject(
                                  new Error(
                                    "Worker was destroyed during onPassword callback"
                                  )
                                );
                              }

                              var waitOn = [];
                              this.pageCache.forEach(
                                function (page) {
                                  if (page) {
                                    waitOn.push(
                                      page._destroy()
                                    );
                                  }
                                }
                              );
                              this.pageCache.length = 0;
                              this.pagePromises.length = 0;
                              var terminated =
                                this.messageHandler.sendWithPromise(
                                  "Terminate",
                                  null
                                );
                              waitOn.push(
                                terminated
                              );

                              if (
                                this
                                  .loadingTaskSettled
                              ) {
                                var annotationStorageResetModified =
                                  this.loadingTask.promise
                                    .then(
                                      function (
                                        pdfDocument
                                      ) {
                                        if (
                                          pdfDocument.hasOwnProperty(
                                            "annotationStorage"
                                          )
                                        ) {
                                          pdfDocument.annotationStorage.resetModified();
                                        }
                                      }
                                    )
                                    ["catch"](
                                      function () {}
                                    );
                                waitOn.push(
                                  annotationStorageResetModified
                                );
                              }

                              Promise.all(
                                waitOn
                              ).then(function () {
                                _this11.commonObjs.clear();

                                _this11.fontLoader.clear();

                                _this11._hasJSActionsPromise =
                                  null;

                                if (
                                  _this11._networkStream
                                ) {
                                  _this11._networkStream.cancelAllRequests(
                                    new _util.AbortException(
                                      "Worker was terminated."
                                    )
                                  );
                                }

                                if (
                                  _this11.messageHandler
                                ) {
                                  _this11.messageHandler.destroy();

                                  _this11.messageHandler =
                                    null;
                                }

                                _this11.destroyCapability.resolve();
                              }, this
                                .destroyCapability.reject);
                              return this
                                .destroyCapability
                                .promise;
                            },
                        },
                        {
                          key: "setupMessageHandler",
                          value:
                            function setupMessageHandler() {
                              var _this12 = this;

                              var messageHandler =
                                  this
                                    .messageHandler,
                                loadingTask =
                                  this
                                    .loadingTask;
                              messageHandler.on(
                                "GetReader",
                                function (
                                  data,
                                  sink
                                ) {
                                  (0,
                                  _util.assert)(
                                    _this12._networkStream,
                                    "GetReader - no `IPDFStream` instance available."
                                  );
                                  _this12._fullReader =
                                    _this12._networkStream.getFullReader();

                                  _this12._fullReader.onProgress =
                                    function (
                                      evt
                                    ) {
                                      _this12._lastProgress =
                                        {
                                          loaded:
                                            evt.loaded,
                                          total:
                                            evt.total,
                                        };
                                    };

                                  sink.onPull =
                                    function () {
                                      _this12._fullReader
                                        .read()
                                        .then(
                                          function (
                                            _ref14
                                          ) {
                                            var value =
                                                _ref14.value,
                                              done =
                                                _ref14.done;

                                            if (
                                              done
                                            ) {
                                              sink.close();
                                              return;
                                            }

                                            (0,
                                            _util.assert)(
                                              (0,
                                              _util.isArrayBuffer)(
                                                value
                                              ),
                                              "GetReader - expected an ArrayBuffer."
                                            );
                                            sink.enqueue(
                                              new Uint8Array(
                                                value
                                              ),
                                              1,
                                              [
                                                value,
                                              ]
                                            );
                                          }
                                        )
                                        ["catch"](
                                          function (
                                            reason
                                          ) {
                                            sink.error(
                                              reason
                                            );
                                          }
                                        );
                                    };

                                  sink.onCancel =
                                    function (
                                      reason
                                    ) {
                                      _this12._fullReader.cancel(
                                        reason
                                      );

                                      sink.ready[
                                        "catch"
                                      ](function (
                                        readyReason
                                      ) {
                                        if (
                                          _this12.destroyed
                                        ) {
                                          return;
                                        }

                                        throw readyReason;
                                      });
                                    };
                                }
                              );
                              messageHandler.on(
                                "ReaderHeadersReady",
                                function (data) {
                                  var headersCapability =
                                    (0,
                                    _util.createPromiseCapability)();
                                  var fullReader =
                                    _this12._fullReader;
                                  fullReader.headersReady.then(
                                    function () {
                                      if (
                                        !fullReader.isStreamingSupported ||
                                        !fullReader.isRangeSupported
                                      ) {
                                        if (
                                          _this12._lastProgress &&
                                          loadingTask.onProgress
                                        ) {
                                          loadingTask.onProgress(
                                            _this12._lastProgress
                                          );
                                        }

                                        fullReader.onProgress =
                                          function (
                                            evt
                                          ) {
                                            if (
                                              loadingTask.onProgress
                                            ) {
                                              loadingTask.onProgress(
                                                {
                                                  loaded:
                                                    evt.loaded,
                                                  total:
                                                    evt.total,
                                                }
                                              );
                                            }
                                          };
                                      }

                                      headersCapability.resolve(
                                        {
                                          isStreamingSupported:
                                            fullReader.isStreamingSupported,
                                          isRangeSupported:
                                            fullReader.isRangeSupported,
                                          contentLength:
                                            fullReader.contentLength,
                                        }
                                      );
                                    },
                                    headersCapability.reject
                                  );
                                  return headersCapability.promise;
                                }
                              );
                              messageHandler.on(
                                "GetRangeReader",
                                function (
                                  data,
                                  sink
                                ) {
                                  (0,
                                  _util.assert)(
                                    _this12._networkStream,
                                    "GetRangeReader - no `IPDFStream` instance available."
                                  );

                                  var rangeReader =
                                    _this12._networkStream.getRangeReader(
                                      data.begin,
                                      data.end
                                    );

                                  if (
                                    !rangeReader
                                  ) {
                                    sink.close();
                                    return;
                                  }

                                  sink.onPull =
                                    function () {
                                      rangeReader
                                        .read()
                                        .then(
                                          function (
                                            _ref15
                                          ) {
                                            var value =
                                                _ref15.value,
                                              done =
                                                _ref15.done;

                                            if (
                                              done
                                            ) {
                                              sink.close();
                                              return;
                                            }

                                            (0,
                                            _util.assert)(
                                              (0,
                                              _util.isArrayBuffer)(
                                                value
                                              ),
                                              "GetRangeReader - expected an ArrayBuffer."
                                            );
                                            sink.enqueue(
                                              new Uint8Array(
                                                value
                                              ),
                                              1,
                                              [
                                                value,
                                              ]
                                            );
                                          }
                                        )
                                        ["catch"](
                                          function (
                                            reason
                                          ) {
                                            sink.error(
                                              reason
                                            );
                                          }
                                        );
                                    };

                                  sink.onCancel =
                                    function (
                                      reason
                                    ) {
                                      rangeReader.cancel(
                                        reason
                                      );
                                      sink.ready[
                                        "catch"
                                      ](function (
                                        readyReason
                                      ) {
                                        if (
                                          _this12.destroyed
                                        ) {
                                          return;
                                        }

                                        throw readyReason;
                                      });
                                    };
                                }
                              );
                              messageHandler.on(
                                "GetDoc",
                                function (
                                  _ref16
                                ) {
                                  var pdfInfo =
                                    _ref16.pdfInfo;
                                  _this12._numPages =
                                    pdfInfo.numPages;

                                  loadingTask._capability.resolve(
                                    new PDFDocumentProxy(
                                      pdfInfo,
                                      _this12
                                    )
                                  );
                                }
                              );
                              messageHandler.on(
                                "DocException",
                                function (ex) {
                                  var reason;

                                  switch (
                                    ex.name
                                  ) {
                                    case "PasswordException":
                                      reason =
                                        new _util.PasswordException(
                                          ex.message,
                                          ex.code
                                        );
                                      break;

                                    case "InvalidPDFException":
                                      reason =
                                        new _util.InvalidPDFException(
                                          ex.message
                                        );
                                      break;

                                    case "MissingPDFException":
                                      reason =
                                        new _util.MissingPDFException(
                                          ex.message
                                        );
                                      break;

                                    case "UnexpectedResponseException":
                                      reason =
                                        new _util.UnexpectedResponseException(
                                          ex.message,
                                          ex.status
                                        );
                                      break;

                                    case "UnknownErrorException":
                                      reason =
                                        new _util.UnknownErrorException(
                                          ex.message,
                                          ex.details
                                        );
                                      break;
                                  }

                                  if (
                                    !(
                                      reason instanceof
                                      Error
                                    )
                                  ) {
                                    var msg =
                                      "DocException - expected a valid Error.";
                                    (0,
                                    _util.warn)(
                                      msg
                                    );
                                  }

                                  loadingTask._capability.reject(
                                    reason
                                  );
                                }
                              );
                              messageHandler.on(
                                "PasswordRequest",
                                function (
                                  exception
                                ) {
                                  _this12._passwordCapability =
                                    (0,
                                    _util.createPromiseCapability)();

                                  if (
                                    loadingTask.onPassword
                                  ) {
                                    var updatePassword =
                                      function updatePassword(
                                        password
                                      ) {
                                        _this12._passwordCapability.resolve(
                                          {
                                            password:
                                              password,
                                          }
                                        );
                                      };

                                    try {
                                      loadingTask.onPassword(
                                        updatePassword,
                                        exception.code
                                      );
                                    } catch (ex) {
                                      _this12._passwordCapability.reject(
                                        ex
                                      );
                                    }
                                  } else {
                                    _this12._passwordCapability.reject(
                                      new _util.PasswordException(
                                        exception.message,
                                        exception.code
                                      )
                                    );
                                  }

                                  return _this12
                                    ._passwordCapability
                                    .promise;
                                }
                              );
                              messageHandler.on(
                                "DataLoaded",
                                function (data) {
                                  if (
                                    loadingTask.onProgress
                                  ) {
                                    loadingTask.onProgress(
                                      {
                                        loaded:
                                          data.length,
                                        total:
                                          data.length,
                                      }
                                    );
                                  }

                                  _this12.downloadInfoCapability.resolve(
                                    data
                                  );
                                }
                              );
                              messageHandler.on(
                                "StartRenderPage",
                                function (data) {
                                  if (
                                    _this12.destroyed
                                  ) {
                                    return;
                                  }

                                  var page =
                                    _this12
                                      .pageCache[
                                      data
                                        .pageIndex
                                    ];

                                  page._startRenderPage(
                                    data.transparency,
                                    data.intent
                                  );
                                }
                              );
                              messageHandler.on(
                                "commonobj",
                                function (data) {
                                  var _globalThis$FontInspe;

                                  if (
                                    _this12.destroyed
                                  ) {
                                    return;
                                  }

                                  var _data =
                                      _slicedToArray(
                                        data,
                                        3
                                      ),
                                    id = _data[0],
                                    type =
                                      _data[1],
                                    exportedData =
                                      _data[2];

                                  if (
                                    _this12.commonObjs.has(
                                      id
                                    )
                                  ) {
                                    return;
                                  }

                                  switch (type) {
                                    case "Font":
                                      var params =
                                        _this12._params;

                                      if (
                                        "error" in
                                        exportedData
                                      ) {
                                        var exportedError =
                                          exportedData.error;
                                        (0,
                                        _util.warn)(
                                          "Error during font loading: ".concat(
                                            exportedError
                                          )
                                        );

                                        _this12.commonObjs.resolve(
                                          id,
                                          exportedError
                                        );

                                        break;
                                      }

                                      var fontRegistry =
                                        null;

                                      if (
                                        params.pdfBug &&
                                        (_globalThis$FontInspe =
                                          globalThis.FontInspector) !==
                                          null &&
                                        _globalThis$FontInspe !==
                                          void 0 &&
                                        _globalThis$FontInspe.enabled
                                      ) {
                                        fontRegistry =
                                          {
                                            registerFont:
                                              function registerFont(
                                                font,
                                                url
                                              ) {
                                                globalThis.FontInspector.fontAdded(
                                                  font,
                                                  url
                                                );
                                              },
                                          };
                                      }

                                      var font =
                                        new _font_loader.FontFaceObject(
                                          exportedData,
                                          {
                                            isEvalSupported:
                                              params.isEvalSupported,
                                            disableFontFace:
                                              params.disableFontFace,
                                            ignoreErrors:
                                              params.ignoreErrors,
                                            onUnsupportedFeature:
                                              _this12._onUnsupportedFeature.bind(
                                                _this12
                                              ),
                                            fontRegistry:
                                              fontRegistry,
                                          }
                                        );

                                      _this12.fontLoader
                                        .bind(
                                          font
                                        )
                                        ["catch"](
                                          function (
                                            reason
                                          ) {
                                            return messageHandler.sendWithPromise(
                                              "FontFallback",
                                              {
                                                id: id,
                                              }
                                            );
                                          }
                                        )
                                        [
                                          "finally"
                                        ](
                                          function () {
                                            if (
                                              !params.fontExtraProperties &&
                                              font.data
                                            ) {
                                              font.data =
                                                null;
                                            }

                                            _this12.commonObjs.resolve(
                                              id,
                                              font
                                            );
                                          }
                                        );

                                      break;

                                    case "FontPath":
                                    case "Image":
                                      _this12.commonObjs.resolve(
                                        id,
                                        exportedData
                                      );

                                      break;

                                    default:
                                      throw new Error(
                                        "Got unknown common object type ".concat(
                                          type
                                        )
                                      );
                                  }
                                }
                              );
                              messageHandler.on(
                                "obj",
                                function (data) {
                                  var _imageData$data;

                                  if (
                                    _this12.destroyed
                                  ) {
                                    return undefined;
                                  }

                                  var _data2 =
                                      _slicedToArray(
                                        data,
                                        4
                                      ),
                                    id =
                                      _data2[0],
                                    pageIndex =
                                      _data2[1],
                                    type =
                                      _data2[2],
                                    imageData =
                                      _data2[3];

                                  var pageProxy =
                                    _this12
                                      .pageCache[
                                      pageIndex
                                    ];

                                  if (
                                    pageProxy.objs.has(
                                      id
                                    )
                                  ) {
                                    return undefined;
                                  }

                                  switch (type) {
                                    case "Image":
                                      pageProxy.objs.resolve(
                                        id,
                                        imageData
                                      );
                                      var MAX_IMAGE_SIZE_TO_STORE = 8000000;

                                      if (
                                        (imageData ===
                                          null ||
                                        imageData ===
                                          void 0
                                          ? void 0
                                          : (_imageData$data =
                                              imageData.data) ===
                                              null ||
                                            _imageData$data ===
                                              void 0
                                          ? void 0
                                          : _imageData$data.length) >
                                        MAX_IMAGE_SIZE_TO_STORE
                                      ) {
                                        pageProxy.cleanupAfterRender = true;
                                      }

                                      break;

                                    default:
                                      throw new Error(
                                        "Got unknown object type ".concat(
                                          type
                                        )
                                      );
                                  }

                                  return undefined;
                                }
                              );
                              messageHandler.on(
                                "DocProgress",
                                function (data) {
                                  if (
                                    _this12.destroyed
                                  ) {
                                    return;
                                  }

                                  if (
                                    loadingTask.onProgress
                                  ) {
                                    loadingTask.onProgress(
                                      {
                                        loaded:
                                          data.loaded,
                                        total:
                                          data.total,
                                      }
                                    );
                                  }
                                }
                              );
                              messageHandler.on(
                                "UnsupportedFeature",
                                this._onUnsupportedFeature.bind(
                                  this
                                )
                              );
                              messageHandler.on(
                                "FetchBuiltInCMap",
                                function (
                                  data,
                                  sink
                                ) {
                                  if (
                                    _this12.destroyed
                                  ) {
                                    sink.error(
                                      new Error(
                                        "Worker was destroyed"
                                      )
                                    );
                                    return;
                                  }

                                  var fetched = false;

                                  sink.onPull =
                                    function () {
                                      if (
                                        fetched
                                      ) {
                                        sink.close();
                                        return;
                                      }

                                      fetched = true;

                                      _this12.CMapReaderFactory.fetch(
                                        data
                                      )
                                        .then(
                                          function (
                                            builtInCMap
                                          ) {
                                            sink.enqueue(
                                              builtInCMap,
                                              1,
                                              [
                                                builtInCMap
                                                  .cMapData
                                                  .buffer,
                                              ]
                                            );
                                          }
                                        )
                                        ["catch"](
                                          function (
                                            reason
                                          ) {
                                            sink.error(
                                              reason
                                            );
                                          }
                                        );
                                    };
                                }
                              );
                            },
                        },
                        {
                          key: "_onUnsupportedFeature",
                          value:
                            function _onUnsupportedFeature(
                              _ref17
                            ) {
                              var featureId =
                                _ref17.featureId;

                              if (
                                this.destroyed
                              ) {
                                return;
                              }

                              if (
                                this.loadingTask
                                  .onUnsupportedFeature
                              ) {
                                this.loadingTask.onUnsupportedFeature(
                                  featureId
                                );
                              }
                            },
                        },
                        {
                          key: "getData",
                          value:
                            function getData() {
                              return this.messageHandler.sendWithPromise(
                                "GetData",
                                null
                              );
                            },
                        },
                        {
                          key: "getPage",
                          value: function getPage(
                            pageNumber
                          ) {
                            var _this13 = this;

                            if (
                              !Number.isInteger(
                                pageNumber
                              ) ||
                              pageNumber <= 0 ||
                              pageNumber >
                                this._numPages
                            ) {
                              return Promise.reject(
                                new Error(
                                  "Invalid page request"
                                )
                              );
                            }

                            var pageIndex =
                              pageNumber - 1;

                            if (
                              pageIndex in
                              this.pagePromises
                            ) {
                              return this
                                .pagePromises[
                                pageIndex
                              ];
                            }

                            var promise =
                              this.messageHandler
                                .sendWithPromise(
                                  "GetPage",
                                  {
                                    pageIndex:
                                      pageIndex,
                                  }
                                )
                                .then(function (
                                  pageInfo
                                ) {
                                  if (
                                    _this13.destroyed
                                  ) {
                                    throw new Error(
                                      "Transport destroyed"
                                    );
                                  }

                                  var page =
                                    new PDFPageProxy(
                                      pageIndex,
                                      pageInfo,
                                      _this13,
                                      _this13._params.ownerDocument,
                                      _this13._params.pdfBug
                                    );
                                  _this13.pageCache[
                                    pageIndex
                                  ] = page;
                                  return page;
                                });
                            this.pagePromises[
                              pageIndex
                            ] = promise;
                            return promise;
                          },
                        },
                        {
                          key: "getPageIndex",
                          value:
                            function getPageIndex(
                              ref
                            ) {
                              return this.messageHandler
                                .sendWithPromise(
                                  "GetPageIndex",
                                  {
                                    ref: ref,
                                  }
                                )
                                ["catch"](
                                  function (
                                    reason
                                  ) {
                                    return Promise.reject(
                                      new Error(
                                        reason
                                      )
                                    );
                                  }
                                );
                            },
                        },
                        {
                          key: "getPageOCGNames",
                          value:
                            function getPageOCGNames(
                              ref
                            ) {
                              return this.messageHandler
                                .sendWithPromise(
                                  "GetPageOCGNames",
                                  {
                                    ref: ref,
                                  }
                                )
                                ["catch"](
                                  function (
                                    reason
                                  ) {
                                    return Promise.reject(
                                      new Error(
                                        reason
                                      )
                                    );
                                  }
                                );
                            },
                        },
                        {
                          key: "getObject",
                          value:
                            function getObject(
                              ref
                            ) {
                              return this.messageHandler
                                .sendWithPromise(
                                  "GetObject",
                                  {
                                    ref: ref,
                                  }
                                )
                                ["catch"](
                                  function (
                                    reason
                                  ) {
                                    return Promise.reject(
                                      new Error(
                                        reason
                                      )
                                    );
                                  }
                                );
                            },
                        },
                        {
                          key: "getAnnotations",
                          value:
                            function getAnnotations(
                              pageIndex,
                              intent
                            ) {
                              return this.messageHandler.sendWithPromise(
                                "GetAnnotations",
                                {
                                  pageIndex:
                                    pageIndex,
                                  intent: intent,
                                }
                              );
                            },
                        },
                        {
                          key: "saveDocument",
                          value:
                            function saveDocument(
                              annotationStorage
                            ) {
                              var _this$_fullReader$fil,
                                _this$_fullReader;

                              return this.messageHandler
                                .sendWithPromise(
                                  "SaveDocument",
                                  {
                                    numPages:
                                      this
                                        ._numPages,
                                    annotationStorage:
                                      (annotationStorage ===
                                        null ||
                                      annotationStorage ===
                                        void 0
                                        ? void 0
                                        : annotationStorage.getAll()) ||
                                      null,
                                    filename:
                                      (_this$_fullReader$fil =
                                        (_this$_fullReader =
                                          this
                                            ._fullReader) ===
                                          null ||
                                        _this$_fullReader ===
                                          void 0
                                          ? void 0
                                          : _this$_fullReader.filename) !==
                                        null &&
                                      _this$_fullReader$fil !==
                                        void 0
                                        ? _this$_fullReader$fil
                                        : null,
                                  }
                                )
                                ["finally"](
                                  function () {
                                    if (
                                      annotationStorage
                                    ) {
                                      annotationStorage.resetModified();
                                    }
                                  }
                                );
                            },
                        },
                        {
                          key: "getFieldObjects",
                          value:
                            function getFieldObjects() {
                              return this.messageHandler.sendWithPromise(
                                "GetFieldObjects",
                                null
                              );
                            },
                        },
                        {
                          key: "hasJSActions",
                          value:
                            function hasJSActions() {
                              return (
                                this
                                  ._hasJSActionsPromise ||
                                (this._hasJSActionsPromise =
                                  this.messageHandler.sendWithPromise(
                                    "HasJSActions",
                                    null
                                  ))
                              );
                            },
                        },
                        {
                          key: "getCalculationOrderIds",
                          value:
                            function getCalculationOrderIds() {
                              return this.messageHandler.sendWithPromise(
                                "GetCalculationOrderIds",
                                null
                              );
                            },
                        },
                        {
                          key: "getDestinations",
                          value:
                            function getDestinations() {
                              return this.messageHandler.sendWithPromise(
                                "GetDestinations",
                                null
                              );
                            },
                        },
                        {
                          key: "getDestination",
                          value:
                            function getDestination(
                              id
                            ) {
                              if (
                                typeof id !==
                                "string"
                              ) {
                                return Promise.reject(
                                  new Error(
                                    "Invalid destination request."
                                  )
                                );
                              }

                              return this.messageHandler.sendWithPromise(
                                "GetDestination",
                                {
                                  id: id,
                                }
                              );
                            },
                        },
                        {
                          key: "getPageLabels",
                          value:
                            function getPageLabels() {
                              return this.messageHandler.sendWithPromise(
                                "GetPageLabels",
                                null
                              );
                            },
                        },
                        {
                          key: "getPageLayout",
                          value:
                            function getPageLayout() {
                              return this.messageHandler.sendWithPromise(
                                "GetPageLayout",
                                null
                              );
                            },
                        },
                        {
                          key: "getPageMode",
                          value:
                            function getPageMode() {
                              return this.messageHandler.sendWithPromise(
                                "GetPageMode",
                                null
                              );
                            },
                        },
                        {
                          key: "getViewerPreferences",
                          value:
                            function getViewerPreferences() {
                              return this.messageHandler.sendWithPromise(
                                "GetViewerPreferences",
                                null
                              );
                            },
                        },
                        {
                          key: "getOpenAction",
                          value:
                            function getOpenAction() {
                              return this.messageHandler.sendWithPromise(
                                "GetOpenAction",
                                null
                              );
                            },
                        },
                        {
                          key: "getAttachments",
                          value:
                            function getAttachments() {
                              return this.messageHandler.sendWithPromise(
                                "GetAttachments",
                                null
                              );
                            },
                        },
                        {
                          key: "getJavaScript",
                          value:
                            function getJavaScript() {
                              return this.messageHandler.sendWithPromise(
                                "GetJavaScript",
                                null
                              );
                            },
                        },
                        {
                          key: "getDocJSActions",
                          value:
                            function getDocJSActions() {
                              return this.messageHandler.sendWithPromise(
                                "GetDocJSActions",
                                null
                              );
                            },
                        },
                        {
                          key: "getPageJSActions",
                          value:
                            function getPageJSActions(
                              pageIndex
                            ) {
                              return this.messageHandler.sendWithPromise(
                                "GetPageJSActions",
                                {
                                  pageIndex:
                                    pageIndex,
                                }
                              );
                            },
                        },
                        {
                          key: "getOutline",
                          value:
                            function getOutline() {
                              return this.messageHandler.sendWithPromise(
                                "GetOutline",
                                null
                              );
                            },
                        },
                        {
                          key: "getOptionalContentConfig",
                          value:
                            function getOptionalContentConfig() {
                              return this.messageHandler
                                .sendWithPromise(
                                  "GetOptionalContentConfig",
                                  null
                                )
                                .then(function (
                                  results
                                ) {
                                  return new _optional_content_config.OptionalContentConfig(
                                    results
                                  );
                                });
                            },
                        },
                        {
                          key: "getPermissions",
                          value:
                            function getPermissions() {
                              return this.messageHandler.sendWithPromise(
                                "GetPermissions",
                                null
                              );
                            },
                        },
                        {
                          key: "getMetadata",
                          value:
                            function getMetadata() {
                              var _this14 = this;

                              return this.messageHandler
                                .sendWithPromise(
                                  "GetMetadata",
                                  null
                                )
                                .then(function (
                                  results
                                ) {
                                  var _this14$_fullReader$f,
                                    _this14$_fullReader,
                                    _this14$_fullReader$c,
                                    _this14$_fullReader2;

                                  return {
                                    info: results[0],
                                    metadata:
                                      results[1]
                                        ? new _metadata.Metadata(
                                            results[1]
                                          )
                                        : null,
                                    contentDispositionFilename:
                                      (_this14$_fullReader$f =
                                        (_this14$_fullReader =
                                          _this14._fullReader) ===
                                          null ||
                                        _this14$_fullReader ===
                                          void 0
                                          ? void 0
                                          : _this14$_fullReader.filename) !==
                                        null &&
                                      _this14$_fullReader$f !==
                                        void 0
                                        ? _this14$_fullReader$f
                                        : null,
                                    contentLength:
                                      (_this14$_fullReader$c =
                                        (_this14$_fullReader2 =
                                          _this14._fullReader) ===
                                          null ||
                                        _this14$_fullReader2 ===
                                          void 0
                                          ? void 0
                                          : _this14$_fullReader2.contentLength) !==
                                        null &&
                                      _this14$_fullReader$c !==
                                        void 0
                                        ? _this14$_fullReader$c
                                        : null,
                                  };
                                });
                            },
                        },
                        {
                          key: "getMarkInfo",
                          value:
                            function getMarkInfo() {
                              return this.messageHandler.sendWithPromise(
                                "GetMarkInfo",
                                null
                              );
                            },
                        },
                        {
                          key: "getStats",
                          value:
                            function getStats() {
                              return this.messageHandler.sendWithPromise(
                                "GetStats",
                                null
                              );
                            },
                        },
                        {
                          key: "startCleanup",
                          value:
                            function startCleanup() {
                              var _this15 = this;

                              return this.messageHandler
                                .sendWithPromise(
                                  "Cleanup",
                                  null
                                )
                                .then(
                                  function () {
                                    for (
                                      var i = 0,
                                        ii =
                                          _this15
                                            .pageCache
                                            .length;
                                      i < ii;
                                      i++
                                    ) {
                                      var page =
                                        _this15
                                          .pageCache[
                                          i
                                        ];

                                      if (page) {
                                        var cleanupSuccessful =
                                          page.cleanup();

                                        if (
                                          !cleanupSuccessful
                                        ) {
                                          throw new Error(
                                            "startCleanup: Page ".concat(
                                              i +
                                                1,
                                              " is currently rendering."
                                            )
                                          );
                                        }
                                      }
                                    }

                                    _this15.commonObjs.clear();

                                    _this15.fontLoader.clear();

                                    _this15._hasJSActionsPromise =
                                      null;
                                  }
                                );
                            },
                        },
                        {
                          key: "loadingParams",
                          get: function get() {
                            var params =
                              this._params;
                            return (0,
                            _util.shadow)(
                              this,
                              "loadingParams",
                              {
                                disableAutoFetch:
                                  params.disableAutoFetch,
                                disableFontFace:
                                  params.disableFontFace,
                              }
                            );
                          },
                        },
                      ]
                    );

                    return WorkerTransport;
                  })();

                var PDFObjects =
                  /*#__PURE__*/ (function () {
                    function PDFObjects() {
                      _classCallCheck(
                        this,
                        PDFObjects
                      );

                      this._objs =
                        Object.create(null);
                    }

                    _createClass(PDFObjects, [
                      {
                        key: "_ensureObj",
                        value:
                          function _ensureObj(
                            objId
                          ) {
                            if (
                              this._objs[objId]
                            ) {
                              return this._objs[
                                objId
                              ];
                            }

                            return (this._objs[
                              objId
                            ] = {
                              capability: (0,
                              _util.createPromiseCapability)(),
                              data: null,
                              resolved: false,
                            });
                          },
                      },
                      {
                        key: "get",
                        value: function get(
                          objId
                        ) {
                          var callback =
                            arguments.length >
                              1 &&
                            arguments[1] !==
                              undefined
                              ? arguments[1]
                              : null;

                          if (callback) {
                            this._ensureObj(
                              objId
                            ).capability.promise.then(
                              callback
                            );

                            return null;
                          }

                          var obj =
                            this._objs[objId];

                          if (
                            !obj ||
                            !obj.resolved
                          ) {
                            throw new Error(
                              "Requesting object that isn't resolved yet ".concat(
                                objId,
                                "."
                              )
                            );
                          }

                          return obj.data;
                        },
                      },
                      {
                        key: "has",
                        value: function has(
                          objId
                        ) {
                          var obj =
                            this._objs[objId];
                          return (
                            (obj === null ||
                            obj === void 0
                              ? void 0
                              : obj.resolved) ||
                            false
                          );
                        },
                      },
                      {
                        key: "resolve",
                        value: function resolve(
                          objId,
                          data
                        ) {
                          var obj =
                            this._ensureObj(
                              objId
                            );

                          obj.resolved = true;
                          obj.data = data;
                          obj.capability.resolve(
                            data
                          );
                        },
                      },
                      {
                        key: "clear",
                        value: function clear() {
                          this._objs =
                            Object.create(null);
                        },
                      },
                    ]);

                    return PDFObjects;
                  })();

                var RenderTask =
                  /*#__PURE__*/ (function () {
                    function RenderTask(
                      internalRenderTask
                    ) {
                      _classCallCheck(
                        this,
                        RenderTask
                      );

                      this._internalRenderTask =
                        internalRenderTask;
                      this.onContinue = null;
                    }

                    _createClass(RenderTask, [
                      {
                        key: "promise",
                        get: function get() {
                          return this
                            ._internalRenderTask
                            .capability.promise;
                        },
                      },
                      {
                        key: "cancel",
                        value: function cancel() {
                          this._internalRenderTask.cancel();
                        },
                      },
                    ]);

                    return RenderTask;
                  })();

                var InternalRenderTask =
                  (function InternalRenderTaskClosure() {
                    var canvasInRendering =
                      new WeakSet();

                    var InternalRenderTask =
                      /*#__PURE__*/ (function () {
                        function InternalRenderTask(
                          _ref18
                        ) {
                          var callback =
                              _ref18.callback,
                            params =
                              _ref18.params,
                            objs = _ref18.objs,
                            commonObjs =
                              _ref18.commonObjs,
                            operatorList =
                              _ref18.operatorList,
                            pageIndex =
                              _ref18.pageIndex,
                            canvasFactory =
                              _ref18.canvasFactory,
                            webGLContext =
                              _ref18.webGLContext,
                            _ref18$useRequestAnim =
                              _ref18.useRequestAnimationFrame,
                            useRequestAnimationFrame =
                              _ref18$useRequestAnim ===
                              void 0
                                ? false
                                : _ref18$useRequestAnim,
                            _ref18$pdfBug =
                              _ref18.pdfBug,
                            pdfBug =
                              _ref18$pdfBug ===
                              void 0
                                ? false
                                : _ref18$pdfBug;

                          _classCallCheck(
                            this,
                            InternalRenderTask
                          );

                          this.callback =
                            callback;
                          this.params = params;
                          this.objs = objs;
                          this.commonObjs =
                            commonObjs;
                          this.operatorListIdx =
                            null;
                          this.operatorList =
                            operatorList;
                          this._pageIndex =
                            pageIndex;
                          this.canvasFactory =
                            canvasFactory;
                          this.webGLContext =
                            webGLContext;
                          this._pdfBug = pdfBug;
                          this.running = false;
                          this.graphicsReadyCallback =
                            null;
                          this.graphicsReady = false;
                          this._useRequestAnimationFrame =
                            useRequestAnimationFrame ===
                              true &&
                            typeof window !==
                              "undefined";
                          this.cancelled = false;
                          this.capability = (0,
                          _util.createPromiseCapability)();
                          this.task =
                            new RenderTask(this);
                          this._continueBound =
                            this._continue.bind(
                              this
                            );
                          this._scheduleNextBound =
                            this._scheduleNext.bind(
                              this
                            );
                          this._nextBound =
                            this._next.bind(this);
                          this._canvas =
                            params.canvasContext.canvas;
                        }

                        _createClass(
                          InternalRenderTask,
                          [
                            {
                              key: "completed",
                              get: function get() {
                                return this.capability.promise[
                                  "catch"
                                ](function () {});
                              },
                            },
                            {
                              key: "initializeGraphics",
                              value:
                                function initializeGraphics(
                                  _ref19
                                ) {
                                  var _globalThis$StepperMa;

                                  var _ref19$transparency =
                                      _ref19.transparency,
                                    transparency =
                                      _ref19$transparency ===
                                      void 0
                                        ? false
                                        : _ref19$transparency,
                                    optionalContentConfig =
                                      _ref19.optionalContentConfig;

                                  if (
                                    this.cancelled
                                  ) {
                                    return;
                                  }

                                  if (
                                    this._canvas
                                  ) {
                                    if (
                                      canvasInRendering.has(
                                        this
                                          ._canvas
                                      )
                                    ) {
                                      throw new Error(
                                        "Cannot use the same canvas during multiple render() operations. " +
                                          "Use different canvas or ensure previous operations were " +
                                          "cancelled or completed."
                                      );
                                    }

                                    canvasInRendering.add(
                                      this._canvas
                                    );
                                  }

                                  if (
                                    this
                                      ._pdfBug &&
                                    (_globalThis$StepperMa =
                                      globalThis.StepperManager) !==
                                      null &&
                                    _globalThis$StepperMa !==
                                      void 0 &&
                                    _globalThis$StepperMa.enabled
                                  ) {
                                    this.stepper =
                                      globalThis.StepperManager.create(
                                        this
                                          ._pageIndex
                                      );
                                    this.stepper.init(
                                      this
                                        .operatorList
                                    );
                                    this.stepper.nextBreakPoint =
                                      this.stepper.getNextBreakPoint();
                                  }

                                  var _this$params =
                                      this.params,
                                    canvasContext =
                                      _this$params.canvasContext,
                                    viewport =
                                      _this$params.viewport,
                                    transform =
                                      _this$params.transform,
                                    imageLayer =
                                      _this$params.imageLayer,
                                    background =
                                      _this$params.background;
                                  this.gfx =
                                    new _canvas.CanvasGraphics(
                                      canvasContext,
                                      this.commonObjs,
                                      this.objs,
                                      this.canvasFactory,
                                      this.webGLContext,
                                      imageLayer,
                                      optionalContentConfig
                                    );
                                  this.gfx.beginDrawing(
                                    {
                                      transform:
                                        transform,
                                      viewport:
                                        viewport,
                                      transparency:
                                        transparency,
                                      background:
                                        background,
                                    }
                                  );
                                  this.operatorListIdx = 0;
                                  this.graphicsReady = true;

                                  if (
                                    this
                                      .graphicsReadyCallback
                                  ) {
                                    this.graphicsReadyCallback();
                                  }
                                },
                            },
                            {
                              key: "cancel",
                              value:
                                function cancel() {
                                  var error =
                                    arguments.length >
                                      0 &&
                                    arguments[0] !==
                                      undefined
                                      ? arguments[0]
                                      : null;
                                  this.running = false;
                                  this.cancelled = true;

                                  if (this.gfx) {
                                    this.gfx.endDrawing();
                                  }

                                  if (
                                    this._canvas
                                  ) {
                                    canvasInRendering[
                                      "delete"
                                    ](
                                      this._canvas
                                    );
                                  }

                                  this.callback(
                                    error ||
                                      new _display_utils.RenderingCancelledException(
                                        "Rendering cancelled, page ".concat(
                                          this
                                            ._pageIndex +
                                            1
                                        ),
                                        "canvas"
                                      )
                                  );
                                },
                            },
                            {
                              key: "operatorListChanged",
                              value:
                                function operatorListChanged() {
                                  if (
                                    !this
                                      .graphicsReady
                                  ) {
                                    if (
                                      !this
                                        .graphicsReadyCallback
                                    ) {
                                      this.graphicsReadyCallback =
                                        this._continueBound;
                                    }

                                    return;
                                  }

                                  if (
                                    this.stepper
                                  ) {
                                    this.stepper.updateOperatorList(
                                      this
                                        .operatorList
                                    );
                                  }

                                  if (
                                    this.running
                                  ) {
                                    return;
                                  }

                                  this._continue();
                                },
                            },
                            {
                              key: "_continue",
                              value:
                                function _continue() {
                                  this.running = true;

                                  if (
                                    this.cancelled
                                  ) {
                                    return;
                                  }

                                  if (
                                    this.task
                                      .onContinue
                                  ) {
                                    this.task.onContinue(
                                      this
                                        ._scheduleNextBound
                                    );
                                  } else {
                                    this._scheduleNext();
                                  }
                                },
                            },
                            {
                              key: "_scheduleNext",
                              value:
                                function _scheduleNext() {
                                  var _this16 =
                                    this;

                                  if (
                                    this
                                      ._useRequestAnimationFrame
                                  ) {
                                    window.requestAnimationFrame(
                                      function () {
                                        _this16
                                          ._nextBound()
                                          [
                                            "catch"
                                          ](
                                            _this16.cancel.bind(
                                              _this16
                                            )
                                          );
                                      }
                                    );
                                  } else {
                                    Promise.resolve()
                                      .then(
                                        this
                                          ._nextBound
                                      )
                                      ["catch"](
                                        this.cancel.bind(
                                          this
                                        )
                                      );
                                  }
                                },
                            },
                            {
                              key: "_next",
                              value:
                                (function () {
                                  var _next2 =
                                    _asyncToGenerator(
                                      /*#__PURE__*/ _regenerator[
                                        "default"
                                      ].mark(
                                        function _callee2() {
                                          return _regenerator[
                                            "default"
                                          ].wrap(
                                            function _callee2$(
                                              _context2
                                            ) {
                                              while (
                                                1
                                              ) {
                                                switch (
                                                  (_context2.prev =
                                                    _context2.next)
                                                ) {
                                                  case 0:
                                                    if (
                                                      !this
                                                        .cancelled
                                                    ) {
                                                      _context2.next = 2;
                                                      break;
                                                    }

                                                    return _context2.abrupt(
                                                      "return"
                                                    );

                                                  case 2:
                                                    this.operatorListIdx =
                                                      this.gfx.executeOperatorList(
                                                        this
                                                          .operatorList,
                                                        this
                                                          .operatorListIdx,
                                                        this
                                                          ._continueBound,
                                                        this
                                                          .stepper
                                                      );

                                                    if (
                                                      this
                                                        .operatorListIdx ===
                                                      this
                                                        .operatorList
                                                        .argsArray
                                                        .length
                                                    ) {
                                                      this.running = false;

                                                      if (
                                                        this
                                                          .operatorList
                                                          .lastChunk
                                                      ) {
                                                        this.gfx.endDrawing();

                                                        if (
                                                          this
                                                            ._canvas
                                                        ) {
                                                          canvasInRendering[
                                                            "delete"
                                                          ](
                                                            this
                                                              ._canvas
                                                          );
                                                        }

                                                        this.callback();
                                                      }
                                                    }

                                                  case 4:
                                                  case "end":
                                                    return _context2.stop();
                                                }
                                              }
                                            },
                                            _callee2,
                                            this
                                          );
                                        }
                                      )
                                    );

                                  function _next() {
                                    return _next2.apply(
                                      this,
                                      arguments
                                    );
                                  }

                                  return _next;
                                })(),
                            },
                          ]
                        );

                        return InternalRenderTask;
                      })();

                    return InternalRenderTask;
                  })();

                var version = "2.8.164";
                exports.version = version;
                var build = "d37821610";
                exports.build = build;
                var putBinaryImageData =
                  _canvas.CanvasGraphics
                    .putBinaryImageData;
                exports.putBinaryImageData =
                  putBinaryImageData;

                /***/
              },
              /* 136 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.FontLoader =
                  exports.FontFaceObject = void 0;

                var _regenerator =
                  _interopRequireDefault(
                    __w_pdfjs_require__(2)
                  );

                var _util =
                  __w_pdfjs_require__(4);

                function _interopRequireDefault(
                  obj
                ) {
                  return obj && obj.__esModule
                    ? obj
                    : { default: obj };
                }

                function _inherits(
                  subClass,
                  superClass
                ) {
                  if (
                    typeof superClass !==
                      "function" &&
                    superClass !== null
                  ) {
                    throw new TypeError(
                      "Super expression must either be null or a function"
                    );
                  }
                  subClass.prototype =
                    Object.create(
                      superClass &&
                        superClass.prototype,
                      {
                        constructor: {
                          value: subClass,
                          writable: true,
                          configurable: true,
                        },
                      }
                    );
                  if (superClass)
                    _setPrototypeOf(
                      subClass,
                      superClass
                    );
                }

                function _setPrototypeOf(o, p) {
                  _setPrototypeOf =
                    Object.setPrototypeOf ||
                    function _setPrototypeOf(
                      o,
                      p
                    ) {
                      o.__proto__ = p;
                      return o;
                    };
                  return _setPrototypeOf(o, p);
                }

                function _createSuper(Derived) {
                  var hasNativeReflectConstruct =
                    _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super =
                        _getPrototypeOf(Derived),
                      result;
                    if (
                      hasNativeReflectConstruct
                    ) {
                      var NewTarget =
                        _getPrototypeOf(
                          this
                        ).constructor;
                      result = Reflect.construct(
                        Super,
                        arguments,
                        NewTarget
                      );
                    } else {
                      result = Super.apply(
                        this,
                        arguments
                      );
                    }
                    return _possibleConstructorReturn(
                      this,
                      result
                    );
                  };
                }

                function _possibleConstructorReturn(
                  self,
                  call
                ) {
                  if (
                    call &&
                    (_typeof(call) === "object" ||
                      typeof call === "function")
                  ) {
                    return call;
                  }
                  return _assertThisInitialized(
                    self
                  );
                }

                function _assertThisInitialized(
                  self
                ) {
                  if (self === void 0) {
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  }
                  return self;
                }

                function _isNativeReflectConstruct() {
                  if (
                    typeof Reflect ===
                      "undefined" ||
                    !Reflect.construct
                  )
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(
                      Reflect.construct(
                        Date,
                        [],
                        function () {}
                      )
                    );
                    return true;
                  } catch (e) {
                    return false;
                  }
                }

                function _getPrototypeOf(o) {
                  _getPrototypeOf =
                    Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function _getPrototypeOf(
                          o
                        ) {
                          return (
                            o.__proto__ ||
                            Object.getPrototypeOf(
                              o
                            )
                          );
                        };
                  return _getPrototypeOf(o);
                }

                function asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  key,
                  arg
                ) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(
                      _next,
                      _throw
                    );
                  }
                }

                function _asyncToGenerator(fn) {
                  return function () {
                    var self = this,
                      args = arguments;
                    return new Promise(function (
                      resolve,
                      reject
                    ) {
                      var gen = fn.apply(
                        self,
                        args
                      );
                      function _next(value) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "next",
                          value
                        );
                      }
                      function _throw(err) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "throw",
                          err
                        );
                      }
                      _next(undefined);
                    });
                  };
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var BaseFontLoader =
                  /*#__PURE__*/ (function () {
                    function BaseFontLoader(
                      _ref
                    ) {
                      var docId = _ref.docId,
                        onUnsupportedFeature =
                          _ref.onUnsupportedFeature,
                        _ref$ownerDocument =
                          _ref.ownerDocument,
                        ownerDocument =
                          _ref$ownerDocument ===
                          void 0
                            ? globalThis.document
                            : _ref$ownerDocument;

                      _classCallCheck(
                        this,
                        BaseFontLoader
                      );

                      if (
                        this.constructor ===
                        BaseFontLoader
                      ) {
                        (0, _util.unreachable)(
                          "Cannot initialize BaseFontLoader."
                        );
                      }

                      this.docId = docId;
                      this._onUnsupportedFeature =
                        onUnsupportedFeature;
                      this._document =
                        ownerDocument;
                      this.nativeFontFaces = [];
                      this.styleElement = null;
                    }

                    _createClass(BaseFontLoader, [
                      {
                        key: "addNativeFontFace",
                        value:
                          function addNativeFontFace(
                            nativeFontFace
                          ) {
                            this.nativeFontFaces.push(
                              nativeFontFace
                            );

                            this._document.fonts.add(
                              nativeFontFace
                            );
                          },
                      },
                      {
                        key: "insertRule",
                        value:
                          function insertRule(
                            rule
                          ) {
                            var styleElement =
                              this.styleElement;

                            if (!styleElement) {
                              styleElement =
                                this.styleElement =
                                  this._document.createElement(
                                    "style"
                                  );
                              styleElement.id =
                                "PDFJS_FONT_STYLE_TAG_".concat(
                                  this.docId
                                );

                              this._document.documentElement
                                .getElementsByTagName(
                                  "head"
                                )[0]
                                .appendChild(
                                  styleElement
                                );
                            }

                            var styleSheet =
                              styleElement.sheet;
                            styleSheet.insertRule(
                              rule,
                              styleSheet.cssRules
                                .length
                            );
                          },
                      },
                      {
                        key: "clear",
                        value: function clear() {
                          var _this = this;

                          this.nativeFontFaces.forEach(
                            function (
                              nativeFontFace
                            ) {
                              _this._document.fonts[
                                "delete"
                              ](nativeFontFace);
                            }
                          );
                          this.nativeFontFaces.length = 0;

                          if (this.styleElement) {
                            this.styleElement.remove();
                            this.styleElement =
                              null;
                          }
                        },
                      },
                      {
                        key: "bind",
                        value: (function () {
                          var _bind =
                            _asyncToGenerator(
                              /*#__PURE__*/ _regenerator[
                                "default"
                              ].mark(
                                function _callee(
                                  font
                                ) {
                                  var _this2 =
                                    this;

                                  var nativeFontFace,
                                    rule;
                                  return _regenerator[
                                    "default"
                                  ].wrap(
                                    function _callee$(
                                      _context
                                    ) {
                                      while (1) {
                                        switch (
                                          (_context.prev =
                                            _context.next)
                                        ) {
                                          case 0:
                                            if (
                                              !(
                                                font.attached ||
                                                font.missingFile
                                              )
                                            ) {
                                              _context.next = 2;
                                              break;
                                            }

                                            return _context.abrupt(
                                              "return"
                                            );

                                          case 2:
                                            font.attached = true;

                                            if (
                                              !this
                                                .isFontLoadingAPISupported
                                            ) {
                                              _context.next = 19;
                                              break;
                                            }

                                            nativeFontFace =
                                              font.createNativeFontFace();

                                            if (
                                              !nativeFontFace
                                            ) {
                                              _context.next = 18;
                                              break;
                                            }

                                            this.addNativeFontFace(
                                              nativeFontFace
                                            );
                                            _context.prev = 7;
                                            _context.next = 10;
                                            return nativeFontFace.loaded;

                                          case 10:
                                            _context.next = 18;
                                            break;

                                          case 12:
                                            _context.prev = 12;
                                            _context.t0 =
                                              _context[
                                                "catch"
                                              ](
                                                7
                                              );

                                            this._onUnsupportedFeature(
                                              {
                                                featureId:
                                                  _util
                                                    .UNSUPPORTED_FEATURES
                                                    .errorFontLoadNative,
                                              }
                                            );

                                            (0,
                                            _util.warn)(
                                              "Failed to load font '"
                                                .concat(
                                                  nativeFontFace.family,
                                                  "': '"
                                                )
                                                .concat(
                                                  _context.t0,
                                                  "'."
                                                )
                                            );
                                            font.disableFontFace = true;
                                            throw _context.t0;

                                          case 18:
                                            return _context.abrupt(
                                              "return"
                                            );

                                          case 19:
                                            rule =
                                              font.createFontFaceRule();

                                            if (
                                              !rule
                                            ) {
                                              _context.next = 26;
                                              break;
                                            }

                                            this.insertRule(
                                              rule
                                            );

                                            if (
                                              !this
                                                .isSyncFontLoadingSupported
                                            ) {
                                              _context.next = 24;
                                              break;
                                            }

                                            return _context.abrupt(
                                              "return"
                                            );

                                          case 24:
                                            _context.next = 26;
                                            return new Promise(
                                              function (
                                                resolve
                                              ) {
                                                var request =
                                                  _this2._queueLoadingCallback(
                                                    resolve
                                                  );

                                                _this2._prepareFontLoadEvent(
                                                  [
                                                    rule,
                                                  ],
                                                  [
                                                    font,
                                                  ],
                                                  request
                                                );
                                              }
                                            );

                                          case 26:
                                          case "end":
                                            return _context.stop();
                                        }
                                      }
                                    },
                                    _callee,
                                    this,
                                    [[7, 12]]
                                  );
                                }
                              )
                            );

                          function bind(_x) {
                            return _bind.apply(
                              this,
                              arguments
                            );
                          }

                          return bind;
                        })(),
                      },
                      {
                        key: "_queueLoadingCallback",
                        value:
                          function _queueLoadingCallback(
                            callback
                          ) {
                            (0,
                            _util.unreachable)(
                              "Abstract method `_queueLoadingCallback`."
                            );
                          },
                      },
                      {
                        key: "isFontLoadingAPISupported",
                        get: function get() {
                          var _this$_document;

                          return (0,
                          _util.shadow)(
                            this,
                            "isFontLoadingAPISupported",
                            !!(
                              (_this$_document =
                                this
                                  ._document) !==
                                null &&
                              _this$_document !==
                                void 0 &&
                              _this$_document.fonts
                            )
                          );
                        },
                      },
                      {
                        key: "isSyncFontLoadingSupported",
                        get: function get() {
                          (0, _util.unreachable)(
                            "Abstract method `isSyncFontLoadingSupported`."
                          );
                        },
                      },
                      {
                        key: "_loadTestFont",
                        get: function get() {
                          (0, _util.unreachable)(
                            "Abstract method `_loadTestFont`."
                          );
                        },
                      },
                      {
                        key: "_prepareFontLoadEvent",
                        value:
                          function _prepareFontLoadEvent(
                            rules,
                            fontsToLoad,
                            request
                          ) {
                            (0,
                            _util.unreachable)(
                              "Abstract method `_prepareFontLoadEvent`."
                            );
                          },
                      },
                    ]);

                    return BaseFontLoader;
                  })();

                var FontLoader;
                exports.FontLoader = FontLoader;
                {
                  exports.FontLoader =
                    FontLoader =
                      /*#__PURE__*/ (function (
                        _BaseFontLoader
                      ) {
                        _inherits(
                          GenericFontLoader,
                          _BaseFontLoader
                        );

                        var _super = _createSuper(
                          GenericFontLoader
                        );

                        function GenericFontLoader(
                          params
                        ) {
                          var _this3;

                          _classCallCheck(
                            this,
                            GenericFontLoader
                          );

                          _this3 = _super.call(
                            this,
                            params
                          );
                          _this3.loadingContext =
                            {
                              requests: [],
                              nextRequestId: 0,
                            };
                          _this3.loadTestFontId = 0;
                          return _this3;
                        }

                        _createClass(
                          GenericFontLoader,
                          [
                            {
                              key: "isSyncFontLoadingSupported",
                              get: function get() {
                                var supported = false;

                                if (
                                  typeof navigator ===
                                  "undefined"
                                ) {
                                  supported = true;
                                } else {
                                  var m =
                                    /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(
                                      navigator.userAgent
                                    );

                                  if (
                                    (m === null ||
                                    m === void 0
                                      ? void 0
                                      : m[1]) >=
                                    14
                                  ) {
                                    supported = true;
                                  }
                                }

                                return (0,
                                _util.shadow)(
                                  this,
                                  "isSyncFontLoadingSupported",
                                  supported
                                );
                              },
                            },
                            {
                              key: "_queueLoadingCallback",
                              value:
                                function _queueLoadingCallback(
                                  callback
                                ) {
                                  function completeRequest() {
                                    (0,
                                    _util.assert)(
                                      !request.done,
                                      "completeRequest() cannot be called twice."
                                    );
                                    request.done = true;

                                    while (
                                      context
                                        .requests
                                        .length >
                                        0 &&
                                      context
                                        .requests[0]
                                        .done
                                    ) {
                                      var otherRequest =
                                        context.requests.shift();
                                      setTimeout(
                                        otherRequest.callback,
                                        0
                                      );
                                    }
                                  }

                                  var context =
                                    this
                                      .loadingContext;
                                  var request = {
                                    id: "pdfjs-font-loading-".concat(
                                      context.nextRequestId++
                                    ),
                                    done: false,
                                    complete:
                                      completeRequest,
                                    callback:
                                      callback,
                                  };
                                  context.requests.push(
                                    request
                                  );
                                  return request;
                                },
                            },
                            {
                              key: "_loadTestFont",
                              get: function get() {
                                var getLoadTestFont =
                                  function getLoadTestFont() {
                                    return atob(
                                      "T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" +
                                        "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" +
                                        "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" +
                                        "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" +
                                        "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" +
                                        "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" +
                                        "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" +
                                        "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" +
                                        "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" +
                                        "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" +
                                        "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" +
                                        "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" +
                                        "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
                                        "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
                                        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
                                        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
                                        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
                                        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" +
                                        "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" +
                                        "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" +
                                        "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" +
                                        "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="
                                    );
                                  };

                                return (0,
                                _util.shadow)(
                                  this,
                                  "_loadTestFont",
                                  getLoadTestFont()
                                );
                              },
                            },
                            {
                              key: "_prepareFontLoadEvent",
                              value:
                                function _prepareFontLoadEvent(
                                  rules,
                                  fonts,
                                  request
                                ) {
                                  var _this4 =
                                    this;

                                  function int32(
                                    data,
                                    offset
                                  ) {
                                    return (
                                      (data.charCodeAt(
                                        offset
                                      ) <<
                                        24) |
                                      (data.charCodeAt(
                                        offset + 1
                                      ) <<
                                        16) |
                                      (data.charCodeAt(
                                        offset + 2
                                      ) <<
                                        8) |
                                      (data.charCodeAt(
                                        offset + 3
                                      ) &
                                        0xff)
                                    );
                                  }

                                  function spliceString(
                                    s,
                                    offset,
                                    remove,
                                    insert
                                  ) {
                                    var chunk1 =
                                      s.substring(
                                        0,
                                        offset
                                      );
                                    var chunk2 =
                                      s.substring(
                                        offset +
                                          remove
                                      );
                                    return (
                                      chunk1 +
                                      insert +
                                      chunk2
                                    );
                                  }

                                  var i, ii;

                                  var canvas =
                                    this._document.createElement(
                                      "canvas"
                                    );

                                  canvas.width = 1;
                                  canvas.height = 1;
                                  var ctx =
                                    canvas.getContext(
                                      "2d"
                                    );
                                  var called = 0;

                                  function isFontReady(
                                    name,
                                    callback
                                  ) {
                                    called++;

                                    if (
                                      called > 30
                                    ) {
                                      (0,
                                      _util.warn)(
                                        "Load test font never loaded."
                                      );
                                      callback();
                                      return;
                                    }

                                    ctx.font =
                                      "30px " +
                                      name;
                                    ctx.fillText(
                                      ".",
                                      0,
                                      20
                                    );
                                    var imageData =
                                      ctx.getImageData(
                                        0,
                                        0,
                                        1,
                                        1
                                      );

                                    if (
                                      imageData
                                        .data[3] >
                                      0
                                    ) {
                                      callback();
                                      return;
                                    }

                                    setTimeout(
                                      isFontReady.bind(
                                        null,
                                        name,
                                        callback
                                      )
                                    );
                                  }

                                  var loadTestFontId =
                                    "lt"
                                      .concat(
                                        Date.now()
                                      )
                                      .concat(
                                        this
                                          .loadTestFontId++
                                      );
                                  var data =
                                    this
                                      ._loadTestFont;
                                  var COMMENT_OFFSET = 976;
                                  data =
                                    spliceString(
                                      data,
                                      COMMENT_OFFSET,
                                      loadTestFontId.length,
                                      loadTestFontId
                                    );
                                  var CFF_CHECKSUM_OFFSET = 16;
                                  var XXXX_VALUE = 0x58585858;
                                  var checksum =
                                    int32(
                                      data,
                                      CFF_CHECKSUM_OFFSET
                                    );

                                  for (
                                    i = 0,
                                      ii =
                                        loadTestFontId.length -
                                        3;
                                    i < ii;
                                    i += 4
                                  ) {
                                    checksum =
                                      (checksum -
                                        XXXX_VALUE +
                                        int32(
                                          loadTestFontId,
                                          i
                                        )) |
                                      0;
                                  }

                                  if (
                                    i <
                                    loadTestFontId.length
                                  ) {
                                    checksum =
                                      (checksum -
                                        XXXX_VALUE +
                                        int32(
                                          loadTestFontId +
                                            "XXX",
                                          i
                                        )) |
                                      0;
                                  }

                                  data =
                                    spliceString(
                                      data,
                                      CFF_CHECKSUM_OFFSET,
                                      4,
                                      (0,
                                      _util.string32)(
                                        checksum
                                      )
                                    );
                                  var url =
                                    "url(data:font/opentype;base64,".concat(
                                      btoa(data),
                                      ");"
                                    );
                                  var rule =
                                    '@font-face {font-family:"'
                                      .concat(
                                        loadTestFontId,
                                        '";src:'
                                      )
                                      .concat(
                                        url,
                                        "}"
                                      );
                                  this.insertRule(
                                    rule
                                  );
                                  var names = [];

                                  for (
                                    i = 0,
                                      ii =
                                        fonts.length;
                                    i < ii;
                                    i++
                                  ) {
                                    names.push(
                                      fonts[i]
                                        .loadedName
                                    );
                                  }

                                  names.push(
                                    loadTestFontId
                                  );

                                  var div =
                                    this._document.createElement(
                                      "div"
                                    );

                                  div.style.visibility =
                                    "hidden";
                                  div.style.width =
                                    div.style.height =
                                      "10px";
                                  div.style.position =
                                    "absolute";
                                  div.style.top =
                                    div.style.left =
                                      "0px";

                                  for (
                                    i = 0,
                                      ii =
                                        names.length;
                                    i < ii;
                                    ++i
                                  ) {
                                    var span =
                                      this._document.createElement(
                                        "span"
                                      );

                                    span.textContent =
                                      "Hi";
                                    span.style.fontFamily =
                                      names[i];
                                    div.appendChild(
                                      span
                                    );
                                  }

                                  this._document.body.appendChild(
                                    div
                                  );

                                  isFontReady(
                                    loadTestFontId,
                                    function () {
                                      _this4._document.body.removeChild(
                                        div
                                      );

                                      request.complete();
                                    }
                                  );
                                },
                            },
                          ]
                        );

                        return GenericFontLoader;
                      })(BaseFontLoader);
                }

                var FontFaceObject =
                  /*#__PURE__*/ (function () {
                    function FontFaceObject(
                      translatedData,
                      _ref2
                    ) {
                      var _ref2$isEvalSupported =
                          _ref2.isEvalSupported,
                        isEvalSupported =
                          _ref2$isEvalSupported ===
                          void 0
                            ? true
                            : _ref2$isEvalSupported,
                        _ref2$disableFontFace =
                          _ref2.disableFontFace,
                        disableFontFace =
                          _ref2$disableFontFace ===
                          void 0
                            ? false
                            : _ref2$disableFontFace,
                        _ref2$ignoreErrors =
                          _ref2.ignoreErrors,
                        ignoreErrors =
                          _ref2$ignoreErrors ===
                          void 0
                            ? false
                            : _ref2$ignoreErrors,
                        onUnsupportedFeature =
                          _ref2.onUnsupportedFeature,
                        _ref2$fontRegistry =
                          _ref2.fontRegistry,
                        fontRegistry =
                          _ref2$fontRegistry ===
                          void 0
                            ? null
                            : _ref2$fontRegistry;

                      _classCallCheck(
                        this,
                        FontFaceObject
                      );

                      this.compiledGlyphs =
                        Object.create(null);

                      for (var i in translatedData) {
                        this[i] =
                          translatedData[i];
                      }

                      this.isEvalSupported =
                        isEvalSupported !== false;
                      this.disableFontFace =
                        disableFontFace === true;
                      this.ignoreErrors =
                        ignoreErrors === true;
                      this._onUnsupportedFeature =
                        onUnsupportedFeature;
                      this.fontRegistry =
                        fontRegistry;
                    }

                    _createClass(FontFaceObject, [
                      {
                        key: "createNativeFontFace",
                        value:
                          function createNativeFontFace() {
                            if (
                              !this.data ||
                              this.disableFontFace
                            ) {
                              return null;
                            }

                            var nativeFontFace =
                              new FontFace(
                                this.loadedName,
                                this.data,
                                {}
                              );

                            if (
                              this.fontRegistry
                            ) {
                              this.fontRegistry.registerFont(
                                this
                              );
                            }

                            return nativeFontFace;
                          },
                      },
                      {
                        key: "createFontFaceRule",
                        value:
                          function createFontFaceRule() {
                            if (
                              !this.data ||
                              this.disableFontFace
                            ) {
                              return null;
                            }

                            var data = (0,
                            _util.bytesToString)(
                              new Uint8Array(
                                this.data
                              )
                            );
                            var url = "url(data:"
                              .concat(
                                this.mimetype,
                                ";base64,"
                              )
                              .concat(
                                btoa(data),
                                ");"
                              );
                            var rule =
                              '@font-face {font-family:"'
                                .concat(
                                  this.loadedName,
                                  '";src:'
                                )
                                .concat(url, "}");

                            if (
                              this.fontRegistry
                            ) {
                              this.fontRegistry.registerFont(
                                this,
                                url
                              );
                            }

                            return rule;
                          },
                      },
                      {
                        key: "getPathGenerator",
                        value:
                          function getPathGenerator(
                            objs,
                            character
                          ) {
                            if (
                              this.compiledGlyphs[
                                character
                              ] !== undefined
                            ) {
                              return this
                                .compiledGlyphs[
                                character
                              ];
                            }

                            var cmds, current;

                            try {
                              cmds = objs.get(
                                this.loadedName +
                                  "_path_" +
                                  character
                              );
                            } catch (ex) {
                              if (
                                !this.ignoreErrors
                              ) {
                                throw ex;
                              }

                              this._onUnsupportedFeature(
                                {
                                  featureId:
                                    _util
                                      .UNSUPPORTED_FEATURES
                                      .errorFontGetPath,
                                }
                              );

                              (0, _util.warn)(
                                'getPathGenerator - ignoring character: "'.concat(
                                  ex,
                                  '".'
                                )
                              );
                              return (this.compiledGlyphs[
                                character
                              ] = null);
                            }

                            if (
                              this
                                .isEvalSupported &&
                              _util
                                .IsEvalSupportedCached
                                .value
                            ) {
                              var args,
                                js = "";

                              for (
                                var i = 0,
                                  ii =
                                    cmds.length;
                                i < ii;
                                i++
                              ) {
                                current = cmds[i];

                                if (
                                  current.args !==
                                  undefined
                                ) {
                                  args =
                                    current.args.join(
                                      ","
                                    );
                                } else {
                                  args = "";
                                }

                                js +=
                                  "c." +
                                  current.cmd +
                                  "(" +
                                  args +
                                  ");\n";
                              }

                              return (this.compiledGlyphs[
                                character
                              ] = new Function(
                                "c",
                                "size",
                                js
                              ));
                            }

                            return (this.compiledGlyphs[
                              character
                            ] = function (
                              c,
                              size
                            ) {
                              for (
                                var _i = 0,
                                  _ii =
                                    cmds.length;
                                _i < _ii;
                                _i++
                              ) {
                                current =
                                  cmds[_i];

                                if (
                                  current.cmd ===
                                  "scale"
                                ) {
                                  current.args = [
                                    size,
                                    -size,
                                  ];
                                }

                                c[
                                  current.cmd
                                ].apply(
                                  c,
                                  current.args
                                );
                              }
                            });
                          },
                      },
                    ]);

                    return FontFaceObject;
                  })();

                exports.FontFaceObject =
                  FontFaceObject;

                /***/
              },
              /* 137 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.NodeCMapReaderFactory =
                  exports.NodeCanvasFactory =
                    void 0;

                var _display_utils =
                  __w_pdfjs_require__(1);

                var _is_node =
                  __w_pdfjs_require__(6);

                var _util =
                  __w_pdfjs_require__(4);

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                function _inherits(
                  subClass,
                  superClass
                ) {
                  if (
                    typeof superClass !==
                      "function" &&
                    superClass !== null
                  ) {
                    throw new TypeError(
                      "Super expression must either be null or a function"
                    );
                  }
                  subClass.prototype =
                    Object.create(
                      superClass &&
                        superClass.prototype,
                      {
                        constructor: {
                          value: subClass,
                          writable: true,
                          configurable: true,
                        },
                      }
                    );
                  if (superClass)
                    _setPrototypeOf(
                      subClass,
                      superClass
                    );
                }

                function _setPrototypeOf(o, p) {
                  _setPrototypeOf =
                    Object.setPrototypeOf ||
                    function _setPrototypeOf(
                      o,
                      p
                    ) {
                      o.__proto__ = p;
                      return o;
                    };
                  return _setPrototypeOf(o, p);
                }

                function _createSuper(Derived) {
                  var hasNativeReflectConstruct =
                    _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super =
                        _getPrototypeOf(Derived),
                      result;
                    if (
                      hasNativeReflectConstruct
                    ) {
                      var NewTarget =
                        _getPrototypeOf(
                          this
                        ).constructor;
                      result = Reflect.construct(
                        Super,
                        arguments,
                        NewTarget
                      );
                    } else {
                      result = Super.apply(
                        this,
                        arguments
                      );
                    }
                    return _possibleConstructorReturn(
                      this,
                      result
                    );
                  };
                }

                function _possibleConstructorReturn(
                  self,
                  call
                ) {
                  if (
                    call &&
                    (_typeof(call) === "object" ||
                      typeof call === "function")
                  ) {
                    return call;
                  }
                  return _assertThisInitialized(
                    self
                  );
                }

                function _assertThisInitialized(
                  self
                ) {
                  if (self === void 0) {
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  }
                  return self;
                }

                function _isNativeReflectConstruct() {
                  if (
                    typeof Reflect ===
                      "undefined" ||
                    !Reflect.construct
                  )
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(
                      Reflect.construct(
                        Date,
                        [],
                        function () {}
                      )
                    );
                    return true;
                  } catch (e) {
                    return false;
                  }
                }

                function _getPrototypeOf(o) {
                  _getPrototypeOf =
                    Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function _getPrototypeOf(
                          o
                        ) {
                          return (
                            o.__proto__ ||
                            Object.getPrototypeOf(
                              o
                            )
                          );
                        };
                  return _getPrototypeOf(o);
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                var NodeCanvasFactory =
                  function NodeCanvasFactory() {
                    _classCallCheck(
                      this,
                      NodeCanvasFactory
                    );

                    (0, _util.unreachable)(
                      "Not implemented: NodeCanvasFactory"
                    );
                  };

                exports.NodeCanvasFactory =
                  NodeCanvasFactory;

                var NodeCMapReaderFactory =
                  function NodeCMapReaderFactory() {
                    _classCallCheck(
                      this,
                      NodeCMapReaderFactory
                    );

                    (0, _util.unreachable)(
                      "Not implemented: NodeCMapReaderFactory"
                    );
                  };

                exports.NodeCMapReaderFactory =
                  NodeCMapReaderFactory;

                if (_is_node.isNodeJS) {
                  exports.NodeCanvasFactory =
                    NodeCanvasFactory =
                      /*#__PURE__*/ (function (
                        _BaseCanvasFactory
                      ) {
                        _inherits(
                          NodeCanvasFactory,
                          _BaseCanvasFactory
                        );

                        var _super = _createSuper(
                          NodeCanvasFactory
                        );

                        function NodeCanvasFactory() {
                          _classCallCheck(
                            this,
                            NodeCanvasFactory
                          );

                          return _super.apply(
                            this,
                            arguments
                          );
                        }

                        _createClass(
                          NodeCanvasFactory,
                          [
                            {
                              key: "create",
                              value:
                                function create(
                                  width,
                                  height
                                ) {
                                  if (
                                    width <= 0 ||
                                    height <= 0
                                  ) {
                                    throw new Error(
                                      "Invalid canvas size"
                                    );
                                  }

                                  var Canvas =
                                    __webpack_require__(
                                      /*! canvas */ "?97a1"
                                    );

                                  var canvas =
                                    Canvas.createCanvas(
                                      width,
                                      height
                                    );
                                  return {
                                    canvas:
                                      canvas,
                                    context:
                                      canvas.getContext(
                                        "2d"
                                      ),
                                  };
                                },
                            },
                          ]
                        );

                        return NodeCanvasFactory;
                      })(
                        _display_utils.BaseCanvasFactory
                      );

                  exports.NodeCMapReaderFactory =
                    NodeCMapReaderFactory =
                      /*#__PURE__*/ (function (
                        _BaseCMapReaderFactor
                      ) {
                        _inherits(
                          NodeCMapReaderFactory,
                          _BaseCMapReaderFactor
                        );

                        var _super2 =
                          _createSuper(
                            NodeCMapReaderFactory
                          );

                        function NodeCMapReaderFactory() {
                          _classCallCheck(
                            this,
                            NodeCMapReaderFactory
                          );

                          return _super2.apply(
                            this,
                            arguments
                          );
                        }

                        _createClass(
                          NodeCMapReaderFactory,
                          [
                            {
                              key: "_fetchData",
                              value:
                                function _fetchData(
                                  url,
                                  compressionType
                                ) {
                                  return new Promise(
                                    function (
                                      resolve,
                                      reject
                                    ) {
                                      var fs =
                                        __webpack_require__(
                                          /*! fs */ "?6e49"
                                        );

                                      fs.readFile(
                                        url,
                                        function (
                                          error,
                                          data
                                        ) {
                                          if (
                                            error ||
                                            !data
                                          ) {
                                            reject(
                                              new Error(
                                                error
                                              )
                                            );
                                            return;
                                          }

                                          resolve(
                                            {
                                              cMapData:
                                                new Uint8Array(
                                                  data
                                                ),
                                              compressionType:
                                                compressionType,
                                            }
                                          );
                                        }
                                      );
                                    }
                                  );
                                },
                            },
                          ]
                        );

                        return NodeCMapReaderFactory;
                      })(
                        _display_utils.BaseCMapReaderFactory
                      );
                }

                /***/
              },
              /* 138 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.AnnotationStorage =
                  void 0;

                var _util =
                  __w_pdfjs_require__(4);

                function _slicedToArray(arr, i) {
                  return (
                    _arrayWithHoles(arr) ||
                    _iterableToArrayLimit(
                      arr,
                      i
                    ) ||
                    _unsupportedIterableToArray(
                      arr,
                      i
                    ) ||
                    _nonIterableRest()
                  );
                }

                function _nonIterableRest() {
                  throw new TypeError(
                    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _iterableToArrayLimit(
                  arr,
                  i
                ) {
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    !(
                      Symbol.iterator in
                      Object(arr)
                    )
                  )
                    return;
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (
                      var _i =
                          arr[Symbol.iterator](),
                        _s;
                      !(_n = (_s = _i.next())
                        .done);
                      _n = true
                    ) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (
                        !_n &&
                        _i["return"] != null
                      )
                        _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }

                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var AnnotationStorage =
                  /*#__PURE__*/ (function () {
                    function AnnotationStorage() {
                      _classCallCheck(
                        this,
                        AnnotationStorage
                      );

                      this._storage = new Map();
                      this._modified = false;
                      this.onSetModified = null;
                      this.onResetModified = null;
                    }

                    _createClass(
                      AnnotationStorage,
                      [
                        {
                          key: "getOrCreateValue",
                          value:
                            function getOrCreateValue(
                              key,
                              defaultValue
                            ) {
                              if (
                                this._storage.has(
                                  key
                                )
                              ) {
                                return this._storage.get(
                                  key
                                );
                              }

                              this._storage.set(
                                key,
                                defaultValue
                              );

                              return defaultValue;
                            },
                        },
                        {
                          key: "setValue",
                          value:
                            function setValue(
                              key,
                              value
                            ) {
                              var obj =
                                this._storage.get(
                                  key
                                );

                              var modified = false;

                              if (
                                obj !== undefined
                              ) {
                                for (
                                  var _i = 0,
                                    _Object$entries =
                                      Object.entries(
                                        value
                                      );
                                  _i <
                                  _Object$entries.length;
                                  _i++
                                ) {
                                  var _Object$entries$_i =
                                      _slicedToArray(
                                        _Object$entries[
                                          _i
                                        ],
                                        2
                                      ),
                                    entry =
                                      _Object$entries$_i[0],
                                    val =
                                      _Object$entries$_i[1];

                                  if (
                                    obj[entry] !==
                                    val
                                  ) {
                                    modified = true;
                                    obj[entry] =
                                      val;
                                  }
                                }
                              } else {
                                this._storage.set(
                                  key,
                                  value
                                );

                                modified = true;
                              }

                              if (modified) {
                                this._setModified();
                              }
                            },
                        },
                        {
                          key: "getAll",
                          value:
                            function getAll() {
                              if (
                                this._storage
                                  .size === 0
                              ) {
                                return null;
                              }

                              return (0,
                              _util.objectFromEntries)(
                                this._storage
                              );
                            },
                        },
                        {
                          key: "size",
                          get: function get() {
                            return this._storage
                              .size;
                          },
                        },
                        {
                          key: "_setModified",
                          value:
                            function _setModified() {
                              if (
                                !this._modified
                              ) {
                                this._modified = true;

                                if (
                                  typeof this
                                    .onSetModified ===
                                  "function"
                                ) {
                                  this.onSetModified();
                                }
                              }
                            },
                        },
                        {
                          key: "resetModified",
                          value:
                            function resetModified() {
                              if (
                                this._modified
                              ) {
                                this._modified = false;

                                if (
                                  typeof this
                                    .onResetModified ===
                                  "function"
                                ) {
                                  this.onResetModified();
                                }
                              }
                            },
                        },
                      ]
                    );

                    return AnnotationStorage;
                  })();

                exports.AnnotationStorage =
                  AnnotationStorage;

                /***/
              },
              /* 139 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.apiCompatibilityParams =
                  void 0;

                var _is_node =
                  __w_pdfjs_require__(6);

                var compatibilityParams =
                  Object.create(null);
                {
                  (function checkFontFace() {
                    if (_is_node.isNodeJS) {
                      compatibilityParams.disableFontFace = true;
                    }
                  })();
                }
                var apiCompatibilityParams =
                  Object.freeze(
                    compatibilityParams
                  );
                exports.apiCompatibilityParams =
                  apiCompatibilityParams;

                /***/
              },
              /* 140 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.CanvasGraphics = void 0;

                var _util =
                  __w_pdfjs_require__(4);

                var _pattern_helper =
                  __w_pdfjs_require__(141);

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                function _createForOfIteratorHelper(
                  o,
                  allowArrayLike
                ) {
                  var it;
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    o[Symbol.iterator] == null
                  ) {
                    if (
                      Array.isArray(o) ||
                      (it =
                        _unsupportedIterableToArray(
                          o
                        )) ||
                      (allowArrayLike &&
                        o &&
                        typeof o.length ===
                          "number")
                    ) {
                      if (it) o = it;
                      var i = 0;
                      var F = function F() {};
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return { done: true };
                          return {
                            done: false,
                            value: o[i++],
                          };
                        },
                        e: function e(_e) {
                          throw _e;
                        },
                        f: F,
                      };
                    }
                    throw new TypeError(
                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  }
                  var normalCompletion = true,
                    didErr = false,
                    err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion =
                        step.done;
                      return step;
                    },
                    e: function e(_e2) {
                      didErr = true;
                      err = _e2;
                    },
                    f: function f() {
                      try {
                        if (
                          !normalCompletion &&
                          it["return"] != null
                        )
                          it["return"]();
                      } finally {
                        if (didErr) throw err;
                      }
                    },
                  };
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                var MIN_FONT_SIZE = 16;
                var MAX_FONT_SIZE = 100;
                var MAX_GROUP_SIZE = 4096;
                var COMPILE_TYPE3_GLYPHS = false;
                var MAX_SIZE_TO_COMPILE = 1000;
                var FULL_CHUNK_HEIGHT = 16;

                function addContextCurrentTransform(
                  ctx
                ) {
                  if (!ctx.mozCurrentTransform) {
                    ctx._originalSave = ctx.save;
                    ctx._originalRestore =
                      ctx.restore;
                    ctx._originalRotate =
                      ctx.rotate;
                    ctx._originalScale =
                      ctx.scale;
                    ctx._originalTranslate =
                      ctx.translate;
                    ctx._originalTransform =
                      ctx.transform;
                    ctx._originalSetTransform =
                      ctx.setTransform;
                    ctx._transformMatrix =
                      ctx._transformMatrix || [
                        1, 0, 0, 1, 0, 0,
                      ];
                    ctx._transformStack = [];
                    Object.defineProperty(
                      ctx,
                      "mozCurrentTransform",
                      {
                        get: function getCurrentTransform() {
                          return this
                            ._transformMatrix;
                        },
                      }
                    );
                    Object.defineProperty(
                      ctx,
                      "mozCurrentTransformInverse",
                      {
                        get: function getCurrentTransformInverse() {
                          var m =
                            this._transformMatrix;
                          var a = m[0],
                            b = m[1],
                            c = m[2],
                            d = m[3],
                            e = m[4],
                            f = m[5];
                          var ad_bc =
                            a * d - b * c;
                          var bc_ad =
                            b * c - a * d;
                          return [
                            d / ad_bc,
                            b / bc_ad,
                            c / bc_ad,
                            a / ad_bc,
                            (d * e - c * f) /
                              bc_ad,
                            (b * e - a * f) /
                              ad_bc,
                          ];
                        },
                      }
                    );

                    ctx.save =
                      function ctxSave() {
                        var old =
                          this._transformMatrix;

                        this._transformStack.push(
                          old
                        );

                        this._transformMatrix =
                          old.slice(0, 6);

                        this._originalSave();
                      };

                    ctx.restore =
                      function ctxRestore() {
                        var prev =
                          this._transformStack.pop();

                        if (prev) {
                          this._transformMatrix =
                            prev;

                          this._originalRestore();
                        }
                      };

                    ctx.translate =
                      function ctxTranslate(
                        x,
                        y
                      ) {
                        var m =
                          this._transformMatrix;
                        m[4] =
                          m[0] * x +
                          m[2] * y +
                          m[4];
                        m[5] =
                          m[1] * x +
                          m[3] * y +
                          m[5];

                        this._originalTranslate(
                          x,
                          y
                        );
                      };

                    ctx.scale = function ctxScale(
                      x,
                      y
                    ) {
                      var m =
                        this._transformMatrix;
                      m[0] = m[0] * x;
                      m[1] = m[1] * x;
                      m[2] = m[2] * y;
                      m[3] = m[3] * y;

                      this._originalScale(x, y);
                    };

                    ctx.transform =
                      function ctxTransform(
                        a,
                        b,
                        c,
                        d,
                        e,
                        f
                      ) {
                        var m =
                          this._transformMatrix;
                        this._transformMatrix = [
                          m[0] * a + m[2] * b,
                          m[1] * a + m[3] * b,
                          m[0] * c + m[2] * d,
                          m[1] * c + m[3] * d,
                          m[0] * e +
                            m[2] * f +
                            m[4],
                          m[1] * e +
                            m[3] * f +
                            m[5],
                        ];

                        ctx._originalTransform(
                          a,
                          b,
                          c,
                          d,
                          e,
                          f
                        );
                      };

                    ctx.setTransform =
                      function ctxSetTransform(
                        a,
                        b,
                        c,
                        d,
                        e,
                        f
                      ) {
                        this._transformMatrix = [
                          a,
                          b,
                          c,
                          d,
                          e,
                          f,
                        ];

                        ctx._originalSetTransform(
                          a,
                          b,
                          c,
                          d,
                          e,
                          f
                        );
                      };

                    ctx.rotate =
                      function ctxRotate(angle) {
                        var cosValue =
                          Math.cos(angle);
                        var sinValue =
                          Math.sin(angle);
                        var m =
                          this._transformMatrix;
                        this._transformMatrix = [
                          m[0] * cosValue +
                            m[2] * sinValue,
                          m[1] * cosValue +
                            m[3] * sinValue,
                          m[0] * -sinValue +
                            m[2] * cosValue,
                          m[1] * -sinValue +
                            m[3] * cosValue,
                          m[4],
                          m[5],
                        ];

                        this._originalRotate(
                          angle
                        );
                      };
                  }
                }

                var CachedCanvases =
                  (function CachedCanvasesClosure() {
                    function CachedCanvases(
                      canvasFactory
                    ) {
                      this.canvasFactory =
                        canvasFactory;
                      this.cache =
                        Object.create(null);
                    }

                    CachedCanvases.prototype = {
                      getCanvas:
                        function CachedCanvases_getCanvas(
                          id,
                          width,
                          height,
                          trackTransform
                        ) {
                          var canvasEntry;

                          if (
                            this.cache[id] !==
                            undefined
                          ) {
                            canvasEntry =
                              this.cache[id];
                            this.canvasFactory.reset(
                              canvasEntry,
                              width,
                              height
                            );
                            canvasEntry.context.setTransform(
                              1,
                              0,
                              0,
                              1,
                              0,
                              0
                            );
                          } else {
                            canvasEntry =
                              this.canvasFactory.create(
                                width,
                                height
                              );
                            this.cache[id] =
                              canvasEntry;
                          }

                          if (trackTransform) {
                            addContextCurrentTransform(
                              canvasEntry.context
                            );
                          }

                          return canvasEntry;
                        },
                      clear: function clear() {
                        for (var id in this
                          .cache) {
                          var canvasEntry =
                            this.cache[id];
                          this.canvasFactory.destroy(
                            canvasEntry
                          );
                          delete this.cache[id];
                        }
                      },
                    };
                    return CachedCanvases;
                  })();

                function compileType3Glyph(
                  imgData
                ) {
                  var POINT_TO_PROCESS_LIMIT = 1000;
                  var width = imgData.width,
                    height = imgData.height,
                    width1 = width + 1;
                  var i, ii, j, j0;
                  var points = new Uint8Array(
                    width1 * (height + 1)
                  );
                  var POINT_TYPES =
                    new Uint8Array([
                      0, 2, 4, 0, 1, 0, 5, 4, 8,
                      10, 0, 8, 0, 2, 1, 0,
                    ]);
                  var lineSize = (width + 7) & ~7,
                    data0 = imgData.data;
                  var data = new Uint8Array(
                    lineSize * height
                  );
                  var pos = 0;

                  for (
                    i = 0, ii = data0.length;
                    i < ii;
                    i++
                  ) {
                    var elem = data0[i];
                    var mask = 128;

                    while (mask > 0) {
                      data[pos++] =
                        elem & mask ? 0 : 255;
                      mask >>= 1;
                    }
                  }

                  var count = 0;
                  pos = 0;

                  if (data[pos] !== 0) {
                    points[0] = 1;
                    ++count;
                  }

                  for (j = 1; j < width; j++) {
                    if (
                      data[pos] !== data[pos + 1]
                    ) {
                      points[j] = data[pos]
                        ? 2
                        : 1;
                      ++count;
                    }

                    pos++;
                  }

                  if (data[pos] !== 0) {
                    points[j] = 2;
                    ++count;
                  }

                  for (i = 1; i < height; i++) {
                    pos = i * lineSize;
                    j0 = i * width1;

                    if (
                      data[pos - lineSize] !==
                      data[pos]
                    ) {
                      points[j0] = data[pos]
                        ? 1
                        : 8;
                      ++count;
                    }

                    var sum =
                      (data[pos] ? 4 : 0) +
                      (data[pos - lineSize]
                        ? 8
                        : 0);

                    for (j = 1; j < width; j++) {
                      sum =
                        (sum >> 2) +
                        (data[pos + 1] ? 4 : 0) +
                        (data[pos - lineSize + 1]
                          ? 8
                          : 0);

                      if (POINT_TYPES[sum]) {
                        points[j0 + j] =
                          POINT_TYPES[sum];
                        ++count;
                      }

                      pos++;
                    }

                    if (
                      data[pos - lineSize] !==
                      data[pos]
                    ) {
                      points[j0 + j] = data[pos]
                        ? 2
                        : 4;
                      ++count;
                    }

                    if (
                      count >
                      POINT_TO_PROCESS_LIMIT
                    ) {
                      return null;
                    }
                  }

                  pos = lineSize * (height - 1);
                  j0 = i * width1;

                  if (data[pos] !== 0) {
                    points[j0] = 8;
                    ++count;
                  }

                  for (j = 1; j < width; j++) {
                    if (
                      data[pos] !== data[pos + 1]
                    ) {
                      points[j0 + j] = data[pos]
                        ? 4
                        : 8;
                      ++count;
                    }

                    pos++;
                  }

                  if (data[pos] !== 0) {
                    points[j0 + j] = 4;
                    ++count;
                  }

                  if (
                    count > POINT_TO_PROCESS_LIMIT
                  ) {
                    return null;
                  }

                  var steps = new Int32Array([
                    0,
                    width1,
                    -1,
                    0,
                    -width1,
                    0,
                    0,
                    0,
                    1,
                  ]);
                  var outlines = [];

                  for (
                    i = 0;
                    count && i <= height;
                    i++
                  ) {
                    var p = i * width1;
                    var end = p + width;

                    while (
                      p < end &&
                      !points[p]
                    ) {
                      p++;
                    }

                    if (p === end) {
                      continue;
                    }

                    var coords = [p % width1, i];
                    var p0 = p;
                    var type = points[p];

                    do {
                      var step = steps[type];

                      do {
                        p += step;
                      } while (!points[p]);

                      var pp = points[p];

                      if (pp !== 5 && pp !== 10) {
                        type = pp;
                        points[p] = 0;
                      } else {
                        type =
                          pp &
                          ((0x33 * type) >> 4);
                        points[p] &=
                          (type >> 2) |
                          (type << 2);
                      }

                      coords.push(p % width1);
                      coords.push(
                        (p / width1) | 0
                      );

                      if (!points[p]) {
                        --count;
                      }
                    } while (p0 !== p);

                    outlines.push(coords);
                    --i;
                  }

                  var drawOutline =
                    function drawOutline(c) {
                      c.save();
                      c.scale(
                        1 / width,
                        -1 / height
                      );
                      c.translate(0, -height);
                      c.beginPath();

                      for (
                        var k = 0,
                          kk = outlines.length;
                        k < kk;
                        k++
                      ) {
                        var o = outlines[k];
                        c.moveTo(o[0], o[1]);

                        for (
                          var l = 2,
                            ll = o.length;
                          l < ll;
                          l += 2
                        ) {
                          c.lineTo(
                            o[l],
                            o[l + 1]
                          );
                        }
                      }

                      c.fill();
                      c.beginPath();
                      c.restore();
                    };

                  return drawOutline;
                }

                var CanvasExtraState =
                  (function CanvasExtraStateClosure() {
                    function CanvasExtraState() {
                      this.alphaIsShape = false;
                      this.fontSize = 0;
                      this.fontSizeScale = 1;
                      this.textMatrix =
                        _util.IDENTITY_MATRIX;
                      this.textMatrixScale = 1;
                      this.fontMatrix =
                        _util.FONT_IDENTITY_MATRIX;
                      this.leading = 0;
                      this.x = 0;
                      this.y = 0;
                      this.lineX = 0;
                      this.lineY = 0;
                      this.charSpacing = 0;
                      this.wordSpacing = 0;
                      this.textHScale = 1;
                      this.textRenderingMode =
                        _util.TextRenderingMode.FILL;
                      this.textRise = 0;
                      this.fillColor = "#000000";
                      this.strokeColor =
                        "#000000";
                      this.patternFill = false;
                      this.fillAlpha = 1;
                      this.strokeAlpha = 1;
                      this.lineWidth = 1;
                      this.activeSMask = null;
                      this.resumeSMaskCtx = null;
                      this.transferMaps = null;
                    }

                    CanvasExtraState.prototype = {
                      clone:
                        function CanvasExtraState_clone() {
                          return Object.create(
                            this
                          );
                        },
                      setCurrentPoint:
                        function CanvasExtraState_setCurrentPoint(
                          x,
                          y
                        ) {
                          this.x = x;
                          this.y = y;
                        },
                    };
                    return CanvasExtraState;
                  })();

                var CanvasGraphics =
                  (function CanvasGraphicsClosure() {
                    var EXECUTION_TIME = 15;
                    var EXECUTION_STEPS = 10;

                    function CanvasGraphics(
                      canvasCtx,
                      commonObjs,
                      objs,
                      canvasFactory,
                      webGLContext,
                      imageLayer,
                      optionalContentConfig
                    ) {
                      this.ctx = canvasCtx;
                      this.current =
                        new CanvasExtraState();
                      this.stateStack = [];
                      this.pendingClip = null;
                      this.pendingEOFill = false;
                      this.res = null;
                      this.xobjs = null;
                      this.commonObjs =
                        commonObjs;
                      this.objs = objs;
                      this.canvasFactory =
                        canvasFactory;
                      this.webGLContext =
                        webGLContext;
                      this.imageLayer =
                        imageLayer;
                      this.groupStack = [];
                      this.processingType3 = null;
                      this.baseTransform = null;
                      this.baseTransformStack =
                        [];
                      this.groupLevel = 0;
                      this.smaskStack = [];
                      this.smaskCounter = 0;
                      this.tempSMask = null;
                      this.contentVisible = true;
                      this.markedContentStack =
                        [];
                      this.optionalContentConfig =
                        optionalContentConfig;
                      this.cachedCanvases =
                        new CachedCanvases(
                          this.canvasFactory
                        );

                      if (canvasCtx) {
                        addContextCurrentTransform(
                          canvasCtx
                        );
                      }

                      this._cachedGetSinglePixelWidth =
                        null;
                    }

                    function putBinaryImageData(
                      ctx,
                      imgData
                    ) {
                      var transferMaps =
                        arguments.length > 2 &&
                        arguments[2] !== undefined
                          ? arguments[2]
                          : null;

                      if (
                        typeof ImageData !==
                          "undefined" &&
                        imgData instanceof
                          ImageData
                      ) {
                        ctx.putImageData(
                          imgData,
                          0,
                          0
                        );
                        return;
                      }

                      var height = imgData.height,
                        width = imgData.width;
                      var partialChunkHeight =
                        height %
                        FULL_CHUNK_HEIGHT;
                      var fullChunks =
                        (height -
                          partialChunkHeight) /
                        FULL_CHUNK_HEIGHT;
                      var totalChunks =
                        partialChunkHeight === 0
                          ? fullChunks
                          : fullChunks + 1;
                      var chunkImgData =
                        ctx.createImageData(
                          width,
                          FULL_CHUNK_HEIGHT
                        );
                      var srcPos = 0,
                        destPos;
                      var src = imgData.data;
                      var dest =
                        chunkImgData.data;
                      var i,
                        j,
                        thisChunkHeight,
                        elemsInThisChunk;
                      var transferMapRed,
                        transferMapGreen,
                        transferMapBlue,
                        transferMapGray;

                      if (transferMaps) {
                        switch (
                          transferMaps.length
                        ) {
                          case 1:
                            transferMapRed =
                              transferMaps[0];
                            transferMapGreen =
                              transferMaps[0];
                            transferMapBlue =
                              transferMaps[0];
                            transferMapGray =
                              transferMaps[0];
                            break;

                          case 4:
                            transferMapRed =
                              transferMaps[0];
                            transferMapGreen =
                              transferMaps[1];
                            transferMapBlue =
                              transferMaps[2];
                            transferMapGray =
                              transferMaps[3];
                            break;
                        }
                      }

                      if (
                        imgData.kind ===
                        _util.ImageKind
                          .GRAYSCALE_1BPP
                      ) {
                        var srcLength =
                          src.byteLength;
                        var dest32 =
                          new Uint32Array(
                            dest.buffer,
                            0,
                            dest.byteLength >> 2
                          );
                        var dest32DataLength =
                          dest32.length;
                        var fullSrcDiff =
                          (width + 7) >> 3;
                        var white = 0xffffffff;
                        var black = _util
                          .IsLittleEndianCached
                          .value
                          ? 0xff000000
                          : 0x000000ff;

                        if (transferMapGray) {
                          if (
                            transferMapGray[0] ===
                              0xff &&
                            transferMapGray[0xff] ===
                              0
                          ) {
                            var _ref = [
                              black,
                              white,
                            ];
                            white = _ref[0];
                            black = _ref[1];
                          }
                        }

                        for (
                          i = 0;
                          i < totalChunks;
                          i++
                        ) {
                          thisChunkHeight =
                            i < fullChunks
                              ? FULL_CHUNK_HEIGHT
                              : partialChunkHeight;
                          destPos = 0;

                          for (
                            j = 0;
                            j < thisChunkHeight;
                            j++
                          ) {
                            var srcDiff =
                              srcLength - srcPos;
                            var k = 0;
                            var kEnd =
                              srcDiff >
                              fullSrcDiff
                                ? width
                                : srcDiff * 8 - 7;
                            var kEndUnrolled =
                              kEnd & ~7;
                            var mask = 0;
                            var srcByte = 0;

                            for (
                              ;
                              k < kEndUnrolled;
                              k += 8
                            ) {
                              srcByte =
                                src[srcPos++];
                              dest32[destPos++] =
                                srcByte & 128
                                  ? white
                                  : black;
                              dest32[destPos++] =
                                srcByte & 64
                                  ? white
                                  : black;
                              dest32[destPos++] =
                                srcByte & 32
                                  ? white
                                  : black;
                              dest32[destPos++] =
                                srcByte & 16
                                  ? white
                                  : black;
                              dest32[destPos++] =
                                srcByte & 8
                                  ? white
                                  : black;
                              dest32[destPos++] =
                                srcByte & 4
                                  ? white
                                  : black;
                              dest32[destPos++] =
                                srcByte & 2
                                  ? white
                                  : black;
                              dest32[destPos++] =
                                srcByte & 1
                                  ? white
                                  : black;
                            }

                            for (
                              ;
                              k < kEnd;
                              k++
                            ) {
                              if (mask === 0) {
                                srcByte =
                                  src[srcPos++];
                                mask = 128;
                              }

                              dest32[destPos++] =
                                srcByte & mask
                                  ? white
                                  : black;
                              mask >>= 1;
                            }
                          }

                          while (
                            destPos <
                            dest32DataLength
                          ) {
                            dest32[destPos++] = 0;
                          }

                          ctx.putImageData(
                            chunkImgData,
                            0,
                            i * FULL_CHUNK_HEIGHT
                          );
                        }
                      } else if (
                        imgData.kind ===
                        _util.ImageKind.RGBA_32BPP
                      ) {
                        var hasTransferMaps = !!(
                          transferMapRed ||
                          transferMapGreen ||
                          transferMapBlue
                        );
                        j = 0;
                        elemsInThisChunk =
                          width *
                          FULL_CHUNK_HEIGHT *
                          4;

                        for (
                          i = 0;
                          i < fullChunks;
                          i++
                        ) {
                          dest.set(
                            src.subarray(
                              srcPos,
                              srcPos +
                                elemsInThisChunk
                            )
                          );
                          srcPos +=
                            elemsInThisChunk;

                          if (hasTransferMaps) {
                            for (
                              var _k = 0;
                              _k <
                              elemsInThisChunk;
                              _k += 4
                            ) {
                              if (
                                transferMapRed
                              ) {
                                dest[_k + 0] =
                                  transferMapRed[
                                    dest[_k + 0]
                                  ];
                              }

                              if (
                                transferMapGreen
                              ) {
                                dest[_k + 1] =
                                  transferMapGreen[
                                    dest[_k + 1]
                                  ];
                              }

                              if (
                                transferMapBlue
                              ) {
                                dest[_k + 2] =
                                  transferMapBlue[
                                    dest[_k + 2]
                                  ];
                              }
                            }
                          }

                          ctx.putImageData(
                            chunkImgData,
                            0,
                            j
                          );
                          j += FULL_CHUNK_HEIGHT;
                        }

                        if (i < totalChunks) {
                          elemsInThisChunk =
                            width *
                            partialChunkHeight *
                            4;
                          dest.set(
                            src.subarray(
                              srcPos,
                              srcPos +
                                elemsInThisChunk
                            )
                          );

                          if (hasTransferMaps) {
                            for (
                              var _k2 = 0;
                              _k2 <
                              elemsInThisChunk;
                              _k2 += 4
                            ) {
                              if (
                                transferMapRed
                              ) {
                                dest[_k2 + 0] =
                                  transferMapRed[
                                    dest[_k2 + 0]
                                  ];
                              }

                              if (
                                transferMapGreen
                              ) {
                                dest[_k2 + 1] =
                                  transferMapGreen[
                                    dest[_k2 + 1]
                                  ];
                              }

                              if (
                                transferMapBlue
                              ) {
                                dest[_k2 + 2] =
                                  transferMapBlue[
                                    dest[_k2 + 2]
                                  ];
                              }
                            }
                          }

                          ctx.putImageData(
                            chunkImgData,
                            0,
                            j
                          );
                        }
                      } else if (
                        imgData.kind ===
                        _util.ImageKind.RGB_24BPP
                      ) {
                        var _hasTransferMaps = !!(
                          transferMapRed ||
                          transferMapGreen ||
                          transferMapBlue
                        );

                        thisChunkHeight =
                          FULL_CHUNK_HEIGHT;
                        elemsInThisChunk =
                          width * thisChunkHeight;

                        for (
                          i = 0;
                          i < totalChunks;
                          i++
                        ) {
                          if (i >= fullChunks) {
                            thisChunkHeight =
                              partialChunkHeight;
                            elemsInThisChunk =
                              width *
                              thisChunkHeight;
                          }

                          destPos = 0;

                          for (
                            j = elemsInThisChunk;
                            j--;

                          ) {
                            dest[destPos++] =
                              src[srcPos++];
                            dest[destPos++] =
                              src[srcPos++];
                            dest[destPos++] =
                              src[srcPos++];
                            dest[destPos++] = 255;
                          }

                          if (_hasTransferMaps) {
                            for (
                              var _k3 = 0;
                              _k3 < destPos;
                              _k3 += 4
                            ) {
                              if (
                                transferMapRed
                              ) {
                                dest[_k3 + 0] =
                                  transferMapRed[
                                    dest[_k3 + 0]
                                  ];
                              }

                              if (
                                transferMapGreen
                              ) {
                                dest[_k3 + 1] =
                                  transferMapGreen[
                                    dest[_k3 + 1]
                                  ];
                              }

                              if (
                                transferMapBlue
                              ) {
                                dest[_k3 + 2] =
                                  transferMapBlue[
                                    dest[_k3 + 2]
                                  ];
                              }
                            }
                          }

                          ctx.putImageData(
                            chunkImgData,
                            0,
                            i * FULL_CHUNK_HEIGHT
                          );
                        }
                      } else {
                        throw new Error(
                          "bad image kind: ".concat(
                            imgData.kind
                          )
                        );
                      }
                    }

                    CanvasGraphics.putBinaryImageData =
                      putBinaryImageData;

                    function putBinaryImageMask(
                      ctx,
                      imgData
                    ) {
                      var height = imgData.height,
                        width = imgData.width;
                      var partialChunkHeight =
                        height %
                        FULL_CHUNK_HEIGHT;
                      var fullChunks =
                        (height -
                          partialChunkHeight) /
                        FULL_CHUNK_HEIGHT;
                      var totalChunks =
                        partialChunkHeight === 0
                          ? fullChunks
                          : fullChunks + 1;
                      var chunkImgData =
                        ctx.createImageData(
                          width,
                          FULL_CHUNK_HEIGHT
                        );
                      var srcPos = 0;
                      var src = imgData.data;
                      var dest =
                        chunkImgData.data;

                      for (
                        var i = 0;
                        i < totalChunks;
                        i++
                      ) {
                        var thisChunkHeight =
                          i < fullChunks
                            ? FULL_CHUNK_HEIGHT
                            : partialChunkHeight;
                        var destPos = 3;

                        for (
                          var j = 0;
                          j < thisChunkHeight;
                          j++
                        ) {
                          var elem = void 0,
                            mask = 0;

                          for (
                            var k = 0;
                            k < width;
                            k++
                          ) {
                            if (!mask) {
                              elem =
                                src[srcPos++];
                              mask = 128;
                            }

                            dest[destPos] =
                              elem & mask
                                ? 0
                                : 255;
                            destPos += 4;
                            mask >>= 1;
                          }
                        }

                        ctx.putImageData(
                          chunkImgData,
                          0,
                          i * FULL_CHUNK_HEIGHT
                        );
                      }
                    }

                    function copyCtxState(
                      sourceCtx,
                      destCtx
                    ) {
                      var properties = [
                        "strokeStyle",
                        "fillStyle",
                        "fillRule",
                        "globalAlpha",
                        "lineWidth",
                        "lineCap",
                        "lineJoin",
                        "miterLimit",
                        "globalCompositeOperation",
                        "font",
                      ];

                      for (
                        var i = 0,
                          ii = properties.length;
                        i < ii;
                        i++
                      ) {
                        var property =
                          properties[i];

                        if (
                          sourceCtx[property] !==
                          undefined
                        ) {
                          destCtx[property] =
                            sourceCtx[property];
                        }
                      }

                      if (
                        sourceCtx.setLineDash !==
                        undefined
                      ) {
                        destCtx.setLineDash(
                          sourceCtx.getLineDash()
                        );
                        destCtx.lineDashOffset =
                          sourceCtx.lineDashOffset;
                      }
                    }

                    function resetCtxToDefault(
                      ctx
                    ) {
                      ctx.strokeStyle = "#000000";
                      ctx.fillStyle = "#000000";
                      ctx.fillRule = "nonzero";
                      ctx.globalAlpha = 1;
                      ctx.lineWidth = 1;
                      ctx.lineCap = "butt";
                      ctx.lineJoin = "miter";
                      ctx.miterLimit = 10;
                      ctx.globalCompositeOperation =
                        "source-over";
                      ctx.font =
                        "10px sans-serif";

                      if (
                        ctx.setLineDash !==
                        undefined
                      ) {
                        ctx.setLineDash([]);
                        ctx.lineDashOffset = 0;
                      }
                    }

                    function composeSMaskBackdrop(
                      bytes,
                      r0,
                      g0,
                      b0
                    ) {
                      var length = bytes.length;

                      for (
                        var i = 3;
                        i < length;
                        i += 4
                      ) {
                        var alpha = bytes[i];

                        if (alpha === 0) {
                          bytes[i - 3] = r0;
                          bytes[i - 2] = g0;
                          bytes[i - 1] = b0;
                        } else if (alpha < 255) {
                          var alpha_ =
                            255 - alpha;
                          bytes[i - 3] =
                            (bytes[i - 3] *
                              alpha +
                              r0 * alpha_) >>
                            8;
                          bytes[i - 2] =
                            (bytes[i - 2] *
                              alpha +
                              g0 * alpha_) >>
                            8;
                          bytes[i - 1] =
                            (bytes[i - 1] *
                              alpha +
                              b0 * alpha_) >>
                            8;
                        }
                      }
                    }

                    function composeSMaskAlpha(
                      maskData,
                      layerData,
                      transferMap
                    ) {
                      var length =
                        maskData.length;
                      var scale = 1 / 255;

                      for (
                        var i = 3;
                        i < length;
                        i += 4
                      ) {
                        var alpha = transferMap
                          ? transferMap[
                              maskData[i]
                            ]
                          : maskData[i];
                        layerData[i] =
                          (layerData[i] *
                            alpha *
                            scale) |
                          0;
                      }
                    }

                    function composeSMaskLuminosity(
                      maskData,
                      layerData,
                      transferMap
                    ) {
                      var length =
                        maskData.length;

                      for (
                        var i = 3;
                        i < length;
                        i += 4
                      ) {
                        var y =
                          maskData[i - 3] * 77 +
                          maskData[i - 2] * 152 +
                          maskData[i - 1] * 28;
                        layerData[i] = transferMap
                          ? (layerData[i] *
                              transferMap[
                                y >> 8
                              ]) >>
                            8
                          : (layerData[i] * y) >>
                            16;
                      }
                    }

                    function genericComposeSMask(
                      maskCtx,
                      layerCtx,
                      width,
                      height,
                      subtype,
                      backdrop,
                      transferMap
                    ) {
                      var hasBackdrop =
                        !!backdrop;
                      var r0 = hasBackdrop
                        ? backdrop[0]
                        : 0;
                      var g0 = hasBackdrop
                        ? backdrop[1]
                        : 0;
                      var b0 = hasBackdrop
                        ? backdrop[2]
                        : 0;
                      var composeFn;

                      if (
                        subtype === "Luminosity"
                      ) {
                        composeFn =
                          composeSMaskLuminosity;
                      } else {
                        composeFn =
                          composeSMaskAlpha;
                      }

                      var PIXELS_TO_PROCESS = 1048576;
                      var chunkSize = Math.min(
                        height,
                        Math.ceil(
                          PIXELS_TO_PROCESS /
                            width
                        )
                      );

                      for (
                        var row = 0;
                        row < height;
                        row += chunkSize
                      ) {
                        var chunkHeight =
                          Math.min(
                            chunkSize,
                            height - row
                          );
                        var maskData =
                          maskCtx.getImageData(
                            0,
                            row,
                            width,
                            chunkHeight
                          );
                        var layerData =
                          layerCtx.getImageData(
                            0,
                            row,
                            width,
                            chunkHeight
                          );

                        if (hasBackdrop) {
                          composeSMaskBackdrop(
                            maskData.data,
                            r0,
                            g0,
                            b0
                          );
                        }

                        composeFn(
                          maskData.data,
                          layerData.data,
                          transferMap
                        );
                        maskCtx.putImageData(
                          layerData,
                          0,
                          row
                        );
                      }
                    }

                    function composeSMask(
                      ctx,
                      smask,
                      layerCtx,
                      webGLContext
                    ) {
                      var mask = smask.canvas;
                      var maskCtx = smask.context;
                      ctx.setTransform(
                        smask.scaleX,
                        0,
                        0,
                        smask.scaleY,
                        smask.offsetX,
                        smask.offsetY
                      );
                      var backdrop =
                        smask.backdrop || null;

                      if (
                        !smask.transferMap &&
                        webGLContext.isEnabled
                      ) {
                        var composed =
                          webGLContext.composeSMask(
                            {
                              layer:
                                layerCtx.canvas,
                              mask: mask,
                              properties: {
                                subtype:
                                  smask.subtype,
                                backdrop:
                                  backdrop,
                              },
                            }
                          );
                        ctx.setTransform(
                          1,
                          0,
                          0,
                          1,
                          0,
                          0
                        );
                        ctx.drawImage(
                          composed,
                          smask.offsetX,
                          smask.offsetY
                        );
                        return;
                      }

                      genericComposeSMask(
                        maskCtx,
                        layerCtx,
                        mask.width,
                        mask.height,
                        smask.subtype,
                        backdrop,
                        smask.transferMap
                      );
                      ctx.drawImage(mask, 0, 0);
                    }

                    var LINE_CAP_STYLES = [
                      "butt",
                      "round",
                      "square",
                    ];
                    var LINE_JOIN_STYLES = [
                      "miter",
                      "round",
                      "bevel",
                    ];
                    var NORMAL_CLIP = {};
                    var EO_CLIP = {};
                    CanvasGraphics.prototype = {
                      beginDrawing:
                        function beginDrawing(
                          _ref2
                        ) {
                          var transform =
                              _ref2.transform,
                            viewport =
                              _ref2.viewport,
                            _ref2$transparency =
                              _ref2.transparency,
                            transparency =
                              _ref2$transparency ===
                              void 0
                                ? false
                                : _ref2$transparency,
                            _ref2$background =
                              _ref2.background,
                            background =
                              _ref2$background ===
                              void 0
                                ? null
                                : _ref2$background;
                          var width =
                            this.ctx.canvas.width;
                          var height =
                            this.ctx.canvas
                              .height;
                          this.ctx.save();
                          this.ctx.fillStyle =
                            background ||
                            "rgb(255, 255, 255)";
                          this.ctx.fillRect(
                            0,
                            0,
                            width,
                            height
                          );
                          this.ctx.restore();

                          if (transparency) {
                            var transparentCanvas =
                              this.cachedCanvases.getCanvas(
                                "transparent",
                                width,
                                height,
                                true
                              );
                            this.compositeCtx =
                              this.ctx;
                            this.transparentCanvas =
                              transparentCanvas.canvas;
                            this.ctx =
                              transparentCanvas.context;
                            this.ctx.save();
                            this.ctx.transform.apply(
                              this.ctx,
                              this.compositeCtx
                                .mozCurrentTransform
                            );
                          }

                          this.ctx.save();
                          resetCtxToDefault(
                            this.ctx
                          );

                          if (transform) {
                            this.ctx.transform.apply(
                              this.ctx,
                              transform
                            );
                          }

                          this.ctx.transform.apply(
                            this.ctx,
                            viewport.transform
                          );
                          this.baseTransform =
                            this.ctx.mozCurrentTransform.slice();
                          this._combinedScaleFactor =
                            Math.hypot(
                              this
                                .baseTransform[0],
                              this
                                .baseTransform[2]
                            );

                          if (this.imageLayer) {
                            this.imageLayer.beginLayout();
                          }
                        },
                      executeOperatorList:
                        function CanvasGraphics_executeOperatorList(
                          operatorList,
                          executionStartIdx,
                          continueCallback,
                          stepper
                        ) {
                          var argsArray =
                            operatorList.argsArray;
                          var fnArray =
                            operatorList.fnArray;
                          var i =
                            executionStartIdx ||
                            0;
                          var argsArrayLen =
                            argsArray.length;

                          if (
                            argsArrayLen === i
                          ) {
                            return i;
                          }

                          var chunkOperations =
                            argsArrayLen - i >
                              EXECUTION_STEPS &&
                            typeof continueCallback ===
                              "function";
                          var endTime =
                            chunkOperations
                              ? Date.now() +
                                EXECUTION_TIME
                              : 0;
                          var steps = 0;
                          var commonObjs =
                            this.commonObjs;
                          var objs = this.objs;
                          var fnId;

                          while (true) {
                            if (
                              stepper !==
                                undefined &&
                              i ===
                                stepper.nextBreakPoint
                            ) {
                              stepper.breakIt(
                                i,
                                continueCallback
                              );
                              return i;
                            }

                            fnId = fnArray[i];

                            if (
                              fnId !==
                              _util.OPS.dependency
                            ) {
                              this.setCurrentOperatorIndex(
                                i
                              );
                              this[fnId].apply(
                                this,
                                argsArray[i]
                              );
                            } else {
                              var _iterator =
                                  _createForOfIteratorHelper(
                                    argsArray[i]
                                  ),
                                _step;

                              try {
                                for (
                                  _iterator.s();
                                  !(_step =
                                    _iterator.n())
                                    .done;

                                ) {
                                  var depObjId =
                                    _step.value;
                                  var objsPool =
                                    depObjId.startsWith(
                                      "g_"
                                    )
                                      ? commonObjs
                                      : objs;

                                  if (
                                    !objsPool.has(
                                      depObjId
                                    )
                                  ) {
                                    objsPool.get(
                                      depObjId,
                                      continueCallback
                                    );
                                    return i;
                                  }
                                }
                              } catch (err) {
                                _iterator.e(err);
                              } finally {
                                _iterator.f();
                              }
                            }

                            i++;

                            if (
                              i === argsArrayLen
                            ) {
                              return i;
                            }

                            if (
                              chunkOperations &&
                              ++steps >
                                EXECUTION_STEPS
                            ) {
                              if (
                                Date.now() >
                                endTime
                              ) {
                                continueCallback();
                                return i;
                              }

                              steps = 0;
                            }
                          }
                        },
                      restoreInitialState:
                        function CanvasGraphics_restoreInitialState() {
                          while (
                            this.stateStack
                              .length ||
                            this.current
                              .activeSMask !==
                              null
                          ) {
                            this.restore();
                          }

                          this.ctx.restore();

                          if (
                            this.transparentCanvas
                          ) {
                            this.ctx =
                              this.compositeCtx;
                            this.ctx.save();
                            this.ctx.setTransform(
                              1,
                              0,
                              0,
                              1,
                              0,
                              0
                            );
                            this.ctx.drawImage(
                              this
                                .transparentCanvas,
                              0,
                              0
                            );
                            this.ctx.restore();
                            this.transparentCanvas =
                              null;
                          }
                        },
                      endDrawing:
                        function CanvasGraphics_endDrawing() {
                          this.restoreInitialState();
                          this.cachedCanvases.clear();
                          this.webGLContext.clear();

                          if (this.imageLayer) {
                            this.imageLayer.endLayout();
                          }
                        },
                      setLineWidth:
                        function CanvasGraphics_setLineWidth(
                          width
                        ) {
                          this.current.lineWidth =
                            width;
                          this.ctx.lineWidth =
                            width;
                        },
                      setLineCap:
                        function CanvasGraphics_setLineCap(
                          style
                        ) {
                          this.ctx.lineCap =
                            LINE_CAP_STYLES[
                              style
                            ];
                        },
                      setLineJoin:
                        function CanvasGraphics_setLineJoin(
                          style
                        ) {
                          this.ctx.lineJoin =
                            LINE_JOIN_STYLES[
                              style
                            ];
                        },
                      setMiterLimit:
                        function CanvasGraphics_setMiterLimit(
                          limit
                        ) {
                          this.ctx.miterLimit =
                            limit;
                        },
                      setDash:
                        function CanvasGraphics_setDash(
                          dashArray,
                          dashPhase
                        ) {
                          var ctx = this.ctx;

                          if (
                            ctx.setLineDash !==
                            undefined
                          ) {
                            ctx.setLineDash(
                              dashArray
                            );
                            ctx.lineDashOffset =
                              dashPhase;
                          }
                        },
                      setRenderingIntent:
                        function setRenderingIntent(
                          intent
                        ) {},
                      setFlatness:
                        function setFlatness(
                          flatness
                        ) {},
                      setGState:
                        function CanvasGraphics_setGState(
                          states
                        ) {
                          for (
                            var i = 0,
                              ii = states.length;
                            i < ii;
                            i++
                          ) {
                            var state = states[i];
                            var key = state[0];
                            var value = state[1];

                            switch (key) {
                              case "LW":
                                this.setLineWidth(
                                  value
                                );
                                break;

                              case "LC":
                                this.setLineCap(
                                  value
                                );
                                break;

                              case "LJ":
                                this.setLineJoin(
                                  value
                                );
                                break;

                              case "ML":
                                this.setMiterLimit(
                                  value
                                );
                                break;

                              case "D":
                                this.setDash(
                                  value[0],
                                  value[1]
                                );
                                break;

                              case "RI":
                                this.setRenderingIntent(
                                  value
                                );
                                break;

                              case "FL":
                                this.setFlatness(
                                  value
                                );
                                break;

                              case "Font":
                                this.setFont(
                                  value[0],
                                  value[1]
                                );
                                break;

                              case "CA":
                                this.current.strokeAlpha =
                                  state[1];
                                break;

                              case "ca":
                                this.current.fillAlpha =
                                  state[1];
                                this.ctx.globalAlpha =
                                  state[1];
                                break;

                              case "BM":
                                this.ctx.globalCompositeOperation =
                                  value;
                                break;

                              case "SMask":
                                if (
                                  this.current
                                    .activeSMask
                                ) {
                                  if (
                                    this
                                      .stateStack
                                      .length >
                                      0 &&
                                    this
                                      .stateStack[
                                      this
                                        .stateStack
                                        .length -
                                        1
                                    ]
                                      .activeSMask ===
                                      this.current
                                        .activeSMask
                                  ) {
                                    this.suspendSMaskGroup();
                                  } else {
                                    this.endSMaskGroup();
                                  }
                                }

                                this.current.activeSMask =
                                  value
                                    ? this
                                        .tempSMask
                                    : null;

                                if (
                                  this.current
                                    .activeSMask
                                ) {
                                  this.beginSMaskGroup();
                                }

                                this.tempSMask =
                                  null;
                                break;

                              case "TR":
                                this.current.transferMaps =
                                  value;
                            }
                          }
                        },
                      beginSMaskGroup:
                        function CanvasGraphics_beginSMaskGroup() {
                          var activeSMask =
                            this.current
                              .activeSMask;
                          var drawnWidth =
                            activeSMask.canvas
                              .width;
                          var drawnHeight =
                            activeSMask.canvas
                              .height;
                          var cacheId =
                            "smaskGroupAt" +
                            this.groupLevel;
                          var scratchCanvas =
                            this.cachedCanvases.getCanvas(
                              cacheId,
                              drawnWidth,
                              drawnHeight,
                              true
                            );
                          var currentCtx =
                            this.ctx;
                          var currentTransform =
                            currentCtx.mozCurrentTransform;
                          this.ctx.save();
                          var groupCtx =
                            scratchCanvas.context;
                          groupCtx.scale(
                            1 /
                              activeSMask.scaleX,
                            1 / activeSMask.scaleY
                          );
                          groupCtx.translate(
                            -activeSMask.offsetX,
                            -activeSMask.offsetY
                          );
                          groupCtx.transform.apply(
                            groupCtx,
                            currentTransform
                          );
                          activeSMask.startTransformInverse =
                            groupCtx.mozCurrentTransformInverse;
                          copyCtxState(
                            currentCtx,
                            groupCtx
                          );
                          this.ctx = groupCtx;
                          this.setGState([
                            ["BM", "source-over"],
                            ["ca", 1],
                            ["CA", 1],
                          ]);
                          this.groupStack.push(
                            currentCtx
                          );
                          this.groupLevel++;
                        },
                      suspendSMaskGroup:
                        function CanvasGraphics_endSMaskGroup() {
                          var groupCtx = this.ctx;
                          this.groupLevel--;
                          this.ctx =
                            this.groupStack.pop();
                          composeSMask(
                            this.ctx,
                            this.current
                              .activeSMask,
                            groupCtx,
                            this.webGLContext
                          );
                          this.ctx.restore();
                          this.ctx.save();
                          copyCtxState(
                            groupCtx,
                            this.ctx
                          );
                          this.current.resumeSMaskCtx =
                            groupCtx;

                          var deltaTransform =
                            _util.Util.transform(
                              this.current
                                .activeSMask
                                .startTransformInverse,
                              groupCtx.mozCurrentTransform
                            );

                          this.ctx.transform.apply(
                            this.ctx,
                            deltaTransform
                          );
                          groupCtx.save();
                          groupCtx.setTransform(
                            1,
                            0,
                            0,
                            1,
                            0,
                            0
                          );
                          groupCtx.clearRect(
                            0,
                            0,
                            groupCtx.canvas.width,
                            groupCtx.canvas.height
                          );
                          groupCtx.restore();
                        },
                      resumeSMaskGroup:
                        function CanvasGraphics_resumeSMaskGroup() {
                          var groupCtx =
                            this.current
                              .resumeSMaskCtx;
                          var currentCtx =
                            this.ctx;
                          this.ctx = groupCtx;
                          this.groupStack.push(
                            currentCtx
                          );
                          this.groupLevel++;
                        },
                      endSMaskGroup:
                        function CanvasGraphics_endSMaskGroup() {
                          var groupCtx = this.ctx;
                          this.groupLevel--;
                          this.ctx =
                            this.groupStack.pop();
                          composeSMask(
                            this.ctx,
                            this.current
                              .activeSMask,
                            groupCtx,
                            this.webGLContext
                          );
                          this.ctx.restore();
                          copyCtxState(
                            groupCtx,
                            this.ctx
                          );

                          var deltaTransform =
                            _util.Util.transform(
                              this.current
                                .activeSMask
                                .startTransformInverse,
                              groupCtx.mozCurrentTransform
                            );

                          this.ctx.transform.apply(
                            this.ctx,
                            deltaTransform
                          );
                        },
                      save: function CanvasGraphics_save() {
                        this.ctx.save();
                        var old = this.current;
                        this.stateStack.push(old);
                        this.current =
                          old.clone();
                        this.current.resumeSMaskCtx =
                          null;
                      },
                      restore:
                        function CanvasGraphics_restore() {
                          if (
                            this.current
                              .resumeSMaskCtx
                          ) {
                            this.resumeSMaskGroup();
                          }

                          if (
                            this.current
                              .activeSMask !==
                              null &&
                            (this.stateStack
                              .length === 0 ||
                              this.stateStack[
                                this.stateStack
                                  .length - 1
                              ].activeSMask !==
                                this.current
                                  .activeSMask)
                          ) {
                            this.endSMaskGroup();
                          }

                          if (
                            this.stateStack
                              .length !== 0
                          ) {
                            this.current =
                              this.stateStack.pop();
                            this.ctx.restore();
                            this.pendingClip =
                              null;
                            this._cachedGetSinglePixelWidth =
                              null;
                          } else {
                            this.current.activeSMask =
                              null;
                          }
                        },
                      transform:
                        function CanvasGraphics_transform(
                          a,
                          b,
                          c,
                          d,
                          e,
                          f
                        ) {
                          if (
                            typeof this.ctx
                              .needDelegateInlineImageGroup ===
                              "function" &&
                            this.ctx.needDelegateInlineImageGroup()
                          ) {
                            return;
                          }

                          this.ctx.transform(
                            a,
                            b,
                            c,
                            d,
                            e,
                            f
                          );
                          this._cachedGetSinglePixelWidth =
                            null;
                        },
                      constructPath:
                        function CanvasGraphics_constructPath(
                          ops,
                          args
                        ) {
                          var ctx = this.ctx;
                          var current =
                            this.current;
                          var x = current.x,
                            y = current.y;

                          for (
                            var i = 0,
                              j = 0,
                              ii = ops.length;
                            i < ii;
                            i++
                          ) {
                            switch (ops[i] | 0) {
                              case _util.OPS
                                .rectangle:
                                x = args[j++];
                                y = args[j++];
                                var width =
                                  args[j++];
                                var height =
                                  args[j++];
                                var xw =
                                  x + width;
                                var yh =
                                  y + height;
                                ctx.moveTo(x, y);

                                if (
                                  width === 0 ||
                                  height === 0
                                ) {
                                  ctx.lineTo(
                                    xw,
                                    yh
                                  );
                                } else {
                                  ctx.lineTo(
                                    xw,
                                    y
                                  );
                                  ctx.lineTo(
                                    xw,
                                    yh
                                  );
                                  ctx.lineTo(
                                    x,
                                    yh
                                  );
                                }

                                ctx.closePath();
                                break;

                              case _util.OPS
                                .moveTo:
                                x = args[j++];
                                y = args[j++];
                                ctx.moveTo(x, y);
                                break;

                              case _util.OPS
                                .lineTo:
                                x = args[j++];
                                y = args[j++];
                                ctx.lineTo(x, y);
                                break;

                              case _util.OPS
                                .curveTo:
                                x = args[j + 4];
                                y = args[j + 5];
                                ctx.bezierCurveTo(
                                  args[j],
                                  args[j + 1],
                                  args[j + 2],
                                  args[j + 3],
                                  x,
                                  y
                                );
                                j += 6;
                                break;

                              case _util.OPS
                                .curveTo2:
                                ctx.bezierCurveTo(
                                  x,
                                  y,
                                  args[j],
                                  args[j + 1],
                                  args[j + 2],
                                  args[j + 3]
                                );
                                x = args[j + 2];
                                y = args[j + 3];
                                j += 4;
                                break;

                              case _util.OPS
                                .curveTo3:
                                x = args[j + 2];
                                y = args[j + 3];
                                ctx.bezierCurveTo(
                                  args[j],
                                  args[j + 1],
                                  x,
                                  y,
                                  x,
                                  y
                                );
                                j += 4;
                                break;

                              case _util.OPS
                                .closePath:
                                ctx.closePath();
                                break;
                            }
                          }

                          current.setCurrentPoint(
                            x,
                            y
                          );
                        },
                      closePath:
                        function CanvasGraphics_closePath() {
                          this.ctx.closePath();
                        },
                      stroke:
                        function CanvasGraphics_stroke(
                          consumePath
                        ) {
                          consumePath =
                            typeof consumePath !==
                            "undefined"
                              ? consumePath
                              : true;
                          var ctx = this.ctx;
                          var strokeColor =
                            this.current
                              .strokeColor;
                          ctx.globalAlpha =
                            this.current.strokeAlpha;

                          if (
                            this.contentVisible
                          ) {
                            if (
                              _typeof(
                                strokeColor
                              ) === "object" &&
                              strokeColor !==
                                null &&
                              strokeColor !==
                                void 0 &&
                              strokeColor.getPattern
                            ) {
                              ctx.save();
                              var transform =
                                ctx.mozCurrentTransform;

                              var scale =
                                _util.Util.singularValueDecompose2dScale(
                                  transform
                                )[0];

                              ctx.strokeStyle =
                                strokeColor.getPattern(
                                  ctx,
                                  this
                                );
                              var lineWidth =
                                this.getSinglePixelWidth();
                              var scaledLineWidth =
                                this.current
                                  .lineWidth *
                                scale;

                              if (
                                lineWidth < 0 &&
                                -lineWidth >=
                                  scaledLineWidth
                              ) {
                                ctx.resetTransform();
                                ctx.lineWidth =
                                  Math.round(
                                    this
                                      ._combinedScaleFactor
                                  );
                              } else {
                                ctx.lineWidth =
                                  Math.max(
                                    lineWidth,
                                    scaledLineWidth
                                  );
                              }

                              ctx.stroke();
                              ctx.restore();
                            } else {
                              var _lineWidth =
                                this.getSinglePixelWidth();

                              if (
                                _lineWidth < 0 &&
                                -_lineWidth >=
                                  this.current
                                    .lineWidth
                              ) {
                                ctx.save();
                                ctx.resetTransform();
                                ctx.lineWidth =
                                  Math.round(
                                    this
                                      ._combinedScaleFactor
                                  );
                                ctx.stroke();
                                ctx.restore();
                              } else {
                                ctx.lineWidth =
                                  Math.max(
                                    _lineWidth,
                                    this.current
                                      .lineWidth
                                  );
                                ctx.stroke();
                              }
                            }
                          }

                          if (consumePath) {
                            this.consumePath();
                          }

                          ctx.globalAlpha =
                            this.current.fillAlpha;
                        },
                      closeStroke:
                        function CanvasGraphics_closeStroke() {
                          this.closePath();
                          this.stroke();
                        },
                      fill: function CanvasGraphics_fill(
                        consumePath,
                        isFillStrokeCombo
                      ) {
                        consumePath =
                          typeof consumePath !==
                          "undefined"
                            ? consumePath
                            : true;
                        var ctx = this.ctx;
                        var fillColor =
                          this.current.fillColor;
                        var isPatternFill =
                          this.current
                            .patternFill;
                        var needRestore = false;

                        if (isPatternFill) {
                          ctx.save();

                          if (
                            this.baseTransform
                          ) {
                            ctx.setTransform.apply(
                              ctx,
                              this.baseTransform
                            );
                          }

                          ctx.fillStyle =
                            fillColor.getPattern(
                              ctx,
                              this
                            );
                          needRestore = true;
                        }

                        if (this.contentVisible) {
                          if (
                            ctx.isLMVCanvasContext &&
                            typeof ctx.isLMVCanvasContext ===
                              "function" &&
                            ctx.isLMVCanvasContext()
                          ) {
                            if (
                              this.pendingEOFill
                            ) {
                              ctx.fill(
                                "evenodd",
                                isFillStrokeCombo
                              );
                              this.pendingEOFill = false;
                            } else {
                              ctx.fill(
                                isFillStrokeCombo
                              );
                            }
                          } else {
                            if (
                              this.pendingEOFill
                            ) {
                              ctx.fill("evenodd");
                              this.pendingEOFill = false;
                            } else {
                              ctx.fill();
                            }
                          }
                        }

                        if (needRestore) {
                          ctx.restore();
                        }

                        if (consumePath) {
                          this.consumePath();
                        }
                      },
                      eoFill:
                        function CanvasGraphics_eoFill() {
                          this.pendingEOFill = true;
                          this.fill();
                        },
                      fillStroke:
                        function CanvasGraphics_fillStroke() {
                          this.fill(false, true);
                          this.stroke(false);
                          this.consumePath();
                        },
                      eoFillStroke:
                        function CanvasGraphics_eoFillStroke() {
                          this.pendingEOFill = true;
                          this.fillStroke();
                        },
                      closeFillStroke:
                        function CanvasGraphics_closeFillStroke() {
                          this.closePath();
                          this.fillStroke();
                        },
                      closeEOFillStroke:
                        function CanvasGraphics_closeEOFillStroke() {
                          this.pendingEOFill = true;
                          this.closePath();
                          this.fillStroke();
                        },
                      endPath:
                        function CanvasGraphics_endPath() {
                          this.consumePath();
                        },
                      clip: function CanvasGraphics_clip() {
                        this.pendingClip =
                          NORMAL_CLIP;
                      },
                      eoClip:
                        function CanvasGraphics_eoClip() {
                          this.pendingClip =
                            EO_CLIP;
                        },
                      beginText:
                        function CanvasGraphics_beginText() {
                          this.current.textMatrix =
                            _util.IDENTITY_MATRIX;
                          this.current.textMatrixScale = 1;
                          this.current.x =
                            this.current.lineX = 0;
                          this.current.y =
                            this.current.lineY = 0;
                        },
                      endText:
                        function CanvasGraphics_endText() {
                          var paths =
                            this.pendingTextPaths;
                          var ctx = this.ctx;

                          if (
                            paths === undefined
                          ) {
                            ctx.beginPath();
                            return;
                          }

                          ctx.save();
                          ctx.beginPath();

                          for (
                            var i = 0;
                            i < paths.length;
                            i++
                          ) {
                            var path = paths[i];
                            ctx.setTransform.apply(
                              ctx,
                              path.transform
                            );
                            ctx.translate(
                              path.x,
                              path.y
                            );
                            path.addToPath(
                              ctx,
                              path.fontSize
                            );
                          }

                          ctx.restore();
                          ctx.clip();
                          ctx.beginPath();
                          delete this
                            .pendingTextPaths;
                        },
                      setCharSpacing:
                        function CanvasGraphics_setCharSpacing(
                          spacing
                        ) {
                          this.current.charSpacing =
                            spacing;
                        },
                      setWordSpacing:
                        function CanvasGraphics_setWordSpacing(
                          spacing
                        ) {
                          this.current.wordSpacing =
                            spacing;
                        },
                      setHScale:
                        function CanvasGraphics_setHScale(
                          scale
                        ) {
                          this.current.textHScale =
                            scale / 100;
                        },
                      setLeading:
                        function CanvasGraphics_setLeading(
                          leading
                        ) {
                          this.current.leading =
                            -leading;
                        },
                      setFont:
                        function CanvasGraphics_setFont(
                          fontRefName,
                          size
                        ) {
                          var fontObj =
                            this.commonObjs.get(
                              fontRefName
                            );
                          var current =
                            this.current;

                          if (!fontObj) {
                            throw new Error(
                              "Can't find font for ".concat(
                                fontRefName
                              )
                            );
                          }

                          current.fontMatrix =
                            fontObj.fontMatrix ||
                            _util.FONT_IDENTITY_MATRIX;

                          if (
                            current
                              .fontMatrix[0] ===
                              0 ||
                            current
                              .fontMatrix[3] === 0
                          ) {
                            (0, _util.warn)(
                              "Invalid font matrix for font " +
                                fontRefName
                            );
                          }

                          if (size < 0) {
                            size = -size;
                            current.fontDirection =
                              -1;
                          } else {
                            current.fontDirection = 1;
                          }

                          this.current.font =
                            fontObj;
                          this.current.fontSize =
                            size;

                          if (
                            fontObj.isType3Font
                          ) {
                            return;
                          }

                          var name =
                            fontObj.loadedName ||
                            "sans-serif";
                          var bold = "normal";

                          if (fontObj.black) {
                            bold = "900";
                          } else if (
                            fontObj.bold
                          ) {
                            bold = "bold";
                          }

                          var italic =
                            fontObj.italic
                              ? "italic"
                              : "normal";
                          var typeface = '"'
                            .concat(name, '", ')
                            .concat(
                              fontObj.fallbackName
                            );
                          var browserFontSize =
                            size;

                          if (
                            size < MIN_FONT_SIZE
                          ) {
                            browserFontSize =
                              MIN_FONT_SIZE;
                          } else if (
                            size > MAX_FONT_SIZE
                          ) {
                            browserFontSize =
                              MAX_FONT_SIZE;
                          }

                          this.current.fontSizeScale =
                            size /
                            browserFontSize;
                          this.ctx.font = ""
                            .concat(italic, " ")
                            .concat(bold, " ")
                            .concat(
                              browserFontSize,
                              "px "
                            )
                            .concat(typeface);
                        },
                      setTextRenderingMode:
                        function CanvasGraphics_setTextRenderingMode(
                          mode
                        ) {
                          this.current.textRenderingMode =
                            mode;
                        },
                      setTextRise:
                        function CanvasGraphics_setTextRise(
                          rise
                        ) {
                          this.current.textRise =
                            rise;
                        },
                      moveText:
                        function CanvasGraphics_moveText(
                          x,
                          y
                        ) {
                          this.current.x =
                            this.current.lineX +=
                              x;
                          this.current.y =
                            this.current.lineY +=
                              y;
                        },
                      setLeadingMoveText:
                        function CanvasGraphics_setLeadingMoveText(
                          x,
                          y
                        ) {
                          this.setLeading(-y);
                          this.moveText(x, y);
                        },
                      setTextMatrix:
                        function CanvasGraphics_setTextMatrix(
                          a,
                          b,
                          c,
                          d,
                          e,
                          f
                        ) {
                          this.current.textMatrix =
                            [a, b, c, d, e, f];
                          this.current.textMatrixScale =
                            Math.hypot(a, b);
                          this.current.x =
                            this.current.lineX = 0;
                          this.current.y =
                            this.current.lineY = 0;
                        },
                      nextLine:
                        function CanvasGraphics_nextLine() {
                          this.moveText(
                            0,
                            this.current.leading
                          );
                        },
                      paintChar:
                        function paintChar(
                          character,
                          x,
                          y,
                          patternTransform,
                          resetLineWidthToOne
                        ) {
                          var ctx = this.ctx;
                          var current =
                            this.current;
                          var font = current.font;
                          var textRenderingMode =
                            current.textRenderingMode;
                          var fontSize =
                            current.fontSize /
                            current.fontSizeScale;
                          var fillStrokeMode =
                            textRenderingMode &
                            _util
                              .TextRenderingMode
                              .FILL_STROKE_MASK;
                          var isAddToPathSet = !!(
                            textRenderingMode &
                            _util
                              .TextRenderingMode
                              .ADD_TO_PATH_FLAG
                          );
                          var patternFill =
                            current.patternFill &&
                            !font.missingFile;
                          var addToPath;

                          if (
                            font.disableFontFace ||
                            isAddToPathSet ||
                            patternFill
                          ) {
                            addToPath =
                              font.getPathGenerator(
                                this.commonObjs,
                                character
                              );
                          }

                          if (
                            addToPath &&
                            (font.disableFontFace ||
                              patternFill)
                          ) {
                            ctx.save();
                            ctx.translate(x, y);
                            ctx.beginPath(
                              character,
                              x,
                              y,
                              font,
                              fontSize
                            );
                            addToPath(
                              ctx,
                              fontSize
                            );

                            if (
                              patternTransform
                            ) {
                              ctx.setTransform.apply(
                                ctx,
                                patternTransform
                              );
                            }

                            if (
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .FILL ||
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .FILL_STROKE
                            ) {
                              ctx.fill();
                            }

                            if (
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .STROKE ||
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .FILL_STROKE
                            ) {
                              if (
                                resetLineWidthToOne
                              ) {
                                ctx.resetTransform();
                                ctx.lineWidth =
                                  Math.round(
                                    this
                                      ._combinedScaleFactor
                                  );
                              }

                              ctx.stroke();
                            }

                            ctx.restore();
                          } else {
                            if (
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .FILL ||
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .FILL_STROKE
                            ) {
                              ctx.fillText(
                                character,
                                x,
                                y,
                                undefined,
                                font,
                                fontSize
                              );
                            }

                            if (
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .STROKE ||
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .FILL_STROKE
                            ) {
                              if (
                                resetLineWidthToOne
                              ) {
                                ctx.save();
                                ctx.moveTo(x, y);
                                ctx.resetTransform();
                                ctx.lineWidth =
                                  Math.round(
                                    this
                                      ._combinedScaleFactor
                                  );
                                ctx.strokeText(
                                  character,
                                  0,
                                  0,
                                  undefined,
                                  font,
                                  fontSize
                                );
                                ctx.restore();
                              } else {
                                ctx.strokeText(
                                  character,
                                  x,
                                  y,
                                  undefined,
                                  font,
                                  fontSize
                                );
                              }
                            }
                          }

                          if (
                            addToPath &&
                            isAddToPathSet
                          ) {
                            var paths =
                              this
                                .pendingTextPaths ||
                              (this.pendingTextPaths =
                                []);
                            paths.push({
                              transform:
                                ctx.mozCurrentTransform,
                              x: x,
                              y: y,
                              fontSize: fontSize,
                              addToPath:
                                addToPath,
                            });
                          }
                        },

                      get isFontSubpixelAAEnabled() {
                        var _this$cachedCanvases$ =
                            this.cachedCanvases.getCanvas(
                              "isFontSubpixelAAEnabled",
                              10,
                              10
                            ),
                          ctx =
                            _this$cachedCanvases$.context;

                        ctx.scale(1.5, 1);
                        ctx.fillText("I", 0, 10);
                        var data =
                          ctx.getImageData(
                            0,
                            0,
                            10,
                            10
                          ).data;
                        var enabled = false;

                        for (
                          var i = 3;
                          i < data.length;
                          i += 4
                        ) {
                          if (
                            data[i] > 0 &&
                            data[i] < 255
                          ) {
                            enabled = true;
                            break;
                          }
                        }

                        return (0, _util.shadow)(
                          this,
                          "isFontSubpixelAAEnabled",
                          enabled
                        );
                      },

                      showText:
                        function CanvasGraphics_showText(
                          glyphs
                        ) {
                          var current =
                            this.current;
                          var font = current.font;

                          if (font.isType3Font) {
                            return this.showType3Text(
                              glyphs
                            );
                          }

                          var fontSize =
                            current.fontSize;

                          if (fontSize === 0) {
                            return undefined;
                          }

                          var ctx = this.ctx;
                          var fontSizeScale =
                            current.fontSizeScale;
                          var charSpacing =
                            current.charSpacing;
                          var wordSpacing =
                            current.wordSpacing;
                          var fontDirection =
                            current.fontDirection;
                          var textHScale =
                            current.textHScale *
                            fontDirection;
                          var glyphsLength =
                            glyphs.length;
                          var vertical =
                            font.vertical;
                          var spacingDir =
                            vertical ? 1 : -1;
                          var defaultVMetrics =
                            font.defaultVMetrics;
                          var widthAdvanceScale =
                            fontSize *
                            current.fontMatrix[0];
                          var simpleFillText =
                            current.textRenderingMode ===
                              _util
                                .TextRenderingMode
                                .FILL &&
                            !font.disableFontFace &&
                            !current.patternFill;
                          ctx.save();
                          var patternTransform;

                          if (
                            current.patternFill
                          ) {
                            ctx.save();
                            var pattern =
                              current.fillColor.getPattern(
                                ctx,
                                this
                              );
                            patternTransform =
                              ctx.mozCurrentTransform;
                            ctx.restore();
                            ctx.fillStyle =
                              pattern;
                          }

                          ctx.transform.apply(
                            ctx,
                            current.textMatrix
                          );
                          ctx.translate(
                            current.x,
                            current.y +
                              current.textRise
                          );

                          if (fontDirection > 0) {
                            ctx.scale(
                              textHScale,
                              -1
                            );
                          } else {
                            ctx.scale(
                              textHScale,
                              1
                            );
                          }

                          var lineWidth =
                            current.lineWidth;
                          var resetLineWidthToOne = false;
                          var scale =
                            current.textMatrixScale;

                          if (
                            scale === 0 ||
                            lineWidth === 0
                          ) {
                            var fillStrokeMode =
                              current.textRenderingMode &
                              _util
                                .TextRenderingMode
                                .FILL_STROKE_MASK;

                            if (
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .STROKE ||
                              fillStrokeMode ===
                                _util
                                  .TextRenderingMode
                                  .FILL_STROKE
                            ) {
                              this._cachedGetSinglePixelWidth =
                                null;
                              lineWidth =
                                this.getSinglePixelWidth();
                              resetLineWidthToOne =
                                lineWidth < 0;
                            }
                          } else {
                            lineWidth /= scale;
                          }

                          if (
                            fontSizeScale !== 1.0
                          ) {
                            ctx.scale(
                              fontSizeScale,
                              fontSizeScale
                            );
                            lineWidth /=
                              fontSizeScale;
                          }

                          ctx.lineWidth =
                            lineWidth;
                          var x = 0,
                            i;

                          for (
                            i = 0;
                            i < glyphsLength;
                            ++i
                          ) {
                            var glyph = glyphs[i];

                            if (
                              (0, _util.isNum)(
                                glyph
                              )
                            ) {
                              x +=
                                (spacingDir *
                                  glyph *
                                  fontSize) /
                                1000;
                              continue;
                            }

                            var restoreNeeded = false;
                            var spacing =
                              (glyph.isSpace
                                ? wordSpacing
                                : 0) +
                              charSpacing;
                            var character =
                              glyph.fontChar;
                            var accent =
                              glyph.accent;
                            var scaledX = void 0,
                              scaledY = void 0;
                            var width =
                              glyph.width;

                            if (vertical) {
                              var vmetric =
                                glyph.vmetric ||
                                defaultVMetrics;
                              var vx =
                                -(glyph.vmetric
                                  ? vmetric[1]
                                  : width * 0.5) *
                                widthAdvanceScale;
                              var vy =
                                vmetric[2] *
                                widthAdvanceScale;
                              width = vmetric
                                ? -vmetric[0]
                                : width;
                              scaledX =
                                vx /
                                fontSizeScale;
                              scaledY =
                                (x + vy) /
                                fontSizeScale;
                            } else {
                              scaledX =
                                x / fontSizeScale;
                              scaledY = 0;
                            }

                            if (
                              font.remeasure &&
                              width > 0
                            ) {
                              var measuredWidth =
                                ((ctx.measureText(
                                  character
                                ).width *
                                  1000) /
                                  fontSize) *
                                fontSizeScale;

                              if (
                                width <
                                  measuredWidth &&
                                this
                                  .isFontSubpixelAAEnabled
                              ) {
                                var characterScaleX =
                                  width /
                                  measuredWidth;
                                restoreNeeded = true;
                                ctx.save();
                                ctx.scale(
                                  characterScaleX,
                                  1
                                );
                                scaledX /=
                                  characterScaleX;
                              } else if (
                                width !==
                                measuredWidth
                              ) {
                                scaledX +=
                                  (((width -
                                    measuredWidth) /
                                    2000) *
                                    fontSize) /
                                  fontSizeScale;
                              }
                            }

                            if (
                              this
                                .contentVisible &&
                              (glyph.isInFont ||
                                font.missingFile)
                            ) {
                              if (
                                simpleFillText &&
                                !accent
                              ) {
                                ctx.fillText(
                                  character,
                                  scaledX,
                                  scaledY
                                );
                              } else {
                                this.paintChar(
                                  character,
                                  scaledX,
                                  scaledY,
                                  patternTransform,
                                  resetLineWidthToOne
                                );

                                if (accent) {
                                  var scaledAccentX =
                                    scaledX +
                                    (fontSize *
                                      accent
                                        .offset
                                        .x) /
                                      fontSizeScale;
                                  var scaledAccentY =
                                    scaledY -
                                    (fontSize *
                                      accent
                                        .offset
                                        .y) /
                                      fontSizeScale;
                                  this.paintChar(
                                    accent.fontChar,
                                    scaledAccentX,
                                    scaledAccentY,
                                    patternTransform,
                                    resetLineWidthToOne
                                  );
                                }
                              }
                            }

                            var charWidth =
                              void 0;

                            if (vertical) {
                              charWidth =
                                width *
                                  widthAdvanceScale -
                                spacing *
                                  fontDirection;
                            } else {
                              charWidth =
                                width *
                                  widthAdvanceScale +
                                spacing *
                                  fontDirection;
                            }

                            x += charWidth;

                            if (restoreNeeded) {
                              ctx.restore();
                            }
                          }

                          if (vertical) {
                            current.y -= x;
                          } else {
                            current.x +=
                              x * textHScale;
                          }

                          ctx.restore();
                        },
                      showType3Text:
                        function CanvasGraphics_showType3Text(
                          glyphs
                        ) {
                          var ctx = this.ctx;
                          var current =
                            this.current;
                          var font = current.font;
                          var fontSize =
                            current.fontSize;
                          var fontDirection =
                            current.fontDirection;
                          var spacingDir =
                            font.vertical
                              ? 1
                              : -1;
                          var charSpacing =
                            current.charSpacing;
                          var wordSpacing =
                            current.wordSpacing;
                          var textHScale =
                            current.textHScale *
                            fontDirection;
                          var fontMatrix =
                            current.fontMatrix ||
                            _util.FONT_IDENTITY_MATRIX;
                          var glyphsLength =
                            glyphs.length;
                          var isTextInvisible =
                            current.textRenderingMode ===
                            _util
                              .TextRenderingMode
                              .INVISIBLE;
                          var i,
                            glyph,
                            width,
                            spacingLength;

                          if (
                            isTextInvisible ||
                            fontSize === 0
                          ) {
                            return;
                          }

                          this._cachedGetSinglePixelWidth =
                            null;
                          ctx.save();
                          ctx.transform.apply(
                            ctx,
                            current.textMatrix
                          );
                          ctx.translate(
                            current.x,
                            current.y
                          );
                          ctx.scale(
                            textHScale,
                            fontDirection
                          );

                          for (
                            i = 0;
                            i < glyphsLength;
                            ++i
                          ) {
                            glyph = glyphs[i];

                            if (
                              (0, _util.isNum)(
                                glyph
                              )
                            ) {
                              spacingLength =
                                (spacingDir *
                                  glyph *
                                  fontSize) /
                                1000;
                              this.ctx.translate(
                                spacingLength,
                                0
                              );
                              current.x +=
                                spacingLength *
                                textHScale;
                              continue;
                            }

                            var spacing =
                              (glyph.isSpace
                                ? wordSpacing
                                : 0) +
                              charSpacing;
                            var operatorList =
                              font
                                .charProcOperatorList[
                                glyph
                                  .operatorListId
                              ];

                            if (!operatorList) {
                              (0, _util.warn)(
                                'Type3 character "'.concat(
                                  glyph.operatorListId,
                                  '" is not available.'
                                )
                              );
                              continue;
                            }

                            if (
                              this.contentVisible
                            ) {
                              this.processingType3 =
                                glyph;
                              this.save();
                              ctx.scale(
                                fontSize,
                                fontSize
                              );
                              ctx.transform.apply(
                                ctx,
                                fontMatrix
                              );
                              this.executeOperatorList(
                                operatorList
                              );
                              this.restore();
                            }

                            var transformed =
                              _util.Util.applyTransform(
                                [glyph.width, 0],
                                fontMatrix
                              );

                            width =
                              transformed[0] *
                                fontSize +
                              spacing;
                            ctx.translate(
                              width,
                              0
                            );
                            current.x +=
                              width * textHScale;
                          }

                          ctx.restore();
                          this.processingType3 =
                            null;
                        },
                      setCharWidth:
                        function CanvasGraphics_setCharWidth(
                          xWidth,
                          yWidth
                        ) {},
                      setCharWidthAndBounds:
                        function CanvasGraphics_setCharWidthAndBounds(
                          xWidth,
                          yWidth,
                          llx,
                          lly,
                          urx,
                          ury
                        ) {
                          this.ctx.rect(
                            llx,
                            lly,
                            urx - llx,
                            ury - lly
                          );
                          this.clip();
                          this.endPath();
                        },
                      getColorN_Pattern:
                        function CanvasGraphics_getColorN_Pattern(
                          IR
                        ) {
                          var _this = this;

                          var pattern;

                          if (
                            IR[0] ===
                            "TilingPattern"
                          ) {
                            var color = IR[1];
                            var baseTransform =
                              this
                                .baseTransform ||
                              this.ctx.mozCurrentTransform.slice();
                            var canvasGraphicsFactory =
                              {
                                createCanvasGraphics:
                                  function createCanvasGraphics(
                                    ctx
                                  ) {
                                    return new CanvasGraphics(
                                      ctx,
                                      _this.commonObjs,
                                      _this.objs,
                                      _this.canvasFactory,
                                      _this.webGLContext
                                    );
                                  },
                              };
                            pattern =
                              new _pattern_helper.TilingPattern(
                                IR,
                                color,
                                this.ctx,
                                canvasGraphicsFactory,
                                baseTransform
                              );
                          } else {
                            pattern = (0,
                            _pattern_helper.getShadingPatternFromIR)(
                              IR
                            );
                          }

                          return pattern;
                        },
                      setStrokeColorN:
                        function CanvasGraphics_setStrokeColorN() {
                          this.current.strokeColor =
                            this.getColorN_Pattern(
                              arguments
                            );
                        },
                      setFillColorN:
                        function CanvasGraphics_setFillColorN() {
                          this.current.fillColor =
                            this.getColorN_Pattern(
                              arguments
                            );
                          this.current.patternFill = true;
                        },
                      setStrokeRGBColor:
                        function CanvasGraphics_setStrokeRGBColor(
                          r,
                          g,
                          b
                        ) {
                          var color =
                            _util.Util.makeHexColor(
                              r,
                              g,
                              b
                            );

                          this.ctx.strokeStyle =
                            color;
                          this.current.strokeColor =
                            color;
                        },
                      setFillRGBColor:
                        function CanvasGraphics_setFillRGBColor(
                          r,
                          g,
                          b
                        ) {
                          var color =
                            _util.Util.makeHexColor(
                              r,
                              g,
                              b
                            );

                          this.ctx.fillStyle =
                            color;
                          this.current.fillColor =
                            color;
                          this.current.patternFill = false;
                        },
                      shadingFill:
                        function CanvasGraphics_shadingFill(
                          patternIR
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          var ctx = this.ctx;
                          this.save();
                          var pattern = (0,
                          _pattern_helper.getShadingPatternFromIR)(
                            patternIR
                          );
                          ctx.fillStyle =
                            pattern.getPattern(
                              ctx,
                              this,
                              true
                            );
                          var inv =
                            ctx.mozCurrentTransformInverse;

                          if (inv) {
                            var canvas =
                              ctx.canvas;
                            var width =
                              canvas.width;
                            var height =
                              canvas.height;

                            var bl =
                              _util.Util.applyTransform(
                                [0, 0],
                                inv
                              );

                            var br =
                              _util.Util.applyTransform(
                                [0, height],
                                inv
                              );

                            var ul =
                              _util.Util.applyTransform(
                                [width, 0],
                                inv
                              );

                            var ur =
                              _util.Util.applyTransform(
                                [width, height],
                                inv
                              );

                            var x0 = Math.min(
                              bl[0],
                              br[0],
                              ul[0],
                              ur[0]
                            );
                            var y0 = Math.min(
                              bl[1],
                              br[1],
                              ul[1],
                              ur[1]
                            );
                            var x1 = Math.max(
                              bl[0],
                              br[0],
                              ul[0],
                              ur[0]
                            );
                            var y1 = Math.max(
                              bl[1],
                              br[1],
                              ul[1],
                              ur[1]
                            );
                            this.ctx.fillRect(
                              x0,
                              y0,
                              x1 - x0,
                              y1 - y0
                            );
                          } else {
                            this.ctx.fillRect(
                              -1e10,
                              -1e10,
                              2e10,
                              2e10
                            );
                          }

                          this.restore();
                        },
                      beginInlineImage:
                        function CanvasGraphics_beginInlineImage() {
                          (0, _util.unreachable)(
                            "Should not call beginInlineImage"
                          );
                        },
                      beginImageData:
                        function CanvasGraphics_beginImageData() {
                          (0, _util.unreachable)(
                            "Should not call beginImageData"
                          );
                        },
                      paintFormXObjectBegin:
                        function CanvasGraphics_paintFormXObjectBegin(
                          matrix,
                          bbox
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          this.save();
                          this.baseTransformStack.push(
                            this.baseTransform
                          );

                          if (
                            Array.isArray(
                              matrix
                            ) &&
                            matrix.length === 6
                          ) {
                            this.transform.apply(
                              this,
                              matrix
                            );
                          }

                          this.baseTransform =
                            this.ctx.mozCurrentTransform;

                          if (bbox) {
                            var width =
                              bbox[2] - bbox[0];
                            var height =
                              bbox[3] - bbox[1];
                            this.ctx.rect(
                              bbox[0],
                              bbox[1],
                              width,
                              height
                            );
                            this.clip();
                            this.endPath();
                          }
                        },
                      paintFormXObjectEnd:
                        function CanvasGraphics_paintFormXObjectEnd() {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          this.restore();
                          this.baseTransform =
                            this.baseTransformStack.pop();
                        },
                      beginGroup:
                        function CanvasGraphics_beginGroup(
                          group
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          this.save();
                          var currentCtx =
                            this.ctx;

                          if (!group.isolated) {
                            (0, _util.info)(
                              "TODO: Support non-isolated groups."
                            );
                          }

                          if (group.knockout) {
                            (0, _util.warn)(
                              "Knockout groups not supported."
                            );
                          }

                          if (
                            !(
                              this.ctx
                                .beginChildGroup &&
                              typeof this.ctx
                                .beginChildGroup ===
                                "function" &&
                              this.ctx.beginChildGroup(
                                group
                              )
                            )
                          ) {
                            var currentTransform =
                              currentCtx.mozCurrentTransform;

                            if (group.matrix) {
                              currentCtx.transform.apply(
                                currentCtx,
                                group.matrix
                              );
                            }

                            if (!group.bbox) {
                              throw new Error(
                                "Bounding box is required."
                              );
                            }

                            var bounds =
                              _util.Util.getAxialAlignedBoundingBox(
                                group.bbox,
                                currentCtx.mozCurrentTransform
                              );

                            var canvasBounds = [
                              0,
                              0,
                              currentCtx.canvas
                                .width,
                              currentCtx.canvas
                                .height,
                            ];
                            bounds =
                              _util.Util.intersect(
                                bounds,
                                canvasBounds
                              ) || [0, 0, 0, 0];
                            var offsetX =
                              Math.floor(
                                bounds[0]
                              );
                            var offsetY =
                              Math.floor(
                                bounds[1]
                              );
                            var drawnWidth =
                              Math.max(
                                Math.ceil(
                                  bounds[2]
                                ) - offsetX,
                                1
                              );
                            var drawnHeight =
                              Math.max(
                                Math.ceil(
                                  bounds[3]
                                ) - offsetY,
                                1
                              );
                            var scaleX = 1,
                              scaleY = 1;

                            if (
                              drawnWidth >
                              MAX_GROUP_SIZE
                            ) {
                              scaleX =
                                drawnWidth /
                                MAX_GROUP_SIZE;
                              drawnWidth =
                                MAX_GROUP_SIZE;
                            }

                            if (
                              drawnHeight >
                              MAX_GROUP_SIZE
                            ) {
                              scaleY =
                                drawnHeight /
                                MAX_GROUP_SIZE;
                              drawnHeight =
                                MAX_GROUP_SIZE;
                            }

                            var cacheId =
                              "groupAt" +
                              this.groupLevel;

                            if (group.smask) {
                              cacheId +=
                                "_smask_" +
                                (this
                                  .smaskCounter++ %
                                  2);
                            }

                            var scratchCanvas =
                              this.cachedCanvases.getCanvas(
                                cacheId,
                                drawnWidth,
                                drawnHeight,
                                true
                              );
                            var groupCtx =
                              scratchCanvas.context;
                            groupCtx.scale(
                              1 / scaleX,
                              1 / scaleY
                            );
                            groupCtx.translate(
                              -offsetX,
                              -offsetY
                            );
                            groupCtx.transform.apply(
                              groupCtx,
                              currentTransform
                            );

                            if (group.smask) {
                              this.smaskStack.push(
                                {
                                  canvas:
                                    scratchCanvas.canvas,
                                  context:
                                    groupCtx,
                                  offsetX:
                                    offsetX,
                                  offsetY:
                                    offsetY,
                                  scaleX: scaleX,
                                  scaleY: scaleY,
                                  subtype:
                                    group.smask
                                      .subtype,
                                  backdrop:
                                    group.smask
                                      .backdrop,
                                  transferMap:
                                    group.smask
                                      .transferMap ||
                                    null,
                                  startTransformInverse:
                                    null,
                                }
                              );
                            } else {
                              currentCtx.setTransform(
                                1,
                                0,
                                0,
                                1,
                                0,
                                0
                              );
                              currentCtx.translate(
                                offsetX,
                                offsetY
                              );
                              currentCtx.scale(
                                scaleX,
                                scaleY
                              );
                            }

                            copyCtxState(
                              currentCtx,
                              groupCtx
                            );
                            this.ctx = groupCtx;
                          }

                          this.setGState([
                            ["BM", "source-over"],
                            ["ca", 1],
                            ["CA", 1],
                          ]);
                          this.groupStack.push(
                            currentCtx
                          );
                          this.groupLevel++;
                          this.current.activeSMask =
                            null;
                        },
                      endGroup:
                        function CanvasGraphics_endGroup(
                          group
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          this.groupLevel--;
                          var groupCtx = this.ctx;
                          this.ctx =
                            this.groupStack.pop();

                          if (
                            !(
                              this.ctx
                                .endChildGroup &&
                              typeof this.ctx
                                .endChildGroup ===
                                "function" &&
                              this.ctx.endChildGroup(
                                group
                              )
                            )
                          ) {
                            if (
                              this.ctx
                                .imageSmoothingEnabled !==
                              undefined
                            ) {
                              this.ctx.imageSmoothingEnabled = false;
                            } else {
                              this.ctx.mozImageSmoothingEnabled = false;
                            }

                            if (group.smask) {
                              this.tempSMask =
                                this.smaskStack.pop();
                            } else {
                              this.ctx.drawImage(
                                groupCtx.canvas,
                                0,
                                0
                              );
                            }
                          }

                          this.restore();
                        },
                      beginAnnotations:
                        function CanvasGraphics_beginAnnotations() {},
                      endAnnotations:
                        function CanvasGraphics_endAnnotations() {},
                      beginAnnotation:
                        function CanvasGraphics_beginAnnotation(
                          rect,
                          transform,
                          matrix
                        ) {
                          this.restoreInitialState();
                          resetCtxToDefault(
                            this.ctx
                          );
                          this.ctx.save();
                          this.save();

                          if (
                            this.baseTransform
                          ) {
                            this.ctx.setTransform.apply(
                              this.ctx,
                              this.baseTransform
                            );
                          }

                          this.ctx.beginPath();
                          this.current =
                            new CanvasExtraState();

                          if (
                            Array.isArray(rect) &&
                            rect.length === 4
                          ) {
                            var width =
                              rect[2] - rect[0];
                            var height =
                              rect[3] - rect[1];
                            this.ctx.rect(
                              rect[0],
                              rect[1],
                              width,
                              height
                            );
                            this.clip();
                            this.endPath();
                          }

                          this.transform.apply(
                            this,
                            transform
                          );
                          this.transform.apply(
                            this,
                            matrix
                          );
                        },
                      endAnnotation:
                        function CanvasGraphics_endAnnotation() {},
                      paintJpegXObject:
                        function CanvasGraphics_paintJpegXObject(
                          objId,
                          w,
                          h
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          var domImage = this
                            .processingType3
                            ? this.commonObjs.get(
                                objId
                              )
                            : this.objs.get(
                                objId
                              );

                          if (!domImage) {
                            (0, _util.warn)(
                              "Dependent image isn't ready yet"
                            );
                            return;
                          }

                          this.save();
                          var ctx = this.ctx;
                          ctx.scale(
                            1 / w,
                            -1 / h
                          );
                          ctx.drawImage(
                            domImage,
                            0,
                            0,
                            domImage.width,
                            domImage.height,
                            0,
                            -h,
                            w,
                            h
                          );

                          if (this.imageLayer) {
                            var currentTransform =
                              ctx.mozCurrentTransformInverse;
                            var position =
                              this.getCanvasPosition(
                                0,
                                0
                              );
                            this.imageLayer.appendImage(
                              {
                                objId: objId,
                                left: position[0],
                                top: position[1],
                                width:
                                  w /
                                  currentTransform[0],
                                height:
                                  h /
                                  currentTransform[3],
                              }
                            );
                          }

                          this.restore();
                        },
                      paintImageMaskXObject:
                        function CanvasGraphics_paintImageMaskXObject(
                          img
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          var ctx = this.ctx;
                          var width = img.width,
                            height = img.height;
                          var fillColor =
                            this.current
                              .fillColor;
                          var isPatternFill =
                            this.current
                              .patternFill;
                          var glyph =
                            this.processingType3;

                          if (
                            COMPILE_TYPE3_GLYPHS &&
                            glyph &&
                            glyph.compiled ===
                              undefined
                          ) {
                            if (
                              width <=
                                MAX_SIZE_TO_COMPILE &&
                              height <=
                                MAX_SIZE_TO_COMPILE
                            ) {
                              glyph.compiled =
                                compileType3Glyph(
                                  {
                                    data: img.data,
                                    width: width,
                                    height:
                                      height,
                                  }
                                );
                            } else {
                              glyph.compiled =
                                null;
                            }
                          }

                          if (
                            glyph !== null &&
                            glyph !== void 0 &&
                            glyph.compiled
                          ) {
                            glyph.compiled(ctx);
                            return;
                          }

                          var maskCanvas =
                            this.cachedCanvases.getCanvas(
                              "maskCanvas",
                              width,
                              height
                            );
                          var maskCtx =
                            maskCanvas.context;
                          maskCtx.save();
                          putBinaryImageMask(
                            maskCtx,
                            img
                          );
                          maskCtx.globalCompositeOperation =
                            "source-in";
                          maskCtx.fillStyle =
                            isPatternFill
                              ? fillColor.getPattern(
                                  maskCtx,
                                  this
                                )
                              : fillColor;
                          maskCtx.fillRect(
                            0,
                            0,
                            width,
                            height
                          );
                          maskCtx.restore();
                          this.paintInlineImageXObject(
                            maskCanvas.canvas
                          );
                        },
                      paintImageMaskXObjectRepeat:
                        function paintImageMaskXObjectRepeat(
                          imgData,
                          scaleX
                        ) {
                          var skewX =
                            arguments.length >
                              2 &&
                            arguments[2] !==
                              undefined
                              ? arguments[2]
                              : 0;
                          var skewY =
                            arguments.length >
                              3 &&
                            arguments[3] !==
                              undefined
                              ? arguments[3]
                              : 0;
                          var scaleY =
                            arguments.length > 4
                              ? arguments[4]
                              : undefined;
                          var positions =
                            arguments.length > 5
                              ? arguments[5]
                              : undefined;

                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          var width =
                            imgData.width;
                          var height =
                            imgData.height;
                          var fillColor =
                            this.current
                              .fillColor;
                          var isPatternFill =
                            this.current
                              .patternFill;
                          var maskCanvas =
                            this.cachedCanvases.getCanvas(
                              "maskCanvas",
                              width,
                              height
                            );
                          var maskCtx =
                            maskCanvas.context;
                          maskCtx.save();
                          putBinaryImageMask(
                            maskCtx,
                            imgData
                          );
                          maskCtx.globalCompositeOperation =
                            "source-in";
                          maskCtx.fillStyle =
                            isPatternFill
                              ? fillColor.getPattern(
                                  maskCtx,
                                  this
                                )
                              : fillColor;
                          maskCtx.fillRect(
                            0,
                            0,
                            width,
                            height
                          );
                          maskCtx.restore();
                          var ctx = this.ctx;

                          for (
                            var i = 0,
                              ii =
                                positions.length;
                            i < ii;
                            i += 2
                          ) {
                            ctx.save();
                            ctx.transform(
                              scaleX,
                              skewX,
                              skewY,
                              scaleY,
                              positions[i],
                              positions[i + 1]
                            );
                            ctx.scale(1, -1);
                            ctx.drawImage(
                              maskCanvas.canvas,
                              0,
                              0,
                              width,
                              height,
                              0,
                              -1,
                              1,
                              1
                            );
                            ctx.restore();
                          }
                        },
                      paintImageMaskXObjectGroup:
                        function CanvasGraphics_paintImageMaskXObjectGroup(
                          images
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          var ctx = this.ctx;
                          var fillColor =
                            this.current
                              .fillColor;
                          var isPatternFill =
                            this.current
                              .patternFill;

                          for (
                            var i = 0,
                              ii = images.length;
                            i < ii;
                            i++
                          ) {
                            var image = images[i];
                            var width =
                                image.width,
                              height =
                                image.height;
                            var maskCanvas =
                              this.cachedCanvases.getCanvas(
                                "maskCanvas",
                                width,
                                height
                              );
                            var maskCtx =
                              maskCanvas.context;
                            maskCtx.save();
                            putBinaryImageMask(
                              maskCtx,
                              image
                            );
                            maskCtx.globalCompositeOperation =
                              "source-in";
                            maskCtx.fillStyle =
                              isPatternFill
                                ? fillColor.getPattern(
                                    maskCtx,
                                    this
                                  )
                                : fillColor;
                            maskCtx.fillRect(
                              0,
                              0,
                              width,
                              height
                            );
                            maskCtx.restore();
                            ctx.save();
                            ctx.transform.apply(
                              ctx,
                              image.transform
                            );
                            ctx.scale(1, -1);
                            ctx.drawImage(
                              maskCanvas.canvas,
                              0,
                              0,
                              width,
                              height,
                              0,
                              -1,
                              1,
                              1
                            );
                            ctx.restore();
                          }
                        },
                      paintImageXObject:
                        function CanvasGraphics_paintImageXObject(
                          objId
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          var imgData =
                            objId.startsWith("g_")
                              ? this.commonObjs.get(
                                  objId
                                )
                              : this.objs.get(
                                  objId
                                );

                          if (!imgData) {
                            (0, _util.warn)(
                              "Dependent image isn't ready yet"
                            );
                            return;
                          }

                          this.paintInlineImageXObject(
                            imgData
                          );
                        },
                      paintImageXObjectRepeat:
                        function CanvasGraphics_paintImageXObjectRepeat(
                          objId,
                          scaleX,
                          scaleY,
                          positions
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          var imgData =
                            objId.startsWith("g_")
                              ? this.commonObjs.get(
                                  objId
                                )
                              : this.objs.get(
                                  objId
                                );

                          if (!imgData) {
                            (0, _util.warn)(
                              "Dependent image isn't ready yet"
                            );
                            return;
                          }

                          var width =
                            imgData.width;
                          var height =
                            imgData.height;
                          var map = [];

                          for (
                            var i = 0,
                              ii =
                                positions.length;
                            i < ii;
                            i += 2
                          ) {
                            map.push({
                              transform: [
                                scaleX,
                                0,
                                0,
                                scaleY,
                                positions[i],
                                positions[i + 1],
                              ],
                              x: 0,
                              y: 0,
                              w: width,
                              h: height,
                            });
                          }

                          this.paintInlineImageXObjectGroup(
                            imgData,
                            map
                          );
                        },
                      paintInlineImageXObject:
                        function CanvasGraphics_paintInlineImageXObject(
                          imgData
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          var width =
                            imgData.width;
                          var height =
                            imgData.height;
                          var ctx = this.ctx;
                          this.save();
                          ctx.scale(
                            1 / width,
                            -1 / height
                          );
                          var currentTransform =
                            ctx.mozCurrentTransformInverse;
                          var widthScale =
                            Math.max(
                              Math.hypot(
                                currentTransform[0],
                                currentTransform[1]
                              ),
                              1
                            );
                          var heightScale =
                            Math.max(
                              Math.hypot(
                                currentTransform[2],
                                currentTransform[3]
                              ),
                              1
                            );
                          var imgToPaint,
                            tmpCanvas,
                            tmpCtx;

                          if (
                            (typeof HTMLElement ===
                              "function" &&
                              imgData instanceof
                                HTMLElement) ||
                            !imgData.data
                          ) {
                            imgToPaint = imgData;
                          } else {
                            tmpCanvas =
                              this.cachedCanvases.getCanvas(
                                "inlineImage",
                                width,
                                height
                              );
                            tmpCtx =
                              tmpCanvas.context;
                            putBinaryImageData(
                              tmpCtx,
                              imgData,
                              this.current
                                .transferMaps
                            );
                            imgToPaint =
                              tmpCanvas.canvas;
                          }

                          var paintWidth = width,
                            paintHeight = height;
                          var tmpCanvasId =
                            "prescale1";

                          while (
                            (widthScale > 2 &&
                              paintWidth > 1) ||
                            (heightScale > 2 &&
                              paintHeight > 1)
                          ) {
                            var newWidth =
                                paintWidth,
                              newHeight =
                                paintHeight;

                            if (
                              widthScale > 2 &&
                              paintWidth > 1
                            ) {
                              newWidth =
                                Math.ceil(
                                  paintWidth / 2
                                );
                              widthScale /=
                                paintWidth /
                                newWidth;
                            }

                            if (
                              heightScale > 2 &&
                              paintHeight > 1
                            ) {
                              newHeight =
                                Math.ceil(
                                  paintHeight / 2
                                );
                              heightScale /=
                                paintHeight /
                                newHeight;
                            }

                            tmpCanvas =
                              this.cachedCanvases.getCanvas(
                                tmpCanvasId,
                                newWidth,
                                newHeight
                              );
                            tmpCtx =
                              tmpCanvas.context;
                            tmpCtx.clearRect(
                              0,
                              0,
                              newWidth,
                              newHeight
                            );
                            tmpCtx.drawImage(
                              imgToPaint,
                              0,
                              0,
                              paintWidth,
                              paintHeight,
                              0,
                              0,
                              newWidth,
                              newHeight
                            );
                            imgToPaint =
                              tmpCanvas.canvas;
                            paintWidth = newWidth;
                            paintHeight =
                              newHeight;
                            tmpCanvasId =
                              tmpCanvasId ===
                              "prescale1"
                                ? "prescale2"
                                : "prescale1";
                          }

                          ctx.drawImage(
                            imgToPaint,
                            0,
                            0,
                            paintWidth,
                            paintHeight,
                            0,
                            -height,
                            width,
                            height
                          );

                          if (this.imageLayer) {
                            var position =
                              this.getCanvasPosition(
                                0,
                                -height
                              );
                            this.imageLayer.appendImage(
                              {
                                imgData: imgData,
                                left: position[0],
                                top: position[1],
                                width:
                                  width /
                                  currentTransform[0],
                                height:
                                  height /
                                  currentTransform[3],
                              }
                            );
                          }

                          this.restore();
                        },
                      paintInlineImageXObjectGroup:
                        function CanvasGraphics_paintInlineImageXObjectGroup(
                          imgData,
                          map
                        ) {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          var ctx = this.ctx;
                          var w = imgData.width;
                          var h = imgData.height;
                          var tmpCanvas =
                            this.cachedCanvases.getCanvas(
                              "inlineImage",
                              w,
                              h
                            );
                          var tmpCtx =
                            tmpCanvas.context;
                          putBinaryImageData(
                            tmpCtx,
                            imgData,
                            this.current
                              .transferMaps
                          );

                          for (
                            var i = 0,
                              ii = map.length;
                            i < ii;
                            i++
                          ) {
                            var entry = map[i];
                            ctx.save();
                            ctx.transform.apply(
                              ctx,
                              entry.transform
                            );
                            ctx.scale(1, -1);
                            ctx.drawImage(
                              tmpCanvas.canvas,
                              entry.x,
                              entry.y,
                              entry.w,
                              entry.h,
                              0,
                              -1,
                              1,
                              1
                            );

                            if (this.imageLayer) {
                              var position =
                                this.getCanvasPosition(
                                  entry.x,
                                  entry.y
                                );
                              this.imageLayer.appendImage(
                                {
                                  imgData:
                                    imgData,
                                  left: position[0],
                                  top: position[1],
                                  width: w,
                                  height: h,
                                }
                              );
                            }

                            ctx.restore();
                          }
                        },
                      paintSolidColorImageMask:
                        function CanvasGraphics_paintSolidColorImageMask() {
                          if (
                            !this.contentVisible
                          ) {
                            return;
                          }

                          this.ctx.fillRect(
                            0,
                            0,
                            1,
                            1
                          );
                        },
                      markPoint:
                        function CanvasGraphics_markPoint(
                          tag
                        ) {},
                      markPointProps:
                        function CanvasGraphics_markPointProps(
                          tag,
                          properties
                        ) {},
                      beginMarkedContent:
                        function CanvasGraphics_beginMarkedContent(
                          tag
                        ) {
                          this.markedContentStack.push(
                            {
                              visible: true,
                            }
                          );

                          if (
                            this.ctx
                              .beginMarkedContent
                          ) {
                            this.ctx.beginMarkedContent(
                              tag
                            );
                          }
                        },
                      beginMarkedContentProps:
                        function CanvasGraphics_beginMarkedContentProps(
                          tag,
                          properties
                        ) {
                          if (tag === "OC") {
                            this.markedContentStack.push(
                              {
                                visible:
                                  this.optionalContentConfig.isVisible(
                                    properties
                                  ),
                              }
                            );
                          } else {
                            this.markedContentStack.push(
                              {
                                visible: true,
                              }
                            );
                          }

                          this.contentVisible = true;

                          if (
                            this.ctx
                              .beginMarkedContentProps
                          ) {
                            this.ctx.beginMarkedContentProps(
                              tag,
                              properties
                            );
                          }
                        },
                      endMarkedContent:
                        function CanvasGraphics_endMarkedContent() {
                          this.markedContentStack.pop();
                          this.contentVisible = true;

                          if (
                            this.ctx
                              .endMarkedContent
                          ) {
                            this.ctx.endMarkedContent();
                          }
                        },
                      setCurrentOperatorIndex:
                        function CanvasGraphics_setCurrentOperatorIndex(
                          index
                        ) {
                          if (
                            this.ctx
                              .setCurrentOperatorIndex
                          ) {
                            this.ctx.setCurrentOperatorIndex(
                              index
                            );
                          }
                        },
                      beginCompat:
                        function CanvasGraphics_beginCompat() {},
                      endCompat:
                        function CanvasGraphics_endCompat() {},
                      consumePath:
                        function CanvasGraphics_consumePath() {
                          var ctx = this.ctx;

                          if (this.pendingClip) {
                            if (
                              this.pendingClip ===
                              EO_CLIP
                            ) {
                              ctx.clip("evenodd");
                            } else {
                              ctx.clip();
                            }

                            this.pendingClip =
                              null;
                          }

                          ctx.beginPath();
                        },
                      getSinglePixelWidth:
                        function getSinglePixelWidth() {
                          if (
                            this
                              ._cachedGetSinglePixelWidth ===
                            null
                          ) {
                            this._cachedGetSinglePixelWidth = 1e-10;
                          }

                          return this
                            ._cachedGetSinglePixelWidth;
                        },
                      getCanvasPosition:
                        function CanvasGraphics_getCanvasPosition(
                          x,
                          y
                        ) {
                          var transform =
                            this.ctx
                              .mozCurrentTransform;
                          return [
                            transform[0] * x +
                              transform[2] * y +
                              transform[4],
                            transform[1] * x +
                              transform[3] * y +
                              transform[5],
                          ];
                        },
                      isContentVisible:
                        function CanvasGraphics_isContentVisible() {
                          for (
                            var i =
                              this
                                .markedContentStack
                                .length - 1;
                            i >= 0;
                            i--
                          ) {
                            if (
                              !this
                                .markedContentStack[
                                i
                              ].visible
                            ) {
                              return false;
                            }
                          }

                          return true;
                        },
                    };

                    for (var op in _util.OPS) {
                      CanvasGraphics.prototype[
                        _util.OPS[op]
                      ] =
                        CanvasGraphics.prototype[
                          op
                        ];
                    }

                    return CanvasGraphics;
                  })();

                exports.CanvasGraphics =
                  CanvasGraphics;

                /***/
              },
              /* 141 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.getShadingPatternFromIR =
                  getShadingPatternFromIR;
                exports.TilingPattern = void 0;

                var _util =
                  __w_pdfjs_require__(4);

                var ShadingIRs = {};

                function applyBoundingBox(
                  ctx,
                  bbox
                ) {
                  if (
                    !bbox ||
                    typeof Path2D === "undefined"
                  ) {
                    return;
                  }

                  var width = bbox[2] - bbox[0];
                  var height = bbox[3] - bbox[1];
                  var region = new Path2D();
                  region.rect(
                    bbox[0],
                    bbox[1],
                    width,
                    height
                  );
                  ctx.clip(region);
                }

                ShadingIRs.RadialAxial = {
                  fromIR:
                    function RadialAxial_fromIR(
                      raw
                    ) {
                      var type = raw[1];
                      var bbox = raw[2];
                      var colorStops = raw[3];
                      var p0 = raw[4];
                      var p1 = raw[5];
                      var r0 = raw[6];
                      var r1 = raw[7];
                      return {
                        getPattern:
                          function RadialAxial_getPattern(
                            ctx
                          ) {
                            applyBoundingBox(
                              ctx,
                              bbox
                            );
                            var grad;

                            if (
                              type === "axial"
                            ) {
                              grad =
                                ctx.createLinearGradient(
                                  p0[0],
                                  p0[1],
                                  p1[0],
                                  p1[1]
                                );
                            } else if (
                              type === "radial"
                            ) {
                              grad =
                                ctx.createRadialGradient(
                                  p0[0],
                                  p0[1],
                                  r0,
                                  p1[0],
                                  p1[1],
                                  r1
                                );
                            }

                            if (grad) {
                              grad.rawData = raw;
                            }

                            for (
                              var i = 0,
                                ii =
                                  colorStops.length;
                              i < ii;
                              ++i
                            ) {
                              var c =
                                colorStops[i];
                              grad.addColorStop(
                                c[0],
                                c[1]
                              );
                            }

                            return grad;
                          },
                      };
                    },
                };

                var createMeshCanvas =
                  (function createMeshCanvasClosure() {
                    function drawTriangle(
                      data,
                      context,
                      p1,
                      p2,
                      p3,
                      c1,
                      c2,
                      c3
                    ) {
                      var coords = context.coords,
                        colors = context.colors;
                      var bytes = data.data,
                        rowSize = data.width * 4;
                      var tmp;

                      if (
                        coords[p1 + 1] >
                        coords[p2 + 1]
                      ) {
                        tmp = p1;
                        p1 = p2;
                        p2 = tmp;
                        tmp = c1;
                        c1 = c2;
                        c2 = tmp;
                      }

                      if (
                        coords[p2 + 1] >
                        coords[p3 + 1]
                      ) {
                        tmp = p2;
                        p2 = p3;
                        p3 = tmp;
                        tmp = c2;
                        c2 = c3;
                        c3 = tmp;
                      }

                      if (
                        coords[p1 + 1] >
                        coords[p2 + 1]
                      ) {
                        tmp = p1;
                        p1 = p2;
                        p2 = tmp;
                        tmp = c1;
                        c1 = c2;
                        c2 = tmp;
                      }

                      var x1 =
                        (coords[p1] +
                          context.offsetX) *
                        context.scaleX;
                      var y1 =
                        (coords[p1 + 1] +
                          context.offsetY) *
                        context.scaleY;
                      var x2 =
                        (coords[p2] +
                          context.offsetX) *
                        context.scaleX;
                      var y2 =
                        (coords[p2 + 1] +
                          context.offsetY) *
                        context.scaleY;
                      var x3 =
                        (coords[p3] +
                          context.offsetX) *
                        context.scaleX;
                      var y3 =
                        (coords[p3 + 1] +
                          context.offsetY) *
                        context.scaleY;

                      if (y1 >= y3) {
                        return;
                      }

                      var c1r = colors[c1],
                        c1g = colors[c1 + 1],
                        c1b = colors[c1 + 2];
                      var c2r = colors[c2],
                        c2g = colors[c2 + 1],
                        c2b = colors[c2 + 2];
                      var c3r = colors[c3],
                        c3g = colors[c3 + 1],
                        c3b = colors[c3 + 2];
                      var minY = Math.round(y1),
                        maxY = Math.round(y3);
                      var xa, car, cag, cab;
                      var xb, cbr, cbg, cbb;

                      for (
                        var y = minY;
                        y <= maxY;
                        y++
                      ) {
                        if (y < y2) {
                          var _k = void 0;

                          if (y < y1) {
                            _k = 0;
                          } else if (y1 === y2) {
                            _k = 1;
                          } else {
                            _k =
                              (y1 - y) /
                              (y1 - y2);
                          }

                          xa =
                            x1 - (x1 - x2) * _k;
                          car =
                            c1r -
                            (c1r - c2r) * _k;
                          cag =
                            c1g -
                            (c1g - c2g) * _k;
                          cab =
                            c1b -
                            (c1b - c2b) * _k;
                        } else {
                          var _k2 = void 0;

                          if (y > y3) {
                            _k2 = 1;
                          } else if (y2 === y3) {
                            _k2 = 0;
                          } else {
                            _k2 =
                              (y2 - y) /
                              (y2 - y3);
                          }

                          xa =
                            x2 - (x2 - x3) * _k2;
                          car =
                            c2r -
                            (c2r - c3r) * _k2;
                          cag =
                            c2g -
                            (c2g - c3g) * _k2;
                          cab =
                            c2b -
                            (c2b - c3b) * _k2;
                        }

                        var k = void 0;

                        if (y < y1) {
                          k = 0;
                        } else if (y > y3) {
                          k = 1;
                        } else {
                          k =
                            (y1 - y) / (y1 - y3);
                        }

                        xb = x1 - (x1 - x3) * k;
                        cbr =
                          c1r - (c1r - c3r) * k;
                        cbg =
                          c1g - (c1g - c3g) * k;
                        cbb =
                          c1b - (c1b - c3b) * k;
                        var x1_ = Math.round(
                          Math.min(xa, xb)
                        );
                        var x2_ = Math.round(
                          Math.max(xa, xb)
                        );
                        var j =
                          rowSize * y + x1_ * 4;

                        for (
                          var x = x1_;
                          x <= x2_;
                          x++
                        ) {
                          k =
                            (xa - x) / (xa - xb);

                          if (k < 0) {
                            k = 0;
                          } else if (k > 1) {
                            k = 1;
                          }

                          bytes[j++] =
                            (car -
                              (car - cbr) * k) |
                            0;
                          bytes[j++] =
                            (cag -
                              (cag - cbg) * k) |
                            0;
                          bytes[j++] =
                            (cab -
                              (cab - cbb) * k) |
                            0;
                          bytes[j++] = 255;
                        }
                      }
                    }

                    function drawFigure(
                      data,
                      figure,
                      context
                    ) {
                      var ps = figure.coords;
                      var cs = figure.colors;
                      var i, ii;

                      switch (figure.type) {
                        case "lattice":
                          var verticesPerRow =
                            figure.verticesPerRow;
                          var rows =
                            Math.floor(
                              ps.length /
                                verticesPerRow
                            ) - 1;
                          var cols =
                            verticesPerRow - 1;

                          for (
                            i = 0;
                            i < rows;
                            i++
                          ) {
                            var q =
                              i * verticesPerRow;

                            for (
                              var j = 0;
                              j < cols;
                              j++, q++
                            ) {
                              drawTriangle(
                                data,
                                context,
                                ps[q],
                                ps[q + 1],
                                ps[
                                  q +
                                    verticesPerRow
                                ],
                                cs[q],
                                cs[q + 1],
                                cs[
                                  q +
                                    verticesPerRow
                                ]
                              );
                              drawTriangle(
                                data,
                                context,
                                ps[
                                  q +
                                    verticesPerRow +
                                    1
                                ],
                                ps[q + 1],
                                ps[
                                  q +
                                    verticesPerRow
                                ],
                                cs[
                                  q +
                                    verticesPerRow +
                                    1
                                ],
                                cs[q + 1],
                                cs[
                                  q +
                                    verticesPerRow
                                ]
                              );
                            }
                          }

                          break;

                        case "triangles":
                          for (
                            i = 0, ii = ps.length;
                            i < ii;
                            i += 3
                          ) {
                            drawTriangle(
                              data,
                              context,
                              ps[i],
                              ps[i + 1],
                              ps[i + 2],
                              cs[i],
                              cs[i + 1],
                              cs[i + 2]
                            );
                          }

                          break;

                        default:
                          throw new Error(
                            "illegal figure"
                          );
                      }
                    }

                    function createMeshCanvas(
                      bounds,
                      combinesScale,
                      coords,
                      colors,
                      figures,
                      backgroundColor,
                      cachedCanvases,
                      webGLContext
                    ) {
                      var EXPECTED_SCALE = 1.1;
                      var MAX_PATTERN_SIZE = 3000;
                      var BORDER_SIZE = 2;
                      var offsetX = Math.floor(
                        bounds[0]
                      );
                      var offsetY = Math.floor(
                        bounds[1]
                      );
                      var boundsWidth =
                        Math.ceil(bounds[2]) -
                        offsetX;
                      var boundsHeight =
                        Math.ceil(bounds[3]) -
                        offsetY;
                      var width = Math.min(
                        Math.ceil(
                          Math.abs(
                            boundsWidth *
                              combinesScale[0] *
                              EXPECTED_SCALE
                          )
                        ),
                        MAX_PATTERN_SIZE
                      );
                      var height = Math.min(
                        Math.ceil(
                          Math.abs(
                            boundsHeight *
                              combinesScale[1] *
                              EXPECTED_SCALE
                          )
                        ),
                        MAX_PATTERN_SIZE
                      );
                      var scaleX =
                        boundsWidth / width;
                      var scaleY =
                        boundsHeight / height;
                      var context = {
                        coords: coords,
                        colors: colors,
                        offsetX: -offsetX,
                        offsetY: -offsetY,
                        scaleX: 1 / scaleX,
                        scaleY: 1 / scaleY,
                      };
                      var paddedWidth =
                        width + BORDER_SIZE * 2;
                      var paddedHeight =
                        height + BORDER_SIZE * 2;
                      var canvas,
                        tmpCanvas,
                        i,
                        ii;

                      if (
                        webGLContext.isEnabled
                      ) {
                        canvas =
                          webGLContext.drawFigures(
                            {
                              width: width,
                              height: height,
                              backgroundColor:
                                backgroundColor,
                              figures: figures,
                              context: context,
                            }
                          );
                        tmpCanvas =
                          cachedCanvases.getCanvas(
                            "mesh",
                            paddedWidth,
                            paddedHeight,
                            false
                          );
                        tmpCanvas.context.drawImage(
                          canvas,
                          BORDER_SIZE,
                          BORDER_SIZE
                        );
                        canvas = tmpCanvas.canvas;
                      } else {
                        tmpCanvas =
                          cachedCanvases.getCanvas(
                            "mesh",
                            paddedWidth,
                            paddedHeight,
                            false
                          );
                        var tmpCtx =
                          tmpCanvas.context;
                        var data =
                          tmpCtx.createImageData(
                            width,
                            height
                          );

                        if (backgroundColor) {
                          var bytes = data.data;

                          for (
                            i = 0,
                              ii = bytes.length;
                            i < ii;
                            i += 4
                          ) {
                            bytes[i] =
                              backgroundColor[0];
                            bytes[i + 1] =
                              backgroundColor[1];
                            bytes[i + 2] =
                              backgroundColor[2];
                            bytes[i + 3] = 255;
                          }
                        }

                        for (
                          i = 0;
                          i < figures.length;
                          i++
                        ) {
                          drawFigure(
                            data,
                            figures[i],
                            context
                          );
                        }

                        tmpCtx.putImageData(
                          data,
                          BORDER_SIZE,
                          BORDER_SIZE
                        );
                        canvas = tmpCanvas.canvas;
                      }

                      return {
                        canvas: canvas,
                        offsetX:
                          offsetX -
                          BORDER_SIZE * scaleX,
                        offsetY:
                          offsetY -
                          BORDER_SIZE * scaleY,
                        scaleX: scaleX,
                        scaleY: scaleY,
                      };
                    }

                    return createMeshCanvas;
                  })();

                ShadingIRs.Mesh = {
                  fromIR: function Mesh_fromIR(
                    raw
                  ) {
                    var coords = raw[2];
                    var colors = raw[3];
                    var figures = raw[4];
                    var bounds = raw[5];
                    var matrix = raw[6];
                    var bbox = raw[7];
                    var background = raw[8];
                    return {
                      getPattern:
                        function Mesh_getPattern(
                          ctx,
                          owner,
                          shadingFill
                        ) {
                          applyBoundingBox(
                            ctx,
                            bbox
                          );
                          var scale;

                          if (shadingFill) {
                            scale =
                              _util.Util.singularValueDecompose2dScale(
                                ctx.mozCurrentTransform
                              );
                          } else {
                            scale =
                              _util.Util.singularValueDecompose2dScale(
                                owner.baseTransform
                              );

                            if (matrix) {
                              var matrixScale =
                                _util.Util.singularValueDecompose2dScale(
                                  matrix
                                );

                              scale = [
                                scale[0] *
                                  matrixScale[0],
                                scale[1] *
                                  matrixScale[1],
                              ];
                            }
                          }

                          var temporaryPatternCanvas =
                            createMeshCanvas(
                              bounds,
                              scale,
                              coords,
                              colors,
                              figures,
                              shadingFill
                                ? null
                                : background,
                              owner.cachedCanvases,
                              owner.webGLContext
                            );

                          if (!shadingFill) {
                            ctx.setTransform.apply(
                              ctx,
                              owner.baseTransform
                            );

                            if (matrix) {
                              ctx.transform.apply(
                                ctx,
                                matrix
                              );
                            }
                          }

                          ctx.translate(
                            temporaryPatternCanvas.offsetX,
                            temporaryPatternCanvas.offsetY
                          );
                          ctx.scale(
                            temporaryPatternCanvas.scaleX,
                            temporaryPatternCanvas.scaleY
                          );
                          return ctx.createPattern(
                            temporaryPatternCanvas.canvas,
                            "no-repeat"
                          );
                        },
                    };
                  },
                };
                ShadingIRs.Dummy = {
                  fromIR:
                    function Dummy_fromIR() {
                      return {
                        getPattern:
                          function Dummy_fromIR_getPattern() {
                            return "hotpink";
                          },
                      };
                    },
                };

                function getShadingPatternFromIR(
                  raw
                ) {
                  var shadingIR =
                    ShadingIRs[raw[0]];

                  if (!shadingIR) {
                    throw new Error(
                      "Unknown IR type: ".concat(
                        raw[0]
                      )
                    );
                  }

                  return shadingIR.fromIR(raw);
                }

                var TilingPattern =
                  (function TilingPatternClosure() {
                    var PaintType = {
                      COLORED: 1,
                      UNCOLORED: 2,
                    };
                    var MAX_PATTERN_SIZE = 3000;

                    function TilingPattern(
                      IR,
                      color,
                      ctx,
                      canvasGraphicsFactory,
                      baseTransform
                    ) {
                      this.operatorList = IR[2];
                      this.matrix = IR[3] || [
                        1, 0, 0, 1, 0, 0,
                      ];
                      this.bbox = IR[4];
                      this.xstep = IR[5];
                      this.ystep = IR[6];
                      this.paintType = IR[7];
                      this.tilingType = IR[8];
                      this.color = color;
                      this.canvasGraphicsFactory =
                        canvasGraphicsFactory;
                      this.baseTransform =
                        baseTransform;
                      this.ctx = ctx;
                    }

                    TilingPattern.prototype = {
                      createPatternCanvas:
                        function TilinPattern_createPatternCanvas(
                          owner
                        ) {
                          var operatorList =
                            this.operatorList;
                          var bbox = this.bbox;
                          var xstep = this.xstep;
                          var ystep = this.ystep;
                          var paintType =
                            this.paintType;
                          var tilingType =
                            this.tilingType;
                          var color = this.color;
                          var canvasGraphicsFactory =
                            this
                              .canvasGraphicsFactory;
                          (0, _util.info)(
                            "TilingType: " +
                              tilingType
                          );
                          var x0 = bbox[0],
                            y0 = bbox[1],
                            x1 = bbox[2],
                            y1 = bbox[3];

                          var matrixScale =
                            _util.Util.singularValueDecompose2dScale(
                              this.matrix
                            );

                          var curMatrixScale =
                            _util.Util.singularValueDecompose2dScale(
                              this.baseTransform
                            );

                          var combinedScale = [
                            matrixScale[0] *
                              curMatrixScale[0],
                            matrixScale[1] *
                              curMatrixScale[1],
                          ];
                          var dimx =
                            this.getSizeAndScale(
                              xstep,
                              this.ctx.canvas
                                .width,
                              combinedScale[0]
                            );
                          var dimy =
                            this.getSizeAndScale(
                              ystep,
                              this.ctx.canvas
                                .height,
                              combinedScale[1]
                            );
                          var tmpCanvas =
                            owner.cachedCanvases.getCanvas(
                              "pattern",
                              dimx.size,
                              dimy.size,
                              true
                            );
                          var tmpCtx =
                            tmpCanvas.context;
                          var graphics =
                            canvasGraphicsFactory.createCanvasGraphics(
                              tmpCtx
                            );
                          graphics.groupLevel =
                            owner.groupLevel;
                          this.setFillAndStrokeStyleToContext(
                            graphics,
                            paintType,
                            color
                          );
                          graphics.transform(
                            dimx.scale,
                            0,
                            0,
                            dimy.scale,
                            0,
                            0
                          );
                          graphics.transform(
                            1,
                            0,
                            0,
                            1,
                            -x0,
                            -y0
                          );
                          this.clipBbox(
                            graphics,
                            bbox,
                            x0,
                            y0,
                            x1,
                            y1
                          );
                          graphics.executeOperatorList(
                            operatorList
                          );
                          this.ctx.transform(
                            1,
                            0,
                            0,
                            1,
                            x0,
                            y0
                          );
                          this.ctx.scale(
                            1 / dimx.scale,
                            1 / dimy.scale
                          );
                          return tmpCanvas.canvas;
                        },
                      getSizeAndScale:
                        function TilingPattern_getSizeAndScale(
                          step,
                          realOutputSize,
                          scale
                        ) {
                          step = Math.abs(step);
                          var maxSize = Math.max(
                            MAX_PATTERN_SIZE,
                            realOutputSize
                          );
                          var size = Math.ceil(
                            step * scale
                          );

                          if (size >= maxSize) {
                            size = maxSize;
                          } else {
                            scale = size / step;
                          }

                          return {
                            scale: scale,
                            size: size,
                          };
                        },
                      clipBbox: function clipBbox(
                        graphics,
                        bbox,
                        x0,
                        y0,
                        x1,
                        y1
                      ) {
                        if (
                          Array.isArray(bbox) &&
                          bbox.length === 4
                        ) {
                          var bboxWidth = x1 - x0;
                          var bboxHeight =
                            y1 - y0;
                          graphics.ctx.rect(
                            x0,
                            y0,
                            bboxWidth,
                            bboxHeight
                          );
                          graphics.clip();
                          graphics.endPath();
                        }
                      },
                      setFillAndStrokeStyleToContext:
                        function setFillAndStrokeStyleToContext(
                          graphics,
                          paintType,
                          color
                        ) {
                          var context =
                              graphics.ctx,
                            current =
                              graphics.current;

                          switch (paintType) {
                            case PaintType.COLORED:
                              var ctx = this.ctx;
                              context.fillStyle =
                                ctx.fillStyle;
                              context.strokeStyle =
                                ctx.strokeStyle;
                              current.fillColor =
                                ctx.fillStyle;
                              current.strokeColor =
                                ctx.strokeStyle;
                              break;

                            case PaintType.UNCOLORED:
                              var cssColor =
                                _util.Util.makeHexColor(
                                  color[0],
                                  color[1],
                                  color[2]
                                );

                              context.fillStyle =
                                cssColor;
                              context.strokeStyle =
                                cssColor;
                              current.fillColor =
                                cssColor;
                              current.strokeColor =
                                cssColor;
                              break;

                            default:
                              throw new _util.FormatError(
                                "Unsupported paint type: ".concat(
                                  paintType
                                )
                              );
                          }
                        },
                      getPattern:
                        function TilingPattern_getPattern(
                          ctx,
                          owner
                        ) {
                          ctx = this.ctx;
                          ctx.setTransform.apply(
                            ctx,
                            this.baseTransform
                          );
                          ctx.transform.apply(
                            ctx,
                            this.matrix
                          );
                          var temporaryPatternCanvas =
                            this.createPatternCanvas(
                              owner
                            );
                          return ctx.createPattern(
                            temporaryPatternCanvas,
                            "repeat"
                          );
                        },
                    };
                    return TilingPattern;
                  })();

                exports.TilingPattern =
                  TilingPattern;

                /***/
              },
              /* 142 */
              /***/ function (
                __unused_webpack_module,
                exports
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.GlobalWorkerOptions =
                  void 0;
                var GlobalWorkerOptions =
                  Object.create(null);
                exports.GlobalWorkerOptions =
                  GlobalWorkerOptions;
                GlobalWorkerOptions.workerPort =
                  GlobalWorkerOptions.workerPort ===
                  undefined
                    ? null
                    : GlobalWorkerOptions.workerPort;
                GlobalWorkerOptions.workerSrc =
                  GlobalWorkerOptions.workerSrc ===
                  undefined
                    ? ""
                    : GlobalWorkerOptions.workerSrc;

                /***/
              },
              /* 143 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.MessageHandler = void 0;

                var _regenerator =
                  _interopRequireDefault(
                    __w_pdfjs_require__(2)
                  );

                var _util =
                  __w_pdfjs_require__(4);

                function _interopRequireDefault(
                  obj
                ) {
                  return obj && obj.__esModule
                    ? obj
                    : { default: obj };
                }

                function asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  key,
                  arg
                ) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(
                      _next,
                      _throw
                    );
                  }
                }

                function _asyncToGenerator(fn) {
                  return function () {
                    var self = this,
                      args = arguments;
                    return new Promise(function (
                      resolve,
                      reject
                    ) {
                      var gen = fn.apply(
                        self,
                        args
                      );
                      function _next(value) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "next",
                          value
                        );
                      }
                      function _throw(err) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "throw",
                          err
                        );
                      }
                      _next(undefined);
                    });
                  };
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                var CallbackKind = {
                  UNKNOWN: 0,
                  DATA: 1,
                  ERROR: 2,
                };
                var StreamKind = {
                  UNKNOWN: 0,
                  CANCEL: 1,
                  CANCEL_COMPLETE: 2,
                  CLOSE: 3,
                  ENQUEUE: 4,
                  ERROR: 5,
                  PULL: 6,
                  PULL_COMPLETE: 7,
                  START_COMPLETE: 8,
                };

                function wrapReason(reason) {
                  if (
                    _typeof(reason) !==
                      "object" ||
                    reason === null
                  ) {
                    return reason;
                  }

                  switch (reason.name) {
                    case "AbortException":
                      return new _util.AbortException(
                        reason.message
                      );

                    case "MissingPDFException":
                      return new _util.MissingPDFException(
                        reason.message
                      );

                    case "UnexpectedResponseException":
                      return new _util.UnexpectedResponseException(
                        reason.message,
                        reason.status
                      );

                    case "UnknownErrorException":
                      return new _util.UnknownErrorException(
                        reason.message,
                        reason.details
                      );

                    default:
                      return new _util.UnknownErrorException(
                        reason.message,
                        reason.toString()
                      );
                  }
                }

                var MessageHandler =
                  /*#__PURE__*/ (function () {
                    function MessageHandler(
                      sourceName,
                      targetName,
                      comObj
                    ) {
                      var _this = this;

                      _classCallCheck(
                        this,
                        MessageHandler
                      );

                      this.sourceName =
                        sourceName;
                      this.targetName =
                        targetName;
                      this.comObj = comObj;
                      this.callbackId = 1;
                      this.streamId = 1;
                      this.postMessageTransfers = true;
                      this.streamSinks =
                        Object.create(null);
                      this.streamControllers =
                        Object.create(null);
                      this.callbackCapabilities =
                        Object.create(null);
                      this.actionHandler =
                        Object.create(null);

                      this._onComObjOnMessage =
                        function (event) {
                          var data = event.data;

                          if (
                            data.targetName !==
                            _this.sourceName
                          ) {
                            return;
                          }

                          if (data.stream) {
                            _this._processStreamMessage(
                              data
                            );

                            return;
                          }

                          if (data.callback) {
                            var callbackId =
                              data.callbackId;
                            var capability =
                              _this
                                .callbackCapabilities[
                                callbackId
                              ];

                            if (!capability) {
                              throw new Error(
                                "Cannot resolve callback ".concat(
                                  callbackId
                                )
                              );
                            }

                            delete _this
                              .callbackCapabilities[
                              callbackId
                            ];

                            if (
                              data.callback ===
                              CallbackKind.DATA
                            ) {
                              capability.resolve(
                                data.data
                              );
                            } else if (
                              data.callback ===
                              CallbackKind.ERROR
                            ) {
                              capability.reject(
                                wrapReason(
                                  data.reason
                                )
                              );
                            } else {
                              throw new Error(
                                "Unexpected callback case"
                              );
                            }

                            return;
                          }

                          var action =
                            _this.actionHandler[
                              data.action
                            ];

                          if (!action) {
                            throw new Error(
                              "Unknown action from worker: ".concat(
                                data.action
                              )
                            );
                          }

                          if (data.callbackId) {
                            var cbSourceName =
                              _this.sourceName;
                            var cbTargetName =
                              data.sourceName;
                            new Promise(function (
                              resolve
                            ) {
                              resolve(
                                action(data.data)
                              );
                            }).then(
                              function (result) {
                                comObj.postMessage(
                                  {
                                    sourceName:
                                      cbSourceName,
                                    targetName:
                                      cbTargetName,
                                    callback:
                                      CallbackKind.DATA,
                                    callbackId:
                                      data.callbackId,
                                    data: result,
                                  }
                                );
                              },
                              function (reason) {
                                comObj.postMessage(
                                  {
                                    sourceName:
                                      cbSourceName,
                                    targetName:
                                      cbTargetName,
                                    callback:
                                      CallbackKind.ERROR,
                                    callbackId:
                                      data.callbackId,
                                    reason:
                                      wrapReason(
                                        reason
                                      ),
                                  }
                                );
                              }
                            );
                            return;
                          }

                          if (data.streamId) {
                            _this._createStreamSink(
                              data
                            );

                            return;
                          }

                          action(data.data);
                        };

                      comObj.addEventListener(
                        "message",
                        this._onComObjOnMessage
                      );
                    }

                    _createClass(MessageHandler, [
                      {
                        key: "on",
                        value: function on(
                          actionName,
                          handler
                        ) {
                          var ah =
                            this.actionHandler;

                          if (ah[actionName]) {
                            throw new Error(
                              'There is already an actionName called "'.concat(
                                actionName,
                                '"'
                              )
                            );
                          }

                          ah[actionName] =
                            handler;
                        },
                      },
                      {
                        key: "send",
                        value: function send(
                          actionName,
                          data,
                          transfers
                        ) {
                          this._postMessage(
                            {
                              sourceName:
                                this.sourceName,
                              targetName:
                                this.targetName,
                              action: actionName,
                              data: data,
                            },
                            transfers
                          );
                        },
                      },
                      {
                        key: "sendWithPromise",
                        value:
                          function sendWithPromise(
                            actionName,
                            data,
                            transfers
                          ) {
                            var callbackId = this
                              .callbackId++;
                            var capability = (0,
                            _util.createPromiseCapability)();
                            this.callbackCapabilities[
                              callbackId
                            ] = capability;

                            try {
                              this._postMessage(
                                {
                                  sourceName:
                                    this
                                      .sourceName,
                                  targetName:
                                    this
                                      .targetName,
                                  action:
                                    actionName,
                                  callbackId:
                                    callbackId,
                                  data: data,
                                },
                                transfers
                              );
                            } catch (ex) {
                              capability.reject(
                                ex
                              );
                            }

                            return capability.promise;
                          },
                      },
                      {
                        key: "sendWithStream",
                        value:
                          function sendWithStream(
                            actionName,
                            data,
                            queueingStrategy,
                            transfers
                          ) {
                            var _this2 = this;

                            var streamId = this
                              .streamId++;
                            var sourceName =
                              this.sourceName;
                            var targetName =
                              this.targetName;
                            var comObj =
                              this.comObj;
                            return new ReadableStream(
                              {
                                start:
                                  function start(
                                    controller
                                  ) {
                                    var startCapability =
                                      (0,
                                      _util.createPromiseCapability)();
                                    _this2.streamControllers[
                                      streamId
                                    ] = {
                                      controller:
                                        controller,
                                      startCall:
                                        startCapability,
                                      pullCall:
                                        null,
                                      cancelCall:
                                        null,
                                      isClosed: false,
                                    };

                                    _this2._postMessage(
                                      {
                                        sourceName:
                                          sourceName,
                                        targetName:
                                          targetName,
                                        action:
                                          actionName,
                                        streamId:
                                          streamId,
                                        data: data,
                                        desiredSize:
                                          controller.desiredSize,
                                      },
                                      transfers
                                    );

                                    return startCapability.promise;
                                  },
                                pull: function pull(
                                  controller
                                ) {
                                  var pullCapability =
                                    (0,
                                    _util.createPromiseCapability)();
                                  _this2.streamControllers[
                                    streamId
                                  ].pullCall =
                                    pullCapability;
                                  comObj.postMessage(
                                    {
                                      sourceName:
                                        sourceName,
                                      targetName:
                                        targetName,
                                      stream:
                                        StreamKind.PULL,
                                      streamId:
                                        streamId,
                                      desiredSize:
                                        controller.desiredSize,
                                    }
                                  );
                                  return pullCapability.promise;
                                },
                                cancel:
                                  function cancel(
                                    reason
                                  ) {
                                    (0,
                                    _util.assert)(
                                      reason instanceof
                                        Error,
                                      "cancel must have a valid reason"
                                    );
                                    var cancelCapability =
                                      (0,
                                      _util.createPromiseCapability)();
                                    _this2.streamControllers[
                                      streamId
                                    ].cancelCall =
                                      cancelCapability;
                                    _this2.streamControllers[
                                      streamId
                                    ].isClosed = true;
                                    comObj.postMessage(
                                      {
                                        sourceName:
                                          sourceName,
                                        targetName:
                                          targetName,
                                        stream:
                                          StreamKind.CANCEL,
                                        streamId:
                                          streamId,
                                        reason:
                                          wrapReason(
                                            reason
                                          ),
                                      }
                                    );
                                    return cancelCapability.promise;
                                  },
                              },
                              queueingStrategy
                            );
                          },
                      },
                      {
                        key: "_createStreamSink",
                        value:
                          function _createStreamSink(
                            data
                          ) {
                            var self = this;
                            var action =
                              this.actionHandler[
                                data.action
                              ];
                            var streamId =
                              data.streamId;
                            var sourceName =
                              this.sourceName;
                            var targetName =
                              data.sourceName;
                            var comObj =
                              this.comObj;
                            var streamSink = {
                              enqueue:
                                function enqueue(
                                  chunk
                                ) {
                                  var size =
                                    arguments.length >
                                      1 &&
                                    arguments[1] !==
                                      undefined
                                      ? arguments[1]
                                      : 1;
                                  var transfers =
                                    arguments.length >
                                    2
                                      ? arguments[2]
                                      : undefined;

                                  if (
                                    this
                                      .isCancelled
                                  ) {
                                    return;
                                  }

                                  var lastDesiredSize =
                                    this
                                      .desiredSize;
                                  this.desiredSize -=
                                    size;

                                  if (
                                    lastDesiredSize >
                                      0 &&
                                    this
                                      .desiredSize <=
                                      0
                                  ) {
                                    this.sinkCapability =
                                      (0,
                                      _util.createPromiseCapability)();
                                    this.ready =
                                      this.sinkCapability.promise;
                                  }

                                  self._postMessage(
                                    {
                                      sourceName:
                                        sourceName,
                                      targetName:
                                        targetName,
                                      stream:
                                        StreamKind.ENQUEUE,
                                      streamId:
                                        streamId,
                                      chunk:
                                        chunk,
                                    },
                                    transfers
                                  );
                                },
                              close:
                                function close() {
                                  if (
                                    this
                                      .isCancelled
                                  ) {
                                    return;
                                  }

                                  this.isCancelled = true;
                                  comObj.postMessage(
                                    {
                                      sourceName:
                                        sourceName,
                                      targetName:
                                        targetName,
                                      stream:
                                        StreamKind.CLOSE,
                                      streamId:
                                        streamId,
                                    }
                                  );
                                  delete self
                                    .streamSinks[
                                    streamId
                                  ];
                                },
                              error:
                                function error(
                                  reason
                                ) {
                                  (0,
                                  _util.assert)(
                                    reason instanceof
                                      Error,
                                    "error must have a valid reason"
                                  );

                                  if (
                                    this
                                      .isCancelled
                                  ) {
                                    return;
                                  }

                                  this.isCancelled = true;
                                  comObj.postMessage(
                                    {
                                      sourceName:
                                        sourceName,
                                      targetName:
                                        targetName,
                                      stream:
                                        StreamKind.ERROR,
                                      streamId:
                                        streamId,
                                      reason:
                                        wrapReason(
                                          reason
                                        ),
                                    }
                                  );
                                },
                              sinkCapability: (0,
                              _util.createPromiseCapability)(),
                              onPull: null,
                              onCancel: null,
                              isCancelled: false,
                              desiredSize:
                                data.desiredSize,
                              ready: null,
                            };
                            streamSink.sinkCapability.resolve();
                            streamSink.ready =
                              streamSink.sinkCapability.promise;
                            this.streamSinks[
                              streamId
                            ] = streamSink;
                            new Promise(function (
                              resolve
                            ) {
                              resolve(
                                action(
                                  data.data,
                                  streamSink
                                )
                              );
                            }).then(
                              function () {
                                comObj.postMessage(
                                  {
                                    sourceName:
                                      sourceName,
                                    targetName:
                                      targetName,
                                    stream:
                                      StreamKind.START_COMPLETE,
                                    streamId:
                                      streamId,
                                    success: true,
                                  }
                                );
                              },
                              function (reason) {
                                comObj.postMessage(
                                  {
                                    sourceName:
                                      sourceName,
                                    targetName:
                                      targetName,
                                    stream:
                                      StreamKind.START_COMPLETE,
                                    streamId:
                                      streamId,
                                    reason:
                                      wrapReason(
                                        reason
                                      ),
                                  }
                                );
                              }
                            );
                          },
                      },
                      {
                        key: "_processStreamMessage",
                        value:
                          function _processStreamMessage(
                            data
                          ) {
                            var streamId =
                              data.streamId;
                            var sourceName =
                              this.sourceName;
                            var targetName =
                              data.sourceName;
                            var comObj =
                              this.comObj;

                            switch (data.stream) {
                              case StreamKind.START_COMPLETE:
                                if (
                                  data.success
                                ) {
                                  this.streamControllers[
                                    streamId
                                  ].startCall.resolve();
                                } else {
                                  this.streamControllers[
                                    streamId
                                  ].startCall.reject(
                                    wrapReason(
                                      data.reason
                                    )
                                  );
                                }

                                break;

                              case StreamKind.PULL_COMPLETE:
                                if (
                                  data.success
                                ) {
                                  this.streamControllers[
                                    streamId
                                  ].pullCall.resolve();
                                } else {
                                  this.streamControllers[
                                    streamId
                                  ].pullCall.reject(
                                    wrapReason(
                                      data.reason
                                    )
                                  );
                                }

                                break;

                              case StreamKind.PULL:
                                if (
                                  !this
                                    .streamSinks[
                                    streamId
                                  ]
                                ) {
                                  comObj.postMessage(
                                    {
                                      sourceName:
                                        sourceName,
                                      targetName:
                                        targetName,
                                      stream:
                                        StreamKind.PULL_COMPLETE,
                                      streamId:
                                        streamId,
                                      success: true,
                                    }
                                  );
                                  break;
                                }

                                if (
                                  this
                                    .streamSinks[
                                    streamId
                                  ].desiredSize <=
                                    0 &&
                                  data.desiredSize >
                                    0
                                ) {
                                  this.streamSinks[
                                    streamId
                                  ].sinkCapability.resolve();
                                }

                                this.streamSinks[
                                  streamId
                                ].desiredSize =
                                  data.desiredSize;
                                var onPull =
                                  this
                                    .streamSinks[
                                    data.streamId
                                  ].onPull;
                                new Promise(
                                  function (
                                    resolve
                                  ) {
                                    resolve(
                                      onPull &&
                                        onPull()
                                    );
                                  }
                                ).then(
                                  function () {
                                    comObj.postMessage(
                                      {
                                        sourceName:
                                          sourceName,
                                        targetName:
                                          targetName,
                                        stream:
                                          StreamKind.PULL_COMPLETE,
                                        streamId:
                                          streamId,
                                        success: true,
                                      }
                                    );
                                  },
                                  function (
                                    reason
                                  ) {
                                    comObj.postMessage(
                                      {
                                        sourceName:
                                          sourceName,
                                        targetName:
                                          targetName,
                                        stream:
                                          StreamKind.PULL_COMPLETE,
                                        streamId:
                                          streamId,
                                        reason:
                                          wrapReason(
                                            reason
                                          ),
                                      }
                                    );
                                  }
                                );
                                break;

                              case StreamKind.ENQUEUE:
                                (0, _util.assert)(
                                  this
                                    .streamControllers[
                                    streamId
                                  ],
                                  "enqueue should have stream controller"
                                );

                                if (
                                  this
                                    .streamControllers[
                                    streamId
                                  ].isClosed
                                ) {
                                  break;
                                }

                                this.streamControllers[
                                  streamId
                                ].controller.enqueue(
                                  data.chunk
                                );
                                break;

                              case StreamKind.CLOSE:
                                (0, _util.assert)(
                                  this
                                    .streamControllers[
                                    streamId
                                  ],
                                  "close should have stream controller"
                                );

                                if (
                                  this
                                    .streamControllers[
                                    streamId
                                  ].isClosed
                                ) {
                                  break;
                                }

                                this.streamControllers[
                                  streamId
                                ].isClosed = true;
                                this.streamControllers[
                                  streamId
                                ].controller.close();

                                this._deleteStreamController(
                                  streamId
                                );

                                break;

                              case StreamKind.ERROR:
                                (0, _util.assert)(
                                  this
                                    .streamControllers[
                                    streamId
                                  ],
                                  "error should have stream controller"
                                );
                                this.streamControllers[
                                  streamId
                                ].controller.error(
                                  wrapReason(
                                    data.reason
                                  )
                                );

                                this._deleteStreamController(
                                  streamId
                                );

                                break;

                              case StreamKind.CANCEL_COMPLETE:
                                if (
                                  data.success
                                ) {
                                  this.streamControllers[
                                    streamId
                                  ].cancelCall.resolve();
                                } else {
                                  this.streamControllers[
                                    streamId
                                  ].cancelCall.reject(
                                    wrapReason(
                                      data.reason
                                    )
                                  );
                                }

                                this._deleteStreamController(
                                  streamId
                                );

                                break;

                              case StreamKind.CANCEL:
                                if (
                                  !this
                                    .streamSinks[
                                    streamId
                                  ]
                                ) {
                                  break;
                                }

                                var onCancel =
                                  this
                                    .streamSinks[
                                    data.streamId
                                  ].onCancel;
                                new Promise(
                                  function (
                                    resolve
                                  ) {
                                    resolve(
                                      onCancel &&
                                        onCancel(
                                          wrapReason(
                                            data.reason
                                          )
                                        )
                                    );
                                  }
                                ).then(
                                  function () {
                                    comObj.postMessage(
                                      {
                                        sourceName:
                                          sourceName,
                                        targetName:
                                          targetName,
                                        stream:
                                          StreamKind.CANCEL_COMPLETE,
                                        streamId:
                                          streamId,
                                        success: true,
                                      }
                                    );
                                  },
                                  function (
                                    reason
                                  ) {
                                    comObj.postMessage(
                                      {
                                        sourceName:
                                          sourceName,
                                        targetName:
                                          targetName,
                                        stream:
                                          StreamKind.CANCEL_COMPLETE,
                                        streamId:
                                          streamId,
                                        reason:
                                          wrapReason(
                                            reason
                                          ),
                                      }
                                    );
                                  }
                                );
                                this.streamSinks[
                                  streamId
                                ].sinkCapability.reject(
                                  wrapReason(
                                    data.reason
                                  )
                                );
                                this.streamSinks[
                                  streamId
                                ].isCancelled = true;
                                delete this
                                  .streamSinks[
                                  streamId
                                ];
                                break;

                              default:
                                throw new Error(
                                  "Unexpected stream case"
                                );
                            }
                          },
                      },
                      {
                        key: "_deleteStreamController",
                        value: (function () {
                          var _deleteStreamController2 =
                            _asyncToGenerator(
                              /*#__PURE__*/ _regenerator[
                                "default"
                              ].mark(
                                function _callee(
                                  streamId
                                ) {
                                  return _regenerator[
                                    "default"
                                  ].wrap(
                                    function _callee$(
                                      _context
                                    ) {
                                      while (1) {
                                        switch (
                                          (_context.prev =
                                            _context.next)
                                        ) {
                                          case 0:
                                            _context.next = 2;
                                            return Promise.allSettled(
                                              [
                                                this
                                                  .streamControllers[
                                                  streamId
                                                ]
                                                  .startCall,
                                                this
                                                  .streamControllers[
                                                  streamId
                                                ]
                                                  .pullCall,
                                                this
                                                  .streamControllers[
                                                  streamId
                                                ]
                                                  .cancelCall,
                                              ].map(
                                                function (
                                                  capability
                                                ) {
                                                  return (
                                                    capability &&
                                                    capability.promise
                                                  );
                                                }
                                              )
                                            );

                                          case 2:
                                            delete this
                                              .streamControllers[
                                              streamId
                                            ];

                                          case 3:
                                          case "end":
                                            return _context.stop();
                                        }
                                      }
                                    },
                                    _callee,
                                    this
                                  );
                                }
                              )
                            );

                          function _deleteStreamController(
                            _x
                          ) {
                            return _deleteStreamController2.apply(
                              this,
                              arguments
                            );
                          }

                          return _deleteStreamController;
                        })(),
                      },
                      {
                        key: "_postMessage",
                        value:
                          function _postMessage(
                            message,
                            transfers
                          ) {
                            if (
                              transfers &&
                              this
                                .postMessageTransfers
                            ) {
                              this.comObj.postMessage(
                                message,
                                transfers
                              );
                            } else {
                              this.comObj.postMessage(
                                message
                              );
                            }
                          },
                      },
                      {
                        key: "destroy",
                        value:
                          function destroy() {
                            this.comObj.removeEventListener(
                              "message",
                              this
                                ._onComObjOnMessage
                            );
                          },
                      },
                    ]);

                    return MessageHandler;
                  })();

                exports.MessageHandler =
                  MessageHandler;

                /***/
              },
              /* 144 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.Metadata = void 0;

                var _util =
                  __w_pdfjs_require__(4);

                var _xml_parser =
                  __w_pdfjs_require__(145);

                function _createForOfIteratorHelper(
                  o,
                  allowArrayLike
                ) {
                  var it;
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    o[Symbol.iterator] == null
                  ) {
                    if (
                      Array.isArray(o) ||
                      (it =
                        _unsupportedIterableToArray(
                          o
                        )) ||
                      (allowArrayLike &&
                        o &&
                        typeof o.length ===
                          "number")
                    ) {
                      if (it) o = it;
                      var i = 0;
                      var F = function F() {};
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return { done: true };
                          return {
                            done: false,
                            value: o[i++],
                          };
                        },
                        e: function e(_e) {
                          throw _e;
                        },
                        f: F,
                      };
                    }
                    throw new TypeError(
                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  }
                  var normalCompletion = true,
                    didErr = false,
                    err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion =
                        step.done;
                      return step;
                    },
                    e: function e(_e2) {
                      didErr = true;
                      err = _e2;
                    },
                    f: function f() {
                      try {
                        if (
                          !normalCompletion &&
                          it["return"] != null
                        )
                          it["return"]();
                      } finally {
                        if (didErr) throw err;
                      }
                    },
                  };
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var Metadata =
                  /*#__PURE__*/ (function () {
                    function Metadata(data) {
                      _classCallCheck(
                        this,
                        Metadata
                      );

                      (0, _util.assert)(
                        typeof data === "string",
                        "Metadata: input is not a string"
                      );
                      data = this._repair(data);
                      var parser =
                        new _xml_parser.SimpleXMLParser(
                          {
                            lowerCaseName: true,
                          }
                        );
                      var xmlDocument =
                        parser.parseFromString(
                          data
                        );
                      this._metadataMap =
                        new Map();

                      if (xmlDocument) {
                        this._parse(xmlDocument);
                      }

                      this._data = data;
                    }

                    _createClass(Metadata, [
                      {
                        key: "_repair",
                        value: function _repair(
                          data
                        ) {
                          return data
                            .replace(/^[^<]+/, "")
                            .replace(
                              />\\376\\377([^<]+)/g,
                              function (
                                all,
                                codes
                              ) {
                                var bytes = codes
                                  .replace(
                                    /\\([0-3])([0-7])([0-7])/g,
                                    function (
                                      code,
                                      d1,
                                      d2,
                                      d3
                                    ) {
                                      return String.fromCharCode(
                                        d1 * 64 +
                                          d2 * 8 +
                                          d3 * 1
                                      );
                                    }
                                  )
                                  .replace(
                                    /&(amp|apos|gt|lt|quot);/g,
                                    function (
                                      str,
                                      name
                                    ) {
                                      switch (
                                        name
                                      ) {
                                        case "amp":
                                          return "&";

                                        case "apos":
                                          return "'";

                                        case "gt":
                                          return ">";

                                        case "lt":
                                          return "<";

                                        case "quot":
                                          return '"';
                                      }

                                      throw new Error(
                                        "_repair: ".concat(
                                          name,
                                          " isn't defined."
                                        )
                                      );
                                    }
                                  );
                                var chars = "";

                                for (
                                  var i = 0,
                                    ii =
                                      bytes.length;
                                  i < ii;
                                  i += 2
                                ) {
                                  var code =
                                    bytes.charCodeAt(
                                      i
                                    ) *
                                      256 +
                                    bytes.charCodeAt(
                                      i + 1
                                    );

                                  if (
                                    code >= 32 &&
                                    code < 127 &&
                                    code !== 60 &&
                                    code !== 62 &&
                                    code !== 38
                                  ) {
                                    chars +=
                                      String.fromCharCode(
                                        code
                                      );
                                  } else {
                                    chars +=
                                      "&#x" +
                                      (
                                        0x10000 +
                                        code
                                      )
                                        .toString(
                                          16
                                        )
                                        .substring(
                                          1
                                        ) +
                                      ";";
                                  }
                                }

                                return (
                                  ">" + chars
                                );
                              }
                            );
                        },
                      },
                      {
                        key: "_getSequence",
                        value:
                          function _getSequence(
                            entry
                          ) {
                            var name =
                              entry.nodeName;

                            if (
                              name !==
                                "rdf:bag" &&
                              name !==
                                "rdf:seq" &&
                              name !== "rdf:alt"
                            ) {
                              return null;
                            }

                            return entry.childNodes.filter(
                              function (node) {
                                return (
                                  node.nodeName ===
                                  "rdf:li"
                                );
                              }
                            );
                          },
                      },
                      {
                        key: "_getCreators",
                        value:
                          function _getCreators(
                            entry
                          ) {
                            if (
                              entry.nodeName !==
                              "dc:creator"
                            ) {
                              return false;
                            }

                            if (
                              !entry.hasChildNodes()
                            ) {
                              return true;
                            }

                            var seqNode =
                              entry.childNodes[0];
                            var authors =
                              this._getSequence(
                                seqNode
                              ) || [];

                            this._metadataMap.set(
                              entry.nodeName,
                              authors.map(
                                function (node) {
                                  return node.textContent.trim();
                                }
                              )
                            );

                            return true;
                          },
                      },
                      {
                        key: "_parse",
                        value: function _parse(
                          xmlDocument
                        ) {
                          var rdf =
                            xmlDocument.documentElement;

                          if (
                            rdf.nodeName !==
                            "rdf:rdf"
                          ) {
                            rdf = rdf.firstChild;

                            while (
                              rdf &&
                              rdf.nodeName !==
                                "rdf:rdf"
                            ) {
                              rdf =
                                rdf.nextSibling;
                            }
                          }

                          if (
                            !rdf ||
                            rdf.nodeName !==
                              "rdf:rdf" ||
                            !rdf.hasChildNodes()
                          ) {
                            return;
                          }

                          var _iterator =
                              _createForOfIteratorHelper(
                                rdf.childNodes
                              ),
                            _step;

                          try {
                            for (
                              _iterator.s();
                              !(_step =
                                _iterator.n())
                                .done;

                            ) {
                              var desc =
                                _step.value;

                              if (
                                desc.nodeName !==
                                "rdf:description"
                              ) {
                                continue;
                              }

                              var _iterator2 =
                                  _createForOfIteratorHelper(
                                    desc.childNodes
                                  ),
                                _step2;

                              try {
                                for (
                                  _iterator2.s();
                                  !(_step2 =
                                    _iterator2.n())
                                    .done;

                                ) {
                                  var entry =
                                    _step2.value;
                                  var name =
                                    entry.nodeName;

                                  if (
                                    name ===
                                    "#text"
                                  ) {
                                    continue;
                                  }

                                  if (
                                    this._getCreators(
                                      entry
                                    )
                                  ) {
                                    continue;
                                  }

                                  this._metadataMap.set(
                                    name,
                                    entry.textContent.trim()
                                  );
                                }
                              } catch (err) {
                                _iterator2.e(err);
                              } finally {
                                _iterator2.f();
                              }
                            }
                          } catch (err) {
                            _iterator.e(err);
                          } finally {
                            _iterator.f();
                          }
                        },
                      },
                      {
                        key: "getRaw",
                        value: function getRaw() {
                          return this._data;
                        },
                      },
                      {
                        key: "get",
                        value: function get(
                          name
                        ) {
                          var _this$_metadataMap$ge;

                          return (_this$_metadataMap$ge =
                            this._metadataMap.get(
                              name
                            )) !== null &&
                            _this$_metadataMap$ge !==
                              void 0
                            ? _this$_metadataMap$ge
                            : null;
                        },
                      },
                      {
                        key: "getAll",
                        value: function getAll() {
                          return (0,
                          _util.objectFromEntries)(
                            this._metadataMap
                          );
                        },
                      },
                      {
                        key: "has",
                        value: function has(
                          name
                        ) {
                          return this._metadataMap.has(
                            name
                          );
                        },
                      },
                    ]);

                    return Metadata;
                  })();

                exports.Metadata = Metadata;

                /***/
              },
              /* 145 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.XMLParserErrorCode =
                  exports.XMLParserBase =
                  exports.SimpleXMLParser =
                  exports.SimpleDOMNode =
                    void 0;

                var _util =
                  __w_pdfjs_require__(4);

                function _inherits(
                  subClass,
                  superClass
                ) {
                  if (
                    typeof superClass !==
                      "function" &&
                    superClass !== null
                  ) {
                    throw new TypeError(
                      "Super expression must either be null or a function"
                    );
                  }
                  subClass.prototype =
                    Object.create(
                      superClass &&
                        superClass.prototype,
                      {
                        constructor: {
                          value: subClass,
                          writable: true,
                          configurable: true,
                        },
                      }
                    );
                  if (superClass)
                    _setPrototypeOf(
                      subClass,
                      superClass
                    );
                }

                function _setPrototypeOf(o, p) {
                  _setPrototypeOf =
                    Object.setPrototypeOf ||
                    function _setPrototypeOf(
                      o,
                      p
                    ) {
                      o.__proto__ = p;
                      return o;
                    };
                  return _setPrototypeOf(o, p);
                }

                function _createSuper(Derived) {
                  var hasNativeReflectConstruct =
                    _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super =
                        _getPrototypeOf(Derived),
                      result;
                    if (
                      hasNativeReflectConstruct
                    ) {
                      var NewTarget =
                        _getPrototypeOf(
                          this
                        ).constructor;
                      result = Reflect.construct(
                        Super,
                        arguments,
                        NewTarget
                      );
                    } else {
                      result = Super.apply(
                        this,
                        arguments
                      );
                    }
                    return _possibleConstructorReturn(
                      this,
                      result
                    );
                  };
                }

                function _possibleConstructorReturn(
                  self,
                  call
                ) {
                  if (
                    call &&
                    (_typeof(call) === "object" ||
                      typeof call === "function")
                  ) {
                    return call;
                  }
                  return _assertThisInitialized(
                    self
                  );
                }

                function _assertThisInitialized(
                  self
                ) {
                  if (self === void 0) {
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  }
                  return self;
                }

                function _isNativeReflectConstruct() {
                  if (
                    typeof Reflect ===
                      "undefined" ||
                    !Reflect.construct
                  )
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(
                      Reflect.construct(
                        Date,
                        [],
                        function () {}
                      )
                    );
                    return true;
                  } catch (e) {
                    return false;
                  }
                }

                function _getPrototypeOf(o) {
                  _getPrototypeOf =
                    Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function _getPrototypeOf(
                          o
                        ) {
                          return (
                            o.__proto__ ||
                            Object.getPrototypeOf(
                              o
                            )
                          );
                        };
                  return _getPrototypeOf(o);
                }

                function _createForOfIteratorHelper(
                  o,
                  allowArrayLike
                ) {
                  var it;
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    o[Symbol.iterator] == null
                  ) {
                    if (
                      Array.isArray(o) ||
                      (it =
                        _unsupportedIterableToArray(
                          o
                        )) ||
                      (allowArrayLike &&
                        o &&
                        typeof o.length ===
                          "number")
                    ) {
                      if (it) o = it;
                      var i = 0;
                      var F = function F() {};
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return { done: true };
                          return {
                            done: false,
                            value: o[i++],
                          };
                        },
                        e: function e(_e2) {
                          throw _e2;
                        },
                        f: F,
                      };
                    }
                    throw new TypeError(
                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  }
                  var normalCompletion = true,
                    didErr = false,
                    err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion =
                        step.done;
                      return step;
                    },
                    e: function e(_e3) {
                      didErr = true;
                      err = _e3;
                    },
                    f: function f() {
                      try {
                        if (
                          !normalCompletion &&
                          it["return"] != null
                        )
                          it["return"]();
                      } finally {
                        if (didErr) throw err;
                      }
                    },
                  };
                }

                function _slicedToArray(arr, i) {
                  return (
                    _arrayWithHoles(arr) ||
                    _iterableToArrayLimit(
                      arr,
                      i
                    ) ||
                    _unsupportedIterableToArray(
                      arr,
                      i
                    ) ||
                    _nonIterableRest()
                  );
                }

                function _nonIterableRest() {
                  throw new TypeError(
                    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _iterableToArrayLimit(
                  arr,
                  i
                ) {
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    !(
                      Symbol.iterator in
                      Object(arr)
                    )
                  )
                    return;
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (
                      var _i =
                          arr[Symbol.iterator](),
                        _s;
                      !(_n = (_s = _i.next())
                        .done);
                      _n = true
                    ) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (
                        !_n &&
                        _i["return"] != null
                      )
                        _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }

                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var XMLParserErrorCode = {
                  NoError: 0,
                  EndOfDocument: -1,
                  UnterminatedCdat: -2,
                  UnterminatedXmlDeclaration: -3,
                  UnterminatedDoctypeDeclaration:
                    -4,
                  UnterminatedComment: -5,
                  MalformedElement: -6,
                  OutOfMemory: -7,
                  UnterminatedAttributeValue: -8,
                  UnterminatedElement: -9,
                  ElementNeverBegun: -10,
                };
                exports.XMLParserErrorCode =
                  XMLParserErrorCode;

                function isWhitespace(s, index) {
                  var ch = s[index];
                  return (
                    ch === " " ||
                    ch === "\n" ||
                    ch === "\r" ||
                    ch === "\t"
                  );
                }

                function isWhitespaceString(s) {
                  for (
                    var i = 0, ii = s.length;
                    i < ii;
                    i++
                  ) {
                    if (!isWhitespace(s, i)) {
                      return false;
                    }
                  }

                  return true;
                }

                var XMLParserBase =
                  /*#__PURE__*/ (function () {
                    function XMLParserBase() {
                      _classCallCheck(
                        this,
                        XMLParserBase
                      );
                    }

                    _createClass(XMLParserBase, [
                      {
                        key: "_resolveEntities",
                        value:
                          function _resolveEntities(
                            s
                          ) {
                            var _this = this;

                            return s.replace(
                              /&([^;]+);/g,
                              function (
                                all,
                                entity
                              ) {
                                if (
                                  entity.substring(
                                    0,
                                    2
                                  ) === "#x"
                                ) {
                                  return String.fromCodePoint(
                                    parseInt(
                                      entity.substring(
                                        2
                                      ),
                                      16
                                    )
                                  );
                                } else if (
                                  entity.substring(
                                    0,
                                    1
                                  ) === "#"
                                ) {
                                  return String.fromCodePoint(
                                    parseInt(
                                      entity.substring(
                                        1
                                      ),
                                      10
                                    )
                                  );
                                }

                                switch (entity) {
                                  case "lt":
                                    return "<";

                                  case "gt":
                                    return ">";

                                  case "amp":
                                    return "&";

                                  case "quot":
                                    return '"';

                                  case "apos":
                                    return "'";
                                }

                                return _this.onResolveEntity(
                                  entity
                                );
                              }
                            );
                          },
                      },
                      {
                        key: "_parseContent",
                        value:
                          function _parseContent(
                            s,
                            start
                          ) {
                            var attributes = [];
                            var pos = start;

                            function skipWs() {
                              while (
                                pos < s.length &&
                                isWhitespace(
                                  s,
                                  pos
                                )
                              ) {
                                ++pos;
                              }
                            }

                            while (
                              pos < s.length &&
                              !isWhitespace(
                                s,
                                pos
                              ) &&
                              s[pos] !== ">" &&
                              s[pos] !== "/"
                            ) {
                              ++pos;
                            }

                            var name =
                              s.substring(
                                start,
                                pos
                              );
                            skipWs();

                            while (
                              pos < s.length &&
                              s[pos] !== ">" &&
                              s[pos] !== "/" &&
                              s[pos] !== "?"
                            ) {
                              skipWs();
                              var attrName = "",
                                attrValue = "";

                              while (
                                pos < s.length &&
                                !isWhitespace(
                                  s,
                                  pos
                                ) &&
                                s[pos] !== "="
                              ) {
                                attrName +=
                                  s[pos];
                                ++pos;
                              }

                              skipWs();

                              if (
                                s[pos] !== "="
                              ) {
                                return null;
                              }

                              ++pos;
                              skipWs();
                              var attrEndChar =
                                s[pos];

                              if (
                                attrEndChar !==
                                  '"' &&
                                attrEndChar !==
                                  "'"
                              ) {
                                return null;
                              }

                              var attrEndIndex =
                                s.indexOf(
                                  attrEndChar,
                                  ++pos
                                );

                              if (
                                attrEndIndex < 0
                              ) {
                                return null;
                              }

                              attrValue =
                                s.substring(
                                  pos,
                                  attrEndIndex
                                );
                              attributes.push({
                                name: attrName,
                                value:
                                  this._resolveEntities(
                                    attrValue
                                  ),
                              });
                              pos =
                                attrEndIndex + 1;
                              skipWs();
                            }

                            return {
                              name: name,
                              attributes:
                                attributes,
                              parsed: pos - start,
                            };
                          },
                      },
                      {
                        key: "_parseProcessingInstruction",
                        value:
                          function _parseProcessingInstruction(
                            s,
                            start
                          ) {
                            var pos = start;

                            function skipWs() {
                              while (
                                pos < s.length &&
                                isWhitespace(
                                  s,
                                  pos
                                )
                              ) {
                                ++pos;
                              }
                            }

                            while (
                              pos < s.length &&
                              !isWhitespace(
                                s,
                                pos
                              ) &&
                              s[pos] !== ">" &&
                              s[pos] !== "/"
                            ) {
                              ++pos;
                            }

                            var name =
                              s.substring(
                                start,
                                pos
                              );
                            skipWs();
                            var attrStart = pos;

                            while (
                              pos < s.length &&
                              (s[pos] !== "?" ||
                                s[pos + 1] !==
                                  ">")
                            ) {
                              ++pos;
                            }

                            var value =
                              s.substring(
                                attrStart,
                                pos
                              );
                            return {
                              name: name,
                              value: value,
                              parsed: pos - start,
                            };
                          },
                      },
                      {
                        key: "parseXml",
                        value: function parseXml(
                          s
                        ) {
                          var i = 0;

                          while (i < s.length) {
                            var ch = s[i];
                            var j = i;

                            if (ch === "<") {
                              ++j;
                              var ch2 = s[j];
                              var q = void 0;

                              switch (ch2) {
                                case "/":
                                  ++j;
                                  q = s.indexOf(
                                    ">",
                                    j
                                  );

                                  if (q < 0) {
                                    this.onError(
                                      XMLParserErrorCode.UnterminatedElement
                                    );
                                    return;
                                  }

                                  this.onEndElement(
                                    s.substring(
                                      j,
                                      q
                                    )
                                  );
                                  j = q + 1;
                                  break;

                                case "?":
                                  ++j;

                                  var pi =
                                    this._parseProcessingInstruction(
                                      s,
                                      j
                                    );

                                  if (
                                    s.substring(
                                      j +
                                        pi.parsed,
                                      j +
                                        pi.parsed +
                                        2
                                    ) !== "?>"
                                  ) {
                                    this.onError(
                                      XMLParserErrorCode.UnterminatedXmlDeclaration
                                    );
                                    return;
                                  }

                                  this.onPi(
                                    pi.name,
                                    pi.value
                                  );
                                  j +=
                                    pi.parsed + 2;
                                  break;

                                case "!":
                                  if (
                                    s.substring(
                                      j + 1,
                                      j + 3
                                    ) === "--"
                                  ) {
                                    q = s.indexOf(
                                      "-->",
                                      j + 3
                                    );

                                    if (q < 0) {
                                      this.onError(
                                        XMLParserErrorCode.UnterminatedComment
                                      );
                                      return;
                                    }

                                    this.onComment(
                                      s.substring(
                                        j + 3,
                                        q
                                      )
                                    );
                                    j = q + 3;
                                  } else if (
                                    s.substring(
                                      j + 1,
                                      j + 8
                                    ) ===
                                    "[CDATA["
                                  ) {
                                    q = s.indexOf(
                                      "]]>",
                                      j + 8
                                    );

                                    if (q < 0) {
                                      this.onError(
                                        XMLParserErrorCode.UnterminatedCdat
                                      );
                                      return;
                                    }

                                    this.onCdata(
                                      s.substring(
                                        j + 8,
                                        q
                                      )
                                    );
                                    j = q + 3;
                                  } else if (
                                    s.substring(
                                      j + 1,
                                      j + 8
                                    ) ===
                                    "DOCTYPE"
                                  ) {
                                    var q2 =
                                      s.indexOf(
                                        "[",
                                        j + 8
                                      );
                                    var complexDoctype = false;
                                    q = s.indexOf(
                                      ">",
                                      j + 8
                                    );

                                    if (q < 0) {
                                      this.onError(
                                        XMLParserErrorCode.UnterminatedDoctypeDeclaration
                                      );
                                      return;
                                    }

                                    if (
                                      q2 > 0 &&
                                      q > q2
                                    ) {
                                      q =
                                        s.indexOf(
                                          "]>",
                                          j + 8
                                        );

                                      if (q < 0) {
                                        this.onError(
                                          XMLParserErrorCode.UnterminatedDoctypeDeclaration
                                        );
                                        return;
                                      }

                                      complexDoctype = true;
                                    }

                                    var doctypeContent =
                                      s.substring(
                                        j + 8,
                                        q +
                                          (complexDoctype
                                            ? 1
                                            : 0)
                                      );
                                    this.onDoctype(
                                      doctypeContent
                                    );
                                    j =
                                      q +
                                      (complexDoctype
                                        ? 2
                                        : 1);
                                  } else {
                                    this.onError(
                                      XMLParserErrorCode.MalformedElement
                                    );
                                    return;
                                  }

                                  break;

                                default:
                                  var content =
                                    this._parseContent(
                                      s,
                                      j
                                    );

                                  if (
                                    content ===
                                    null
                                  ) {
                                    this.onError(
                                      XMLParserErrorCode.MalformedElement
                                    );
                                    return;
                                  }

                                  var isClosed = false;

                                  if (
                                    s.substring(
                                      j +
                                        content.parsed,
                                      j +
                                        content.parsed +
                                        2
                                    ) === "/>"
                                  ) {
                                    isClosed = true;
                                  } else if (
                                    s.substring(
                                      j +
                                        content.parsed,
                                      j +
                                        content.parsed +
                                        1
                                    ) !== ">"
                                  ) {
                                    this.onError(
                                      XMLParserErrorCode.UnterminatedElement
                                    );
                                    return;
                                  }

                                  this.onBeginElement(
                                    content.name,
                                    content.attributes,
                                    isClosed
                                  );
                                  j +=
                                    content.parsed +
                                    (isClosed
                                      ? 2
                                      : 1);
                                  break;
                              }
                            } else {
                              while (
                                j < s.length &&
                                s[j] !== "<"
                              ) {
                                j++;
                              }

                              var text =
                                s.substring(i, j);
                              this.onText(
                                this._resolveEntities(
                                  text
                                )
                              );
                            }

                            i = j;
                          }
                        },
                      },
                      {
                        key: "onResolveEntity",
                        value:
                          function onResolveEntity(
                            name
                          ) {
                            return "&".concat(
                              name,
                              ";"
                            );
                          },
                      },
                      {
                        key: "onPi",
                        value: function onPi(
                          name,
                          value
                        ) {},
                      },
                      {
                        key: "onComment",
                        value: function onComment(
                          text
                        ) {},
                      },
                      {
                        key: "onCdata",
                        value: function onCdata(
                          text
                        ) {},
                      },
                      {
                        key: "onDoctype",
                        value: function onDoctype(
                          doctypeContent
                        ) {},
                      },
                      {
                        key: "onText",
                        value: function onText(
                          text
                        ) {},
                      },
                      {
                        key: "onBeginElement",
                        value:
                          function onBeginElement(
                            name,
                            attributes,
                            isEmpty
                          ) {},
                      },
                      {
                        key: "onEndElement",
                        value:
                          function onEndElement(
                            name
                          ) {},
                      },
                      {
                        key: "onError",
                        value: function onError(
                          code
                        ) {},
                      },
                    ]);

                    return XMLParserBase;
                  })();

                exports.XMLParserBase =
                  XMLParserBase;

                var SimpleDOMNode =
                  /*#__PURE__*/ (function () {
                    function SimpleDOMNode(
                      nodeName,
                      nodeValue
                    ) {
                      _classCallCheck(
                        this,
                        SimpleDOMNode
                      );

                      this.nodeName = nodeName;
                      this.nodeValue = nodeValue;
                      Object.defineProperty(
                        this,
                        "parentNode",
                        {
                          value: null,
                          writable: true,
                        }
                      );
                    }

                    _createClass(SimpleDOMNode, [
                      {
                        key: "firstChild",
                        get: function get() {
                          return (
                            this.childNodes &&
                            this.childNodes[0]
                          );
                        },
                      },
                      {
                        key: "nextSibling",
                        get: function get() {
                          var childNodes =
                            this.parentNode
                              .childNodes;

                          if (!childNodes) {
                            return undefined;
                          }

                          var index =
                            childNodes.indexOf(
                              this
                            );

                          if (index === -1) {
                            return undefined;
                          }

                          return childNodes[
                            index + 1
                          ];
                        },
                      },
                      {
                        key: "textContent",
                        get: function get() {
                          if (!this.childNodes) {
                            return (
                              this.nodeValue || ""
                            );
                          }

                          return this.childNodes
                            .map(function (
                              child
                            ) {
                              return child.textContent;
                            })
                            .join("");
                        },
                      },
                      {
                        key: "hasChildNodes",
                        value:
                          function hasChildNodes() {
                            return (
                              this.childNodes &&
                              this.childNodes
                                .length > 0
                            );
                          },
                      },
                      {
                        key: "searchNode",
                        value:
                          function searchNode(
                            paths,
                            pos
                          ) {
                            if (
                              pos >= paths.length
                            ) {
                              return this;
                            }

                            var component =
                              paths[pos];
                            var stack = [];
                            var node = this;

                            while (true) {
                              if (
                                component.name ===
                                node.nodeName
                              ) {
                                if (
                                  component.pos ===
                                  0
                                ) {
                                  var res =
                                    node.searchNode(
                                      paths,
                                      pos + 1
                                    );

                                  if (
                                    res !== null
                                  ) {
                                    return res;
                                  }
                                } else if (
                                  stack.length ===
                                  0
                                ) {
                                  return null;
                                } else {
                                  var _stack$pop =
                                      stack.pop(),
                                    _stack$pop2 =
                                      _slicedToArray(
                                        _stack$pop,
                                        1
                                      ),
                                    parent =
                                      _stack$pop2[0];

                                  var siblingPos = 0;

                                  var _iterator =
                                      _createForOfIteratorHelper(
                                        parent.childNodes
                                      ),
                                    _step;

                                  try {
                                    for (
                                      _iterator.s();
                                      !(_step =
                                        _iterator.n())
                                        .done;

                                    ) {
                                      var child =
                                        _step.value;

                                      if (
                                        component.name ===
                                        child.nodeName
                                      ) {
                                        if (
                                          siblingPos ===
                                          component.pos
                                        ) {
                                          return child.searchNode(
                                            paths,
                                            pos +
                                              1
                                          );
                                        }

                                        siblingPos++;
                                      }
                                    }
                                  } catch (err) {
                                    _iterator.e(
                                      err
                                    );
                                  } finally {
                                    _iterator.f();
                                  }

                                  return node.searchNode(
                                    paths,
                                    pos + 1
                                  );
                                }
                              }

                              if (
                                node.childNodes &&
                                node.childNodes
                                  .length !== 0
                              ) {
                                stack.push([
                                  node,
                                  0,
                                ]);
                                node =
                                  node
                                    .childNodes[0];
                              } else if (
                                stack.length === 0
                              ) {
                                return null;
                              } else {
                                while (
                                  stack.length !==
                                  0
                                ) {
                                  var _stack$pop3 =
                                      stack.pop(),
                                    _stack$pop4 =
                                      _slicedToArray(
                                        _stack$pop3,
                                        2
                                      ),
                                    _parent =
                                      _stack$pop4[0],
                                    currentPos =
                                      _stack$pop4[1];

                                  var newPos =
                                    currentPos +
                                    1;

                                  if (
                                    newPos <
                                    _parent
                                      .childNodes
                                      .length
                                  ) {
                                    stack.push([
                                      _parent,
                                      newPos,
                                    ]);
                                    node =
                                      _parent
                                        .childNodes[
                                        newPos
                                      ];
                                    break;
                                  }
                                }

                                if (
                                  stack.length ===
                                  0
                                ) {
                                  return null;
                                }
                              }
                            }
                          },
                      },
                      {
                        key: "dump",
                        value: function dump(
                          buffer
                        ) {
                          if (
                            this.nodeName ===
                            "#text"
                          ) {
                            buffer.push(
                              (0,
                              _util.encodeToXmlString)(
                                this.nodeValue
                              )
                            );
                            return;
                          }

                          buffer.push(
                            "<".concat(
                              this.nodeName
                            )
                          );

                          if (this.attributes) {
                            var _iterator2 =
                                _createForOfIteratorHelper(
                                  this.attributes
                                ),
                              _step2;

                            try {
                              for (
                                _iterator2.s();
                                !(_step2 =
                                  _iterator2.n())
                                  .done;

                              ) {
                                var attribute =
                                  _step2.value;
                                buffer.push(
                                  " "
                                    .concat(
                                      attribute.name,
                                      '="'
                                    )
                                    .concat(
                                      (0,
                                      _util.encodeToXmlString)(
                                        attribute.value
                                      ),
                                      '"'
                                    )
                                );
                              }
                            } catch (err) {
                              _iterator2.e(err);
                            } finally {
                              _iterator2.f();
                            }
                          }

                          if (
                            this.hasChildNodes()
                          ) {
                            buffer.push(">");

                            var _iterator3 =
                                _createForOfIteratorHelper(
                                  this.childNodes
                                ),
                              _step3;

                            try {
                              for (
                                _iterator3.s();
                                !(_step3 =
                                  _iterator3.n())
                                  .done;

                              ) {
                                var child =
                                  _step3.value;
                                child.dump(
                                  buffer
                                );
                              }
                            } catch (err) {
                              _iterator3.e(err);
                            } finally {
                              _iterator3.f();
                            }

                            buffer.push(
                              "</".concat(
                                this.nodeName,
                                ">"
                              )
                            );
                          } else if (
                            this.nodeValue
                          ) {
                            buffer.push(
                              ">"
                                .concat(
                                  (0,
                                  _util.encodeToXmlString)(
                                    this.nodeValue
                                  ),
                                  "</"
                                )
                                .concat(
                                  this.nodeName,
                                  ">"
                                )
                            );
                          } else {
                            buffer.push("/>");
                          }
                        },
                      },
                    ]);

                    return SimpleDOMNode;
                  })();

                exports.SimpleDOMNode =
                  SimpleDOMNode;

                var SimpleXMLParser =
                  /*#__PURE__*/ (function (
                    _XMLParserBase
                  ) {
                    _inherits(
                      SimpleXMLParser,
                      _XMLParserBase
                    );

                    var _super = _createSuper(
                      SimpleXMLParser
                    );

                    function SimpleXMLParser(
                      _ref
                    ) {
                      var _this2;

                      var _ref$hasAttributes =
                          _ref.hasAttributes,
                        hasAttributes =
                          _ref$hasAttributes ===
                          void 0
                            ? false
                            : _ref$hasAttributes,
                        _ref$lowerCaseName =
                          _ref.lowerCaseName,
                        lowerCaseName =
                          _ref$lowerCaseName ===
                          void 0
                            ? false
                            : _ref$lowerCaseName;

                      _classCallCheck(
                        this,
                        SimpleXMLParser
                      );

                      _this2 = _super.call(this);
                      _this2._currentFragment =
                        null;
                      _this2._stack = null;
                      _this2._errorCode =
                        XMLParserErrorCode.NoError;
                      _this2._hasAttributes =
                        hasAttributes;
                      _this2._lowerCaseName =
                        lowerCaseName;
                      return _this2;
                    }

                    _createClass(
                      SimpleXMLParser,
                      [
                        {
                          key: "parseFromString",
                          value:
                            function parseFromString(
                              data
                            ) {
                              this._currentFragment =
                                [];
                              this._stack = [];
                              this._errorCode =
                                XMLParserErrorCode.NoError;
                              this.parseXml(data);

                              if (
                                this
                                  ._errorCode !==
                                XMLParserErrorCode.NoError
                              ) {
                                return undefined;
                              }

                              var _this$_currentFragmen =
                                  _slicedToArray(
                                    this
                                      ._currentFragment,
                                    1
                                  ),
                                documentElement =
                                  _this$_currentFragmen[0];

                              if (
                                !documentElement
                              ) {
                                return undefined;
                              }

                              return {
                                documentElement:
                                  documentElement,
                              };
                            },
                        },
                        {
                          key: "onText",
                          value: function onText(
                            text
                          ) {
                            if (
                              isWhitespaceString(
                                text
                              )
                            ) {
                              return;
                            }

                            var node =
                              new SimpleDOMNode(
                                "#text",
                                text
                              );

                            this._currentFragment.push(
                              node
                            );
                          },
                        },
                        {
                          key: "onCdata",
                          value: function onCdata(
                            text
                          ) {
                            var node =
                              new SimpleDOMNode(
                                "#text",
                                text
                              );

                            this._currentFragment.push(
                              node
                            );
                          },
                        },
                        {
                          key: "onBeginElement",
                          value:
                            function onBeginElement(
                              name,
                              attributes,
                              isEmpty
                            ) {
                              if (
                                this
                                  ._lowerCaseName
                              ) {
                                name =
                                  name.toLowerCase();
                              }

                              var node =
                                new SimpleDOMNode(
                                  name
                                );
                              node.childNodes =
                                [];

                              if (
                                this
                                  ._hasAttributes
                              ) {
                                node.attributes =
                                  attributes;
                              }

                              this._currentFragment.push(
                                node
                              );

                              if (isEmpty) {
                                return;
                              }

                              this._stack.push(
                                this
                                  ._currentFragment
                              );

                              this._currentFragment =
                                node.childNodes;
                            },
                        },
                        {
                          key: "onEndElement",
                          value:
                            function onEndElement(
                              name
                            ) {
                              this._currentFragment =
                                this._stack.pop() ||
                                [];
                              var lastElement =
                                this
                                  ._currentFragment[
                                  this
                                    ._currentFragment
                                    .length - 1
                                ];

                              if (!lastElement) {
                                return;
                              }

                              for (
                                var i = 0,
                                  ii =
                                    lastElement
                                      .childNodes
                                      .length;
                                i < ii;
                                i++
                              ) {
                                lastElement.childNodes[
                                  i
                                ].parentNode =
                                  lastElement;
                              }
                            },
                        },
                        {
                          key: "onError",
                          value: function onError(
                            code
                          ) {
                            this._errorCode =
                              code;
                          },
                        },
                      ]
                    );

                    return SimpleXMLParser;
                  })(XMLParserBase);

                exports.SimpleXMLParser =
                  SimpleXMLParser;

                /***/
              },
              /* 146 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.OptionalContentConfig =
                  void 0;

                var _util =
                  __w_pdfjs_require__(4);

                function _createForOfIteratorHelper(
                  o,
                  allowArrayLike
                ) {
                  var it;
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    o[Symbol.iterator] == null
                  ) {
                    if (
                      Array.isArray(o) ||
                      (it =
                        _unsupportedIterableToArray(
                          o
                        )) ||
                      (allowArrayLike &&
                        o &&
                        typeof o.length ===
                          "number")
                    ) {
                      if (it) o = it;
                      var i = 0;
                      var F = function F() {};
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return { done: true };
                          return {
                            done: false,
                            value: o[i++],
                          };
                        },
                        e: function e(_e) {
                          throw _e;
                        },
                        f: F,
                      };
                    }
                    throw new TypeError(
                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  }
                  var normalCompletion = true,
                    didErr = false,
                    err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion =
                        step.done;
                      return step;
                    },
                    e: function e(_e2) {
                      didErr = true;
                      err = _e2;
                    },
                    f: function f() {
                      try {
                        if (
                          !normalCompletion &&
                          it["return"] != null
                        )
                          it["return"]();
                      } finally {
                        if (didErr) throw err;
                      }
                    },
                  };
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                var OptionalContentGroup =
                  function OptionalContentGroup(
                    name,
                    intent
                  ) {
                    _classCallCheck(
                      this,
                      OptionalContentGroup
                    );

                    this.visible = true;
                    this.name = name;
                    this.intent = intent;
                  };

                var OptionalContentConfig =
                  /*#__PURE__*/ (function () {
                    function OptionalContentConfig(
                      data
                    ) {
                      _classCallCheck(
                        this,
                        OptionalContentConfig
                      );

                      this.name = null;
                      this.creator = null;
                      this._order = null;
                      this._groups = new Map();

                      if (data === null) {
                        return;
                      }

                      this.name = data.name;
                      this.creator = data.creator;
                      this._order = data.order;

                      var _iterator =
                          _createForOfIteratorHelper(
                            data.groups
                          ),
                        _step;

                      try {
                        for (
                          _iterator.s();
                          !(_step = _iterator.n())
                            .done;

                        ) {
                          var _group =
                            _step.value;

                          this._groups.set(
                            _group.id,
                            new OptionalContentGroup(
                              _group.name,
                              _group.intent
                            )
                          );
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      if (
                        data.baseState === "OFF"
                      ) {
                        var _iterator2 =
                            _createForOfIteratorHelper(
                              this._groups
                            ),
                          _step2;

                        try {
                          for (
                            _iterator2.s();
                            !(_step2 =
                              _iterator2.n())
                              .done;

                          ) {
                            var group =
                              _step2.value;
                            group.visible = false;
                          }
                        } catch (err) {
                          _iterator2.e(err);
                        } finally {
                          _iterator2.f();
                        }
                      }

                      var _iterator3 =
                          _createForOfIteratorHelper(
                            data.on
                          ),
                        _step3;

                      try {
                        for (
                          _iterator3.s();
                          !(_step3 =
                            _iterator3.n()).done;

                        ) {
                          var on = _step3.value;
                          this._groups.get(
                            on
                          ).visible = true;
                        }
                      } catch (err) {
                        _iterator3.e(err);
                      } finally {
                        _iterator3.f();
                      }

                      var _iterator4 =
                          _createForOfIteratorHelper(
                            data.off
                          ),
                        _step4;

                      try {
                        for (
                          _iterator4.s();
                          !(_step4 =
                            _iterator4.n()).done;

                        ) {
                          var off = _step4.value;
                          this._groups.get(
                            off
                          ).visible = false;
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }
                    }

                    _createClass(
                      OptionalContentConfig,
                      [
                        {
                          key: "isVisible",
                          value:
                            function isVisible(
                              group
                            ) {
                              if (!group) {
                                (0, _util.warn)(
                                  "Optional content group not defined."
                                );
                                return true;
                              }

                              if (
                                group.type ===
                                "OCG"
                              ) {
                                if (
                                  !this._groups.has(
                                    group.id
                                  )
                                ) {
                                  (0, _util.warn)(
                                    "Optional content group not found: ".concat(
                                      group.id
                                    )
                                  );
                                  return true;
                                }

                                return this._groups.get(
                                  group.id
                                ).visible;
                              } else if (
                                group.type ===
                                "OCMD"
                              ) {
                                if (
                                  group.expression
                                ) {
                                  (0, _util.warn)(
                                    "Visibility expression not supported yet."
                                  );
                                }

                                if (
                                  !group.policy ||
                                  group.policy ===
                                    "AnyOn"
                                ) {
                                  var _iterator5 =
                                      _createForOfIteratorHelper(
                                        group.ids
                                      ),
                                    _step5;

                                  try {
                                    for (
                                      _iterator5.s();
                                      !(_step5 =
                                        _iterator5.n())
                                        .done;

                                    ) {
                                      var id =
                                        _step5.value;

                                      if (
                                        !this._groups.has(
                                          id
                                        )
                                      ) {
                                        (0,
                                        _util.warn)(
                                          "Optional content group not found: ".concat(
                                            id
                                          )
                                        );
                                        return true;
                                      }

                                      if (
                                        this._groups.get(
                                          id
                                        ).visible
                                      ) {
                                        return true;
                                      }
                                    }
                                  } catch (err) {
                                    _iterator5.e(
                                      err
                                    );
                                  } finally {
                                    _iterator5.f();
                                  }

                                  return false;
                                } else if (
                                  group.policy ===
                                  "AllOn"
                                ) {
                                  var _iterator6 =
                                      _createForOfIteratorHelper(
                                        group.ids
                                      ),
                                    _step6;

                                  try {
                                    for (
                                      _iterator6.s();
                                      !(_step6 =
                                        _iterator6.n())
                                        .done;

                                    ) {
                                      var _id =
                                        _step6.value;

                                      if (
                                        !this._groups.has(
                                          _id
                                        )
                                      ) {
                                        (0,
                                        _util.warn)(
                                          "Optional content group not found: ".concat(
                                            _id
                                          )
                                        );
                                        return true;
                                      }

                                      if (
                                        !this._groups.get(
                                          _id
                                        ).visible
                                      ) {
                                        return false;
                                      }
                                    }
                                  } catch (err) {
                                    _iterator6.e(
                                      err
                                    );
                                  } finally {
                                    _iterator6.f();
                                  }

                                  return true;
                                } else if (
                                  group.policy ===
                                  "AnyOff"
                                ) {
                                  var _iterator7 =
                                      _createForOfIteratorHelper(
                                        group.ids
                                      ),
                                    _step7;

                                  try {
                                    for (
                                      _iterator7.s();
                                      !(_step7 =
                                        _iterator7.n())
                                        .done;

                                    ) {
                                      var _id2 =
                                        _step7.value;

                                      if (
                                        !this._groups.has(
                                          _id2
                                        )
                                      ) {
                                        (0,
                                        _util.warn)(
                                          "Optional content group not found: ".concat(
                                            _id2
                                          )
                                        );
                                        return true;
                                      }

                                      if (
                                        !this._groups.get(
                                          _id2
                                        ).visible
                                      ) {
                                        return true;
                                      }
                                    }
                                  } catch (err) {
                                    _iterator7.e(
                                      err
                                    );
                                  } finally {
                                    _iterator7.f();
                                  }

                                  return false;
                                } else if (
                                  group.policy ===
                                  "AllOff"
                                ) {
                                  var _iterator8 =
                                      _createForOfIteratorHelper(
                                        group.ids
                                      ),
                                    _step8;

                                  try {
                                    for (
                                      _iterator8.s();
                                      !(_step8 =
                                        _iterator8.n())
                                        .done;

                                    ) {
                                      var _id3 =
                                        _step8.value;

                                      if (
                                        !this._groups.has(
                                          _id3
                                        )
                                      ) {
                                        (0,
                                        _util.warn)(
                                          "Optional content group not found: ".concat(
                                            _id3
                                          )
                                        );
                                        return true;
                                      }

                                      if (
                                        this._groups.get(
                                          _id3
                                        ).visible
                                      ) {
                                        return false;
                                      }
                                    }
                                  } catch (err) {
                                    _iterator8.e(
                                      err
                                    );
                                  } finally {
                                    _iterator8.f();
                                  }

                                  return true;
                                }

                                (0, _util.warn)(
                                  "Unknown optional content policy ".concat(
                                    group.policy,
                                    "."
                                  )
                                );
                                return true;
                              }

                              (0, _util.warn)(
                                "Unknown group type ".concat(
                                  group.type,
                                  "."
                                )
                              );
                              return true;
                            },
                        },
                        {
                          key: "setVisibility",
                          value:
                            function setVisibility(
                              id
                            ) {
                              var visible =
                                arguments.length >
                                  1 &&
                                arguments[1] !==
                                  undefined
                                  ? arguments[1]
                                  : true;

                              if (
                                !this._groups.has(
                                  id
                                )
                              ) {
                                (0, _util.warn)(
                                  "Optional content group not found: ".concat(
                                    id
                                  )
                                );
                                return;
                              }

                              this._groups.get(
                                id
                              ).visible =
                                !!visible;
                            },
                        },
                        {
                          key: "getOrder",
                          value:
                            function getOrder() {
                              if (
                                !this._groups.size
                              ) {
                                return null;
                              }

                              if (this._order) {
                                return this._order.slice();
                              }

                              return Array.from(
                                this._groups.keys()
                              );
                            },
                        },
                        {
                          key: "getGroups",
                          value:
                            function getGroups() {
                              if (
                                !this._groups.size
                              ) {
                                return null;
                              }

                              return (0,
                              _util.objectFromEntries)(
                                this._groups
                              );
                            },
                        },
                        {
                          key: "getGroup",
                          value:
                            function getGroup(
                              id
                            ) {
                              return (
                                this._groups.get(
                                  id
                                ) || null
                              );
                            },
                        },
                      ]
                    );

                    return OptionalContentConfig;
                  })();

                exports.OptionalContentConfig =
                  OptionalContentConfig;

                /***/
              },
              /* 147 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.PDFDataTransportStream =
                  void 0;

                var _regenerator =
                  _interopRequireDefault(
                    __w_pdfjs_require__(2)
                  );

                var _util =
                  __w_pdfjs_require__(4);

                function _interopRequireDefault(
                  obj
                ) {
                  return obj && obj.__esModule
                    ? obj
                    : { default: obj };
                }

                function asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  key,
                  arg
                ) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(
                      _next,
                      _throw
                    );
                  }
                }

                function _asyncToGenerator(fn) {
                  return function () {
                    var self = this,
                      args = arguments;
                    return new Promise(function (
                      resolve,
                      reject
                    ) {
                      var gen = fn.apply(
                        self,
                        args
                      );
                      function _next(value) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "next",
                          value
                        );
                      }
                      function _throw(err) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "throw",
                          err
                        );
                      }
                      _next(undefined);
                    });
                  };
                }

                function _createForOfIteratorHelper(
                  o,
                  allowArrayLike
                ) {
                  var it;
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    o[Symbol.iterator] == null
                  ) {
                    if (
                      Array.isArray(o) ||
                      (it =
                        _unsupportedIterableToArray(
                          o
                        )) ||
                      (allowArrayLike &&
                        o &&
                        typeof o.length ===
                          "number")
                    ) {
                      if (it) o = it;
                      var i = 0;
                      var F = function F() {};
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return { done: true };
                          return {
                            done: false,
                            value: o[i++],
                          };
                        },
                        e: function e(_e) {
                          throw _e;
                        },
                        f: F,
                      };
                    }
                    throw new TypeError(
                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  }
                  var normalCompletion = true,
                    didErr = false,
                    err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion =
                        step.done;
                      return step;
                    },
                    e: function e(_e2) {
                      didErr = true;
                      err = _e2;
                    },
                    f: function f() {
                      try {
                        if (
                          !normalCompletion &&
                          it["return"] != null
                        )
                          it["return"]();
                      } finally {
                        if (didErr) throw err;
                      }
                    },
                  };
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var PDFDataTransportStream =
                  /*#__PURE__*/ (function () {
                    function PDFDataTransportStream(
                      params,
                      pdfDataRangeTransport
                    ) {
                      var _this = this;

                      _classCallCheck(
                        this,
                        PDFDataTransportStream
                      );

                      (0, _util.assert)(
                        pdfDataRangeTransport,
                        'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'
                      );
                      this._queuedChunks = [];
                      this._progressiveDone =
                        params.progressiveDone ||
                        false;
                      var initialData =
                        params.initialData;

                      if (
                        (initialData === null ||
                        initialData === void 0
                          ? void 0
                          : initialData.length) >
                        0
                      ) {
                        var buffer =
                          new Uint8Array(
                            initialData
                          ).buffer;

                        this._queuedChunks.push(
                          buffer
                        );
                      }

                      this._pdfDataRangeTransport =
                        pdfDataRangeTransport;
                      this._isStreamingSupported =
                        !params.disableStream;
                      this._isRangeSupported =
                        !params.disableRange;
                      this._contentLength =
                        params.length;
                      this._fullRequestReader =
                        null;
                      this._rangeReaders = [];

                      this._pdfDataRangeTransport.addRangeListener(
                        function (begin, chunk) {
                          _this._onReceiveData({
                            begin: begin,
                            chunk: chunk,
                          });
                        }
                      );

                      this._pdfDataRangeTransport.addProgressListener(
                        function (loaded, total) {
                          _this._onProgress({
                            loaded: loaded,
                            total: total,
                          });
                        }
                      );

                      this._pdfDataRangeTransport.addProgressiveReadListener(
                        function (chunk) {
                          _this._onReceiveData({
                            chunk: chunk,
                          });
                        }
                      );

                      this._pdfDataRangeTransport.addProgressiveDoneListener(
                        function () {
                          _this._onProgressiveDone();
                        }
                      );

                      this._pdfDataRangeTransport.transportReady();
                    }

                    _createClass(
                      PDFDataTransportStream,
                      [
                        {
                          key: "_onReceiveData",
                          value:
                            function _onReceiveData(
                              args
                            ) {
                              var buffer =
                                new Uint8Array(
                                  args.chunk
                                ).buffer;

                              if (
                                args.begin ===
                                undefined
                              ) {
                                if (
                                  this
                                    ._fullRequestReader
                                ) {
                                  this._fullRequestReader._enqueue(
                                    buffer
                                  );
                                } else {
                                  this._queuedChunks.push(
                                    buffer
                                  );
                                }
                              } else {
                                var found =
                                  this._rangeReaders.some(
                                    function (
                                      rangeReader
                                    ) {
                                      if (
                                        rangeReader._begin !==
                                        args.begin
                                      ) {
                                        return false;
                                      }

                                      rangeReader._enqueue(
                                        buffer
                                      );

                                      return true;
                                    }
                                  );

                                (0, _util.assert)(
                                  found,
                                  "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found."
                                );
                              }
                            },
                        },
                        {
                          key: "_progressiveDataLength",
                          get: function get() {
                            var _this$_fullRequestRea,
                              _this$_fullRequestRea2;

                            return (_this$_fullRequestRea =
                              (_this$_fullRequestRea2 =
                                this
                                  ._fullRequestReader) ===
                                null ||
                              _this$_fullRequestRea2 ===
                                void 0
                                ? void 0
                                : _this$_fullRequestRea2._loaded) !==
                              null &&
                              _this$_fullRequestRea !==
                                void 0
                              ? _this$_fullRequestRea
                              : 0;
                          },
                        },
                        {
                          key: "_onProgress",
                          value:
                            function _onProgress(
                              evt
                            ) {
                              if (
                                evt.total ===
                                undefined
                              ) {
                                var firstReader =
                                  this
                                    ._rangeReaders[0];

                                if (
                                  firstReader !==
                                    null &&
                                  firstReader !==
                                    void 0 &&
                                  firstReader.onProgress
                                ) {
                                  firstReader.onProgress(
                                    {
                                      loaded:
                                        evt.loaded,
                                    }
                                  );
                                }
                              } else {
                                var fullReader =
                                  this
                                    ._fullRequestReader;

                                if (
                                  fullReader !==
                                    null &&
                                  fullReader !==
                                    void 0 &&
                                  fullReader.onProgress
                                ) {
                                  fullReader.onProgress(
                                    {
                                      loaded:
                                        evt.loaded,
                                      total:
                                        evt.total,
                                    }
                                  );
                                }
                              }
                            },
                        },
                        {
                          key: "_onProgressiveDone",
                          value:
                            function _onProgressiveDone() {
                              if (
                                this
                                  ._fullRequestReader
                              ) {
                                this._fullRequestReader.progressiveDone();
                              }

                              this._progressiveDone = true;
                            },
                        },
                        {
                          key: "_removeRangeReader",
                          value:
                            function _removeRangeReader(
                              reader
                            ) {
                              var i =
                                this._rangeReaders.indexOf(
                                  reader
                                );

                              if (i >= 0) {
                                this._rangeReaders.splice(
                                  i,
                                  1
                                );
                              }
                            },
                        },
                        {
                          key: "getFullReader",
                          value:
                            function getFullReader() {
                              (0, _util.assert)(
                                !this
                                  ._fullRequestReader,
                                "PDFDataTransportStream.getFullReader can only be called once."
                              );
                              var queuedChunks =
                                this
                                  ._queuedChunks;
                              this._queuedChunks =
                                null;
                              return new PDFDataTransportStreamReader(
                                this,
                                queuedChunks,
                                this._progressiveDone
                              );
                            },
                        },
                        {
                          key: "getRangeReader",
                          value:
                            function getRangeReader(
                              begin,
                              end
                            ) {
                              if (
                                end <=
                                this
                                  ._progressiveDataLength
                              ) {
                                return null;
                              }

                              var reader =
                                new PDFDataTransportStreamRangeReader(
                                  this,
                                  begin,
                                  end
                                );

                              this._pdfDataRangeTransport.requestDataRange(
                                begin,
                                end
                              );

                              this._rangeReaders.push(
                                reader
                              );

                              return reader;
                            },
                        },
                        {
                          key: "cancelAllRequests",
                          value:
                            function cancelAllRequests(
                              reason
                            ) {
                              if (
                                this
                                  ._fullRequestReader
                              ) {
                                this._fullRequestReader.cancel(
                                  reason
                                );
                              }

                              var readers =
                                this._rangeReaders.slice(
                                  0
                                );

                              readers.forEach(
                                function (
                                  rangeReader
                                ) {
                                  rangeReader.cancel(
                                    reason
                                  );
                                }
                              );

                              this._pdfDataRangeTransport.abort();
                            },
                        },
                      ]
                    );

                    return PDFDataTransportStream;
                  })();

                exports.PDFDataTransportStream =
                  PDFDataTransportStream;

                var PDFDataTransportStreamReader =
                  /*#__PURE__*/ (function () {
                    function PDFDataTransportStreamReader(
                      stream,
                      queuedChunks
                    ) {
                      var progressiveDone =
                        arguments.length > 2 &&
                        arguments[2] !== undefined
                          ? arguments[2]
                          : false;

                      _classCallCheck(
                        this,
                        PDFDataTransportStreamReader
                      );

                      this._stream = stream;
                      this._done =
                        progressiveDone || false;
                      this._filename = null;
                      this._queuedChunks =
                        queuedChunks || [];
                      this._loaded = 0;

                      var _iterator =
                          _createForOfIteratorHelper(
                            this._queuedChunks
                          ),
                        _step;

                      try {
                        for (
                          _iterator.s();
                          !(_step = _iterator.n())
                            .done;

                        ) {
                          var chunk = _step.value;
                          this._loaded +=
                            chunk.byteLength;
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      this._requests = [];
                      this._headersReady =
                        Promise.resolve();
                      stream._fullRequestReader =
                        this;
                      this.onProgress = null;
                    }

                    _createClass(
                      PDFDataTransportStreamReader,
                      [
                        {
                          key: "_enqueue",
                          value:
                            function _enqueue(
                              chunk
                            ) {
                              if (this._done) {
                                return;
                              }

                              if (
                                this._requests
                                  .length > 0
                              ) {
                                var requestCapability =
                                  this._requests.shift();

                                requestCapability.resolve(
                                  {
                                    value: chunk,
                                    done: false,
                                  }
                                );
                              } else {
                                this._queuedChunks.push(
                                  chunk
                                );
                              }

                              this._loaded +=
                                chunk.byteLength;
                            },
                        },
                        {
                          key: "headersReady",
                          get: function get() {
                            return this
                              ._headersReady;
                          },
                        },
                        {
                          key: "filename",
                          get: function get() {
                            return this._filename;
                          },
                        },
                        {
                          key: "isRangeSupported",
                          get: function get() {
                            return this._stream
                              ._isRangeSupported;
                          },
                        },
                        {
                          key: "isStreamingSupported",
                          get: function get() {
                            return this._stream
                              ._isStreamingSupported;
                          },
                        },
                        {
                          key: "contentLength",
                          get: function get() {
                            return this._stream
                              ._contentLength;
                          },
                        },
                        {
                          key: "read",
                          value: (function () {
                            var _read =
                              _asyncToGenerator(
                                /*#__PURE__*/ _regenerator[
                                  "default"
                                ].mark(
                                  function _callee() {
                                    var chunk,
                                      requestCapability;
                                    return _regenerator[
                                      "default"
                                    ].wrap(
                                      function _callee$(
                                        _context
                                      ) {
                                        while (
                                          1
                                        ) {
                                          switch (
                                            (_context.prev =
                                              _context.next)
                                          ) {
                                            case 0:
                                              if (
                                                !(
                                                  this
                                                    ._queuedChunks
                                                    .length >
                                                  0
                                                )
                                              ) {
                                                _context.next = 3;
                                                break;
                                              }

                                              chunk =
                                                this._queuedChunks.shift();
                                              return _context.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    chunk,
                                                  done: false,
                                                }
                                              );

                                            case 3:
                                              if (
                                                !this
                                                  ._done
                                              ) {
                                                _context.next = 5;
                                                break;
                                              }

                                              return _context.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    undefined,
                                                  done: true,
                                                }
                                              );

                                            case 5:
                                              requestCapability =
                                                (0,
                                                _util.createPromiseCapability)();

                                              this._requests.push(
                                                requestCapability
                                              );

                                              return _context.abrupt(
                                                "return",
                                                requestCapability.promise
                                              );

                                            case 8:
                                            case "end":
                                              return _context.stop();
                                          }
                                        }
                                      },
                                      _callee,
                                      this
                                    );
                                  }
                                )
                              );

                            function read() {
                              return _read.apply(
                                this,
                                arguments
                              );
                            }

                            return read;
                          })(),
                        },
                        {
                          key: "cancel",
                          value: function cancel(
                            reason
                          ) {
                            this._done = true;

                            this._requests.forEach(
                              function (
                                requestCapability
                              ) {
                                requestCapability.resolve(
                                  {
                                    value:
                                      undefined,
                                    done: true,
                                  }
                                );
                              }
                            );

                            this._requests = [];
                          },
                        },
                        {
                          key: "progressiveDone",
                          value:
                            function progressiveDone() {
                              if (this._done) {
                                return;
                              }

                              this._done = true;
                            },
                        },
                      ]
                    );

                    return PDFDataTransportStreamReader;
                  })();

                var PDFDataTransportStreamRangeReader =
                  /*#__PURE__*/ (function () {
                    function PDFDataTransportStreamRangeReader(
                      stream,
                      begin,
                      end
                    ) {
                      _classCallCheck(
                        this,
                        PDFDataTransportStreamRangeReader
                      );

                      this._stream = stream;
                      this._begin = begin;
                      this._end = end;
                      this._queuedChunk = null;
                      this._requests = [];
                      this._done = false;
                      this.onProgress = null;
                    }

                    _createClass(
                      PDFDataTransportStreamRangeReader,
                      [
                        {
                          key: "_enqueue",
                          value:
                            function _enqueue(
                              chunk
                            ) {
                              if (this._done) {
                                return;
                              }

                              if (
                                this._requests
                                  .length === 0
                              ) {
                                this._queuedChunk =
                                  chunk;
                              } else {
                                var requestsCapability =
                                  this._requests.shift();

                                requestsCapability.resolve(
                                  {
                                    value: chunk,
                                    done: false,
                                  }
                                );

                                this._requests.forEach(
                                  function (
                                    requestCapability
                                  ) {
                                    requestCapability.resolve(
                                      {
                                        value:
                                          undefined,
                                        done: true,
                                      }
                                    );
                                  }
                                );

                                this._requests =
                                  [];
                              }

                              this._done = true;

                              this._stream._removeRangeReader(
                                this
                              );
                            },
                        },
                        {
                          key: "isStreamingSupported",
                          get: function get() {
                            return false;
                          },
                        },
                        {
                          key: "read",
                          value: (function () {
                            var _read2 =
                              _asyncToGenerator(
                                /*#__PURE__*/ _regenerator[
                                  "default"
                                ].mark(
                                  function _callee2() {
                                    var chunk,
                                      requestCapability;
                                    return _regenerator[
                                      "default"
                                    ].wrap(
                                      function _callee2$(
                                        _context2
                                      ) {
                                        while (
                                          1
                                        ) {
                                          switch (
                                            (_context2.prev =
                                              _context2.next)
                                          ) {
                                            case 0:
                                              if (
                                                !this
                                                  ._queuedChunk
                                              ) {
                                                _context2.next = 4;
                                                break;
                                              }

                                              chunk =
                                                this
                                                  ._queuedChunk;
                                              this._queuedChunk =
                                                null;
                                              return _context2.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    chunk,
                                                  done: false,
                                                }
                                              );

                                            case 4:
                                              if (
                                                !this
                                                  ._done
                                              ) {
                                                _context2.next = 6;
                                                break;
                                              }

                                              return _context2.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    undefined,
                                                  done: true,
                                                }
                                              );

                                            case 6:
                                              requestCapability =
                                                (0,
                                                _util.createPromiseCapability)();

                                              this._requests.push(
                                                requestCapability
                                              );

                                              return _context2.abrupt(
                                                "return",
                                                requestCapability.promise
                                              );

                                            case 9:
                                            case "end":
                                              return _context2.stop();
                                          }
                                        }
                                      },
                                      _callee2,
                                      this
                                    );
                                  }
                                )
                              );

                            function read() {
                              return _read2.apply(
                                this,
                                arguments
                              );
                            }

                            return read;
                          })(),
                        },
                        {
                          key: "cancel",
                          value: function cancel(
                            reason
                          ) {
                            this._done = true;

                            this._requests.forEach(
                              function (
                                requestCapability
                              ) {
                                requestCapability.resolve(
                                  {
                                    value:
                                      undefined,
                                    done: true,
                                  }
                                );
                              }
                            );

                            this._requests = [];

                            this._stream._removeRangeReader(
                              this
                            );
                          },
                        },
                      ]
                    );

                    return PDFDataTransportStreamRangeReader;
                  })();

                /***/
              },
              /* 148 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.WebGLContext = void 0;

                var _util =
                  __w_pdfjs_require__(4);

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var WebGLContext =
                  /*#__PURE__*/ (function () {
                    function WebGLContext(_ref) {
                      var _ref$enable =
                          _ref.enable,
                        enable =
                          _ref$enable === void 0
                            ? false
                            : _ref$enable;

                      _classCallCheck(
                        this,
                        WebGLContext
                      );

                      this._enabled =
                        enable === true;
                    }

                    _createClass(WebGLContext, [
                      {
                        key: "isEnabled",
                        get: function get() {
                          var enabled =
                            this._enabled;

                          if (enabled) {
                            enabled =
                              WebGLUtils.tryInitGL();
                          }

                          return (0,
                          _util.shadow)(
                            this,
                            "isEnabled",
                            enabled
                          );
                        },
                      },
                      {
                        key: "composeSMask",
                        value:
                          function composeSMask(
                            _ref2
                          ) {
                            var layer =
                                _ref2.layer,
                              mask = _ref2.mask,
                              properties =
                                _ref2.properties;
                            return WebGLUtils.composeSMask(
                              layer,
                              mask,
                              properties
                            );
                          },
                      },
                      {
                        key: "drawFigures",
                        value:
                          function drawFigures(
                            _ref3
                          ) {
                            var width =
                                _ref3.width,
                              height =
                                _ref3.height,
                              backgroundColor =
                                _ref3.backgroundColor,
                              figures =
                                _ref3.figures,
                              context =
                                _ref3.context;
                            return WebGLUtils.drawFigures(
                              width,
                              height,
                              backgroundColor,
                              figures,
                              context
                            );
                          },
                      },
                      {
                        key: "clear",
                        value: function clear() {
                          WebGLUtils.cleanup();
                        },
                      },
                    ]);

                    return WebGLContext;
                  })();

                exports.WebGLContext =
                  WebGLContext;

                var WebGLUtils =
                  (function WebGLUtilsClosure() {
                    function loadShader(
                      gl,
                      code,
                      shaderType
                    ) {
                      var shader =
                        gl.createShader(
                          shaderType
                        );
                      gl.shaderSource(
                        shader,
                        code
                      );
                      gl.compileShader(shader);
                      var compiled =
                        gl.getShaderParameter(
                          shader,
                          gl.COMPILE_STATUS
                        );

                      if (!compiled) {
                        var errorMsg =
                          gl.getShaderInfoLog(
                            shader
                          );
                        throw new Error(
                          "Error during shader compilation: " +
                            errorMsg
                        );
                      }

                      return shader;
                    }

                    function createVertexShader(
                      gl,
                      code
                    ) {
                      return loadShader(
                        gl,
                        code,
                        gl.VERTEX_SHADER
                      );
                    }

                    function createFragmentShader(
                      gl,
                      code
                    ) {
                      return loadShader(
                        gl,
                        code,
                        gl.FRAGMENT_SHADER
                      );
                    }

                    function createProgram(
                      gl,
                      shaders
                    ) {
                      var program =
                        gl.createProgram();

                      for (
                        var i = 0,
                          ii = shaders.length;
                        i < ii;
                        ++i
                      ) {
                        gl.attachShader(
                          program,
                          shaders[i]
                        );
                      }

                      gl.linkProgram(program);
                      var linked =
                        gl.getProgramParameter(
                          program,
                          gl.LINK_STATUS
                        );

                      if (!linked) {
                        var errorMsg =
                          gl.getProgramInfoLog(
                            program
                          );
                        throw new Error(
                          "Error during program linking: " +
                            errorMsg
                        );
                      }

                      return program;
                    }

                    function createTexture(
                      gl,
                      image,
                      textureId
                    ) {
                      gl.activeTexture(textureId);
                      var texture =
                        gl.createTexture();
                      gl.bindTexture(
                        gl.TEXTURE_2D,
                        texture
                      );
                      gl.texParameteri(
                        gl.TEXTURE_2D,
                        gl.TEXTURE_WRAP_S,
                        gl.CLAMP_TO_EDGE
                      );
                      gl.texParameteri(
                        gl.TEXTURE_2D,
                        gl.TEXTURE_WRAP_T,
                        gl.CLAMP_TO_EDGE
                      );
                      gl.texParameteri(
                        gl.TEXTURE_2D,
                        gl.TEXTURE_MIN_FILTER,
                        gl.NEAREST
                      );
                      gl.texParameteri(
                        gl.TEXTURE_2D,
                        gl.TEXTURE_MAG_FILTER,
                        gl.NEAREST
                      );
                      gl.texImage2D(
                        gl.TEXTURE_2D,
                        0,
                        gl.RGBA,
                        gl.RGBA,
                        gl.UNSIGNED_BYTE,
                        image
                      );
                      return texture;
                    }

                    var currentGL, currentCanvas;

                    function generateGL() {
                      if (currentGL) {
                        return;
                      }

                      currentCanvas =
                        document.createElement(
                          "canvas"
                        );
                      currentGL =
                        currentCanvas.getContext(
                          "webgl",
                          {
                            premultipliedalpha: false,
                          }
                        );
                    }

                    var smaskVertexShaderCode =
                      "\
  attribute vec2 a_position;                                    \
  attribute vec2 a_texCoord;                                    \
                                                                \
  uniform vec2 u_resolution;                                    \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_texCoord = a_texCoord;                                    \
  }                                                             ";
                    var smaskFragmentShaderCode =
                      "\
  precision mediump float;                                      \
                                                                \
  uniform vec4 u_backdrop;                                      \
  uniform int u_subtype;                                        \
  uniform sampler2D u_image;                                    \
  uniform sampler2D u_mask;                                     \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec4 imageColor = texture2D(u_image, v_texCoord);           \
    vec4 maskColor = texture2D(u_mask, v_texCoord);             \
    if (u_backdrop.a > 0.0) {                                   \
      maskColor.rgb = maskColor.rgb * maskColor.a +             \
                      u_backdrop.rgb * (1.0 - maskColor.a);     \
    }                                                           \
    float lum;                                                  \
    if (u_subtype == 0) {                                       \
      lum = maskColor.a;                                        \
    } else {                                                    \
      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \
            maskColor.b * 0.11;                                 \
    }                                                           \
    imageColor.a *= lum;                                        \
    imageColor.rgb *= imageColor.a;                             \
    gl_FragColor = imageColor;                                  \
  }                                                             ";
                    var smaskCache = null;

                    function initSmaskGL() {
                      generateGL();
                      var canvas = currentCanvas;
                      currentCanvas = null;
                      var gl = currentGL;
                      currentGL = null;
                      var vertexShader =
                        createVertexShader(
                          gl,
                          smaskVertexShaderCode
                        );
                      var fragmentShader =
                        createFragmentShader(
                          gl,
                          smaskFragmentShaderCode
                        );
                      var program = createProgram(
                        gl,
                        [
                          vertexShader,
                          fragmentShader,
                        ]
                      );
                      gl.useProgram(program);
                      var cache = {};
                      cache.gl = gl;
                      cache.canvas = canvas;
                      cache.resolutionLocation =
                        gl.getUniformLocation(
                          program,
                          "u_resolution"
                        );
                      cache.positionLocation =
                        gl.getAttribLocation(
                          program,
                          "a_position"
                        );
                      cache.backdropLocation =
                        gl.getUniformLocation(
                          program,
                          "u_backdrop"
                        );
                      cache.subtypeLocation =
                        gl.getUniformLocation(
                          program,
                          "u_subtype"
                        );
                      var texCoordLocation =
                        gl.getAttribLocation(
                          program,
                          "a_texCoord"
                        );
                      var texLayerLocation =
                        gl.getUniformLocation(
                          program,
                          "u_image"
                        );
                      var texMaskLocation =
                        gl.getUniformLocation(
                          program,
                          "u_mask"
                        );
                      var texCoordBuffer =
                        gl.createBuffer();
                      gl.bindBuffer(
                        gl.ARRAY_BUFFER,
                        texCoordBuffer
                      );
                      gl.bufferData(
                        gl.ARRAY_BUFFER,
                        new Float32Array([
                          0.0, 0.0, 1.0, 0.0, 0.0,
                          1.0, 0.0, 1.0, 1.0, 0.0,
                          1.0, 1.0,
                        ]),
                        gl.STATIC_DRAW
                      );
                      gl.enableVertexAttribArray(
                        texCoordLocation
                      );
                      gl.vertexAttribPointer(
                        texCoordLocation,
                        2,
                        gl.FLOAT,
                        false,
                        0,
                        0
                      );
                      gl.uniform1i(
                        texLayerLocation,
                        0
                      );
                      gl.uniform1i(
                        texMaskLocation,
                        1
                      );
                      smaskCache = cache;
                    }

                    function composeSMask(
                      layer,
                      mask,
                      properties
                    ) {
                      var width = layer.width,
                        height = layer.height;

                      if (!smaskCache) {
                        initSmaskGL();
                      }

                      var cache = smaskCache,
                        canvas = cache.canvas,
                        gl = cache.gl;
                      canvas.width = width;
                      canvas.height = height;
                      gl.viewport(
                        0,
                        0,
                        gl.drawingBufferWidth,
                        gl.drawingBufferHeight
                      );
                      gl.uniform2f(
                        cache.resolutionLocation,
                        width,
                        height
                      );

                      if (properties.backdrop) {
                        gl.uniform4f(
                          cache.resolutionLocation,
                          properties.backdrop[0],
                          properties.backdrop[1],
                          properties.backdrop[2],
                          1
                        );
                      } else {
                        gl.uniform4f(
                          cache.resolutionLocation,
                          0,
                          0,
                          0,
                          0
                        );
                      }

                      gl.uniform1i(
                        cache.subtypeLocation,
                        properties.subtype ===
                          "Luminosity"
                          ? 1
                          : 0
                      );
                      var texture = createTexture(
                        gl,
                        layer,
                        gl.TEXTURE0
                      );
                      var maskTexture =
                        createTexture(
                          gl,
                          mask,
                          gl.TEXTURE1
                        );
                      var buffer =
                        gl.createBuffer();
                      gl.bindBuffer(
                        gl.ARRAY_BUFFER,
                        buffer
                      );
                      gl.bufferData(
                        gl.ARRAY_BUFFER,
                        new Float32Array([
                          0,
                          0,
                          width,
                          0,
                          0,
                          height,
                          0,
                          height,
                          width,
                          0,
                          width,
                          height,
                        ]),
                        gl.STATIC_DRAW
                      );
                      gl.enableVertexAttribArray(
                        cache.positionLocation
                      );
                      gl.vertexAttribPointer(
                        cache.positionLocation,
                        2,
                        gl.FLOAT,
                        false,
                        0,
                        0
                      );
                      gl.clearColor(0, 0, 0, 0);
                      gl.enable(gl.BLEND);
                      gl.blendFunc(
                        gl.ONE,
                        gl.ONE_MINUS_SRC_ALPHA
                      );
                      gl.clear(
                        gl.COLOR_BUFFER_BIT
                      );
                      gl.drawArrays(
                        gl.TRIANGLES,
                        0,
                        6
                      );
                      gl.flush();
                      gl.deleteTexture(texture);
                      gl.deleteTexture(
                        maskTexture
                      );
                      gl.deleteBuffer(buffer);
                      return canvas;
                    }

                    var figuresVertexShaderCode =
                      "\
  attribute vec2 a_position;                                    \
  attribute vec3 a_color;                                       \
                                                                \
  uniform vec2 u_resolution;                                    \
  uniform vec2 u_scale;                                         \
  uniform vec2 u_offset;                                        \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    vec2 position = (a_position + u_offset) * u_scale;          \
    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_color = vec4(a_color / 255.0, 1.0);                       \
  }                                                             ";
                    var figuresFragmentShaderCode =
                      "\
  precision mediump float;                                      \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    gl_FragColor = v_color;                                     \
  }                                                             ";
                    var figuresCache = null;

                    function initFiguresGL() {
                      generateGL();
                      var canvas = currentCanvas;
                      currentCanvas = null;
                      var gl = currentGL;
                      currentGL = null;
                      var vertexShader =
                        createVertexShader(
                          gl,
                          figuresVertexShaderCode
                        );
                      var fragmentShader =
                        createFragmentShader(
                          gl,
                          figuresFragmentShaderCode
                        );
                      var program = createProgram(
                        gl,
                        [
                          vertexShader,
                          fragmentShader,
                        ]
                      );
                      gl.useProgram(program);
                      var cache = {};
                      cache.gl = gl;
                      cache.canvas = canvas;
                      cache.resolutionLocation =
                        gl.getUniformLocation(
                          program,
                          "u_resolution"
                        );
                      cache.scaleLocation =
                        gl.getUniformLocation(
                          program,
                          "u_scale"
                        );
                      cache.offsetLocation =
                        gl.getUniformLocation(
                          program,
                          "u_offset"
                        );
                      cache.positionLocation =
                        gl.getAttribLocation(
                          program,
                          "a_position"
                        );
                      cache.colorLocation =
                        gl.getAttribLocation(
                          program,
                          "a_color"
                        );
                      figuresCache = cache;
                    }

                    function drawFigures(
                      width,
                      height,
                      backgroundColor,
                      figures,
                      context
                    ) {
                      if (!figuresCache) {
                        initFiguresGL();
                      }

                      var cache = figuresCache,
                        canvas = cache.canvas,
                        gl = cache.gl;
                      canvas.width = width;
                      canvas.height = height;
                      gl.viewport(
                        0,
                        0,
                        gl.drawingBufferWidth,
                        gl.drawingBufferHeight
                      );
                      gl.uniform2f(
                        cache.resolutionLocation,
                        width,
                        height
                      );
                      var count = 0;

                      for (
                        var i = 0,
                          ii = figures.length;
                        i < ii;
                        i++
                      ) {
                        switch (figures[i].type) {
                          case "lattice":
                            var rows =
                              (figures[i].coords
                                .length /
                                figures[i]
                                  .verticesPerRow) |
                              0;
                            count +=
                              (rows - 1) *
                              (figures[i]
                                .verticesPerRow -
                                1) *
                              6;
                            break;

                          case "triangles":
                            count +=
                              figures[i].coords
                                .length;
                            break;
                        }
                      }

                      var coords =
                        new Float32Array(
                          count * 2
                        );
                      var colors = new Uint8Array(
                        count * 3
                      );
                      var coordsMap =
                          context.coords,
                        colorsMap =
                          context.colors;
                      var pIndex = 0,
                        cIndex = 0;

                      for (
                        var _i = 0,
                          _ii = figures.length;
                        _i < _ii;
                        _i++
                      ) {
                        var figure = figures[_i],
                          ps = figure.coords,
                          cs = figure.colors;

                        switch (figure.type) {
                          case "lattice":
                            var cols =
                              figure.verticesPerRow;

                            var _rows =
                              (ps.length / cols) |
                              0;

                            for (
                              var row = 1;
                              row < _rows;
                              row++
                            ) {
                              var offset =
                                row * cols + 1;

                              for (
                                var col = 1;
                                col < cols;
                                col++, offset++
                              ) {
                                coords[pIndex] =
                                  coordsMap[
                                    ps[
                                      offset -
                                        cols -
                                        1
                                    ]
                                  ];
                                coords[
                                  pIndex + 1
                                ] =
                                  coordsMap[
                                    ps[
                                      offset -
                                        cols -
                                        1
                                    ] + 1
                                  ];
                                coords[
                                  pIndex + 2
                                ] =
                                  coordsMap[
                                    ps[
                                      offset -
                                        cols
                                    ]
                                  ];
                                coords[
                                  pIndex + 3
                                ] =
                                  coordsMap[
                                    ps[
                                      offset -
                                        cols
                                    ] + 1
                                  ];
                                coords[
                                  pIndex + 4
                                ] =
                                  coordsMap[
                                    ps[offset - 1]
                                  ];
                                coords[
                                  pIndex + 5
                                ] =
                                  coordsMap[
                                    ps[
                                      offset - 1
                                    ] + 1
                                  ];
                                colors[cIndex] =
                                  colorsMap[
                                    cs[
                                      offset -
                                        cols -
                                        1
                                    ]
                                  ];
                                colors[
                                  cIndex + 1
                                ] =
                                  colorsMap[
                                    cs[
                                      offset -
                                        cols -
                                        1
                                    ] + 1
                                  ];
                                colors[
                                  cIndex + 2
                                ] =
                                  colorsMap[
                                    cs[
                                      offset -
                                        cols -
                                        1
                                    ] + 2
                                  ];
                                colors[
                                  cIndex + 3
                                ] =
                                  colorsMap[
                                    cs[
                                      offset -
                                        cols
                                    ]
                                  ];
                                colors[
                                  cIndex + 4
                                ] =
                                  colorsMap[
                                    cs[
                                      offset -
                                        cols
                                    ] + 1
                                  ];
                                colors[
                                  cIndex + 5
                                ] =
                                  colorsMap[
                                    cs[
                                      offset -
                                        cols
                                    ] + 2
                                  ];
                                colors[
                                  cIndex + 6
                                ] =
                                  colorsMap[
                                    cs[offset - 1]
                                  ];
                                colors[
                                  cIndex + 7
                                ] =
                                  colorsMap[
                                    cs[
                                      offset - 1
                                    ] + 1
                                  ];
                                colors[
                                  cIndex + 8
                                ] =
                                  colorsMap[
                                    cs[
                                      offset - 1
                                    ] + 2
                                  ];
                                coords[
                                  pIndex + 6
                                ] =
                                  coords[
                                    pIndex + 2
                                  ];
                                coords[
                                  pIndex + 7
                                ] =
                                  coords[
                                    pIndex + 3
                                  ];
                                coords[
                                  pIndex + 8
                                ] =
                                  coords[
                                    pIndex + 4
                                  ];
                                coords[
                                  pIndex + 9
                                ] =
                                  coords[
                                    pIndex + 5
                                  ];
                                coords[
                                  pIndex + 10
                                ] =
                                  coordsMap[
                                    ps[offset]
                                  ];
                                coords[
                                  pIndex + 11
                                ] =
                                  coordsMap[
                                    ps[offset] + 1
                                  ];
                                colors[
                                  cIndex + 9
                                ] =
                                  colors[
                                    cIndex + 3
                                  ];
                                colors[
                                  cIndex + 10
                                ] =
                                  colors[
                                    cIndex + 4
                                  ];
                                colors[
                                  cIndex + 11
                                ] =
                                  colors[
                                    cIndex + 5
                                  ];
                                colors[
                                  cIndex + 12
                                ] =
                                  colors[
                                    cIndex + 6
                                  ];
                                colors[
                                  cIndex + 13
                                ] =
                                  colors[
                                    cIndex + 7
                                  ];
                                colors[
                                  cIndex + 14
                                ] =
                                  colors[
                                    cIndex + 8
                                  ];
                                colors[
                                  cIndex + 15
                                ] =
                                  colorsMap[
                                    cs[offset]
                                  ];
                                colors[
                                  cIndex + 16
                                ] =
                                  colorsMap[
                                    cs[offset] + 1
                                  ];
                                colors[
                                  cIndex + 17
                                ] =
                                  colorsMap[
                                    cs[offset] + 2
                                  ];
                                pIndex += 12;
                                cIndex += 18;
                              }
                            }

                            break;

                          case "triangles":
                            for (
                              var j = 0,
                                jj = ps.length;
                              j < jj;
                              j++
                            ) {
                              coords[pIndex] =
                                coordsMap[ps[j]];
                              coords[pIndex + 1] =
                                coordsMap[
                                  ps[j] + 1
                                ];
                              colors[cIndex] =
                                colorsMap[cs[j]];
                              colors[cIndex + 1] =
                                colorsMap[
                                  cs[j] + 1
                                ];
                              colors[cIndex + 2] =
                                colorsMap[
                                  cs[j] + 2
                                ];
                              pIndex += 2;
                              cIndex += 3;
                            }

                            break;
                        }
                      }

                      if (backgroundColor) {
                        gl.clearColor(
                          backgroundColor[0] /
                            255,
                          backgroundColor[1] /
                            255,
                          backgroundColor[2] /
                            255,
                          1.0
                        );
                      } else {
                        gl.clearColor(0, 0, 0, 0);
                      }

                      gl.clear(
                        gl.COLOR_BUFFER_BIT
                      );
                      var coordsBuffer =
                        gl.createBuffer();
                      gl.bindBuffer(
                        gl.ARRAY_BUFFER,
                        coordsBuffer
                      );
                      gl.bufferData(
                        gl.ARRAY_BUFFER,
                        coords,
                        gl.STATIC_DRAW
                      );
                      gl.enableVertexAttribArray(
                        cache.positionLocation
                      );
                      gl.vertexAttribPointer(
                        cache.positionLocation,
                        2,
                        gl.FLOAT,
                        false,
                        0,
                        0
                      );
                      var colorsBuffer =
                        gl.createBuffer();
                      gl.bindBuffer(
                        gl.ARRAY_BUFFER,
                        colorsBuffer
                      );
                      gl.bufferData(
                        gl.ARRAY_BUFFER,
                        colors,
                        gl.STATIC_DRAW
                      );
                      gl.enableVertexAttribArray(
                        cache.colorLocation
                      );
                      gl.vertexAttribPointer(
                        cache.colorLocation,
                        3,
                        gl.UNSIGNED_BYTE,
                        false,
                        0,
                        0
                      );
                      gl.uniform2f(
                        cache.scaleLocation,
                        context.scaleX,
                        context.scaleY
                      );
                      gl.uniform2f(
                        cache.offsetLocation,
                        context.offsetX,
                        context.offsetY
                      );
                      gl.drawArrays(
                        gl.TRIANGLES,
                        0,
                        count
                      );
                      gl.flush();
                      gl.deleteBuffer(
                        coordsBuffer
                      );
                      gl.deleteBuffer(
                        colorsBuffer
                      );
                      return canvas;
                    }

                    return {
                      tryInitGL:
                        function tryInitGL() {
                          try {
                            generateGL();
                            return !!currentGL;
                          } catch (ex) {}

                          return false;
                        },
                      composeSMask: composeSMask,
                      drawFigures: drawFigures,
                      cleanup:
                        function cleanup() {
                          var _smaskCache,
                            _figuresCache;

                          if (
                            (_smaskCache =
                              smaskCache) !==
                              null &&
                            _smaskCache !==
                              void 0 &&
                            _smaskCache.canvas
                          ) {
                            smaskCache.canvas.width = 0;
                            smaskCache.canvas.height = 0;
                          }

                          if (
                            (_figuresCache =
                              figuresCache) !==
                              null &&
                            _figuresCache !==
                              void 0 &&
                            _figuresCache.canvas
                          ) {
                            figuresCache.canvas.width = 0;
                            figuresCache.canvas.height = 0;
                          }

                          smaskCache = null;
                          figuresCache = null;
                        },
                    };
                  })();

                /***/
              },
              /* 149 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.AnnotationLayer = void 0;

                var _display_utils =
                  __w_pdfjs_require__(1);

                var _util =
                  __w_pdfjs_require__(4);

                var _annotation_storage =
                  __w_pdfjs_require__(138);

                var _scripting_utils =
                  __w_pdfjs_require__(150);

                function _get(
                  target,
                  property,
                  receiver
                ) {
                  if (
                    typeof Reflect !==
                      "undefined" &&
                    Reflect.get
                  ) {
                    _get = Reflect.get;
                  } else {
                    _get = function _get(
                      target,
                      property,
                      receiver
                    ) {
                      var base = _superPropBase(
                        target,
                        property
                      );
                      if (!base) return;
                      var desc =
                        Object.getOwnPropertyDescriptor(
                          base,
                          property
                        );
                      if (desc.get) {
                        return desc.get.call(
                          receiver
                        );
                      }
                      return desc.value;
                    };
                  }
                  return _get(
                    target,
                    property,
                    receiver || target
                  );
                }

                function _superPropBase(
                  object,
                  property
                ) {
                  while (
                    !Object.prototype.hasOwnProperty.call(
                      object,
                      property
                    )
                  ) {
                    object =
                      _getPrototypeOf(object);
                    if (object === null) break;
                  }
                  return object;
                }

                function _slicedToArray(arr, i) {
                  return (
                    _arrayWithHoles(arr) ||
                    _iterableToArrayLimit(
                      arr,
                      i
                    ) ||
                    _unsupportedIterableToArray(
                      arr,
                      i
                    ) ||
                    _nonIterableRest()
                  );
                }

                function _nonIterableRest() {
                  throw new TypeError(
                    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _iterableToArrayLimit(
                  arr,
                  i
                ) {
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    !(
                      Symbol.iterator in
                      Object(arr)
                    )
                  )
                    return;
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (
                      var _i =
                          arr[Symbol.iterator](),
                        _s;
                      !(_n = (_s = _i.next())
                        .done);
                      _n = true
                    ) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (
                        !_n &&
                        _i["return"] != null
                      )
                        _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }

                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }

                function _inherits(
                  subClass,
                  superClass
                ) {
                  if (
                    typeof superClass !==
                      "function" &&
                    superClass !== null
                  ) {
                    throw new TypeError(
                      "Super expression must either be null or a function"
                    );
                  }
                  subClass.prototype =
                    Object.create(
                      superClass &&
                        superClass.prototype,
                      {
                        constructor: {
                          value: subClass,
                          writable: true,
                          configurable: true,
                        },
                      }
                    );
                  if (superClass)
                    _setPrototypeOf(
                      subClass,
                      superClass
                    );
                }

                function _setPrototypeOf(o, p) {
                  _setPrototypeOf =
                    Object.setPrototypeOf ||
                    function _setPrototypeOf(
                      o,
                      p
                    ) {
                      o.__proto__ = p;
                      return o;
                    };
                  return _setPrototypeOf(o, p);
                }

                function _createSuper(Derived) {
                  var hasNativeReflectConstruct =
                    _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super =
                        _getPrototypeOf(Derived),
                      result;
                    if (
                      hasNativeReflectConstruct
                    ) {
                      var NewTarget =
                        _getPrototypeOf(
                          this
                        ).constructor;
                      result = Reflect.construct(
                        Super,
                        arguments,
                        NewTarget
                      );
                    } else {
                      result = Super.apply(
                        this,
                        arguments
                      );
                    }
                    return _possibleConstructorReturn(
                      this,
                      result
                    );
                  };
                }

                function _possibleConstructorReturn(
                  self,
                  call
                ) {
                  if (
                    call &&
                    (_typeof(call) === "object" ||
                      typeof call === "function")
                  ) {
                    return call;
                  }
                  return _assertThisInitialized(
                    self
                  );
                }

                function _assertThisInitialized(
                  self
                ) {
                  if (self === void 0) {
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  }
                  return self;
                }

                function _isNativeReflectConstruct() {
                  if (
                    typeof Reflect ===
                      "undefined" ||
                    !Reflect.construct
                  )
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(
                      Reflect.construct(
                        Date,
                        [],
                        function () {}
                      )
                    );
                    return true;
                  } catch (e) {
                    return false;
                  }
                }

                function _getPrototypeOf(o) {
                  _getPrototypeOf =
                    Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function _getPrototypeOf(
                          o
                        ) {
                          return (
                            o.__proto__ ||
                            Object.getPrototypeOf(
                              o
                            )
                          );
                        };
                  return _getPrototypeOf(o);
                }

                function _createForOfIteratorHelper(
                  o,
                  allowArrayLike
                ) {
                  var it;
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    o[Symbol.iterator] == null
                  ) {
                    if (
                      Array.isArray(o) ||
                      (it =
                        _unsupportedIterableToArray(
                          o
                        )) ||
                      (allowArrayLike &&
                        o &&
                        typeof o.length ===
                          "number")
                    ) {
                      if (it) o = it;
                      var i = 0;
                      var F = function F() {};
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return { done: true };
                          return {
                            done: false,
                            value: o[i++],
                          };
                        },
                        e: function e(_e2) {
                          throw _e2;
                        },
                        f: F,
                      };
                    }
                    throw new TypeError(
                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  }
                  var normalCompletion = true,
                    didErr = false,
                    err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion =
                        step.done;
                      return step;
                    },
                    e: function e(_e3) {
                      didErr = true;
                      err = _e3;
                    },
                    f: function f() {
                      try {
                        if (
                          !normalCompletion &&
                          it["return"] != null
                        )
                          it["return"]();
                      } finally {
                        if (didErr) throw err;
                      }
                    },
                  };
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var AnnotationElementFactory =
                  /*#__PURE__*/ (function () {
                    function AnnotationElementFactory() {
                      _classCallCheck(
                        this,
                        AnnotationElementFactory
                      );
                    }

                    _createClass(
                      AnnotationElementFactory,
                      null,
                      [
                        {
                          key: "create",
                          value: function create(
                            parameters
                          ) {
                            var subtype =
                              parameters.data
                                .annotationType;

                            switch (subtype) {
                              case _util
                                .AnnotationType
                                .LINK:
                                return new LinkAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .TEXT:
                                return new TextAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .WIDGET:
                                var fieldType =
                                  parameters.data
                                    .fieldType;

                                switch (
                                  fieldType
                                ) {
                                  case "Tx":
                                    return new TextWidgetAnnotationElement(
                                      parameters
                                    );

                                  case "Btn":
                                    if (
                                      parameters
                                        .data
                                        .radioButton
                                    ) {
                                      return new RadioButtonWidgetAnnotationElement(
                                        parameters
                                      );
                                    } else if (
                                      parameters
                                        .data
                                        .checkBox
                                    ) {
                                      return new CheckboxWidgetAnnotationElement(
                                        parameters
                                      );
                                    }

                                    return new PushButtonWidgetAnnotationElement(
                                      parameters
                                    );

                                  case "Ch":
                                    return new ChoiceWidgetAnnotationElement(
                                      parameters
                                    );
                                }

                                return new WidgetAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .POPUP:
                                return new PopupAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .FREETEXT:
                                return new FreeTextAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .LINE:
                                return new LineAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .SQUARE:
                                return new SquareAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .CIRCLE:
                                return new CircleAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .POLYLINE:
                                return new PolylineAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .CARET:
                                return new CaretAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .INK:
                                return new InkAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .POLYGON:
                                return new PolygonAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .HIGHLIGHT:
                                return new HighlightAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .UNDERLINE:
                                return new UnderlineAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .SQUIGGLY:
                                return new SquigglyAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .STRIKEOUT:
                                return new StrikeOutAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .STAMP:
                                return new StampAnnotationElement(
                                  parameters
                                );

                              case _util
                                .AnnotationType
                                .FILEATTACHMENT:
                                return new FileAttachmentAnnotationElement(
                                  parameters
                                );

                              default:
                                return new AnnotationElement(
                                  parameters
                                );
                            }
                          },
                        },
                      ]
                    );

                    return AnnotationElementFactory;
                  })();

                var AnnotationElement =
                  /*#__PURE__*/ (function () {
                    function AnnotationElement(
                      parameters
                    ) {
                      var _ref =
                          arguments.length > 1 &&
                          arguments[1] !==
                            undefined
                            ? arguments[1]
                            : {},
                        _ref$isRenderable =
                          _ref.isRenderable,
                        isRenderable =
                          _ref$isRenderable ===
                          void 0
                            ? false
                            : _ref$isRenderable,
                        _ref$ignoreBorder =
                          _ref.ignoreBorder,
                        ignoreBorder =
                          _ref$ignoreBorder ===
                          void 0
                            ? false
                            : _ref$ignoreBorder,
                        _ref$createQuadrilate =
                          _ref.createQuadrilaterals,
                        createQuadrilaterals =
                          _ref$createQuadrilate ===
                          void 0
                            ? false
                            : _ref$createQuadrilate;

                      _classCallCheck(
                        this,
                        AnnotationElement
                      );

                      this.isRenderable =
                        isRenderable;
                      this.data = parameters.data;
                      this.layer =
                        parameters.layer;
                      this.page = parameters.page;
                      this.viewport =
                        parameters.viewport;
                      this.linkService =
                        parameters.linkService;
                      this.downloadManager =
                        parameters.downloadManager;
                      this.imageResourcesPath =
                        parameters.imageResourcesPath;
                      this.renderInteractiveForms =
                        parameters.renderInteractiveForms;
                      this.svgFactory =
                        parameters.svgFactory;
                      this.annotationStorage =
                        parameters.annotationStorage;
                      this.enableScripting =
                        parameters.enableScripting;
                      this.hasJSActions =
                        parameters.hasJSActions;
                      this._mouseState =
                        parameters.mouseState;

                      if (isRenderable) {
                        this.container =
                          this._createContainer(
                            ignoreBorder
                          );
                      }

                      if (createQuadrilaterals) {
                        this.quadrilaterals =
                          this._createQuadrilaterals(
                            ignoreBorder
                          );
                      }
                    }

                    _createClass(
                      AnnotationElement,
                      [
                        {
                          key: "_createContainer",
                          value:
                            function _createContainer() {
                              var ignoreBorder =
                                arguments.length >
                                  0 &&
                                arguments[0] !==
                                  undefined
                                  ? arguments[0]
                                  : false;
                              var data =
                                  this.data,
                                page = this.page,
                                viewport =
                                  this.viewport;
                              var container =
                                document.createElement(
                                  "section"
                                );
                              var width =
                                data.rect[2] -
                                data.rect[0];
                              var height =
                                data.rect[3] -
                                data.rect[1];
                              container.setAttribute(
                                "data-annotation-id",
                                data.id
                              );

                              var rect =
                                _util.Util.normalizeRect(
                                  [
                                    data.rect[0],
                                    page.view[3] -
                                      data
                                        .rect[1] +
                                      page
                                        .view[1],
                                    data.rect[2],
                                    page.view[3] -
                                      data
                                        .rect[3] +
                                      page
                                        .view[1],
                                  ]
                                );

                              container.style.transform =
                                "matrix(".concat(
                                  viewport.transform.join(
                                    ","
                                  ),
                                  ")"
                                );
                              container.style.transformOrigin =
                                ""
                                  .concat(
                                    -rect[0],
                                    "px "
                                  )
                                  .concat(
                                    -rect[1],
                                    "px"
                                  );

                              if (
                                !ignoreBorder &&
                                data.borderStyle
                                  .width > 0
                              ) {
                                container.style.borderWidth =
                                  "".concat(
                                    data
                                      .borderStyle
                                      .width,
                                    "px"
                                  );

                                if (
                                  data.borderStyle
                                    .style !==
                                  _util
                                    .AnnotationBorderStyleType
                                    .UNDERLINE
                                ) {
                                  width =
                                    width -
                                    2 *
                                      data
                                        .borderStyle
                                        .width;
                                  height =
                                    height -
                                    2 *
                                      data
                                        .borderStyle
                                        .width;
                                }

                                var horizontalRadius =
                                  data.borderStyle
                                    .horizontalCornerRadius;
                                var verticalRadius =
                                  data.borderStyle
                                    .verticalCornerRadius;

                                if (
                                  horizontalRadius >
                                    0 ||
                                  verticalRadius >
                                    0
                                ) {
                                  var radius = ""
                                    .concat(
                                      horizontalRadius,
                                      "px / "
                                    )
                                    .concat(
                                      verticalRadius,
                                      "px"
                                    );
                                  container.style.borderRadius =
                                    radius;
                                }

                                switch (
                                  data.borderStyle
                                    .style
                                ) {
                                  case _util
                                    .AnnotationBorderStyleType
                                    .SOLID:
                                    container.style.borderStyle =
                                      "solid";
                                    break;

                                  case _util
                                    .AnnotationBorderStyleType
                                    .DASHED:
                                    container.style.borderStyle =
                                      "dashed";
                                    break;

                                  case _util
                                    .AnnotationBorderStyleType
                                    .BEVELED:
                                    (0,
                                    _util.warn)(
                                      "Unimplemented border style: beveled"
                                    );
                                    break;

                                  case _util
                                    .AnnotationBorderStyleType
                                    .INSET:
                                    (0,
                                    _util.warn)(
                                      "Unimplemented border style: inset"
                                    );
                                    break;

                                  case _util
                                    .AnnotationBorderStyleType
                                    .UNDERLINE:
                                    container.style.borderBottomStyle =
                                      "solid";
                                    break;

                                  default:
                                    break;
                                }

                                if (data.color) {
                                  container.style.borderColor =
                                    _util.Util.makeHexColor(
                                      data
                                        .color[0] |
                                        0,
                                      data
                                        .color[1] |
                                        0,
                                      data
                                        .color[2] |
                                        0
                                    );
                                } else {
                                  container.style.borderWidth = 0;
                                }
                              }

                              container.style.left =
                                "".concat(
                                  rect[0],
                                  "px"
                                );
                              container.style.top =
                                "".concat(
                                  rect[1],
                                  "px"
                                );
                              container.style.width =
                                "".concat(
                                  width,
                                  "px"
                                );
                              container.style.height =
                                "".concat(
                                  height,
                                  "px"
                                );
                              return container;
                            },
                        },
                        {
                          key: "_createQuadrilaterals",
                          value:
                            function _createQuadrilaterals() {
                              var ignoreBorder =
                                arguments.length >
                                  0 &&
                                arguments[0] !==
                                  undefined
                                  ? arguments[0]
                                  : false;

                              if (
                                !this.data
                                  .quadPoints
                              ) {
                                return null;
                              }

                              var quadrilaterals =
                                [];
                              var savedRect =
                                this.data.rect;

                              var _iterator =
                                  _createForOfIteratorHelper(
                                    this.data
                                      .quadPoints
                                  ),
                                _step;

                              try {
                                for (
                                  _iterator.s();
                                  !(_step =
                                    _iterator.n())
                                    .done;

                                ) {
                                  var quadPoint =
                                    _step.value;
                                  this.data.rect =
                                    [
                                      quadPoint[2]
                                        .x,
                                      quadPoint[2]
                                        .y,
                                      quadPoint[1]
                                        .x,
                                      quadPoint[1]
                                        .y,
                                    ];
                                  quadrilaterals.push(
                                    this._createContainer(
                                      ignoreBorder
                                    )
                                  );
                                }
                              } catch (err) {
                                _iterator.e(err);
                              } finally {
                                _iterator.f();
                              }

                              this.data.rect =
                                savedRect;
                              return quadrilaterals;
                            },
                        },
                        {
                          key: "_createPopup",
                          value:
                            function _createPopup(
                              trigger,
                              data
                            ) {
                              var container =
                                this.container;

                              if (
                                this
                                  .quadrilaterals
                              ) {
                                trigger =
                                  trigger ||
                                  this
                                    .quadrilaterals;
                                container =
                                  this
                                    .quadrilaterals[0];
                              }

                              if (!trigger) {
                                trigger =
                                  document.createElement(
                                    "div"
                                  );
                                trigger.style.height =
                                  container.style.height;
                                trigger.style.width =
                                  container.style.width;
                                container.appendChild(
                                  trigger
                                );
                              }

                              var popupElement =
                                new PopupElement({
                                  container:
                                    container,
                                  trigger:
                                    trigger,
                                  color:
                                    data.color,
                                  title:
                                    data.title,
                                  modificationDate:
                                    data.modificationDate,
                                  contents:
                                    data.contents,
                                  hideWrapper: true,
                                });
                              var popup =
                                popupElement.render();
                              popup.style.left =
                                container.style.width;
                              container.appendChild(
                                popup
                              );
                            },
                        },
                        {
                          key: "_renderQuadrilaterals",
                          value:
                            function _renderQuadrilaterals(
                              className
                            ) {
                              this.quadrilaterals.forEach(
                                function (
                                  quadrilateral
                                ) {
                                  quadrilateral.className =
                                    className;
                                }
                              );
                              return this
                                .quadrilaterals;
                            },
                        },
                        {
                          key: "render",
                          value:
                            function render() {
                              (0,
                              _util.unreachable)(
                                "Abstract method `AnnotationElement.render` called"
                              );
                            },
                        },
                      ]
                    );

                    return AnnotationElement;
                  })();

                var LinkAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement
                  ) {
                    _inherits(
                      LinkAnnotationElement,
                      _AnnotationElement
                    );

                    var _super = _createSuper(
                      LinkAnnotationElement
                    );

                    function LinkAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        LinkAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data.url ||
                        parameters.data.dest ||
                        parameters.data.action ||
                        parameters.data
                          .isTooltipOnly ||
                        (parameters.data
                          .actions &&
                          (parameters.data.actions
                            .Action ||
                            parameters.data
                              .actions[
                              "Mouse Up"
                            ] ||
                            parameters.data
                              .actions[
                              "Mouse Down"
                            ]))
                      );
                      return _super.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          createQuadrilaterals: true,
                        }
                      );
                    }

                    _createClass(
                      LinkAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              var data =
                                  this.data,
                                linkService =
                                  this
                                    .linkService;
                              var link =
                                document.createElement(
                                  "a"
                                );

                              if (data.url) {
                                (0,
                                _display_utils.addLinkAttributes)(
                                  link,
                                  {
                                    url: data.url,
                                    target:
                                      data.newWindow
                                        ? _display_utils
                                            .LinkTarget
                                            .BLANK
                                        : linkService.externalLinkTarget,
                                    rel: linkService.externalLinkRel,
                                    enabled:
                                      linkService.externalLinkEnabled,
                                  }
                                );
                              } else if (
                                data.action
                              ) {
                                this._bindNamedAction(
                                  link,
                                  data.action
                                );
                              } else if (
                                data.dest
                              ) {
                                this._bindLink(
                                  link,
                                  data.dest
                                );
                              } else if (
                                data.actions &&
                                (data.actions
                                  .Action ||
                                  data.actions[
                                    "Mouse Up"
                                  ] ||
                                  data.actions[
                                    "Mouse Down"
                                  ]) &&
                                this
                                  .enableScripting &&
                                this.hasJSActions
                              ) {
                                this._bindJSAction(
                                  link,
                                  data
                                );
                              } else {
                                this._bindLink(
                                  link,
                                  ""
                                );
                              }

                              if (
                                this
                                  .quadrilaterals
                              ) {
                                return this._renderQuadrilaterals(
                                  "linkAnnotation"
                                ).map(function (
                                  quadrilateral,
                                  index
                                ) {
                                  var linkElement =
                                    index === 0
                                      ? link
                                      : link.cloneNode();
                                  quadrilateral.appendChild(
                                    linkElement
                                  );
                                  return quadrilateral;
                                });
                              }

                              this.container.className =
                                "linkAnnotation";
                              this.container.appendChild(
                                link
                              );
                              return this
                                .container;
                            },
                        },
                        {
                          key: "_bindLink",
                          value:
                            function _bindLink(
                              link,
                              destination
                            ) {
                              var _this = this;

                              link.href =
                                this.linkService.getDestinationHash(
                                  destination
                                );

                              link.onclick =
                                function () {
                                  if (
                                    destination
                                  ) {
                                    _this.linkService.goToDestination(
                                      destination
                                    );
                                  }

                                  return false;
                                };

                              if (
                                destination ||
                                destination === ""
                              ) {
                                link.className =
                                  "internalLink";
                              }
                            },
                        },
                        {
                          key: "_bindNamedAction",
                          value:
                            function _bindNamedAction(
                              link,
                              action
                            ) {
                              var _this2 = this;

                              link.href =
                                this.linkService.getAnchorUrl(
                                  ""
                                );

                              link.onclick =
                                function () {
                                  _this2.linkService.executeNamedAction(
                                    action
                                  );

                                  return false;
                                };

                              link.className =
                                "internalLink";
                            },
                        },
                        {
                          key: "_bindJSAction",
                          value:
                            function _bindJSAction(
                              link,
                              data
                            ) {
                              var _this3 = this;

                              link.href =
                                this.linkService.getAnchorUrl(
                                  ""
                                );
                              var map = new Map([
                                [
                                  "Action",
                                  "onclick",
                                ],
                                [
                                  "Mouse Up",
                                  "onmouseup",
                                ],
                                [
                                  "Mouse Down",
                                  "onmousedown",
                                ],
                              ]);

                              var _loop =
                                function _loop() {
                                  var name =
                                    _Object$keys[
                                      _i
                                    ];
                                  var jsName =
                                    map.get(name);

                                  if (!jsName) {
                                    return "continue";
                                  }

                                  link[jsName] =
                                    function () {
                                      var _this3$linkService$ev;

                                      (_this3$linkService$ev =
                                        _this3
                                          .linkService
                                          .eventBus) ===
                                        null ||
                                      _this3$linkService$ev ===
                                        void 0
                                        ? void 0
                                        : _this3$linkService$ev.dispatch(
                                            "dispatcheventinsandbox",
                                            {
                                              source:
                                                _this3,
                                              detail:
                                                {
                                                  id: data.id,
                                                  name: name,
                                                },
                                            }
                                          );
                                      return false;
                                    };
                                };

                              for (
                                var _i = 0,
                                  _Object$keys =
                                    Object.keys(
                                      data.actions
                                    );
                                _i <
                                _Object$keys.length;
                                _i++
                              ) {
                                var _ret =
                                  _loop();

                                if (
                                  _ret ===
                                  "continue"
                                )
                                  continue;
                              }

                              link.className =
                                "internalLink";
                            },
                        },
                      ]
                    );

                    return LinkAnnotationElement;
                  })(AnnotationElement);

                var TextAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement2
                  ) {
                    _inherits(
                      TextAnnotationElement,
                      _AnnotationElement2
                    );

                    var _super2 = _createSuper(
                      TextAnnotationElement
                    );

                    function TextAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        TextAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super2.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                        }
                      );
                    }

                    _createClass(
                      TextAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                "textAnnotation";
                              var image =
                                document.createElement(
                                  "img"
                                );
                              image.style.height =
                                this.container.style.height;
                              image.style.width =
                                this.container.style.width;
                              image.src =
                                this
                                  .imageResourcesPath +
                                "annotation-" +
                                this.data.name.toLowerCase() +
                                ".svg";
                              image.alt =
                                "[{{type}} Annotation]";
                              image.dataset.l10nId =
                                "text_annotation_type";
                              image.dataset.l10nArgs =
                                JSON.stringify({
                                  type: this.data
                                    .name,
                                });

                              if (
                                !this.data
                                  .hasPopup
                              ) {
                                this._createPopup(
                                  image,
                                  this.data
                                );
                              }

                              this.container.appendChild(
                                image
                              );
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return TextAnnotationElement;
                  })(AnnotationElement);

                var WidgetAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement3
                  ) {
                    _inherits(
                      WidgetAnnotationElement,
                      _AnnotationElement3
                    );

                    var _super3 = _createSuper(
                      WidgetAnnotationElement
                    );

                    function WidgetAnnotationElement() {
                      _classCallCheck(
                        this,
                        WidgetAnnotationElement
                      );

                      return _super3.apply(
                        this,
                        arguments
                      );
                    }

                    _createClass(
                      WidgetAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              if (
                                this.data
                                  .alternativeText
                              ) {
                                this.container.title =
                                  this.data.alternativeText;
                              }

                              return this
                                .container;
                            },
                        },
                        {
                          key: "_getKeyModifier",
                          value:
                            function _getKeyModifier(
                              event
                            ) {
                              return (
                                (navigator.platform.includes(
                                  "Win"
                                ) &&
                                  event.ctrlKey) ||
                                (navigator.platform.includes(
                                  "Mac"
                                ) &&
                                  event.metaKey)
                              );
                            },
                        },
                        {
                          key: "_setEventListener",
                          value:
                            function _setEventListener(
                              element,
                              baseName,
                              eventName,
                              valueGetter
                            ) {
                              var _this4 = this;

                              if (
                                baseName.includes(
                                  "mouse"
                                )
                              ) {
                                element.addEventListener(
                                  baseName,
                                  function (
                                    event
                                  ) {
                                    var _this4$linkService$ev;

                                    (_this4$linkService$ev =
                                      _this4
                                        .linkService
                                        .eventBus) ===
                                      null ||
                                    _this4$linkService$ev ===
                                      void 0
                                      ? void 0
                                      : _this4$linkService$ev.dispatch(
                                          "dispatcheventinsandbox",
                                          {
                                            source:
                                              _this4,
                                            detail:
                                              {
                                                id: _this4
                                                  .data
                                                  .id,
                                                name: eventName,
                                                value:
                                                  valueGetter(
                                                    event
                                                  ),
                                                shift:
                                                  event.shiftKey,
                                                modifier:
                                                  _this4._getKeyModifier(
                                                    event
                                                  ),
                                              },
                                          }
                                        );
                                  }
                                );
                              } else {
                                element.addEventListener(
                                  baseName,
                                  function (
                                    event
                                  ) {
                                    var _this4$linkService$ev2;

                                    (_this4$linkService$ev2 =
                                      _this4
                                        .linkService
                                        .eventBus) ===
                                      null ||
                                    _this4$linkService$ev2 ===
                                      void 0
                                      ? void 0
                                      : _this4$linkService$ev2.dispatch(
                                          "dispatcheventinsandbox",
                                          {
                                            source:
                                              _this4,
                                            detail:
                                              {
                                                id: _this4
                                                  .data
                                                  .id,
                                                name: eventName,
                                                value:
                                                  event
                                                    .target
                                                    .checked,
                                              },
                                          }
                                        );
                                  }
                                );
                              }
                            },
                        },
                        {
                          key: "_setEventListeners",
                          value:
                            function _setEventListeners(
                              element,
                              names,
                              getter
                            ) {
                              var _iterator2 =
                                  _createForOfIteratorHelper(
                                    names
                                  ),
                                _step2;

                              try {
                                for (
                                  _iterator2.s();
                                  !(_step2 =
                                    _iterator2.n())
                                    .done;

                                ) {
                                  var _this$data$actions;

                                  var _step2$value =
                                      _slicedToArray(
                                        _step2.value,
                                        2
                                      ),
                                    baseName =
                                      _step2$value[0],
                                    eventName =
                                      _step2$value[1];

                                  if (
                                    eventName ===
                                      "Action" ||
                                    ((_this$data$actions =
                                      this.data
                                        .actions) !==
                                      null &&
                                      _this$data$actions !==
                                        void 0 &&
                                      _this$data$actions[
                                        eventName
                                      ])
                                  ) {
                                    this._setEventListener(
                                      element,
                                      baseName,
                                      eventName,
                                      getter
                                    );
                                  }
                                }
                              } catch (err) {
                                _iterator2.e(err);
                              } finally {
                                _iterator2.f();
                              }
                            },
                        },
                      ]
                    );

                    return WidgetAnnotationElement;
                  })(AnnotationElement);

                var TextWidgetAnnotationElement =
                  /*#__PURE__*/ (function (
                    _WidgetAnnotationElem
                  ) {
                    _inherits(
                      TextWidgetAnnotationElement,
                      _WidgetAnnotationElem
                    );

                    var _super4 = _createSuper(
                      TextWidgetAnnotationElement
                    );

                    function TextWidgetAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        TextWidgetAnnotationElement
                      );

                      var isRenderable =
                        parameters.renderInteractiveForms ||
                        (!parameters.data
                          .hasAppearance &&
                          !!parameters.data
                            .fieldValue);
                      return _super4.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                        }
                      );
                    }

                    _createClass(
                      TextWidgetAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              var _this5 = this;

                              var storage =
                                this
                                  .annotationStorage;
                              var id =
                                this.data.id;
                              this.container.className =
                                "textWidgetAnnotation";
                              var element = null;

                              if (
                                this
                                  .renderInteractiveForms
                              ) {
                                var textContent =
                                  storage.getOrCreateValue(
                                    id,
                                    {
                                      value:
                                        this.data
                                          .fieldValue,
                                    }
                                  ).value;
                                var elementData =
                                  {
                                    userValue:
                                      null,
                                    formattedValue:
                                      null,
                                    beforeInputSelectionRange:
                                      null,
                                    beforeInputValue:
                                      null,
                                  };

                                if (
                                  this.data
                                    .multiLine
                                ) {
                                  element =
                                    document.createElement(
                                      "textarea"
                                    );
                                  element.textContent =
                                    textContent;
                                } else {
                                  element =
                                    document.createElement(
                                      "input"
                                    );
                                  element.type =
                                    "text";
                                  element.setAttribute(
                                    "value",
                                    textContent
                                  );
                                }

                                elementData.userValue =
                                  textContent;
                                element.setAttribute(
                                  "id",
                                  id
                                );
                                element.addEventListener(
                                  "input",
                                  function (
                                    event
                                  ) {
                                    storage.setValue(
                                      id,
                                      {
                                        value:
                                          event
                                            .target
                                            .value,
                                      }
                                    );
                                  }
                                );

                                var blurListener =
                                  function blurListener(
                                    event
                                  ) {
                                    if (
                                      elementData.formattedValue
                                    ) {
                                      event.target.value =
                                        elementData.formattedValue;
                                    }

                                    event.target.setSelectionRange(
                                      0,
                                      0
                                    );
                                    elementData.beforeInputSelectionRange =
                                      null;
                                  };

                                if (
                                  this
                                    .enableScripting &&
                                  this
                                    .hasJSActions
                                ) {
                                  var _this$data$actions2;

                                  element.addEventListener(
                                    "focus",
                                    function (
                                      event
                                    ) {
                                      if (
                                        elementData.userValue
                                      ) {
                                        event.target.value =
                                          elementData.userValue;
                                      }
                                    }
                                  );
                                  element.addEventListener(
                                    "updatefromsandbox",
                                    function (
                                      event
                                    ) {
                                      var detail =
                                        event.detail;
                                      var actions =
                                        {
                                          value:
                                            function value() {
                                              elementData.userValue =
                                                detail.value ||
                                                "";
                                              storage.setValue(
                                                id,
                                                {
                                                  value:
                                                    elementData.userValue.toString(),
                                                }
                                              );

                                              if (
                                                !elementData.formattedValue
                                              ) {
                                                event.target.value =
                                                  elementData.userValue;
                                              }
                                            },
                                          valueAsString:
                                            function valueAsString() {
                                              elementData.formattedValue =
                                                detail.valueAsString ||
                                                "";

                                              if (
                                                event.target !==
                                                document.activeElement
                                              ) {
                                                event.target.value =
                                                  elementData.formattedValue;
                                              }

                                              storage.setValue(
                                                id,
                                                {
                                                  formattedValue:
                                                    elementData.formattedValue,
                                                }
                                              );
                                            },
                                          focus:
                                            function focus() {
                                              setTimeout(
                                                function () {
                                                  return event.target.focus(
                                                    {
                                                      preventScroll: false,
                                                    }
                                                  );
                                                },
                                                0
                                              );
                                            },
                                          userName:
                                            function userName() {
                                              event.target.title =
                                                detail.userName;
                                            },
                                          hidden:
                                            function hidden() {
                                              event.target.style.visibility =
                                                detail.hidden
                                                  ? "hidden"
                                                  : "visible";
                                              storage.setValue(
                                                id,
                                                {
                                                  hidden:
                                                    detail.hidden,
                                                }
                                              );
                                            },
                                          editable:
                                            function editable() {
                                              event.target.disabled =
                                                !detail.editable;
                                            },
                                          selRange:
                                            function selRange() {
                                              var _detail$selRange =
                                                  _slicedToArray(
                                                    detail.selRange,
                                                    2
                                                  ),
                                                selStart =
                                                  _detail$selRange[0],
                                                selEnd =
                                                  _detail$selRange[1];

                                              if (
                                                selStart >=
                                                  0 &&
                                                selEnd <
                                                  event
                                                    .target
                                                    .value
                                                    .length
                                              ) {
                                                event.target.setSelectionRange(
                                                  selStart,
                                                  selEnd
                                                );
                                              }
                                            },
                                          strokeColor:
                                            function strokeColor() {
                                              var color =
                                                detail.strokeColor;
                                              event.target.style.color =
                                                _scripting_utils.ColorConverters[
                                                  "".concat(
                                                    color[0],
                                                    "_HTML"
                                                  )
                                                ](
                                                  color.slice(
                                                    1
                                                  )
                                                );
                                            },
                                        };
                                      Object.keys(
                                        detail
                                      )
                                        .filter(
                                          function (
                                            name
                                          ) {
                                            return (
                                              name in
                                              actions
                                            );
                                          }
                                        )
                                        .forEach(
                                          function (
                                            name
                                          ) {
                                            return actions[
                                              name
                                            ]();
                                          }
                                        );
                                    }
                                  );
                                  element.addEventListener(
                                    "keydown",
                                    function (
                                      event
                                    ) {
                                      var _this5$linkService$ev;

                                      elementData.beforeInputValue =
                                        event.target.value;
                                      var commitKey =
                                        -1;

                                      if (
                                        event.key ===
                                        "Escape"
                                      ) {
                                        commitKey = 0;
                                      } else if (
                                        event.key ===
                                        "Enter"
                                      ) {
                                        commitKey = 2;
                                      } else if (
                                        event.key ===
                                        "Tab"
                                      ) {
                                        commitKey = 3;
                                      }

                                      if (
                                        commitKey ===
                                        -1
                                      ) {
                                        return;
                                      }

                                      elementData.userValue =
                                        event.target.value;
                                      (_this5$linkService$ev =
                                        _this5
                                          .linkService
                                          .eventBus) ===
                                        null ||
                                      _this5$linkService$ev ===
                                        void 0
                                        ? void 0
                                        : _this5$linkService$ev.dispatch(
                                            "dispatcheventinsandbox",
                                            {
                                              source:
                                                _this5,
                                              detail:
                                                {
                                                  id: id,
                                                  name: "Keystroke",
                                                  value:
                                                    event
                                                      .target
                                                      .value,
                                                  willCommit: true,
                                                  commitKey:
                                                    commitKey,
                                                  selStart:
                                                    event
                                                      .target
                                                      .selectionStart,
                                                  selEnd:
                                                    event
                                                      .target
                                                      .selectionEnd,
                                                },
                                            }
                                          );
                                    }
                                  );
                                  var _blurListener =
                                    blurListener;
                                  blurListener =
                                    null;
                                  element.addEventListener(
                                    "blur",
                                    function (
                                      event
                                    ) {
                                      if (
                                        _this5
                                          ._mouseState
                                          .isDown
                                      ) {
                                        var _this5$linkService$ev2;

                                        elementData.userValue =
                                          event.target.value;
                                        (_this5$linkService$ev2 =
                                          _this5
                                            .linkService
                                            .eventBus) ===
                                          null ||
                                        _this5$linkService$ev2 ===
                                          void 0
                                          ? void 0
                                          : _this5$linkService$ev2.dispatch(
                                              "dispatcheventinsandbox",
                                              {
                                                source:
                                                  _this5,
                                                detail:
                                                  {
                                                    id: id,
                                                    name: "Keystroke",
                                                    value:
                                                      event
                                                        .target
                                                        .value,
                                                    willCommit: true,
                                                    commitKey: 1,
                                                    selStart:
                                                      event
                                                        .target
                                                        .selectionStart,
                                                    selEnd:
                                                      event
                                                        .target
                                                        .selectionEnd,
                                                  },
                                              }
                                            );
                                      }

                                      _blurListener(
                                        event
                                      );
                                    }
                                  );
                                  element.addEventListener(
                                    "mousedown",
                                    function (
                                      event
                                    ) {
                                      elementData.beforeInputValue =
                                        event.target.value;
                                      elementData.beforeInputSelectionRange =
                                        null;
                                    }
                                  );
                                  element.addEventListener(
                                    "keyup",
                                    function (
                                      event
                                    ) {
                                      if (
                                        event
                                          .target
                                          .selectionStart ===
                                        event
                                          .target
                                          .selectionEnd
                                      ) {
                                        elementData.beforeInputSelectionRange =
                                          null;
                                      }
                                    }
                                  );
                                  element.addEventListener(
                                    "select",
                                    function (
                                      event
                                    ) {
                                      elementData.beforeInputSelectionRange =
                                        [
                                          event
                                            .target
                                            .selectionStart,
                                          event
                                            .target
                                            .selectionEnd,
                                        ];
                                    }
                                  );

                                  if (
                                    (_this$data$actions2 =
                                      this.data
                                        .actions) !==
                                      null &&
                                    _this$data$actions2 !==
                                      void 0 &&
                                    _this$data$actions2.Keystroke
                                  ) {
                                    element.addEventListener(
                                      "input",
                                      function (
                                        event
                                      ) {
                                        var _this5$linkService$ev3;

                                        var selStart =
                                          -1;
                                        var selEnd =
                                          -1;

                                        if (
                                          elementData.beforeInputSelectionRange
                                        ) {
                                          var _elementData$beforeIn =
                                            _slicedToArray(
                                              elementData.beforeInputSelectionRange,
                                              2
                                            );

                                          selStart =
                                            _elementData$beforeIn[0];
                                          selEnd =
                                            _elementData$beforeIn[1];
                                        }

                                        (_this5$linkService$ev3 =
                                          _this5
                                            .linkService
                                            .eventBus) ===
                                          null ||
                                        _this5$linkService$ev3 ===
                                          void 0
                                          ? void 0
                                          : _this5$linkService$ev3.dispatch(
                                              "dispatcheventinsandbox",
                                              {
                                                source:
                                                  _this5,
                                                detail:
                                                  {
                                                    id: id,
                                                    name: "Keystroke",
                                                    value:
                                                      elementData.beforeInputValue,
                                                    change:
                                                      event.data,
                                                    willCommit: false,
                                                    selStart:
                                                      selStart,
                                                    selEnd:
                                                      selEnd,
                                                  },
                                              }
                                            );
                                      }
                                    );
                                  }

                                  this._setEventListeners(
                                    element,
                                    [
                                      [
                                        "focus",
                                        "Focus",
                                      ],
                                      [
                                        "blur",
                                        "Blur",
                                      ],
                                      [
                                        "mousedown",
                                        "Mouse Down",
                                      ],
                                      [
                                        "mouseenter",
                                        "Mouse Enter",
                                      ],
                                      [
                                        "mouseleave",
                                        "Mouse Exit",
                                      ],
                                      [
                                        "mouseup",
                                        "Mouse Up",
                                      ],
                                    ],
                                    function (
                                      event
                                    ) {
                                      return event
                                        .target
                                        .value;
                                    }
                                  );
                                }

                                if (
                                  blurListener
                                ) {
                                  element.addEventListener(
                                    "blur",
                                    blurListener
                                  );
                                }

                                element.disabled =
                                  this.data.readOnly;
                                element.name =
                                  this.data.fieldName;

                                if (
                                  this.data
                                    .maxLen !==
                                  null
                                ) {
                                  element.maxLength =
                                    this.data.maxLen;
                                }

                                if (
                                  this.data.comb
                                ) {
                                  var fieldWidth =
                                    this.data
                                      .rect[2] -
                                    this.data
                                      .rect[0];
                                  var combWidth =
                                    fieldWidth /
                                    this.data
                                      .maxLen;
                                  element.classList.add(
                                    "comb"
                                  );
                                  element.style.letterSpacing =
                                    "calc(".concat(
                                      combWidth,
                                      "px - 1ch)"
                                    );
                                }
                              } else {
                                element =
                                  document.createElement(
                                    "div"
                                  );
                                element.textContent =
                                  this.data.fieldValue;
                                element.style.verticalAlign =
                                  "middle";
                                element.style.display =
                                  "table-cell";
                              }

                              this._setTextStyle(
                                element
                              );

                              this.container.appendChild(
                                element
                              );
                              return this
                                .container;
                            },
                        },
                        {
                          key: "_setTextStyle",
                          value:
                            function _setTextStyle(
                              element
                            ) {
                              var TEXT_ALIGNMENT =
                                [
                                  "left",
                                  "center",
                                  "right",
                                ];
                              var _this$data$defaultApp =
                                  this.data
                                    .defaultAppearanceData,
                                fontSize =
                                  _this$data$defaultApp.fontSize,
                                fontColor =
                                  _this$data$defaultApp.fontColor;
                              var style =
                                element.style;

                              if (fontSize) {
                                style.fontSize =
                                  "".concat(
                                    fontSize,
                                    "px"
                                  );
                              }

                              style.color =
                                _util.Util.makeHexColor(
                                  fontColor[0],
                                  fontColor[1],
                                  fontColor[2]
                                );

                              if (
                                this.data
                                  .textAlignment !==
                                null
                              ) {
                                style.textAlign =
                                  TEXT_ALIGNMENT[
                                    this.data.textAlignment
                                  ];
                              }
                            },
                        },
                      ]
                    );

                    return TextWidgetAnnotationElement;
                  })(WidgetAnnotationElement);

                var CheckboxWidgetAnnotationElement =
                  /*#__PURE__*/ (function (
                    _WidgetAnnotationElem2
                  ) {
                    _inherits(
                      CheckboxWidgetAnnotationElement,
                      _WidgetAnnotationElem2
                    );

                    var _super5 = _createSuper(
                      CheckboxWidgetAnnotationElement
                    );

                    function CheckboxWidgetAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        CheckboxWidgetAnnotationElement
                      );

                      return _super5.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            parameters.renderInteractiveForms,
                        }
                      );
                    }

                    _createClass(
                      CheckboxWidgetAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              var storage =
                                this
                                  .annotationStorage;
                              var data =
                                this.data;
                              var id = data.id;
                              var value =
                                storage.getOrCreateValue(
                                  id,
                                  {
                                    value:
                                      data.fieldValue &&
                                      data.fieldValue !==
                                        "Off",
                                  }
                                ).value;
                              this.container.className =
                                "buttonWidgetAnnotation checkBox";
                              var element =
                                document.createElement(
                                  "input"
                                );
                              element.disabled =
                                data.readOnly;
                              element.type =
                                "checkbox";
                              element.name =
                                this.data.fieldName;

                              if (value) {
                                element.setAttribute(
                                  "checked",
                                  true
                                );
                              }

                              element.setAttribute(
                                "id",
                                id
                              );
                              element.addEventListener(
                                "change",
                                function (event) {
                                  var name =
                                    event.target
                                      .name;

                                  var _iterator3 =
                                      _createForOfIteratorHelper(
                                        document.getElementsByName(
                                          name
                                        )
                                      ),
                                    _step3;

                                  try {
                                    for (
                                      _iterator3.s();
                                      !(_step3 =
                                        _iterator3.n())
                                        .done;

                                    ) {
                                      var checkbox =
                                        _step3.value;

                                      if (
                                        checkbox !==
                                        event.target
                                      ) {
                                        checkbox.checked = false;
                                        storage.setValue(
                                          checkbox.parentNode.getAttribute(
                                            "data-annotation-id"
                                          ),
                                          {
                                            value: false,
                                          }
                                        );
                                      }
                                    }
                                  } catch (err) {
                                    _iterator3.e(
                                      err
                                    );
                                  } finally {
                                    _iterator3.f();
                                  }

                                  storage.setValue(
                                    id,
                                    {
                                      value:
                                        event
                                          .target
                                          .checked,
                                    }
                                  );
                                }
                              );

                              if (
                                this
                                  .enableScripting &&
                                this.hasJSActions
                              ) {
                                element.addEventListener(
                                  "updatefromsandbox",
                                  function (
                                    event
                                  ) {
                                    var detail =
                                      event.detail;
                                    var actions =
                                      {
                                        value:
                                          function value() {
                                            event.target.checked =
                                              detail.value !==
                                              "Off";
                                            storage.setValue(
                                              id,
                                              {
                                                value:
                                                  event
                                                    .target
                                                    .checked,
                                              }
                                            );
                                          },
                                        focus:
                                          function focus() {
                                            setTimeout(
                                              function () {
                                                return event.target.focus(
                                                  {
                                                    preventScroll: false,
                                                  }
                                                );
                                              },
                                              0
                                            );
                                          },
                                        hidden:
                                          function hidden() {
                                            event.target.style.visibility =
                                              detail.hidden
                                                ? "hidden"
                                                : "visible";
                                            storage.setValue(
                                              id,
                                              {
                                                hidden:
                                                  detail.hidden,
                                              }
                                            );
                                          },
                                        editable:
                                          function editable() {
                                            event.target.disabled =
                                              !detail.editable;
                                          },
                                      };
                                    Object.keys(
                                      detail
                                    )
                                      .filter(
                                        function (
                                          name
                                        ) {
                                          return (
                                            name in
                                            actions
                                          );
                                        }
                                      )
                                      .forEach(
                                        function (
                                          name
                                        ) {
                                          return actions[
                                            name
                                          ]();
                                        }
                                      );
                                  }
                                );

                                this._setEventListeners(
                                  element,
                                  [
                                    [
                                      "change",
                                      "Validate",
                                    ],
                                    [
                                      "change",
                                      "Action",
                                    ],
                                    [
                                      "focus",
                                      "Focus",
                                    ],
                                    [
                                      "blur",
                                      "Blur",
                                    ],
                                    [
                                      "mousedown",
                                      "Mouse Down",
                                    ],
                                    [
                                      "mouseenter",
                                      "Mouse Enter",
                                    ],
                                    [
                                      "mouseleave",
                                      "Mouse Exit",
                                    ],
                                    [
                                      "mouseup",
                                      "Mouse Up",
                                    ],
                                  ],
                                  function (
                                    event
                                  ) {
                                    return event
                                      .target
                                      .checked;
                                  }
                                );
                              }

                              this.container.appendChild(
                                element
                              );
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return CheckboxWidgetAnnotationElement;
                  })(WidgetAnnotationElement);

                var RadioButtonWidgetAnnotationElement =
                  /*#__PURE__*/ (function (
                    _WidgetAnnotationElem3
                  ) {
                    _inherits(
                      RadioButtonWidgetAnnotationElement,
                      _WidgetAnnotationElem3
                    );

                    var _super6 = _createSuper(
                      RadioButtonWidgetAnnotationElement
                    );

                    function RadioButtonWidgetAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        RadioButtonWidgetAnnotationElement
                      );

                      return _super6.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            parameters.renderInteractiveForms,
                        }
                      );
                    }

                    _createClass(
                      RadioButtonWidgetAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                "buttonWidgetAnnotation radioButton";
                              var storage =
                                this
                                  .annotationStorage;
                              var data =
                                this.data;
                              var id = data.id;
                              var value =
                                storage.getOrCreateValue(
                                  id,
                                  {
                                    value:
                                      data.fieldValue ===
                                      data.buttonValue,
                                  }
                                ).value;
                              var element =
                                document.createElement(
                                  "input"
                                );
                              element.disabled =
                                data.readOnly;
                              element.type =
                                "radio";
                              element.name =
                                data.fieldName;

                              if (value) {
                                element.setAttribute(
                                  "checked",
                                  true
                                );
                              }

                              element.setAttribute(
                                "pdfButtonValue",
                                data.buttonValue
                              );
                              element.setAttribute(
                                "id",
                                id
                              );
                              element.addEventListener(
                                "change",
                                function (event) {
                                  var target =
                                    event.target;

                                  var _iterator4 =
                                      _createForOfIteratorHelper(
                                        document.getElementsByName(
                                          target.name
                                        )
                                      ),
                                    _step4;

                                  try {
                                    for (
                                      _iterator4.s();
                                      !(_step4 =
                                        _iterator4.n())
                                        .done;

                                    ) {
                                      var radio =
                                        _step4.value;

                                      if (
                                        radio !==
                                        target
                                      ) {
                                        storage.setValue(
                                          radio.getAttribute(
                                            "id"
                                          ),
                                          {
                                            value: false,
                                          }
                                        );
                                      }
                                    }
                                  } catch (err) {
                                    _iterator4.e(
                                      err
                                    );
                                  } finally {
                                    _iterator4.f();
                                  }

                                  storage.setValue(
                                    id,
                                    {
                                      value:
                                        target.checked,
                                    }
                                  );
                                }
                              );

                              if (
                                this
                                  .enableScripting &&
                                this.hasJSActions
                              ) {
                                element.addEventListener(
                                  "updatefromsandbox",
                                  function (
                                    event
                                  ) {
                                    var detail =
                                      event.detail;
                                    var actions =
                                      {
                                        value:
                                          function value() {
                                            var fieldValue =
                                              detail.value;

                                            var _iterator5 =
                                                _createForOfIteratorHelper(
                                                  document.getElementsByName(
                                                    event
                                                      .target
                                                      .name
                                                  )
                                                ),
                                              _step5;

                                            try {
                                              for (
                                                _iterator5.s();
                                                !(_step5 =
                                                  _iterator5.n())
                                                  .done;

                                              ) {
                                                var radio =
                                                  _step5.value;
                                                var radioId =
                                                  radio.getAttribute(
                                                    "id"
                                                  );

                                                if (
                                                  fieldValue ===
                                                  radio.getAttribute(
                                                    "pdfButtonValue"
                                                  )
                                                ) {
                                                  radio.setAttribute(
                                                    "checked",
                                                    true
                                                  );
                                                  storage.setValue(
                                                    radioId,
                                                    {
                                                      value: true,
                                                    }
                                                  );
                                                } else {
                                                  storage.setValue(
                                                    radioId,
                                                    {
                                                      value: false,
                                                    }
                                                  );
                                                }
                                              }
                                            } catch (err) {
                                              _iterator5.e(
                                                err
                                              );
                                            } finally {
                                              _iterator5.f();
                                            }
                                          },
                                        focus:
                                          function focus() {
                                            setTimeout(
                                              function () {
                                                return event.target.focus(
                                                  {
                                                    preventScroll: false,
                                                  }
                                                );
                                              },
                                              0
                                            );
                                          },
                                        hidden:
                                          function hidden() {
                                            event.target.style.visibility =
                                              detail.hidden
                                                ? "hidden"
                                                : "visible";
                                            storage.setValue(
                                              id,
                                              {
                                                hidden:
                                                  detail.hidden,
                                              }
                                            );
                                          },
                                        editable:
                                          function editable() {
                                            event.target.disabled =
                                              !detail.editable;
                                          },
                                      };
                                    Object.keys(
                                      detail
                                    )
                                      .filter(
                                        function (
                                          name
                                        ) {
                                          return (
                                            name in
                                            actions
                                          );
                                        }
                                      )
                                      .forEach(
                                        function (
                                          name
                                        ) {
                                          return actions[
                                            name
                                          ]();
                                        }
                                      );
                                  }
                                );

                                this._setEventListeners(
                                  element,
                                  [
                                    [
                                      "change",
                                      "Validate",
                                    ],
                                    [
                                      "change",
                                      "Action",
                                    ],
                                    [
                                      "focus",
                                      "Focus",
                                    ],
                                    [
                                      "blur",
                                      "Blur",
                                    ],
                                    [
                                      "mousedown",
                                      "Mouse Down",
                                    ],
                                    [
                                      "mouseenter",
                                      "Mouse Enter",
                                    ],
                                    [
                                      "mouseleave",
                                      "Mouse Exit",
                                    ],
                                    [
                                      "mouseup",
                                      "Mouse Up",
                                    ],
                                  ],
                                  function (
                                    event
                                  ) {
                                    return event
                                      .target
                                      .checked;
                                  }
                                );
                              }

                              this.container.appendChild(
                                element
                              );
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return RadioButtonWidgetAnnotationElement;
                  })(WidgetAnnotationElement);

                var PushButtonWidgetAnnotationElement =
                  /*#__PURE__*/ (function (
                    _LinkAnnotationElemen
                  ) {
                    _inherits(
                      PushButtonWidgetAnnotationElement,
                      _LinkAnnotationElemen
                    );

                    var _super7 = _createSuper(
                      PushButtonWidgetAnnotationElement
                    );

                    function PushButtonWidgetAnnotationElement() {
                      _classCallCheck(
                        this,
                        PushButtonWidgetAnnotationElement
                      );

                      return _super7.apply(
                        this,
                        arguments
                      );
                    }

                    _createClass(
                      PushButtonWidgetAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              var container =
                                _get(
                                  _getPrototypeOf(
                                    PushButtonWidgetAnnotationElement.prototype
                                  ),
                                  "render",
                                  this
                                ).call(this);

                              container.className =
                                "buttonWidgetAnnotation pushButton";

                              if (
                                this.data
                                  .alternativeText
                              ) {
                                container.title =
                                  this.data.alternativeText;
                              }

                              return container;
                            },
                        },
                      ]
                    );

                    return PushButtonWidgetAnnotationElement;
                  })(LinkAnnotationElement);

                var ChoiceWidgetAnnotationElement =
                  /*#__PURE__*/ (function (
                    _WidgetAnnotationElem4
                  ) {
                    _inherits(
                      ChoiceWidgetAnnotationElement,
                      _WidgetAnnotationElem4
                    );

                    var _super8 = _createSuper(
                      ChoiceWidgetAnnotationElement
                    );

                    function ChoiceWidgetAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        ChoiceWidgetAnnotationElement
                      );

                      return _super8.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            parameters.renderInteractiveForms,
                        }
                      );
                    }

                    _createClass(
                      ChoiceWidgetAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              var _this6 = this;

                              this.container.className =
                                "choiceWidgetAnnotation";
                              var storage =
                                this
                                  .annotationStorage;
                              var id =
                                this.data.id;
                              storage.getOrCreateValue(
                                id,
                                {
                                  value:
                                    this.data
                                      .fieldValue
                                      .length > 0
                                      ? this.data
                                          .fieldValue[0]
                                      : undefined,
                                }
                              );
                              var selectElement =
                                document.createElement(
                                  "select"
                                );
                              selectElement.disabled =
                                this.data.readOnly;
                              selectElement.name =
                                this.data.fieldName;
                              selectElement.setAttribute(
                                "id",
                                id
                              );

                              if (
                                !this.data.combo
                              ) {
                                selectElement.size =
                                  this.data.options.length;

                                if (
                                  this.data
                                    .multiSelect
                                ) {
                                  selectElement.multiple = true;
                                }
                              }

                              var _iterator6 =
                                  _createForOfIteratorHelper(
                                    this.data
                                      .options
                                  ),
                                _step6;

                              try {
                                for (
                                  _iterator6.s();
                                  !(_step6 =
                                    _iterator6.n())
                                    .done;

                                ) {
                                  var option =
                                    _step6.value;
                                  var optionElement =
                                    document.createElement(
                                      "option"
                                    );
                                  optionElement.textContent =
                                    option.displayValue;
                                  optionElement.value =
                                    option.exportValue;

                                  if (
                                    this.data.fieldValue.includes(
                                      option.exportValue
                                    )
                                  ) {
                                    optionElement.setAttribute(
                                      "selected",
                                      true
                                    );
                                  }

                                  selectElement.appendChild(
                                    optionElement
                                  );
                                }
                              } catch (err) {
                                _iterator6.e(err);
                              } finally {
                                _iterator6.f();
                              }

                              var getValue =
                                function getValue(
                                  event,
                                  isExport
                                ) {
                                  var name =
                                    isExport
                                      ? "value"
                                      : "textContent";
                                  var options =
                                    event.target
                                      .options;

                                  if (
                                    !event.target
                                      .multiple
                                  ) {
                                    return options.selectedIndex ===
                                      -1
                                      ? null
                                      : options[
                                          options
                                            .selectedIndex
                                        ][name];
                                  }

                                  return Array.prototype.filter
                                    .call(
                                      options,
                                      function (
                                        option
                                      ) {
                                        return option.selected;
                                      }
                                    )
                                    .map(
                                      function (
                                        option
                                      ) {
                                        return option[
                                          name
                                        ];
                                      }
                                    );
                                };

                              var getItems =
                                function getItems(
                                  event
                                ) {
                                  var options =
                                    event.target
                                      .options;
                                  return Array.prototype.map.call(
                                    options,
                                    function (
                                      option
                                    ) {
                                      return {
                                        displayValue:
                                          option.textContent,
                                        exportValue:
                                          option.value,
                                      };
                                    }
                                  );
                                };

                              if (
                                this
                                  .enableScripting &&
                                this.hasJSActions
                              ) {
                                selectElement.addEventListener(
                                  "updatefromsandbox",
                                  function (
                                    event
                                  ) {
                                    var detail =
                                      event.detail;
                                    var actions =
                                      {
                                        value:
                                          function value() {
                                            var options =
                                              selectElement.options;
                                            var value =
                                              detail.value;
                                            var values =
                                              new Set(
                                                Array.isArray(
                                                  value
                                                )
                                                  ? value
                                                  : [
                                                      value,
                                                    ]
                                              );
                                            Array.prototype.forEach.call(
                                              options,
                                              function (
                                                option
                                              ) {
                                                option.selected =
                                                  values.has(
                                                    option.value
                                                  );
                                              }
                                            );
                                            storage.setValue(
                                              id,
                                              {
                                                value:
                                                  getValue(
                                                    event,
                                                    true
                                                  ),
                                              }
                                            );
                                          },
                                        multipleSelection:
                                          function multipleSelection() {
                                            selectElement.multiple = true;
                                          },
                                        remove:
                                          function remove() {
                                            var options =
                                              selectElement.options;
                                            var index =
                                              detail.remove;
                                            options[
                                              index
                                            ].selected = false;
                                            selectElement.remove(
                                              index
                                            );

                                            if (
                                              options.length >
                                              0
                                            ) {
                                              var i =
                                                Array.prototype.findIndex.call(
                                                  options,
                                                  function (
                                                    option
                                                  ) {
                                                    return option.selected;
                                                  }
                                                );

                                              if (
                                                i ===
                                                -1
                                              ) {
                                                options[0].selected = true;
                                              }
                                            }

                                            storage.setValue(
                                              id,
                                              {
                                                value:
                                                  getValue(
                                                    event,
                                                    true
                                                  ),
                                                items:
                                                  getItems(
                                                    event
                                                  ),
                                              }
                                            );
                                          },
                                        clear:
                                          function clear() {
                                            while (
                                              selectElement.length !==
                                              0
                                            ) {
                                              selectElement.remove(
                                                0
                                              );
                                            }

                                            storage.setValue(
                                              id,
                                              {
                                                value:
                                                  null,
                                                items:
                                                  [],
                                              }
                                            );
                                          },
                                        insert:
                                          function insert() {
                                            var _detail$insert =
                                                detail.insert,
                                              index =
                                                _detail$insert.index,
                                              displayValue =
                                                _detail$insert.displayValue,
                                              exportValue =
                                                _detail$insert.exportValue;
                                            var optionElement =
                                              document.createElement(
                                                "option"
                                              );
                                            optionElement.textContent =
                                              displayValue;
                                            optionElement.value =
                                              exportValue;
                                            selectElement.insertBefore(
                                              optionElement,
                                              selectElement
                                                .children[
                                                index
                                              ]
                                            );
                                            storage.setValue(
                                              id,
                                              {
                                                value:
                                                  getValue(
                                                    event,
                                                    true
                                                  ),
                                                items:
                                                  getItems(
                                                    event
                                                  ),
                                              }
                                            );
                                          },
                                        items:
                                          function items() {
                                            var items =
                                              detail.items;

                                            while (
                                              selectElement.length !==
                                              0
                                            ) {
                                              selectElement.remove(
                                                0
                                              );
                                            }

                                            var _iterator7 =
                                                _createForOfIteratorHelper(
                                                  items
                                                ),
                                              _step7;

                                            try {
                                              for (
                                                _iterator7.s();
                                                !(_step7 =
                                                  _iterator7.n())
                                                  .done;

                                              ) {
                                                var item =
                                                  _step7.value;
                                                var displayValue =
                                                    item.displayValue,
                                                  exportValue =
                                                    item.exportValue;
                                                var optionElement =
                                                  document.createElement(
                                                    "option"
                                                  );
                                                optionElement.textContent =
                                                  displayValue;
                                                optionElement.value =
                                                  exportValue;
                                                selectElement.appendChild(
                                                  optionElement
                                                );
                                              }
                                            } catch (err) {
                                              _iterator7.e(
                                                err
                                              );
                                            } finally {
                                              _iterator7.f();
                                            }

                                            if (
                                              selectElement
                                                .options
                                                .length >
                                              0
                                            ) {
                                              selectElement.options[0].selected = true;
                                            }

                                            storage.setValue(
                                              id,
                                              {
                                                value:
                                                  getValue(
                                                    event,
                                                    true
                                                  ),
                                                items:
                                                  getItems(
                                                    event
                                                  ),
                                              }
                                            );
                                          },
                                        indices:
                                          function indices() {
                                            var indices =
                                              new Set(
                                                detail.indices
                                              );
                                            var options =
                                              event
                                                .target
                                                .options;
                                            Array.prototype.forEach.call(
                                              options,
                                              function (
                                                option,
                                                i
                                              ) {
                                                option.selected =
                                                  indices.has(
                                                    i
                                                  );
                                              }
                                            );
                                            storage.setValue(
                                              id,
                                              {
                                                value:
                                                  getValue(
                                                    event,
                                                    true
                                                  ),
                                              }
                                            );
                                          },
                                        focus:
                                          function focus() {
                                            setTimeout(
                                              function () {
                                                return event.target.focus(
                                                  {
                                                    preventScroll: false,
                                                  }
                                                );
                                              },
                                              0
                                            );
                                          },
                                        hidden:
                                          function hidden() {
                                            event.target.style.visibility =
                                              detail.hidden
                                                ? "hidden"
                                                : "visible";
                                            storage.setValue(
                                              id,
                                              {
                                                hidden:
                                                  detail.hidden,
                                              }
                                            );
                                          },
                                        editable:
                                          function editable() {
                                            event.target.disabled =
                                              !detail.editable;
                                          },
                                      };
                                    Object.keys(
                                      detail
                                    )
                                      .filter(
                                        function (
                                          name
                                        ) {
                                          return (
                                            name in
                                            actions
                                          );
                                        }
                                      )
                                      .forEach(
                                        function (
                                          name
                                        ) {
                                          return actions[
                                            name
                                          ]();
                                        }
                                      );
                                  }
                                );
                                selectElement.addEventListener(
                                  "input",
                                  function (
                                    event
                                  ) {
                                    var _this6$linkService$ev;

                                    var exportValue =
                                      getValue(
                                        event,
                                        true
                                      );
                                    var value =
                                      getValue(
                                        event,
                                        false
                                      );
                                    storage.setValue(
                                      id,
                                      {
                                        value:
                                          exportValue,
                                      }
                                    );
                                    (_this6$linkService$ev =
                                      _this6
                                        .linkService
                                        .eventBus) ===
                                      null ||
                                    _this6$linkService$ev ===
                                      void 0
                                      ? void 0
                                      : _this6$linkService$ev.dispatch(
                                          "dispatcheventinsandbox",
                                          {
                                            source:
                                              _this6,
                                            detail:
                                              {
                                                id: id,
                                                name: "Keystroke",
                                                value:
                                                  value,
                                                changeEx:
                                                  exportValue,
                                                willCommit: true,
                                                commitKey: 1,
                                                keyDown: false,
                                              },
                                          }
                                        );
                                  }
                                );

                                this._setEventListeners(
                                  selectElement,
                                  [
                                    [
                                      "focus",
                                      "Focus",
                                    ],
                                    [
                                      "blur",
                                      "Blur",
                                    ],
                                    [
                                      "mousedown",
                                      "Mouse Down",
                                    ],
                                    [
                                      "mouseenter",
                                      "Mouse Enter",
                                    ],
                                    [
                                      "mouseleave",
                                      "Mouse Exit",
                                    ],
                                    [
                                      "mouseup",
                                      "Mouse Up",
                                    ],
                                    [
                                      "input",
                                      "Action",
                                    ],
                                  ],
                                  function (
                                    event
                                  ) {
                                    return event
                                      .target
                                      .checked;
                                  }
                                );
                              } else {
                                selectElement.addEventListener(
                                  "input",
                                  function (
                                    event
                                  ) {
                                    storage.setValue(
                                      id,
                                      {
                                        value:
                                          getValue(
                                            event
                                          ),
                                      }
                                    );
                                  }
                                );
                              }

                              this.container.appendChild(
                                selectElement
                              );
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return ChoiceWidgetAnnotationElement;
                  })(WidgetAnnotationElement);

                var PopupAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement4
                  ) {
                    _inherits(
                      PopupAnnotationElement,
                      _AnnotationElement4
                    );

                    var _super9 = _createSuper(
                      PopupAnnotationElement
                    );

                    function PopupAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        PopupAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super9.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                        }
                      );
                    }

                    _createClass(
                      PopupAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              var IGNORE_TYPES = [
                                "Line",
                                "Square",
                                "Circle",
                                "PolyLine",
                                "Polygon",
                                "Ink",
                              ];
                              this.container.className =
                                "popupAnnotation";

                              if (
                                IGNORE_TYPES.includes(
                                  this.data
                                    .parentType
                                )
                              ) {
                                return this
                                  .container;
                              }

                              var selector =
                                '[data-annotation-id="'.concat(
                                  this.data
                                    .parentId,
                                  '"]'
                                );
                              var parentElements =
                                this.layer.querySelectorAll(
                                  selector
                                );

                              if (
                                parentElements.length ===
                                0
                              ) {
                                return this
                                  .container;
                              }

                              var popup =
                                new PopupElement({
                                  container:
                                    this
                                      .container,
                                  trigger:
                                    Array.from(
                                      parentElements
                                    ),
                                  color:
                                    this.data
                                      .color,
                                  title:
                                    this.data
                                      .title,
                                  modificationDate:
                                    this.data
                                      .modificationDate,
                                  contents:
                                    this.data
                                      .contents,
                                });
                              var page =
                                this.page;

                              var rect =
                                _util.Util.normalizeRect(
                                  [
                                    this.data
                                      .parentRect[0],
                                    page.view[3] -
                                      this.data
                                        .parentRect[1] +
                                      page
                                        .view[1],
                                    this.data
                                      .parentRect[2],
                                    page.view[3] -
                                      this.data
                                        .parentRect[3] +
                                      page
                                        .view[1],
                                  ]
                                );

                              var popupLeft =
                                rect[0] +
                                this.data
                                  .parentRect[2] -
                                this.data
                                  .parentRect[0];
                              var popupTop =
                                rect[1];
                              this.container.style.transformOrigin =
                                ""
                                  .concat(
                                    -popupLeft,
                                    "px "
                                  )
                                  .concat(
                                    -popupTop,
                                    "px"
                                  );
                              this.container.style.left =
                                "".concat(
                                  popupLeft,
                                  "px"
                                );
                              this.container.style.top =
                                "".concat(
                                  popupTop,
                                  "px"
                                );
                              this.container.appendChild(
                                popup.render()
                              );
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return PopupAnnotationElement;
                  })(AnnotationElement);

                var PopupElement =
                  /*#__PURE__*/ (function () {
                    function PopupElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        PopupElement
                      );

                      this.container =
                        parameters.container;
                      this.trigger =
                        parameters.trigger;
                      this.color =
                        parameters.color;
                      this.title =
                        parameters.title;
                      this.modificationDate =
                        parameters.modificationDate;
                      this.contents =
                        parameters.contents;
                      this.hideWrapper =
                        parameters.hideWrapper ||
                        false;
                      this.pinned = false;
                    }

                    _createClass(PopupElement, [
                      {
                        key: "render",
                        value: function render() {
                          var _this7 = this;

                          var BACKGROUND_ENLIGHT = 0.7;
                          var wrapper =
                            document.createElement(
                              "div"
                            );
                          wrapper.className =
                            "popupWrapper";
                          this.hideElement = this
                            .hideWrapper
                            ? wrapper
                            : this.container;
                          this.hideElement.hidden = true;
                          var popup =
                            document.createElement(
                              "div"
                            );
                          popup.className =
                            "popup";
                          var color = this.color;

                          if (color) {
                            var r =
                              BACKGROUND_ENLIGHT *
                                (255 - color[0]) +
                              color[0];
                            var g =
                              BACKGROUND_ENLIGHT *
                                (255 - color[1]) +
                              color[1];
                            var b =
                              BACKGROUND_ENLIGHT *
                                (255 - color[2]) +
                              color[2];
                            popup.style.backgroundColor =
                              _util.Util.makeHexColor(
                                r | 0,
                                g | 0,
                                b | 0
                              );
                          }

                          var title =
                            document.createElement(
                              "h1"
                            );
                          title.textContent =
                            this.title;
                          popup.appendChild(
                            title
                          );

                          var dateObject =
                            _display_utils.PDFDateString.toDateObject(
                              this
                                .modificationDate
                            );

                          if (dateObject) {
                            var modificationDate =
                              document.createElement(
                                "span"
                              );
                            modificationDate.textContent =
                              "{{date}}, {{time}}";
                            modificationDate.dataset.l10nId =
                              "annotation_date_string";
                            modificationDate.dataset.l10nArgs =
                              JSON.stringify({
                                date: dateObject.toLocaleDateString(),
                                time: dateObject.toLocaleTimeString(),
                              });
                            popup.appendChild(
                              modificationDate
                            );
                          }

                          var contents =
                            this._formatContents(
                              this.contents
                            );

                          popup.appendChild(
                            contents
                          );

                          if (
                            !Array.isArray(
                              this.trigger
                            )
                          ) {
                            this.trigger = [
                              this.trigger,
                            ];
                          }

                          this.trigger.forEach(
                            function (element) {
                              element.addEventListener(
                                "click",
                                _this7._toggle.bind(
                                  _this7
                                )
                              );
                              element.addEventListener(
                                "mouseover",
                                _this7._show.bind(
                                  _this7,
                                  false
                                )
                              );
                              element.addEventListener(
                                "mouseout",
                                _this7._hide.bind(
                                  _this7,
                                  false
                                )
                              );
                            }
                          );
                          popup.addEventListener(
                            "click",
                            this._hide.bind(
                              this,
                              true
                            )
                          );
                          wrapper.appendChild(
                            popup
                          );
                          return wrapper;
                        },
                      },
                      {
                        key: "_formatContents",
                        value:
                          function _formatContents(
                            contents
                          ) {
                            var p =
                              document.createElement(
                                "p"
                              );
                            var lines =
                              contents.split(
                                /(?:\r\n?|\n)/
                              );

                            for (
                              var i = 0,
                                ii = lines.length;
                              i < ii;
                              ++i
                            ) {
                              var line = lines[i];
                              p.appendChild(
                                document.createTextNode(
                                  line
                                )
                              );

                              if (i < ii - 1) {
                                p.appendChild(
                                  document.createElement(
                                    "br"
                                  )
                                );
                              }
                            }

                            return p;
                          },
                      },
                      {
                        key: "_toggle",
                        value:
                          function _toggle() {
                            if (this.pinned) {
                              this._hide(true);
                            } else {
                              this._show(true);
                            }
                          },
                      },
                      {
                        key: "_show",
                        value: function _show() {
                          var pin =
                            arguments.length >
                              0 &&
                            arguments[0] !==
                              undefined
                              ? arguments[0]
                              : false;

                          if (pin) {
                            this.pinned = true;
                          }

                          if (
                            this.hideElement
                              .hidden
                          ) {
                            this.hideElement.hidden = false;
                            this.container.style.zIndex += 1;
                          }
                        },
                      },
                      {
                        key: "_hide",
                        value: function _hide() {
                          var unpin =
                            arguments.length >
                              0 &&
                            arguments[0] !==
                              undefined
                              ? arguments[0]
                              : true;

                          if (unpin) {
                            this.pinned = false;
                          }

                          if (
                            !this.hideElement
                              .hidden &&
                            !this.pinned
                          ) {
                            this.hideElement.hidden = true;
                            this.container.style.zIndex -= 1;
                          }
                        },
                      },
                    ]);

                    return PopupElement;
                  })();

                var FreeTextAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement5
                  ) {
                    _inherits(
                      FreeTextAnnotationElement,
                      _AnnotationElement5
                    );

                    var _super10 = _createSuper(
                      FreeTextAnnotationElement
                    );

                    function FreeTextAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        FreeTextAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super10.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                        }
                      );
                    }

                    _createClass(
                      FreeTextAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                "freeTextAnnotation";

                              if (
                                !this.data
                                  .hasPopup
                              ) {
                                this._createPopup(
                                  null,
                                  this.data
                                );
                              }

                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return FreeTextAnnotationElement;
                  })(AnnotationElement);

                var LineAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement6
                  ) {
                    _inherits(
                      LineAnnotationElement,
                      _AnnotationElement6
                    );

                    var _super11 = _createSuper(
                      LineAnnotationElement
                    );

                    function LineAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        LineAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super11.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                        }
                      );
                    }

                    _createClass(
                      LineAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                "lineAnnotation";
                              var data =
                                this.data;
                              var width =
                                data.rect[2] -
                                data.rect[0];
                              var height =
                                data.rect[3] -
                                data.rect[1];
                              var svg =
                                this.svgFactory.create(
                                  width,
                                  height
                                );
                              var line =
                                this.svgFactory.createElement(
                                  "svg:line"
                                );
                              line.setAttribute(
                                "x1",
                                data.rect[2] -
                                  data
                                    .lineCoordinates[0]
                              );
                              line.setAttribute(
                                "y1",
                                data.rect[3] -
                                  data
                                    .lineCoordinates[1]
                              );
                              line.setAttribute(
                                "x2",
                                data.rect[2] -
                                  data
                                    .lineCoordinates[2]
                              );
                              line.setAttribute(
                                "y2",
                                data.rect[3] -
                                  data
                                    .lineCoordinates[3]
                              );
                              line.setAttribute(
                                "stroke-width",
                                data.borderStyle
                                  .width || 1
                              );
                              line.setAttribute(
                                "stroke",
                                "transparent"
                              );
                              svg.appendChild(
                                line
                              );
                              this.container.append(
                                svg
                              );

                              this._createPopup(
                                line,
                                data
                              );

                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return LineAnnotationElement;
                  })(AnnotationElement);

                var SquareAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement7
                  ) {
                    _inherits(
                      SquareAnnotationElement,
                      _AnnotationElement7
                    );

                    var _super12 = _createSuper(
                      SquareAnnotationElement
                    );

                    function SquareAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        SquareAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super12.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                        }
                      );
                    }

                    _createClass(
                      SquareAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                "squareAnnotation";
                              var data =
                                this.data;
                              var width =
                                data.rect[2] -
                                data.rect[0];
                              var height =
                                data.rect[3] -
                                data.rect[1];
                              var svg =
                                this.svgFactory.create(
                                  width,
                                  height
                                );
                              var borderWidth =
                                data.borderStyle
                                  .width;
                              var square =
                                this.svgFactory.createElement(
                                  "svg:rect"
                                );
                              square.setAttribute(
                                "x",
                                borderWidth / 2
                              );
                              square.setAttribute(
                                "y",
                                borderWidth / 2
                              );
                              square.setAttribute(
                                "width",
                                width -
                                  borderWidth
                              );
                              square.setAttribute(
                                "height",
                                height -
                                  borderWidth
                              );
                              square.setAttribute(
                                "stroke-width",
                                borderWidth || 1
                              );
                              square.setAttribute(
                                "stroke",
                                "transparent"
                              );
                              square.setAttribute(
                                "fill",
                                "none"
                              );
                              svg.appendChild(
                                square
                              );
                              this.container.append(
                                svg
                              );

                              this._createPopup(
                                square,
                                data
                              );

                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return SquareAnnotationElement;
                  })(AnnotationElement);

                var CircleAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement8
                  ) {
                    _inherits(
                      CircleAnnotationElement,
                      _AnnotationElement8
                    );

                    var _super13 = _createSuper(
                      CircleAnnotationElement
                    );

                    function CircleAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        CircleAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super13.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                        }
                      );
                    }

                    _createClass(
                      CircleAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                "circleAnnotation";
                              var data =
                                this.data;
                              var width =
                                data.rect[2] -
                                data.rect[0];
                              var height =
                                data.rect[3] -
                                data.rect[1];
                              var svg =
                                this.svgFactory.create(
                                  width,
                                  height
                                );
                              var borderWidth =
                                data.borderStyle
                                  .width;
                              var circle =
                                this.svgFactory.createElement(
                                  "svg:ellipse"
                                );
                              circle.setAttribute(
                                "cx",
                                width / 2
                              );
                              circle.setAttribute(
                                "cy",
                                height / 2
                              );
                              circle.setAttribute(
                                "rx",
                                width / 2 -
                                  borderWidth / 2
                              );
                              circle.setAttribute(
                                "ry",
                                height / 2 -
                                  borderWidth / 2
                              );
                              circle.setAttribute(
                                "stroke-width",
                                borderWidth || 1
                              );
                              circle.setAttribute(
                                "stroke",
                                "transparent"
                              );
                              circle.setAttribute(
                                "fill",
                                "none"
                              );
                              svg.appendChild(
                                circle
                              );
                              this.container.append(
                                svg
                              );

                              this._createPopup(
                                circle,
                                data
                              );

                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return CircleAnnotationElement;
                  })(AnnotationElement);

                var PolylineAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement9
                  ) {
                    _inherits(
                      PolylineAnnotationElement,
                      _AnnotationElement9
                    );

                    var _super14 = _createSuper(
                      PolylineAnnotationElement
                    );

                    function PolylineAnnotationElement(
                      parameters
                    ) {
                      var _this8;

                      _classCallCheck(
                        this,
                        PolylineAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      _this8 = _super14.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                        }
                      );
                      _this8.containerClassName =
                        "polylineAnnotation";
                      _this8.svgElementName =
                        "svg:polyline";
                      return _this8;
                    }

                    _createClass(
                      PolylineAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                this.containerClassName;
                              var data =
                                this.data;
                              var width =
                                data.rect[2] -
                                data.rect[0];
                              var height =
                                data.rect[3] -
                                data.rect[1];
                              var svg =
                                this.svgFactory.create(
                                  width,
                                  height
                                );
                              var points = [];

                              var _iterator8 =
                                  _createForOfIteratorHelper(
                                    data.vertices
                                  ),
                                _step8;

                              try {
                                for (
                                  _iterator8.s();
                                  !(_step8 =
                                    _iterator8.n())
                                    .done;

                                ) {
                                  var coordinate =
                                    _step8.value;
                                  var x =
                                    coordinate.x -
                                    data.rect[0];
                                  var y =
                                    data.rect[3] -
                                    coordinate.y;
                                  points.push(
                                    x + "," + y
                                  );
                                }
                              } catch (err) {
                                _iterator8.e(err);
                              } finally {
                                _iterator8.f();
                              }

                              points =
                                points.join(" ");
                              var polyline =
                                this.svgFactory.createElement(
                                  this
                                    .svgElementName
                                );
                              polyline.setAttribute(
                                "points",
                                points
                              );
                              polyline.setAttribute(
                                "stroke-width",
                                data.borderStyle
                                  .width || 1
                              );
                              polyline.setAttribute(
                                "stroke",
                                "transparent"
                              );
                              polyline.setAttribute(
                                "fill",
                                "none"
                              );
                              svg.appendChild(
                                polyline
                              );
                              this.container.append(
                                svg
                              );

                              this._createPopup(
                                polyline,
                                data
                              );

                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return PolylineAnnotationElement;
                  })(AnnotationElement);

                var PolygonAnnotationElement =
                  /*#__PURE__*/ (function (
                    _PolylineAnnotationEl
                  ) {
                    _inherits(
                      PolygonAnnotationElement,
                      _PolylineAnnotationEl
                    );

                    var _super15 = _createSuper(
                      PolygonAnnotationElement
                    );

                    function PolygonAnnotationElement(
                      parameters
                    ) {
                      var _this9;

                      _classCallCheck(
                        this,
                        PolygonAnnotationElement
                      );

                      _this9 = _super15.call(
                        this,
                        parameters
                      );
                      _this9.containerClassName =
                        "polygonAnnotation";
                      _this9.svgElementName =
                        "svg:polygon";
                      return _this9;
                    }

                    return PolygonAnnotationElement;
                  })(PolylineAnnotationElement);

                var CaretAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement10
                  ) {
                    _inherits(
                      CaretAnnotationElement,
                      _AnnotationElement10
                    );

                    var _super16 = _createSuper(
                      CaretAnnotationElement
                    );

                    function CaretAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        CaretAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super16.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                        }
                      );
                    }

                    _createClass(
                      CaretAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                "caretAnnotation";

                              if (
                                !this.data
                                  .hasPopup
                              ) {
                                this._createPopup(
                                  null,
                                  this.data
                                );
                              }

                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return CaretAnnotationElement;
                  })(AnnotationElement);

                var InkAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement11
                  ) {
                    _inherits(
                      InkAnnotationElement,
                      _AnnotationElement11
                    );

                    var _super17 = _createSuper(
                      InkAnnotationElement
                    );

                    function InkAnnotationElement(
                      parameters
                    ) {
                      var _this10;

                      _classCallCheck(
                        this,
                        InkAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      _this10 = _super17.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                        }
                      );
                      _this10.containerClassName =
                        "inkAnnotation";
                      _this10.svgElementName =
                        "svg:polyline";
                      return _this10;
                    }

                    _createClass(
                      InkAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                this.containerClassName;
                              var data =
                                this.data;
                              var width =
                                data.rect[2] -
                                data.rect[0];
                              var height =
                                data.rect[3] -
                                data.rect[1];
                              var svg =
                                this.svgFactory.create(
                                  width,
                                  height
                                );

                              var _iterator9 =
                                  _createForOfIteratorHelper(
                                    data.inkLists
                                  ),
                                _step9;

                              try {
                                for (
                                  _iterator9.s();
                                  !(_step9 =
                                    _iterator9.n())
                                    .done;

                                ) {
                                  var inkList =
                                    _step9.value;
                                  var points = [];

                                  var _iterator10 =
                                      _createForOfIteratorHelper(
                                        inkList
                                      ),
                                    _step10;

                                  try {
                                    for (
                                      _iterator10.s();
                                      !(_step10 =
                                        _iterator10.n())
                                        .done;

                                    ) {
                                      var coordinate =
                                        _step10.value;
                                      var x =
                                        coordinate.x -
                                        data
                                          .rect[0];
                                      var y =
                                        data
                                          .rect[3] -
                                        coordinate.y;
                                      points.push(
                                        ""
                                          .concat(
                                            x,
                                            ","
                                          )
                                          .concat(
                                            y
                                          )
                                      );
                                    }
                                  } catch (err) {
                                    _iterator10.e(
                                      err
                                    );
                                  } finally {
                                    _iterator10.f();
                                  }

                                  points =
                                    points.join(
                                      " "
                                    );
                                  var polyline =
                                    this.svgFactory.createElement(
                                      this
                                        .svgElementName
                                    );
                                  polyline.setAttribute(
                                    "points",
                                    points
                                  );
                                  polyline.setAttribute(
                                    "stroke-width",
                                    data
                                      .borderStyle
                                      .width || 1
                                  );
                                  polyline.setAttribute(
                                    "stroke",
                                    "transparent"
                                  );
                                  polyline.setAttribute(
                                    "fill",
                                    "none"
                                  );

                                  this._createPopup(
                                    polyline,
                                    data
                                  );

                                  svg.appendChild(
                                    polyline
                                  );
                                }
                              } catch (err) {
                                _iterator9.e(err);
                              } finally {
                                _iterator9.f();
                              }

                              this.container.append(
                                svg
                              );
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return InkAnnotationElement;
                  })(AnnotationElement);

                var HighlightAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement12
                  ) {
                    _inherits(
                      HighlightAnnotationElement,
                      _AnnotationElement12
                    );

                    var _super18 = _createSuper(
                      HighlightAnnotationElement
                    );

                    function HighlightAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        HighlightAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super18.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                          createQuadrilaterals: true,
                        }
                      );
                    }

                    _createClass(
                      HighlightAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              if (
                                !this.data
                                  .hasPopup
                              ) {
                                this._createPopup(
                                  null,
                                  this.data
                                );
                              }

                              if (
                                this
                                  .quadrilaterals
                              ) {
                                return this._renderQuadrilaterals(
                                  "highlightAnnotation"
                                );
                              }

                              this.container.className =
                                "highlightAnnotation";
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return HighlightAnnotationElement;
                  })(AnnotationElement);

                var UnderlineAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement13
                  ) {
                    _inherits(
                      UnderlineAnnotationElement,
                      _AnnotationElement13
                    );

                    var _super19 = _createSuper(
                      UnderlineAnnotationElement
                    );

                    function UnderlineAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        UnderlineAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super19.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                          createQuadrilaterals: true,
                        }
                      );
                    }

                    _createClass(
                      UnderlineAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              if (
                                !this.data
                                  .hasPopup
                              ) {
                                this._createPopup(
                                  null,
                                  this.data
                                );
                              }

                              if (
                                this
                                  .quadrilaterals
                              ) {
                                return this._renderQuadrilaterals(
                                  "underlineAnnotation"
                                );
                              }

                              this.container.className =
                                "underlineAnnotation";
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return UnderlineAnnotationElement;
                  })(AnnotationElement);

                var SquigglyAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement14
                  ) {
                    _inherits(
                      SquigglyAnnotationElement,
                      _AnnotationElement14
                    );

                    var _super20 = _createSuper(
                      SquigglyAnnotationElement
                    );

                    function SquigglyAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        SquigglyAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super20.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                          createQuadrilaterals: true,
                        }
                      );
                    }

                    _createClass(
                      SquigglyAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              if (
                                !this.data
                                  .hasPopup
                              ) {
                                this._createPopup(
                                  null,
                                  this.data
                                );
                              }

                              if (
                                this
                                  .quadrilaterals
                              ) {
                                return this._renderQuadrilaterals(
                                  "squigglyAnnotation"
                                );
                              }

                              this.container.className =
                                "squigglyAnnotation";
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return SquigglyAnnotationElement;
                  })(AnnotationElement);

                var StrikeOutAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement15
                  ) {
                    _inherits(
                      StrikeOutAnnotationElement,
                      _AnnotationElement15
                    );

                    var _super21 = _createSuper(
                      StrikeOutAnnotationElement
                    );

                    function StrikeOutAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        StrikeOutAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super21.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                          createQuadrilaterals: true,
                        }
                      );
                    }

                    _createClass(
                      StrikeOutAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              if (
                                !this.data
                                  .hasPopup
                              ) {
                                this._createPopup(
                                  null,
                                  this.data
                                );
                              }

                              if (
                                this
                                  .quadrilaterals
                              ) {
                                return this._renderQuadrilaterals(
                                  "strikeoutAnnotation"
                                );
                              }

                              this.container.className =
                                "strikeoutAnnotation";
                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return StrikeOutAnnotationElement;
                  })(AnnotationElement);

                var StampAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement16
                  ) {
                    _inherits(
                      StampAnnotationElement,
                      _AnnotationElement16
                    );

                    var _super22 = _createSuper(
                      StampAnnotationElement
                    );

                    function StampAnnotationElement(
                      parameters
                    ) {
                      _classCallCheck(
                        this,
                        StampAnnotationElement
                      );

                      var isRenderable = !!(
                        parameters.data
                          .hasPopup ||
                        parameters.data.title ||
                        parameters.data.contents
                      );
                      return _super22.call(
                        this,
                        parameters,
                        {
                          isRenderable:
                            isRenderable,
                          ignoreBorder: true,
                        }
                      );
                    }

                    _createClass(
                      StampAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                "stampAnnotation";

                              if (
                                !this.data
                                  .hasPopup
                              ) {
                                this._createPopup(
                                  null,
                                  this.data
                                );
                              }

                              return this
                                .container;
                            },
                        },
                      ]
                    );

                    return StampAnnotationElement;
                  })(AnnotationElement);

                var FileAttachmentAnnotationElement =
                  /*#__PURE__*/ (function (
                    _AnnotationElement17
                  ) {
                    _inherits(
                      FileAttachmentAnnotationElement,
                      _AnnotationElement17
                    );

                    var _super23 = _createSuper(
                      FileAttachmentAnnotationElement
                    );

                    function FileAttachmentAnnotationElement(
                      parameters
                    ) {
                      var _this11$linkService$e;

                      var _this11;

                      _classCallCheck(
                        this,
                        FileAttachmentAnnotationElement
                      );

                      _this11 = _super23.call(
                        this,
                        parameters,
                        {
                          isRenderable: true,
                        }
                      );
                      var _this11$data$file =
                          _this11.data.file,
                        filename =
                          _this11$data$file.filename,
                        content =
                          _this11$data$file.content;
                      _this11.filename = (0,
                      _display_utils.getFilenameFromUrl)(
                        filename
                      );
                      _this11.content = content;
                      (_this11$linkService$e =
                        _this11.linkService
                          .eventBus) === null ||
                      _this11$linkService$e ===
                        void 0
                        ? void 0
                        : _this11$linkService$e.dispatch(
                            "fileattachmentannotation",
                            {
                              source:
                                _assertThisInitialized(
                                  _this11
                                ),
                              id: (0,
                              _util.stringToPDFString)(
                                filename
                              ),
                              filename: filename,
                              content: content,
                            }
                          );
                      return _this11;
                    }

                    _createClass(
                      FileAttachmentAnnotationElement,
                      [
                        {
                          key: "render",
                          value:
                            function render() {
                              this.container.className =
                                "fileAttachmentAnnotation";
                              var trigger =
                                document.createElement(
                                  "div"
                                );
                              trigger.style.height =
                                this.container.style.height;
                              trigger.style.width =
                                this.container.style.width;
                              trigger.addEventListener(
                                "dblclick",
                                this._download.bind(
                                  this
                                )
                              );

                              if (
                                !this.data
                                  .hasPopup &&
                                (this.data
                                  .title ||
                                  this.data
                                    .contents)
                              ) {
                                this._createPopup(
                                  trigger,
                                  this.data
                                );
                              }

                              this.container.appendChild(
                                trigger
                              );
                              return this
                                .container;
                            },
                        },
                        {
                          key: "_download",
                          value:
                            function _download() {
                              if (
                                !this
                                  .downloadManager
                              ) {
                                (0, _util.warn)(
                                  "Download cannot be started due to unavailable download manager"
                                );
                                return;
                              }

                              this.downloadManager.downloadData(
                                this.content,
                                this.filename,
                                ""
                              );
                            },
                        },
                      ]
                    );

                    return FileAttachmentAnnotationElement;
                  })(AnnotationElement);

                var AnnotationLayer =
                  /*#__PURE__*/ (function () {
                    function AnnotationLayer() {
                      _classCallCheck(
                        this,
                        AnnotationLayer
                      );
                    }

                    _createClass(
                      AnnotationLayer,
                      null,
                      [
                        {
                          key: "render",
                          value: function render(
                            parameters
                          ) {
                            var sortedAnnotations =
                                [],
                              popupAnnotations =
                                [];

                            var _iterator11 =
                                _createForOfIteratorHelper(
                                  parameters.annotations
                                ),
                              _step11;

                            try {
                              for (
                                _iterator11.s();
                                !(_step11 =
                                  _iterator11.n())
                                  .done;

                              ) {
                                var _data =
                                  _step11.value;

                                if (!_data) {
                                  continue;
                                }

                                if (
                                  _data.annotationType ===
                                  _util
                                    .AnnotationType
                                    .POPUP
                                ) {
                                  popupAnnotations.push(
                                    _data
                                  );
                                  continue;
                                }

                                sortedAnnotations.push(
                                  _data
                                );
                              }
                            } catch (err) {
                              _iterator11.e(err);
                            } finally {
                              _iterator11.f();
                            }

                            if (
                              popupAnnotations.length
                            ) {
                              sortedAnnotations.push.apply(
                                sortedAnnotations,
                                popupAnnotations
                              );
                            }

                            for (
                              var _i2 = 0,
                                _sortedAnnotations =
                                  sortedAnnotations;
                              _i2 <
                              _sortedAnnotations.length;
                              _i2++
                            ) {
                              var data =
                                _sortedAnnotations[
                                  _i2
                                ];
                              var element =
                                AnnotationElementFactory.create(
                                  {
                                    data: data,
                                    layer:
                                      parameters.div,
                                    page: parameters.page,
                                    viewport:
                                      parameters.viewport,
                                    linkService:
                                      parameters.linkService,
                                    downloadManager:
                                      parameters.downloadManager,
                                    imageResourcesPath:
                                      parameters.imageResourcesPath ||
                                      "",
                                    renderInteractiveForms:
                                      typeof parameters.renderInteractiveForms ===
                                      "boolean"
                                        ? parameters.renderInteractiveForms
                                        : true,
                                    svgFactory:
                                      new _display_utils.DOMSVGFactory(),
                                    annotationStorage:
                                      parameters.annotationStorage ||
                                      new _annotation_storage.AnnotationStorage(),
                                    enableScripting:
                                      parameters.enableScripting,
                                    hasJSActions:
                                      parameters.hasJSActions,
                                    mouseState:
                                      parameters.mouseState || {
                                        isDown: false,
                                      },
                                  }
                                );

                              if (
                                element.isRenderable
                              ) {
                                var rendered =
                                  element.render();

                                if (data.hidden) {
                                  rendered.style.visibility =
                                    "hidden";
                                }

                                if (
                                  Array.isArray(
                                    rendered
                                  )
                                ) {
                                  var _iterator12 =
                                      _createForOfIteratorHelper(
                                        rendered
                                      ),
                                    _step12;

                                  try {
                                    for (
                                      _iterator12.s();
                                      !(_step12 =
                                        _iterator12.n())
                                        .done;

                                    ) {
                                      var renderedElement =
                                        _step12.value;
                                      parameters.div.appendChild(
                                        renderedElement
                                      );
                                    }
                                  } catch (err) {
                                    _iterator12.e(
                                      err
                                    );
                                  } finally {
                                    _iterator12.f();
                                  }
                                } else {
                                  if (
                                    element instanceof
                                    PopupAnnotationElement
                                  ) {
                                    parameters.div.prepend(
                                      rendered
                                    );
                                  } else {
                                    parameters.div.appendChild(
                                      rendered
                                    );
                                  }
                                }
                              }
                            }
                          },
                        },
                        {
                          key: "update",
                          value: function update(
                            parameters
                          ) {
                            var transform =
                              "matrix(".concat(
                                parameters.viewport.transform.join(
                                  ","
                                ),
                                ")"
                              );

                            var _iterator13 =
                                _createForOfIteratorHelper(
                                  parameters.annotations
                                ),
                              _step13;

                            try {
                              for (
                                _iterator13.s();
                                !(_step13 =
                                  _iterator13.n())
                                  .done;

                              ) {
                                var data =
                                  _step13.value;
                                var elements =
                                  parameters.div.querySelectorAll(
                                    '[data-annotation-id="'.concat(
                                      data.id,
                                      '"]'
                                    )
                                  );

                                if (elements) {
                                  elements.forEach(
                                    function (
                                      element
                                    ) {
                                      element.style.transform =
                                        transform;
                                    }
                                  );
                                }
                              }
                            } catch (err) {
                              _iterator13.e(err);
                            } finally {
                              _iterator13.f();
                            }

                            parameters.div.hidden = false;
                          },
                        },
                      ]
                    );

                    return AnnotationLayer;
                  })();

                exports.AnnotationLayer =
                  AnnotationLayer;

                /***/
              },
              /* 150 */
              /***/ function (
                __unused_webpack_module,
                exports
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.ColorConverters = void 0;

                function _slicedToArray(arr, i) {
                  return (
                    _arrayWithHoles(arr) ||
                    _iterableToArrayLimit(
                      arr,
                      i
                    ) ||
                    _unsupportedIterableToArray(
                      arr,
                      i
                    ) ||
                    _nonIterableRest()
                  );
                }

                function _nonIterableRest() {
                  throw new TypeError(
                    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _iterableToArrayLimit(
                  arr,
                  i
                ) {
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    !(
                      Symbol.iterator in
                      Object(arr)
                    )
                  )
                    return;
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (
                      var _i =
                          arr[Symbol.iterator](),
                        _s;
                      !(_n = (_s = _i.next())
                        .done);
                      _n = true
                    ) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (
                        !_n &&
                        _i["return"] != null
                      )
                        _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }

                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                function makeColorComp(n) {
                  return Math.floor(
                    Math.max(0, Math.min(1, n)) *
                      255
                  )
                    .toString(16)
                    .padStart(2, "0");
                }

                var ColorConverters =
                  /*#__PURE__*/ (function () {
                    function ColorConverters() {
                      _classCallCheck(
                        this,
                        ColorConverters
                      );
                    }

                    _createClass(
                      ColorConverters,
                      null,
                      [
                        {
                          key: "CMYK_G",
                          value: function CMYK_G(
                            _ref
                          ) {
                            var _ref2 =
                                _slicedToArray(
                                  _ref,
                                  4
                                ),
                              c = _ref2[0],
                              y = _ref2[1],
                              m = _ref2[2],
                              k = _ref2[3];

                            return [
                              "G",
                              1 -
                                Math.min(
                                  1,
                                  0.3 * c +
                                    0.59 * m +
                                    0.11 * y +
                                    k
                                ),
                            ];
                          },
                        },
                        {
                          key: "G_CMYK",
                          value: function G_CMYK(
                            _ref3
                          ) {
                            var _ref4 =
                                _slicedToArray(
                                  _ref3,
                                  1
                                ),
                              g = _ref4[0];

                            return [
                              "CMYK",
                              0,
                              0,
                              0,
                              1 - g,
                            ];
                          },
                        },
                        {
                          key: "G_RGB",
                          value: function G_RGB(
                            _ref5
                          ) {
                            var _ref6 =
                                _slicedToArray(
                                  _ref5,
                                  1
                                ),
                              g = _ref6[0];

                            return [
                              "RGB",
                              g,
                              g,
                              g,
                            ];
                          },
                        },
                        {
                          key: "G_HTML",
                          value: function G_HTML(
                            _ref7
                          ) {
                            var _ref8 =
                                _slicedToArray(
                                  _ref7,
                                  1
                                ),
                              g = _ref8[0];

                            var G =
                              makeColorComp(g);
                            return "#"
                              .concat(G)
                              .concat(G)
                              .concat(G);
                          },
                        },
                        {
                          key: "RGB_G",
                          value: function RGB_G(
                            _ref9
                          ) {
                            var _ref10 =
                                _slicedToArray(
                                  _ref9,
                                  3
                                ),
                              r = _ref10[0],
                              g = _ref10[1],
                              b = _ref10[2];

                            return [
                              "G",
                              0.3 * r +
                                0.59 * g +
                                0.11 * b,
                            ];
                          },
                        },
                        {
                          key: "RGB_HTML",
                          value:
                            function RGB_HTML(
                              _ref11
                            ) {
                              var _ref12 =
                                  _slicedToArray(
                                    _ref11,
                                    3
                                  ),
                                r = _ref12[0],
                                g = _ref12[1],
                                b = _ref12[2];

                              var R =
                                makeColorComp(r);
                              var G =
                                makeColorComp(g);
                              var B =
                                makeColorComp(b);
                              return "#"
                                .concat(R)
                                .concat(G)
                                .concat(B);
                            },
                        },
                        {
                          key: "T_HTML",
                          value:
                            function T_HTML() {
                              return "#00000000";
                            },
                        },
                        {
                          key: "CMYK_RGB",
                          value:
                            function CMYK_RGB(
                              _ref13
                            ) {
                              var _ref14 =
                                  _slicedToArray(
                                    _ref13,
                                    4
                                  ),
                                c = _ref14[0],
                                y = _ref14[1],
                                m = _ref14[2],
                                k = _ref14[3];

                              return [
                                "RGB",
                                1 -
                                  Math.min(
                                    1,
                                    c + k
                                  ),
                                1 -
                                  Math.min(
                                    1,
                                    m + k
                                  ),
                                1 -
                                  Math.min(
                                    1,
                                    y + k
                                  ),
                              ];
                            },
                        },
                        {
                          key: "CMYK_HTML",
                          value:
                            function CMYK_HTML(
                              components
                            ) {
                              return this.RGB_HTML(
                                this.CMYK_RGB(
                                  components
                                )
                              );
                            },
                        },
                        {
                          key: "RGB_CMYK",
                          value:
                            function RGB_CMYK(
                              _ref15
                            ) {
                              var _ref16 =
                                  _slicedToArray(
                                    _ref15,
                                    3
                                  ),
                                r = _ref16[0],
                                g = _ref16[1],
                                b = _ref16[2];

                              var c = 1 - r;
                              var m = 1 - g;
                              var y = 1 - b;
                              var k = Math.min(
                                c,
                                m,
                                y
                              );
                              return [
                                "CMYK",
                                c,
                                m,
                                y,
                                k,
                              ];
                            },
                        },
                      ]
                    );

                    return ColorConverters;
                  })();

                exports.ColorConverters =
                  ColorConverters;

                /***/
              },
              /* 151 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.renderTextLayer = void 0;

                var _util =
                  __w_pdfjs_require__(4);

                var renderTextLayer =
                  (function renderTextLayerClosure() {
                    var MAX_TEXT_DIVS_TO_RENDER = 100000;
                    var NonWhitespaceRegexp =
                      /\S/;

                    function isAllWhitespace(
                      str
                    ) {
                      return !NonWhitespaceRegexp.test(
                        str
                      );
                    }

                    function appendText(
                      task,
                      geom,
                      styles
                    ) {
                      var textDiv =
                        document.createElement(
                          "div"
                        );
                      var textDivProperties = {
                        angle: 0,
                        canvasWidth: 0,
                        isWhitespace: false,
                        originalTransform: null,
                        paddingBottom: 0,
                        paddingLeft: 0,
                        paddingRight: 0,
                        paddingTop: 0,
                        scale: 1,
                      };

                      task._textDivs.push(
                        textDiv
                      );

                      if (
                        isAllWhitespace(geom.str)
                      ) {
                        textDivProperties.isWhitespace = true;

                        task._textDivProperties.set(
                          textDiv,
                          textDivProperties
                        );

                        return;
                      }

                      var tx =
                        _util.Util.transform(
                          task._viewport
                            .transform,
                          geom.transform
                        );

                      var angle = Math.atan2(
                        tx[1],
                        tx[0]
                      );
                      var style =
                        styles[geom.fontName];

                      if (style.vertical) {
                        angle += Math.PI / 2;
                      }

                      var fontHeight = Math.hypot(
                        tx[2],
                        tx[3]
                      );
                      var fontAscent = fontHeight;

                      if (style.ascent) {
                        fontAscent =
                          style.ascent *
                          fontAscent;
                      } else if (style.descent) {
                        fontAscent =
                          (1 + style.descent) *
                          fontAscent;
                      }

                      var left, top;

                      if (angle === 0) {
                        left = tx[4];
                        top = tx[5] - fontAscent;
                      } else {
                        left =
                          tx[4] +
                          fontAscent *
                            Math.sin(angle);
                        top =
                          tx[5] -
                          fontAscent *
                            Math.cos(angle);
                      }

                      textDiv.style.left =
                        "".concat(left, "px");
                      textDiv.style.top =
                        "".concat(top, "px");
                      textDiv.style.fontSize =
                        "".concat(
                          fontHeight,
                          "px"
                        );
                      textDiv.style.fontFamily =
                        style.fontFamily;

                      if (
                        task._container
                          .classList &&
                        task._container.classList.contains(
                          "visible"
                        ) &&
                        geom.fillColor
                      ) {
                        textDiv.style.color =
                          "rgb("
                            .concat(
                              geom.fillColor[0],
                              ", "
                            )
                            .concat(
                              geom.fillColor[1],
                              ", "
                            )
                            .concat(
                              geom.fillColor[2],
                              ");"
                            );
                      }

                      textDiv.textContent =
                        geom.str;
                      textDiv.dir = geom.dir;

                      if (
                        task._fontInspectorEnabled
                      ) {
                        textDiv.dataset.fontName =
                          geom.fontName;
                      }

                      if (angle !== 0) {
                        textDivProperties.angle =
                          angle * (180 / Math.PI);
                      }

                      var shouldScaleText = false;

                      if (geom.str.length > 1) {
                        shouldScaleText = true;
                      } else if (
                        geom.transform[0] !==
                        geom.transform[3]
                      ) {
                        var absScaleX = Math.abs(
                            geom.transform[0]
                          ),
                          absScaleY = Math.abs(
                            geom.transform[3]
                          );

                        if (
                          absScaleX !==
                            absScaleY &&
                          Math.max(
                            absScaleX,
                            absScaleY
                          ) /
                            Math.min(
                              absScaleX,
                              absScaleY
                            ) >
                            1.5
                        ) {
                          shouldScaleText = true;
                        }
                      }

                      if (shouldScaleText) {
                        if (style.vertical) {
                          textDivProperties.canvasWidth =
                            geom.height *
                            task._viewport.scale;
                        } else {
                          textDivProperties.canvasWidth =
                            geom.width *
                            task._viewport.scale;
                        }
                      }

                      task._textDivProperties.set(
                        textDiv,
                        textDivProperties
                      );

                      if (
                        task._textContentStream
                      ) {
                        task._layoutText(textDiv);
                      }

                      if (
                        task._enhanceTextSelection
                      ) {
                        var angleCos = 1,
                          angleSin = 0;

                        if (angle !== 0) {
                          angleCos =
                            Math.cos(angle);
                          angleSin =
                            Math.sin(angle);
                        }

                        var divWidth =
                          (style.vertical
                            ? geom.height
                            : geom.width) *
                          task._viewport.scale;
                        var divHeight =
                          fontHeight;
                        var m, b;

                        if (angle !== 0) {
                          m = [
                            angleCos,
                            angleSin,
                            -angleSin,
                            angleCos,
                            left,
                            top,
                          ];
                          b =
                            _util.Util.getAxialAlignedBoundingBox(
                              [
                                0,
                                0,
                                divWidth,
                                divHeight,
                              ],
                              m
                            );
                        } else {
                          b = [
                            left,
                            top,
                            left + divWidth,
                            top + divHeight,
                          ];
                        }

                        task._bounds.push({
                          left: b[0],
                          top: b[1],
                          right: b[2],
                          bottom: b[3],
                          div: textDiv,
                          size: [
                            divWidth,
                            divHeight,
                          ],
                          m: m,
                        });
                      }
                    }

                    function render(task) {
                      if (task._canceled) {
                        return;
                      }

                      var textDivs =
                        task._textDivs;
                      var capability =
                        task._capability;
                      var textDivsLength =
                        textDivs.length;

                      if (
                        textDivsLength >
                        MAX_TEXT_DIVS_TO_RENDER
                      ) {
                        task._renderingDone = true;
                        capability.resolve();
                        return;
                      }

                      if (
                        !task._textContentStream
                      ) {
                        for (
                          var i = 0;
                          i < textDivsLength;
                          i++
                        ) {
                          task._layoutText(
                            textDivs[i]
                          );
                        }
                      }

                      task._renderingDone = true;
                      capability.resolve();
                    }

                    function findPositiveMin(
                      ts,
                      offset,
                      count
                    ) {
                      var result = 0;

                      for (
                        var i = 0;
                        i < count;
                        i++
                      ) {
                        var t = ts[offset++];

                        if (t > 0) {
                          result = result
                            ? Math.min(t, result)
                            : t;
                        }
                      }

                      return result;
                    }

                    function expand(task) {
                      var bounds = task._bounds;
                      var viewport =
                        task._viewport;
                      var expanded = expandBounds(
                        viewport.width,
                        viewport.height,
                        bounds
                      );

                      var _loop = function _loop(
                        i
                      ) {
                        var div = bounds[i].div;

                        var divProperties =
                          task._textDivProperties.get(
                            div
                          );

                        if (
                          divProperties.angle ===
                          0
                        ) {
                          divProperties.paddingLeft =
                            bounds[i].left -
                            expanded[i].left;
                          divProperties.paddingTop =
                            bounds[i].top -
                            expanded[i].top;
                          divProperties.paddingRight =
                            expanded[i].right -
                            bounds[i].right;
                          divProperties.paddingBottom =
                            expanded[i].bottom -
                            bounds[i].bottom;

                          task._textDivProperties.set(
                            div,
                            divProperties
                          );

                          return "continue";
                        }

                        var e = expanded[i],
                          b = bounds[i];
                        var m = b.m,
                          c = m[0],
                          s = m[1];
                        var points = [
                          [0, 0],
                          [0, b.size[1]],
                          [b.size[0], 0],
                          b.size,
                        ];
                        var ts = new Float64Array(
                          64
                        );
                        points.forEach(function (
                          p,
                          j
                        ) {
                          var t =
                            _util.Util.applyTransform(
                              p,
                              m
                            );

                          ts[j + 0] =
                            c &&
                            (e.left - t[0]) / c;
                          ts[j + 4] =
                            s &&
                            (e.top - t[1]) / s;
                          ts[j + 8] =
                            c &&
                            (e.right - t[0]) / c;
                          ts[j + 12] =
                            s &&
                            (e.bottom - t[1]) / s;
                          ts[j + 16] =
                            s &&
                            (e.left - t[0]) / -s;
                          ts[j + 20] =
                            c &&
                            (e.top - t[1]) / c;
                          ts[j + 24] =
                            s &&
                            (e.right - t[0]) / -s;
                          ts[j + 28] =
                            c &&
                            (e.bottom - t[1]) / c;
                          ts[j + 32] =
                            c &&
                            (e.left - t[0]) / -c;
                          ts[j + 36] =
                            s &&
                            (e.top - t[1]) / -s;
                          ts[j + 40] =
                            c &&
                            (e.right - t[0]) / -c;
                          ts[j + 44] =
                            s &&
                            (e.bottom - t[1]) /
                              -s;
                          ts[j + 48] =
                            s &&
                            (e.left - t[0]) / s;
                          ts[j + 52] =
                            c &&
                            (e.top - t[1]) / -c;
                          ts[j + 56] =
                            s &&
                            (e.right - t[0]) / s;
                          ts[j + 60] =
                            c &&
                            (e.bottom - t[1]) /
                              -c;
                        });
                        var boxScale =
                          1 +
                          Math.min(
                            Math.abs(c),
                            Math.abs(s)
                          );
                        divProperties.paddingLeft =
                          findPositiveMin(
                            ts,
                            32,
                            16
                          ) / boxScale;
                        divProperties.paddingTop =
                          findPositiveMin(
                            ts,
                            48,
                            16
                          ) / boxScale;
                        divProperties.paddingRight =
                          findPositiveMin(
                            ts,
                            0,
                            16
                          ) / boxScale;
                        divProperties.paddingBottom =
                          findPositiveMin(
                            ts,
                            16,
                            16
                          ) / boxScale;

                        task._textDivProperties.set(
                          div,
                          divProperties
                        );
                      };

                      for (
                        var i = 0;
                        i < expanded.length;
                        i++
                      ) {
                        var _ret = _loop(i);

                        if (_ret === "continue")
                          continue;
                      }
                    }

                    function expandBounds(
                      width,
                      height,
                      boxes
                    ) {
                      var bounds = boxes.map(
                        function (box, i) {
                          return {
                            x1: box.left,
                            y1: box.top,
                            x2: box.right,
                            y2: box.bottom,
                            index: i,
                            x1New: undefined,
                            x2New: undefined,
                          };
                        }
                      );
                      expandBoundsLTR(
                        width,
                        bounds
                      );
                      var expanded = new Array(
                        boxes.length
                      );
                      bounds.forEach(function (
                        b
                      ) {
                        var i = b.index;
                        expanded[i] = {
                          left: b.x1New,
                          top: 0,
                          right: b.x2New,
                          bottom: 0,
                        };
                      });
                      boxes.map(function (
                        box,
                        i
                      ) {
                        var e = expanded[i],
                          b = bounds[i];
                        b.x1 = box.top;
                        b.y1 = width - e.right;
                        b.x2 = box.bottom;
                        b.y2 = width - e.left;
                        b.index = i;
                        b.x1New = undefined;
                        b.x2New = undefined;
                      });
                      expandBoundsLTR(
                        height,
                        bounds
                      );
                      bounds.forEach(function (
                        b
                      ) {
                        var i = b.index;
                        expanded[i].top = b.x1New;
                        expanded[i].bottom =
                          b.x2New;
                      });
                      return expanded;
                    }

                    function expandBoundsLTR(
                      width,
                      bounds
                    ) {
                      bounds.sort(function (
                        a,
                        b
                      ) {
                        return (
                          a.x1 - b.x1 ||
                          a.index - b.index
                        );
                      });
                      var fakeBoundary = {
                        x1: -Infinity,
                        y1: -Infinity,
                        x2: 0,
                        y2: Infinity,
                        index: -1,
                        x1New: 0,
                        x2New: 0,
                      };
                      var horizon = [
                        {
                          start: -Infinity,
                          end: Infinity,
                          boundary: fakeBoundary,
                        },
                      ];
                      bounds.forEach(function (
                        boundary
                      ) {
                        var i = 0;

                        while (
                          i < horizon.length &&
                          horizon[i].end <=
                            boundary.y1
                        ) {
                          i++;
                        }

                        var j =
                          horizon.length - 1;

                        while (
                          j >= 0 &&
                          horizon[j].start >=
                            boundary.y2
                        ) {
                          j--;
                        }

                        var horizonPart,
                          affectedBoundary;
                        var q,
                          k,
                          maxXNew = -Infinity;

                        for (q = i; q <= j; q++) {
                          horizonPart =
                            horizon[q];
                          affectedBoundary =
                            horizonPart.boundary;
                          var xNew = void 0;

                          if (
                            affectedBoundary.x2 >
                            boundary.x1
                          ) {
                            xNew =
                              affectedBoundary.index >
                              boundary.index
                                ? affectedBoundary.x1New
                                : boundary.x1;
                          } else if (
                            affectedBoundary.x2New ===
                            undefined
                          ) {
                            xNew =
                              (affectedBoundary.x2 +
                                boundary.x1) /
                              2;
                          } else {
                            xNew =
                              affectedBoundary.x2New;
                          }

                          if (xNew > maxXNew) {
                            maxXNew = xNew;
                          }
                        }

                        boundary.x1New = maxXNew;

                        for (q = i; q <= j; q++) {
                          horizonPart =
                            horizon[q];
                          affectedBoundary =
                            horizonPart.boundary;

                          if (
                            affectedBoundary.x2New ===
                            undefined
                          ) {
                            if (
                              affectedBoundary.x2 >
                              boundary.x1
                            ) {
                              if (
                                affectedBoundary.index >
                                boundary.index
                              ) {
                                affectedBoundary.x2New =
                                  affectedBoundary.x2;
                              }
                            } else {
                              affectedBoundary.x2New =
                                maxXNew;
                            }
                          } else if (
                            affectedBoundary.x2New >
                            maxXNew
                          ) {
                            affectedBoundary.x2New =
                              Math.max(
                                maxXNew,
                                affectedBoundary.x2
                              );
                          }
                        }

                        var changedHorizon = [];
                        var lastBoundary = null;

                        for (q = i; q <= j; q++) {
                          horizonPart =
                            horizon[q];
                          affectedBoundary =
                            horizonPart.boundary;
                          var useBoundary =
                            affectedBoundary.x2 >
                            boundary.x2
                              ? affectedBoundary
                              : boundary;

                          if (
                            lastBoundary ===
                            useBoundary
                          ) {
                            changedHorizon[
                              changedHorizon.length -
                                1
                            ].end =
                              horizonPart.end;
                          } else {
                            changedHorizon.push({
                              start:
                                horizonPart.start,
                              end: horizonPart.end,
                              boundary:
                                useBoundary,
                            });
                            lastBoundary =
                              useBoundary;
                          }
                        }

                        if (
                          horizon[i].start <
                          boundary.y1
                        ) {
                          changedHorizon[0].start =
                            boundary.y1;
                          changedHorizon.unshift({
                            start:
                              horizon[i].start,
                            end: boundary.y1,
                            boundary:
                              horizon[i].boundary,
                          });
                        }

                        if (
                          boundary.y2 <
                          horizon[j].end
                        ) {
                          changedHorizon[
                            changedHorizon.length -
                              1
                          ].end = boundary.y2;
                          changedHorizon.push({
                            start: boundary.y2,
                            end: horizon[j].end,
                            boundary:
                              horizon[j].boundary,
                          });
                        }

                        for (q = i; q <= j; q++) {
                          horizonPart =
                            horizon[q];
                          affectedBoundary =
                            horizonPart.boundary;

                          if (
                            affectedBoundary.x2New !==
                            undefined
                          ) {
                            continue;
                          }

                          var used = false;

                          for (
                            k = i - 1;
                            !used &&
                            k >= 0 &&
                            horizon[k].start >=
                              affectedBoundary.y1;
                            k--
                          ) {
                            used =
                              horizon[k]
                                .boundary ===
                              affectedBoundary;
                          }

                          for (
                            k = j + 1;
                            !used &&
                            k < horizon.length &&
                            horizon[k].end <=
                              affectedBoundary.y2;
                            k++
                          ) {
                            used =
                              horizon[k]
                                .boundary ===
                              affectedBoundary;
                          }

                          for (
                            k = 0;
                            !used &&
                            k <
                              changedHorizon.length;
                            k++
                          ) {
                            used =
                              changedHorizon[k]
                                .boundary ===
                              affectedBoundary;
                          }

                          if (!used) {
                            affectedBoundary.x2New =
                              maxXNew;
                          }
                        }

                        Array.prototype.splice.apply(
                          horizon,
                          [i, j - i + 1].concat(
                            changedHorizon
                          )
                        );
                      });
                      horizon.forEach(function (
                        horizonPart
                      ) {
                        var affectedBoundary =
                          horizonPart.boundary;

                        if (
                          affectedBoundary.x2New ===
                          undefined
                        ) {
                          affectedBoundary.x2New =
                            Math.max(
                              width,
                              affectedBoundary.x2
                            );
                        }
                      });
                    }

                    function TextLayerRenderTask(
                      _ref
                    ) {
                      var _globalThis$FontInspe,
                        _this = this;

                      var textContent =
                          _ref.textContent,
                        textContentStream =
                          _ref.textContentStream,
                        container =
                          _ref.container,
                        viewport = _ref.viewport,
                        textDivs = _ref.textDivs,
                        textContentItemsStr =
                          _ref.textContentItemsStr,
                        enhanceTextSelection =
                          _ref.enhanceTextSelection;
                      this._textContent =
                        textContent;
                      this._textContentStream =
                        textContentStream;
                      this._container = container;
                      this._document =
                        container.ownerDocument;
                      this._viewport = viewport;
                      this._textDivs =
                        textDivs || [];
                      this._textContentItemsStr =
                        textContentItemsStr || [];
                      this._enhanceTextSelection =
                        !!enhanceTextSelection;
                      this._fontInspectorEnabled =
                        !!(
                          (_globalThis$FontInspe =
                            globalThis.FontInspector) !==
                            null &&
                          _globalThis$FontInspe !==
                            void 0 &&
                          _globalThis$FontInspe.enabled
                        );
                      this._reader = null;
                      this._layoutTextLastFontSize =
                        null;
                      this._layoutTextLastFontFamily =
                        null;
                      this._layoutTextCtx = null;
                      this._textDivProperties =
                        new WeakMap();
                      this._renderingDone = false;
                      this._canceled = false;
                      this._capability = (0,
                      _util.createPromiseCapability)();
                      this._renderTimer = null;
                      this._bounds = [];

                      this._capability.promise[
                        "finally"
                      ](function () {
                        if (
                          _this._layoutTextCtx
                        ) {
                          _this._layoutTextCtx.canvas.width = 0;
                          _this._layoutTextCtx.canvas.height = 0;
                          _this._layoutTextCtx =
                            null;
                        }
                      })["catch"](function () {});
                    }

                    TextLayerRenderTask.prototype =
                      {
                        get promise() {
                          return this._capability
                            .promise;
                        },

                        cancel:
                          function TextLayer_cancel() {
                            this._canceled = true;

                            if (this._reader) {
                              this._reader.cancel(
                                new _util.AbortException(
                                  "TextLayer task cancelled."
                                )
                              );

                              this._reader = null;
                            }

                            if (
                              this
                                ._renderTimer !==
                              null
                            ) {
                              clearTimeout(
                                this._renderTimer
                              );
                              this._renderTimer =
                                null;
                            }

                            this._capability.reject(
                              new Error(
                                "TextLayer task cancelled."
                              )
                            );
                          },
                        _processItems:
                          function _processItems(
                            items,
                            styleCache
                          ) {
                            for (
                              var i = 0,
                                len =
                                  items.length;
                              i < len;
                              i++
                            ) {
                              this._textContentItemsStr.push(
                                items[i].str
                              );

                              appendText(
                                this,
                                items[i],
                                styleCache
                              );
                            }
                          },
                        _layoutText:
                          function _layoutText(
                            textDiv
                          ) {
                            var textDivProperties =
                              this._textDivProperties.get(
                                textDiv
                              );

                            if (
                              textDivProperties.isWhitespace
                            ) {
                              return;
                            }

                            var transform = "";

                            if (
                              textDivProperties.canvasWidth !==
                              0
                            ) {
                              var _textDiv$style =
                                  textDiv.style,
                                fontSize =
                                  _textDiv$style.fontSize,
                                fontFamily =
                                  _textDiv$style.fontFamily;

                              if (
                                fontSize !==
                                  this
                                    ._layoutTextLastFontSize ||
                                fontFamily !==
                                  this
                                    ._layoutTextLastFontFamily
                              ) {
                                this._layoutTextCtx.font =
                                  ""
                                    .concat(
                                      fontSize,
                                      " "
                                    )
                                    .concat(
                                      fontFamily
                                    );
                                this._layoutTextLastFontSize =
                                  fontSize;
                                this._layoutTextLastFontFamily =
                                  fontFamily;
                              }

                              var _this$_layoutTextCtx$ =
                                  this._layoutTextCtx.measureText(
                                    textDiv.textContent
                                  ),
                                width =
                                  _this$_layoutTextCtx$.width;

                              if (width > 0) {
                                textDivProperties.scale =
                                  textDivProperties.canvasWidth /
                                  width;
                                transform =
                                  "scaleX(".concat(
                                    textDivProperties.scale,
                                    ")"
                                  );
                              }
                            }

                            if (
                              textDivProperties.angle !==
                              0
                            ) {
                              transform =
                                "rotate("
                                  .concat(
                                    textDivProperties.angle,
                                    "deg) "
                                  )
                                  .concat(
                                    transform
                                  );
                            }

                            if (
                              transform.length > 0
                            ) {
                              if (
                                this
                                  ._enhanceTextSelection
                              ) {
                                textDivProperties.originalTransform =
                                  transform;
                              }

                              textDiv.style.transform =
                                transform;
                            }

                            this._textDivProperties.set(
                              textDiv,
                              textDivProperties
                            );

                            this._container.appendChild(
                              textDiv
                            );
                          },
                        _render:
                          function TextLayer_render(
                            timeout
                          ) {
                            var _this2 = this;

                            var capability = (0,
                            _util.createPromiseCapability)();
                            var styleCache =
                              Object.create(null);

                            var canvas =
                              this._document.createElement(
                                "canvas"
                              );

                            canvas.mozOpaque = true;
                            this._layoutTextCtx =
                              canvas.getContext(
                                "2d",
                                {
                                  alpha: false,
                                }
                              );

                            if (
                              this._textContent
                            ) {
                              var textItems =
                                this._textContent
                                  .items;
                              var textStyles =
                                this._textContent
                                  .styles;

                              this._processItems(
                                textItems,
                                textStyles
                              );

                              capability.resolve();
                            } else if (
                              this
                                ._textContentStream
                            ) {
                              var pump =
                                function pump() {
                                  _this2._reader
                                    .read()
                                    .then(
                                      function (
                                        _ref2
                                      ) {
                                        var value =
                                            _ref2.value,
                                          done =
                                            _ref2.done;

                                        if (
                                          done
                                        ) {
                                          capability.resolve();
                                          return;
                                        }

                                        Object.assign(
                                          styleCache,
                                          value.styles
                                        );

                                        _this2._processItems(
                                          value.items,
                                          styleCache
                                        );

                                        pump();
                                      },
                                      capability.reject
                                    );
                                };

                              this._reader =
                                this._textContentStream.getReader();
                              pump();
                            } else {
                              throw new Error(
                                'Neither "textContent" nor "textContentStream"' +
                                  " parameters specified."
                              );
                            }

                            capability.promise.then(
                              function () {
                                styleCache = null;

                                if (!timeout) {
                                  render(_this2);
                                } else {
                                  _this2._renderTimer =
                                    setTimeout(
                                      function () {
                                        render(
                                          _this2
                                        );
                                        _this2._renderTimer =
                                          null;
                                      },
                                      timeout
                                    );
                                }
                              },
                              this._capability
                                .reject
                            );
                          },
                        expandTextDivs:
                          function TextLayer_expandTextDivs(
                            expandDivs
                          ) {
                            if (
                              !this
                                ._enhanceTextSelection ||
                              !this._renderingDone
                            ) {
                              return;
                            }

                            if (
                              this._bounds !==
                              null
                            ) {
                              expand(this);
                              this._bounds = null;
                            }

                            var transformBuf = [],
                              paddingBuf = [];

                            for (
                              var i = 0,
                                ii =
                                  this._textDivs
                                    .length;
                              i < ii;
                              i++
                            ) {
                              var div =
                                this._textDivs[i];

                              var divProps =
                                this._textDivProperties.get(
                                  div
                                );

                              if (
                                divProps.isWhitespace
                              ) {
                                continue;
                              }

                              if (expandDivs) {
                                transformBuf.length = 0;
                                paddingBuf.length = 0;

                                if (
                                  divProps.originalTransform
                                ) {
                                  transformBuf.push(
                                    divProps.originalTransform
                                  );
                                }

                                if (
                                  divProps.paddingTop >
                                  0
                                ) {
                                  paddingBuf.push(
                                    "".concat(
                                      divProps.paddingTop,
                                      "px"
                                    )
                                  );
                                  transformBuf.push(
                                    "translateY(".concat(
                                      -divProps.paddingTop,
                                      "px)"
                                    )
                                  );
                                } else {
                                  paddingBuf.push(
                                    0
                                  );
                                }

                                if (
                                  divProps.paddingRight >
                                  0
                                ) {
                                  paddingBuf.push(
                                    "".concat(
                                      divProps.paddingRight /
                                        divProps.scale,
                                      "px"
                                    )
                                  );
                                } else {
                                  paddingBuf.push(
                                    0
                                  );
                                }

                                if (
                                  divProps.paddingBottom >
                                  0
                                ) {
                                  paddingBuf.push(
                                    "".concat(
                                      divProps.paddingBottom,
                                      "px"
                                    )
                                  );
                                } else {
                                  paddingBuf.push(
                                    0
                                  );
                                }

                                if (
                                  divProps.paddingLeft >
                                  0
                                ) {
                                  paddingBuf.push(
                                    "".concat(
                                      divProps.paddingLeft /
                                        divProps.scale,
                                      "px"
                                    )
                                  );
                                  transformBuf.push(
                                    "translateX(".concat(
                                      -divProps.paddingLeft /
                                        divProps.scale,
                                      "px)"
                                    )
                                  );
                                } else {
                                  paddingBuf.push(
                                    0
                                  );
                                }

                                div.style.padding =
                                  paddingBuf.join(
                                    " "
                                  );

                                if (
                                  transformBuf.length
                                ) {
                                  div.style.transform =
                                    transformBuf.join(
                                      " "
                                    );
                                }
                              } else {
                                div.style.padding =
                                  null;
                                div.style.transform =
                                  divProps.originalTransform;
                              }
                            }
                          },
                      };

                    function renderTextLayer(
                      renderParameters
                    ) {
                      var task =
                        new TextLayerRenderTask({
                          textContent:
                            renderParameters.textContent,
                          textContentStream:
                            renderParameters.textContentStream,
                          container:
                            renderParameters.container,
                          viewport:
                            renderParameters.viewport,
                          textDivs:
                            renderParameters.textDivs,
                          textContentItemsStr:
                            renderParameters.textContentItemsStr,
                          enhanceTextSelection:
                            renderParameters.enhanceTextSelection,
                        });

                      task._render(
                        renderParameters.timeout
                      );

                      return task;
                    }

                    return renderTextLayer;
                  })();

                exports.renderTextLayer =
                  renderTextLayer;

                /***/
              },
              /* 152 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.SVGGraphics = void 0;

                var _util =
                  __w_pdfjs_require__(4);

                var _display_utils =
                  __w_pdfjs_require__(1);

                var _is_node =
                  __w_pdfjs_require__(6);

                function _toConsumableArray(arr) {
                  return (
                    _arrayWithoutHoles(arr) ||
                    _iterableToArray(arr) ||
                    _unsupportedIterableToArray(
                      arr
                    ) ||
                    _nonIterableSpread()
                  );
                }

                function _nonIterableSpread() {
                  throw new TypeError(
                    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _iterableToArray(iter) {
                  if (
                    typeof Symbol !==
                      "undefined" &&
                    Symbol.iterator in
                      Object(iter)
                  )
                    return Array.from(iter);
                }

                function _arrayWithoutHoles(arr) {
                  if (Array.isArray(arr))
                    return _arrayLikeToArray(arr);
                }

                function _slicedToArray(arr, i) {
                  return (
                    _arrayWithHoles(arr) ||
                    _iterableToArrayLimit(
                      arr,
                      i
                    ) ||
                    _unsupportedIterableToArray(
                      arr,
                      i
                    ) ||
                    _nonIterableRest()
                  );
                }

                function _nonIterableRest() {
                  throw new TypeError(
                    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _iterableToArrayLimit(
                  arr,
                  i
                ) {
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    !(
                      Symbol.iterator in
                      Object(arr)
                    )
                  )
                    return;
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (
                      var _i =
                          arr[Symbol.iterator](),
                        _s;
                      !(_n = (_s = _i.next())
                        .done);
                      _n = true
                    ) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (
                        !_n &&
                        _i["return"] != null
                      )
                        _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }

                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }

                function _createForOfIteratorHelper(
                  o,
                  allowArrayLike
                ) {
                  var it;
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    o[Symbol.iterator] == null
                  ) {
                    if (
                      Array.isArray(o) ||
                      (it =
                        _unsupportedIterableToArray(
                          o
                        )) ||
                      (allowArrayLike &&
                        o &&
                        typeof o.length ===
                          "number")
                    ) {
                      if (it) o = it;
                      var i = 0;
                      var F = function F() {};
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return { done: true };
                          return {
                            done: false,
                            value: o[i++],
                          };
                        },
                        e: function e(_e2) {
                          throw _e2;
                        },
                        f: F,
                      };
                    }
                    throw new TypeError(
                      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                  }
                  var normalCompletion = true,
                    didErr = false,
                    err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion =
                        step.done;
                      return step;
                    },
                    e: function e(_e3) {
                      didErr = true;
                      err = _e3;
                    },
                    f: function f() {
                      try {
                        if (
                          !normalCompletion &&
                          it["return"] != null
                        )
                          it["return"]();
                      } finally {
                        if (didErr) throw err;
                      }
                    },
                  };
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var SVGGraphics =
                  function SVGGraphics() {
                    throw new Error(
                      "Not implemented: SVGGraphics"
                    );
                  };

                exports.SVGGraphics = SVGGraphics;
                {
                  var opListToTree =
                    function opListToTree(
                      opList
                    ) {
                      var opTree = [];
                      var tmp = [];

                      var _iterator =
                          _createForOfIteratorHelper(
                            opList
                          ),
                        _step;

                      try {
                        for (
                          _iterator.s();
                          !(_step = _iterator.n())
                            .done;

                        ) {
                          var opListElement =
                            _step.value;

                          if (
                            opListElement.fn ===
                            "save"
                          ) {
                            opTree.push({
                              fnId: 92,
                              fn: "group",
                              items: [],
                            });
                            tmp.push(opTree);
                            opTree =
                              opTree[
                                opTree.length - 1
                              ].items;
                            continue;
                          }

                          if (
                            opListElement.fn ===
                            "restore"
                          ) {
                            opTree = tmp.pop();
                          } else {
                            opTree.push(
                              opListElement
                            );
                          }
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      return opTree;
                    };

                  var pf = function pf(value) {
                    if (Number.isInteger(value)) {
                      return value.toString();
                    }

                    var s = value.toFixed(10);
                    var i = s.length - 1;

                    if (s[i] !== "0") {
                      return s;
                    }

                    do {
                      i--;
                    } while (s[i] === "0");

                    return s.substring(
                      0,
                      s[i] === "." ? i : i + 1
                    );
                  };

                  var pm = function pm(m) {
                    if (
                      m[4] === 0 &&
                      m[5] === 0
                    ) {
                      if (
                        m[1] === 0 &&
                        m[2] === 0
                      ) {
                        if (
                          m[0] === 1 &&
                          m[3] === 1
                        ) {
                          return "";
                        }

                        return "scale("
                          .concat(pf(m[0]), " ")
                          .concat(pf(m[3]), ")");
                      }

                      if (
                        m[0] === m[3] &&
                        m[1] === -m[2]
                      ) {
                        var a =
                          (Math.acos(m[0]) *
                            180) /
                          Math.PI;
                        return "rotate(".concat(
                          pf(a),
                          ")"
                        );
                      }
                    } else {
                      if (
                        m[0] === 1 &&
                        m[1] === 0 &&
                        m[2] === 0 &&
                        m[3] === 1
                      ) {
                        return "translate("
                          .concat(pf(m[4]), " ")
                          .concat(pf(m[5]), ")");
                      }
                    }

                    return (
                      "matrix("
                        .concat(pf(m[0]), " ")
                        .concat(pf(m[1]), " ")
                        .concat(pf(m[2]), " ")
                        .concat(pf(m[3]), " ")
                        .concat(pf(m[4]), " ") +
                      "".concat(pf(m[5]), ")")
                    );
                  };

                  var SVG_DEFAULTS = {
                    fontStyle: "normal",
                    fontWeight: "normal",
                    fillColor: "#000000",
                  };
                  var XML_NS =
                    "http://www.w3.org/XML/1998/namespace";
                  var XLINK_NS =
                    "http://www.w3.org/1999/xlink";
                  var LINE_CAP_STYLES = [
                    "butt",
                    "round",
                    "square",
                  ];
                  var LINE_JOIN_STYLES = [
                    "miter",
                    "round",
                    "bevel",
                  ];

                  var convertImgDataToPng =
                    (function () {
                      var PNG_HEADER =
                        new Uint8Array([
                          0x89, 0x50, 0x4e, 0x47,
                          0x0d, 0x0a, 0x1a, 0x0a,
                        ]);
                      var CHUNK_WRAPPER_SIZE = 12;
                      var crcTable =
                        new Int32Array(256);

                      for (
                        var i = 0;
                        i < 256;
                        i++
                      ) {
                        var c = i;

                        for (
                          var h = 0;
                          h < 8;
                          h++
                        ) {
                          if (c & 1) {
                            c =
                              0xedb88320 ^
                              ((c >> 1) &
                                0x7fffffff);
                          } else {
                            c =
                              (c >> 1) &
                              0x7fffffff;
                          }
                        }

                        crcTable[i] = c;
                      }

                      function crc32(
                        data,
                        start,
                        end
                      ) {
                        var crc = -1;

                        for (
                          var _i = start;
                          _i < end;
                          _i++
                        ) {
                          var a =
                            (crc ^ data[_i]) &
                            0xff;
                          var b = crcTable[a];
                          crc = (crc >>> 8) ^ b;
                        }

                        return crc ^ -1;
                      }

                      function writePngChunk(
                        type,
                        body,
                        data,
                        offset
                      ) {
                        var p = offset;
                        var len = body.length;
                        data[p] =
                          (len >> 24) & 0xff;
                        data[p + 1] =
                          (len >> 16) & 0xff;
                        data[p + 2] =
                          (len >> 8) & 0xff;
                        data[p + 3] = len & 0xff;
                        p += 4;
                        data[p] =
                          type.charCodeAt(0) &
                          0xff;
                        data[p + 1] =
                          type.charCodeAt(1) &
                          0xff;
                        data[p + 2] =
                          type.charCodeAt(2) &
                          0xff;
                        data[p + 3] =
                          type.charCodeAt(3) &
                          0xff;
                        p += 4;
                        data.set(body, p);
                        p += body.length;
                        var crc = crc32(
                          data,
                          offset + 4,
                          p
                        );
                        data[p] =
                          (crc >> 24) & 0xff;
                        data[p + 1] =
                          (crc >> 16) & 0xff;
                        data[p + 2] =
                          (crc >> 8) & 0xff;
                        data[p + 3] = crc & 0xff;
                      }

                      function adler32(
                        data,
                        start,
                        end
                      ) {
                        var a = 1;
                        var b = 0;

                        for (
                          var _i2 = start;
                          _i2 < end;
                          ++_i2
                        ) {
                          a =
                            (a +
                              (data[_i2] &
                                0xff)) %
                            65521;
                          b = (b + a) % 65521;
                        }

                        return (b << 16) | a;
                      }

                      function deflateSync(
                        literals
                      ) {
                        if (!_is_node.isNodeJS) {
                          return deflateSyncUncompressed(
                            literals
                          );
                        }

                        try {
                          var input;

                          if (
                            parseInt(
                              process.versions
                                .node
                            ) >= 8
                          ) {
                            input = literals;
                          } else {
                            input =
                              Buffer.from(
                                literals
                              );
                          }

                          var output =
                            __webpack_require__(
                              /*! zlib */ "?331b"
                            ).deflateSync(input, {
                              level: 9,
                            });

                          return output instanceof
                            Uint8Array
                            ? output
                            : new Uint8Array(
                                output
                              );
                        } catch (e) {
                          (0, _util.warn)(
                            "Not compressing PNG because zlib.deflateSync is unavailable: " +
                              e
                          );
                        }

                        return deflateSyncUncompressed(
                          literals
                        );
                      }

                      function deflateSyncUncompressed(
                        literals
                      ) {
                        var len = literals.length;
                        var maxBlockLength = 0xffff;
                        var deflateBlocks =
                          Math.ceil(
                            len / maxBlockLength
                          );
                        var idat = new Uint8Array(
                          2 +
                            len +
                            deflateBlocks * 5 +
                            4
                        );
                        var pi = 0;
                        idat[pi++] = 0x78;
                        idat[pi++] = 0x9c;
                        var pos = 0;

                        while (
                          len > maxBlockLength
                        ) {
                          idat[pi++] = 0x00;
                          idat[pi++] = 0xff;
                          idat[pi++] = 0xff;
                          idat[pi++] = 0x00;
                          idat[pi++] = 0x00;
                          idat.set(
                            literals.subarray(
                              pos,
                              pos + maxBlockLength
                            ),
                            pi
                          );
                          pi += maxBlockLength;
                          pos += maxBlockLength;
                          len -= maxBlockLength;
                        }

                        idat[pi++] = 0x01;
                        idat[pi++] = len & 0xff;
                        idat[pi++] =
                          (len >> 8) & 0xff;
                        idat[pi++] =
                          ~len & 0xffff & 0xff;
                        idat[pi++] =
                          ((~len & 0xffff) >> 8) &
                          0xff;
                        idat.set(
                          literals.subarray(pos),
                          pi
                        );
                        pi +=
                          literals.length - pos;
                        var adler = adler32(
                          literals,
                          0,
                          literals.length
                        );
                        idat[pi++] =
                          (adler >> 24) & 0xff;
                        idat[pi++] =
                          (adler >> 16) & 0xff;
                        idat[pi++] =
                          (adler >> 8) & 0xff;
                        idat[pi++] = adler & 0xff;
                        return idat;
                      }

                      function encode(
                        imgData,
                        kind,
                        forceDataSchema,
                        isMask
                      ) {
                        var width = imgData.width;
                        var height =
                          imgData.height;
                        var bitDepth,
                          colorType,
                          lineSize;
                        var bytes = imgData.data;

                        switch (kind) {
                          case _util.ImageKind
                            .GRAYSCALE_1BPP:
                            colorType = 0;
                            bitDepth = 1;
                            lineSize =
                              (width + 7) >> 3;
                            break;

                          case _util.ImageKind
                            .RGB_24BPP:
                            colorType = 2;
                            bitDepth = 8;
                            lineSize = width * 3;
                            break;

                          case _util.ImageKind
                            .RGBA_32BPP:
                            colorType = 6;
                            bitDepth = 8;
                            lineSize = width * 4;
                            break;

                          default:
                            throw new Error(
                              "invalid format"
                            );
                        }

                        var literals =
                          new Uint8Array(
                            (1 + lineSize) *
                              height
                          );
                        var offsetLiterals = 0,
                          offsetBytes = 0;

                        for (
                          var y = 0;
                          y < height;
                          ++y
                        ) {
                          literals[
                            offsetLiterals++
                          ] = 0;
                          literals.set(
                            bytes.subarray(
                              offsetBytes,
                              offsetBytes +
                                lineSize
                            ),
                            offsetLiterals
                          );
                          offsetBytes += lineSize;
                          offsetLiterals +=
                            lineSize;
                        }

                        if (
                          kind ===
                            _util.ImageKind
                              .GRAYSCALE_1BPP &&
                          isMask
                        ) {
                          offsetLiterals = 0;

                          for (
                            var _y = 0;
                            _y < height;
                            _y++
                          ) {
                            offsetLiterals++;

                            for (
                              var _i3 = 0;
                              _i3 < lineSize;
                              _i3++
                            ) {
                              literals[
                                offsetLiterals++
                              ] ^= 0xff;
                            }
                          }
                        }

                        var ihdr = new Uint8Array(
                          [
                            (width >> 24) & 0xff,
                            (width >> 16) & 0xff,
                            (width >> 8) & 0xff,
                            width & 0xff,
                            (height >> 24) & 0xff,
                            (height >> 16) & 0xff,
                            (height >> 8) & 0xff,
                            height & 0xff,
                            bitDepth,
                            colorType,
                            0x00,
                            0x00,
                            0x00,
                          ]
                        );
                        var idat =
                          deflateSync(literals);
                        var pngLength =
                          PNG_HEADER.length +
                          CHUNK_WRAPPER_SIZE * 3 +
                          ihdr.length +
                          idat.length;
                        var data = new Uint8Array(
                          pngLength
                        );
                        var offset = 0;
                        data.set(
                          PNG_HEADER,
                          offset
                        );
                        offset +=
                          PNG_HEADER.length;
                        writePngChunk(
                          "IHDR",
                          ihdr,
                          data,
                          offset
                        );
                        offset +=
                          CHUNK_WRAPPER_SIZE +
                          ihdr.length;
                        writePngChunk(
                          "IDATA",
                          idat,
                          data,
                          offset
                        );
                        offset +=
                          CHUNK_WRAPPER_SIZE +
                          idat.length;
                        writePngChunk(
                          "IEND",
                          new Uint8Array(0),
                          data,
                          offset
                        );
                        return (0,
                        _util.createObjectURL)(
                          data,
                          "image/png",
                          forceDataSchema
                        );
                      }

                      return function convertImgDataToPng(
                        imgData,
                        forceDataSchema,
                        isMask
                      ) {
                        var kind =
                          imgData.kind ===
                          undefined
                            ? _util.ImageKind
                                .GRAYSCALE_1BPP
                            : imgData.kind;
                        return encode(
                          imgData,
                          kind,
                          forceDataSchema,
                          isMask
                        );
                      };
                    })();

                  var SVGExtraState =
                    /*#__PURE__*/ (function () {
                      function SVGExtraState() {
                        _classCallCheck(
                          this,
                          SVGExtraState
                        );

                        this.fontSizeScale = 1;
                        this.fontWeight =
                          SVG_DEFAULTS.fontWeight;
                        this.fontSize = 0;
                        this.textMatrix =
                          _util.IDENTITY_MATRIX;
                        this.fontMatrix =
                          _util.FONT_IDENTITY_MATRIX;
                        this.leading = 0;
                        this.textRenderingMode =
                          _util.TextRenderingMode.FILL;
                        this.textMatrixScale = 1;
                        this.x = 0;
                        this.y = 0;
                        this.lineX = 0;
                        this.lineY = 0;
                        this.charSpacing = 0;
                        this.wordSpacing = 0;
                        this.textHScale = 1;
                        this.textRise = 0;
                        this.fillColor =
                          SVG_DEFAULTS.fillColor;
                        this.strokeColor =
                          "#000000";
                        this.fillAlpha = 1;
                        this.strokeAlpha = 1;
                        this.lineWidth = 1;
                        this.lineJoin = "";
                        this.lineCap = "";
                        this.miterLimit = 0;
                        this.dashArray = [];
                        this.dashPhase = 0;
                        this.dependencies = [];
                        this.activeClipUrl = null;
                        this.clipGroup = null;
                        this.maskId = "";
                      }

                      _createClass(
                        SVGExtraState,
                        [
                          {
                            key: "clone",
                            value:
                              function clone() {
                                return Object.create(
                                  this
                                );
                              },
                          },
                          {
                            key: "setCurrentPoint",
                            value:
                              function setCurrentPoint(
                                x,
                                y
                              ) {
                                this.x = x;
                                this.y = y;
                              },
                          },
                        ]
                      );

                      return SVGExtraState;
                    })();

                  var clipCount = 0;
                  var maskCount = 0;
                  var shadingCount = 0;

                  exports.SVGGraphics =
                    SVGGraphics =
                      /*#__PURE__*/ (function () {
                        function SVGGraphics(
                          commonObjs,
                          objs
                        ) {
                          var forceDataSchema =
                            arguments.length >
                              2 &&
                            arguments[2] !==
                              undefined
                              ? arguments[2]
                              : false;

                          _classCallCheck(
                            this,
                            SVGGraphics
                          );

                          this.svgFactory =
                            new _display_utils.DOMSVGFactory();
                          this.current =
                            new SVGExtraState();
                          this.transformMatrix =
                            _util.IDENTITY_MATRIX;
                          this.transformStack =
                            [];
                          this.extraStack = [];
                          this.commonObjs =
                            commonObjs;
                          this.objs = objs;
                          this.pendingClip = null;
                          this.pendingEOFill = false;
                          this.embedFonts = false;
                          this.embeddedFonts =
                            Object.create(null);
                          this.cssStyle = null;
                          this.forceDataSchema =
                            !!forceDataSchema;
                          this._operatorIdMapping =
                            [];

                          for (var op in _util.OPS) {
                            this._operatorIdMapping[
                              _util.OPS[op]
                            ] = op;
                          }
                        }

                        _createClass(
                          SVGGraphics,
                          [
                            {
                              key: "save",
                              value:
                                function save() {
                                  this.transformStack.push(
                                    this
                                      .transformMatrix
                                  );
                                  var old =
                                    this.current;
                                  this.extraStack.push(
                                    old
                                  );
                                  this.current =
                                    old.clone();
                                },
                            },
                            {
                              key: "restore",
                              value:
                                function restore() {
                                  this.transformMatrix =
                                    this.transformStack.pop();
                                  this.current =
                                    this.extraStack.pop();
                                  this.pendingClip =
                                    null;
                                  this.tgrp =
                                    null;
                                },
                            },
                            {
                              key: "group",
                              value:
                                function group(
                                  items
                                ) {
                                  this.save();
                                  this.executeOpTree(
                                    items
                                  );
                                  this.restore();
                                },
                            },
                            {
                              key: "loadDependencies",
                              value:
                                function loadDependencies(
                                  operatorList
                                ) {
                                  var _this =
                                    this;

                                  var fnArray =
                                    operatorList.fnArray;
                                  var argsArray =
                                    operatorList.argsArray;

                                  for (
                                    var i = 0,
                                      ii =
                                        fnArray.length;
                                    i < ii;
                                    i++
                                  ) {
                                    if (
                                      fnArray[
                                        i
                                      ] !==
                                      _util.OPS
                                        .dependency
                                    ) {
                                      continue;
                                    }

                                    var _iterator2 =
                                        _createForOfIteratorHelper(
                                          argsArray[
                                            i
                                          ]
                                        ),
                                      _step2;

                                    try {
                                      var _loop =
                                        function _loop() {
                                          var obj =
                                            _step2.value;
                                          var objsPool =
                                            obj.startsWith(
                                              "g_"
                                            )
                                              ? _this.commonObjs
                                              : _this.objs;
                                          var promise =
                                            new Promise(
                                              function (
                                                resolve
                                              ) {
                                                objsPool.get(
                                                  obj,
                                                  resolve
                                                );
                                              }
                                            );

                                          _this.current.dependencies.push(
                                            promise
                                          );
                                        };

                                      for (
                                        _iterator2.s();
                                        !(_step2 =
                                          _iterator2.n())
                                          .done;

                                      ) {
                                        _loop();
                                      }
                                    } catch (err) {
                                      _iterator2.e(
                                        err
                                      );
                                    } finally {
                                      _iterator2.f();
                                    }
                                  }

                                  return Promise.all(
                                    this.current
                                      .dependencies
                                  );
                                },
                            },
                            {
                              key: "transform",
                              value:
                                function transform(
                                  a,
                                  b,
                                  c,
                                  d,
                                  e,
                                  f
                                ) {
                                  var transformMatrix =
                                    [
                                      a,
                                      b,
                                      c,
                                      d,
                                      e,
                                      f,
                                    ];
                                  this.transformMatrix =
                                    _util.Util.transform(
                                      this
                                        .transformMatrix,
                                      transformMatrix
                                    );
                                  this.tgrp =
                                    null;
                                },
                            },
                            {
                              key: "getSVG",
                              value:
                                function getSVG(
                                  operatorList,
                                  viewport
                                ) {
                                  var _this2 =
                                    this;

                                  this.viewport =
                                    viewport;

                                  var svgElement =
                                    this._initialize(
                                      viewport
                                    );

                                  return this.loadDependencies(
                                    operatorList
                                  ).then(
                                    function () {
                                      _this2.transformMatrix =
                                        _util.IDENTITY_MATRIX;

                                      _this2.executeOpTree(
                                        _this2.convertOpList(
                                          operatorList
                                        )
                                      );

                                      return svgElement;
                                    }
                                  );
                                },
                            },
                            {
                              key: "convertOpList",
                              value:
                                function convertOpList(
                                  operatorList
                                ) {
                                  var operatorIdMapping =
                                    this
                                      ._operatorIdMapping;
                                  var argsArray =
                                    operatorList.argsArray;
                                  var fnArray =
                                    operatorList.fnArray;
                                  var opList = [];

                                  for (
                                    var i = 0,
                                      ii =
                                        fnArray.length;
                                    i < ii;
                                    i++
                                  ) {
                                    var fnId =
                                      fnArray[i];
                                    opList.push({
                                      fnId: fnId,
                                      fn: operatorIdMapping[
                                        fnId
                                      ],
                                      args: argsArray[
                                        i
                                      ],
                                    });
                                  }

                                  return opListToTree(
                                    opList
                                  );
                                },
                            },
                            {
                              key: "executeOpTree",
                              value:
                                function executeOpTree(
                                  opTree
                                ) {
                                  var _iterator3 =
                                      _createForOfIteratorHelper(
                                        opTree
                                      ),
                                    _step3;

                                  try {
                                    for (
                                      _iterator3.s();
                                      !(_step3 =
                                        _iterator3.n())
                                        .done;

                                    ) {
                                      var opTreeElement =
                                        _step3.value;
                                      var fn =
                                        opTreeElement.fn;
                                      var fnId =
                                        opTreeElement.fnId;
                                      var args =
                                        opTreeElement.args;

                                      switch (
                                        fnId | 0
                                      ) {
                                        case _util
                                          .OPS
                                          .beginText:
                                          this.beginText();
                                          break;

                                        case _util
                                          .OPS
                                          .dependency:
                                          break;

                                        case _util
                                          .OPS
                                          .setLeading:
                                          this.setLeading(
                                            args
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setLeadingMoveText:
                                          this.setLeadingMoveText(
                                            args[0],
                                            args[1]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setFont:
                                          this.setFont(
                                            args
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .showText:
                                          this.showText(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .showSpacedText:
                                          this.showText(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .endText:
                                          this.endText();
                                          break;

                                        case _util
                                          .OPS
                                          .moveText:
                                          this.moveText(
                                            args[0],
                                            args[1]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setCharSpacing:
                                          this.setCharSpacing(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setWordSpacing:
                                          this.setWordSpacing(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setHScale:
                                          this.setHScale(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setTextMatrix:
                                          this.setTextMatrix(
                                            args[0],
                                            args[1],
                                            args[2],
                                            args[3],
                                            args[4],
                                            args[5]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setTextRise:
                                          this.setTextRise(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setTextRenderingMode:
                                          this.setTextRenderingMode(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setLineWidth:
                                          this.setLineWidth(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setLineJoin:
                                          this.setLineJoin(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setLineCap:
                                          this.setLineCap(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setMiterLimit:
                                          this.setMiterLimit(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setFillRGBColor:
                                          this.setFillRGBColor(
                                            args[0],
                                            args[1],
                                            args[2]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setStrokeRGBColor:
                                          this.setStrokeRGBColor(
                                            args[0],
                                            args[1],
                                            args[2]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setStrokeColorN:
                                          this.setStrokeColorN(
                                            args
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setFillColorN:
                                          this.setFillColorN(
                                            args
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .shadingFill:
                                          this.shadingFill(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setDash:
                                          this.setDash(
                                            args[0],
                                            args[1]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setRenderingIntent:
                                          this.setRenderingIntent(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setFlatness:
                                          this.setFlatness(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .setGState:
                                          this.setGState(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .fill:
                                          this.fill();
                                          break;

                                        case _util
                                          .OPS
                                          .eoFill:
                                          this.eoFill();
                                          break;

                                        case _util
                                          .OPS
                                          .stroke:
                                          this.stroke();
                                          break;

                                        case _util
                                          .OPS
                                          .fillStroke:
                                          this.fillStroke();
                                          break;

                                        case _util
                                          .OPS
                                          .eoFillStroke:
                                          this.eoFillStroke();
                                          break;

                                        case _util
                                          .OPS
                                          .clip:
                                          this.clip(
                                            "nonzero"
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .eoClip:
                                          this.clip(
                                            "evenodd"
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .paintSolidColorImageMask:
                                          this.paintSolidColorImageMask();
                                          break;

                                        case _util
                                          .OPS
                                          .paintImageXObject:
                                          this.paintImageXObject(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .paintInlineImageXObject:
                                          this.paintInlineImageXObject(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .paintImageMaskXObject:
                                          this.paintImageMaskXObject(
                                            args[0]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .paintFormXObjectBegin:
                                          this.paintFormXObjectBegin(
                                            args[0],
                                            args[1]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .paintFormXObjectEnd:
                                          this.paintFormXObjectEnd();
                                          break;

                                        case _util
                                          .OPS
                                          .closePath:
                                          this.closePath();
                                          break;

                                        case _util
                                          .OPS
                                          .closeStroke:
                                          this.closeStroke();
                                          break;

                                        case _util
                                          .OPS
                                          .closeFillStroke:
                                          this.closeFillStroke();
                                          break;

                                        case _util
                                          .OPS
                                          .closeEOFillStroke:
                                          this.closeEOFillStroke();
                                          break;

                                        case _util
                                          .OPS
                                          .nextLine:
                                          this.nextLine();
                                          break;

                                        case _util
                                          .OPS
                                          .transform:
                                          this.transform(
                                            args[0],
                                            args[1],
                                            args[2],
                                            args[3],
                                            args[4],
                                            args[5]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .constructPath:
                                          this.constructPath(
                                            args[0],
                                            args[1]
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .endPath:
                                          this.endPath();
                                          break;

                                        case 92:
                                          this.group(
                                            opTreeElement.items
                                          );
                                          break;

                                        default:
                                          (0,
                                          _util.warn)(
                                            "Unimplemented operator ".concat(
                                              fn
                                            )
                                          );
                                          break;
                                      }
                                    }
                                  } catch (err) {
                                    _iterator3.e(
                                      err
                                    );
                                  } finally {
                                    _iterator3.f();
                                  }
                                },
                            },
                            {
                              key: "setWordSpacing",
                              value:
                                function setWordSpacing(
                                  wordSpacing
                                ) {
                                  this.current.wordSpacing =
                                    wordSpacing;
                                },
                            },
                            {
                              key: "setCharSpacing",
                              value:
                                function setCharSpacing(
                                  charSpacing
                                ) {
                                  this.current.charSpacing =
                                    charSpacing;
                                },
                            },
                            {
                              key: "nextLine",
                              value:
                                function nextLine() {
                                  this.moveText(
                                    0,
                                    this.current
                                      .leading
                                  );
                                },
                            },
                            {
                              key: "setTextMatrix",
                              value:
                                function setTextMatrix(
                                  a,
                                  b,
                                  c,
                                  d,
                                  e,
                                  f
                                ) {
                                  var current =
                                    this.current;
                                  current.textMatrix =
                                    current.lineMatrix =
                                      [
                                        a,
                                        b,
                                        c,
                                        d,
                                        e,
                                        f,
                                      ];
                                  current.textMatrixScale =
                                    Math.hypot(
                                      a,
                                      b
                                    );
                                  current.x =
                                    current.lineX = 0;
                                  current.y =
                                    current.lineY = 0;
                                  current.xcoords =
                                    [];
                                  current.ycoords =
                                    [];
                                  current.tspan =
                                    this.svgFactory.createElement(
                                      "svg:tspan"
                                    );
                                  current.tspan.setAttributeNS(
                                    null,
                                    "font-family",
                                    current.fontFamily
                                  );
                                  current.tspan.setAttributeNS(
                                    null,
                                    "font-size",
                                    "".concat(
                                      pf(
                                        current.fontSize
                                      ),
                                      "px"
                                    )
                                  );
                                  current.tspan.setAttributeNS(
                                    null,
                                    "y",
                                    pf(-current.y)
                                  );
                                  current.txtElement =
                                    this.svgFactory.createElement(
                                      "svg:text"
                                    );
                                  current.txtElement.appendChild(
                                    current.tspan
                                  );
                                },
                            },
                            {
                              key: "beginText",
                              value:
                                function beginText() {
                                  var current =
                                    this.current;
                                  current.x =
                                    current.lineX = 0;
                                  current.y =
                                    current.lineY = 0;
                                  current.textMatrix =
                                    _util.IDENTITY_MATRIX;
                                  current.lineMatrix =
                                    _util.IDENTITY_MATRIX;
                                  current.textMatrixScale = 1;
                                  current.tspan =
                                    this.svgFactory.createElement(
                                      "svg:tspan"
                                    );
                                  current.txtElement =
                                    this.svgFactory.createElement(
                                      "svg:text"
                                    );
                                  current.txtgrp =
                                    this.svgFactory.createElement(
                                      "svg:g"
                                    );
                                  current.xcoords =
                                    [];
                                  current.ycoords =
                                    [];
                                },
                            },
                            {
                              key: "moveText",
                              value:
                                function moveText(
                                  x,
                                  y
                                ) {
                                  var current =
                                    this.current;
                                  current.x =
                                    current.lineX +=
                                      x;
                                  current.y =
                                    current.lineY +=
                                      y;
                                  current.xcoords =
                                    [];
                                  current.ycoords =
                                    [];
                                  current.tspan =
                                    this.svgFactory.createElement(
                                      "svg:tspan"
                                    );
                                  current.tspan.setAttributeNS(
                                    null,
                                    "font-family",
                                    current.fontFamily
                                  );
                                  current.tspan.setAttributeNS(
                                    null,
                                    "font-size",
                                    "".concat(
                                      pf(
                                        current.fontSize
                                      ),
                                      "px"
                                    )
                                  );
                                  current.tspan.setAttributeNS(
                                    null,
                                    "y",
                                    pf(-current.y)
                                  );
                                },
                            },
                            {
                              key: "showText",
                              value:
                                function showText(
                                  glyphs
                                ) {
                                  var current =
                                    this.current;
                                  var font =
                                    current.font;
                                  var fontSize =
                                    current.fontSize;

                                  if (
                                    fontSize === 0
                                  ) {
                                    return;
                                  }

                                  var fontSizeScale =
                                    current.fontSizeScale;
                                  var charSpacing =
                                    current.charSpacing;
                                  var wordSpacing =
                                    current.wordSpacing;
                                  var fontDirection =
                                    current.fontDirection;
                                  var textHScale =
                                    current.textHScale *
                                    fontDirection;
                                  var vertical =
                                    font.vertical;
                                  var spacingDir =
                                    vertical
                                      ? 1
                                      : -1;
                                  var defaultVMetrics =
                                    font.defaultVMetrics;
                                  var widthAdvanceScale =
                                    fontSize *
                                    current
                                      .fontMatrix[0];
                                  var x = 0;

                                  var _iterator4 =
                                      _createForOfIteratorHelper(
                                        glyphs
                                      ),
                                    _step4;

                                  try {
                                    for (
                                      _iterator4.s();
                                      !(_step4 =
                                        _iterator4.n())
                                        .done;

                                    ) {
                                      var glyph =
                                        _step4.value;

                                      if (
                                        glyph ===
                                        null
                                      ) {
                                        x +=
                                          fontDirection *
                                          wordSpacing;
                                        continue;
                                      } else if (
                                        (0,
                                        _util.isNum)(
                                          glyph
                                        )
                                      ) {
                                        x +=
                                          (spacingDir *
                                            glyph *
                                            fontSize) /
                                          1000;
                                        continue;
                                      }

                                      var spacing =
                                        (glyph.isSpace
                                          ? wordSpacing
                                          : 0) +
                                        charSpacing;
                                      var character =
                                        glyph.fontChar;
                                      var scaledX =
                                          void 0,
                                        scaledY =
                                          void 0;
                                      var width =
                                        glyph.width;

                                      if (
                                        vertical
                                      ) {
                                        var vx =
                                          void 0;
                                        var vmetric =
                                          glyph.vmetric ||
                                          defaultVMetrics;
                                        vx =
                                          glyph.vmetric
                                            ? vmetric[1]
                                            : width *
                                              0.5;
                                        vx =
                                          -vx *
                                          widthAdvanceScale;
                                        var vy =
                                          vmetric[2] *
                                          widthAdvanceScale;
                                        width =
                                          vmetric
                                            ? -vmetric[0]
                                            : width;
                                        scaledX =
                                          vx /
                                          fontSizeScale;
                                        scaledY =
                                          (x +
                                            vy) /
                                          fontSizeScale;
                                      } else {
                                        scaledX =
                                          x /
                                          fontSizeScale;
                                        scaledY = 0;
                                      }

                                      if (
                                        glyph.isInFont ||
                                        font.missingFile
                                      ) {
                                        current.xcoords.push(
                                          current.x +
                                            scaledX
                                        );

                                        if (
                                          vertical
                                        ) {
                                          current.ycoords.push(
                                            -current.y +
                                              scaledY
                                          );
                                        }

                                        current.tspan.textContent +=
                                          character;
                                      } else {
                                      }

                                      var charWidth =
                                        void 0;

                                      if (
                                        vertical
                                      ) {
                                        charWidth =
                                          width *
                                            widthAdvanceScale -
                                          spacing *
                                            fontDirection;
                                      } else {
                                        charWidth =
                                          width *
                                            widthAdvanceScale +
                                          spacing *
                                            fontDirection;
                                      }

                                      x +=
                                        charWidth;
                                    }
                                  } catch (err) {
                                    _iterator4.e(
                                      err
                                    );
                                  } finally {
                                    _iterator4.f();
                                  }

                                  current.tspan.setAttributeNS(
                                    null,
                                    "x",
                                    current.xcoords
                                      .map(pf)
                                      .join(" ")
                                  );

                                  if (vertical) {
                                    current.tspan.setAttributeNS(
                                      null,
                                      "y",
                                      current.ycoords
                                        .map(pf)
                                        .join(" ")
                                    );
                                  } else {
                                    current.tspan.setAttributeNS(
                                      null,
                                      "y",
                                      pf(
                                        -current.y
                                      )
                                    );
                                  }

                                  if (vertical) {
                                    current.y -=
                                      x;
                                  } else {
                                    current.x +=
                                      x *
                                      textHScale;
                                  }

                                  current.tspan.setAttributeNS(
                                    null,
                                    "font-family",
                                    current.fontFamily
                                  );
                                  current.tspan.setAttributeNS(
                                    null,
                                    "font-size",
                                    "".concat(
                                      pf(
                                        current.fontSize
                                      ),
                                      "px"
                                    )
                                  );

                                  if (
                                    current.fontStyle !==
                                    SVG_DEFAULTS.fontStyle
                                  ) {
                                    current.tspan.setAttributeNS(
                                      null,
                                      "font-style",
                                      current.fontStyle
                                    );
                                  }

                                  if (
                                    current.fontWeight !==
                                    SVG_DEFAULTS.fontWeight
                                  ) {
                                    current.tspan.setAttributeNS(
                                      null,
                                      "font-weight",
                                      current.fontWeight
                                    );
                                  }

                                  var fillStrokeMode =
                                    current.textRenderingMode &
                                    _util
                                      .TextRenderingMode
                                      .FILL_STROKE_MASK;

                                  if (
                                    fillStrokeMode ===
                                      _util
                                        .TextRenderingMode
                                        .FILL ||
                                    fillStrokeMode ===
                                      _util
                                        .TextRenderingMode
                                        .FILL_STROKE
                                  ) {
                                    if (
                                      current.fillColor !==
                                      SVG_DEFAULTS.fillColor
                                    ) {
                                      current.tspan.setAttributeNS(
                                        null,
                                        "fill",
                                        current.fillColor
                                      );
                                    }

                                    if (
                                      current.fillAlpha <
                                      1
                                    ) {
                                      current.tspan.setAttributeNS(
                                        null,
                                        "fill-opacity",
                                        current.fillAlpha
                                      );
                                    }
                                  } else if (
                                    current.textRenderingMode ===
                                    _util
                                      .TextRenderingMode
                                      .ADD_TO_PATH
                                  ) {
                                    current.tspan.setAttributeNS(
                                      null,
                                      "fill",
                                      "transparent"
                                    );
                                  } else {
                                    current.tspan.setAttributeNS(
                                      null,
                                      "fill",
                                      "none"
                                    );
                                  }

                                  if (
                                    fillStrokeMode ===
                                      _util
                                        .TextRenderingMode
                                        .STROKE ||
                                    fillStrokeMode ===
                                      _util
                                        .TextRenderingMode
                                        .FILL_STROKE
                                  ) {
                                    var lineWidthScale =
                                      1 /
                                      (current.textMatrixScale ||
                                        1);

                                    this._setStrokeAttributes(
                                      current.tspan,
                                      lineWidthScale
                                    );
                                  }

                                  var textMatrix =
                                    current.textMatrix;

                                  if (
                                    current.textRise !==
                                    0
                                  ) {
                                    textMatrix =
                                      textMatrix.slice();
                                    textMatrix[5] +=
                                      current.textRise;
                                  }

                                  current.txtElement.setAttributeNS(
                                    null,
                                    "transform",
                                    ""
                                      .concat(
                                        pm(
                                          textMatrix
                                        ),
                                        " scale("
                                      )
                                      .concat(
                                        pf(
                                          textHScale
                                        ),
                                        ", -1)"
                                      )
                                  );
                                  current.txtElement.setAttributeNS(
                                    XML_NS,
                                    "xml:space",
                                    "preserve"
                                  );
                                  current.txtElement.appendChild(
                                    current.tspan
                                  );
                                  current.txtgrp.appendChild(
                                    current.txtElement
                                  );

                                  this._ensureTransformGroup().appendChild(
                                    current.txtElement
                                  );
                                },
                            },
                            {
                              key: "setLeadingMoveText",
                              value:
                                function setLeadingMoveText(
                                  x,
                                  y
                                ) {
                                  this.setLeading(
                                    -y
                                  );
                                  this.moveText(
                                    x,
                                    y
                                  );
                                },
                            },
                            {
                              key: "addFontStyle",
                              value:
                                function addFontStyle(
                                  fontObj
                                ) {
                                  if (
                                    !fontObj.data
                                  ) {
                                    throw new Error(
                                      "addFontStyle: No font data available, " +
                                        'ensure that the "fontExtraProperties" API parameter is set.'
                                    );
                                  }

                                  if (
                                    !this.cssStyle
                                  ) {
                                    this.cssStyle =
                                      this.svgFactory.createElement(
                                        "svg:style"
                                      );
                                    this.cssStyle.setAttributeNS(
                                      null,
                                      "type",
                                      "text/css"
                                    );
                                    this.defs.appendChild(
                                      this
                                        .cssStyle
                                    );
                                  }

                                  var url = (0,
                                  _util.createObjectURL)(
                                    fontObj.data,
                                    fontObj.mimetype,
                                    this
                                      .forceDataSchema
                                  );
                                  this.cssStyle.textContent +=
                                    '@font-face { font-family: "'.concat(
                                      fontObj.loadedName,
                                      '";'
                                    ) +
                                    " src: url(".concat(
                                      url,
                                      "); }\n"
                                    );
                                },
                            },
                            {
                              key: "setFont",
                              value:
                                function setFont(
                                  details
                                ) {
                                  var current =
                                    this.current;
                                  var fontObj =
                                    this.commonObjs.get(
                                      details[0]
                                    );
                                  var size =
                                    details[1];
                                  current.font =
                                    fontObj;

                                  if (
                                    this
                                      .embedFonts &&
                                    !fontObj.missingFile &&
                                    !this
                                      .embeddedFonts[
                                      fontObj
                                        .loadedName
                                    ]
                                  ) {
                                    this.addFontStyle(
                                      fontObj
                                    );
                                    this.embeddedFonts[
                                      fontObj.loadedName
                                    ] = fontObj;
                                  }

                                  current.fontMatrix =
                                    fontObj.fontMatrix ||
                                    _util.FONT_IDENTITY_MATRIX;
                                  var bold =
                                    "normal";

                                  if (
                                    fontObj.black
                                  ) {
                                    bold = "900";
                                  } else if (
                                    fontObj.bold
                                  ) {
                                    bold = "bold";
                                  }

                                  var italic =
                                    fontObj.italic
                                      ? "italic"
                                      : "normal";

                                  if (size < 0) {
                                    size = -size;
                                    current.fontDirection =
                                      -1;
                                  } else {
                                    current.fontDirection = 1;
                                  }

                                  current.fontSize =
                                    size;
                                  current.fontFamily =
                                    fontObj.loadedName;
                                  current.fontWeight =
                                    bold;
                                  current.fontStyle =
                                    italic;
                                  current.tspan =
                                    this.svgFactory.createElement(
                                      "svg:tspan"
                                    );
                                  current.tspan.setAttributeNS(
                                    null,
                                    "y",
                                    pf(-current.y)
                                  );
                                  current.xcoords =
                                    [];
                                  current.ycoords =
                                    [];
                                },
                            },
                            {
                              key: "endText",
                              value:
                                function endText() {
                                  var _current$txtElement;

                                  var current =
                                    this.current;

                                  if (
                                    current.textRenderingMode &
                                      _util
                                        .TextRenderingMode
                                        .ADD_TO_PATH_FLAG &&
                                    (_current$txtElement =
                                      current.txtElement) !==
                                      null &&
                                    _current$txtElement !==
                                      void 0 &&
                                    _current$txtElement.hasChildNodes()
                                  ) {
                                    current.element =
                                      current.txtElement;
                                    this.clip(
                                      "nonzero"
                                    );
                                    this.endPath();
                                  }
                                },
                            },
                            {
                              key: "setLineWidth",
                              value:
                                function setLineWidth(
                                  width
                                ) {
                                  if (width > 0) {
                                    this.current.lineWidth =
                                      width;
                                  }
                                },
                            },
                            {
                              key: "setLineCap",
                              value:
                                function setLineCap(
                                  style
                                ) {
                                  this.current.lineCap =
                                    LINE_CAP_STYLES[
                                      style
                                    ];
                                },
                            },
                            {
                              key: "setLineJoin",
                              value:
                                function setLineJoin(
                                  style
                                ) {
                                  this.current.lineJoin =
                                    LINE_JOIN_STYLES[
                                      style
                                    ];
                                },
                            },
                            {
                              key: "setMiterLimit",
                              value:
                                function setMiterLimit(
                                  limit
                                ) {
                                  this.current.miterLimit =
                                    limit;
                                },
                            },
                            {
                              key: "setStrokeAlpha",
                              value:
                                function setStrokeAlpha(
                                  strokeAlpha
                                ) {
                                  this.current.strokeAlpha =
                                    strokeAlpha;
                                },
                            },
                            {
                              key: "setStrokeRGBColor",
                              value:
                                function setStrokeRGBColor(
                                  r,
                                  g,
                                  b
                                ) {
                                  this.current.strokeColor =
                                    _util.Util.makeHexColor(
                                      r,
                                      g,
                                      b
                                    );
                                },
                            },
                            {
                              key: "setFillAlpha",
                              value:
                                function setFillAlpha(
                                  fillAlpha
                                ) {
                                  this.current.fillAlpha =
                                    fillAlpha;
                                },
                            },
                            {
                              key: "setFillRGBColor",
                              value:
                                function setFillRGBColor(
                                  r,
                                  g,
                                  b
                                ) {
                                  this.current.fillColor =
                                    _util.Util.makeHexColor(
                                      r,
                                      g,
                                      b
                                    );
                                  this.current.tspan =
                                    this.svgFactory.createElement(
                                      "svg:tspan"
                                    );
                                  this.current.xcoords =
                                    [];
                                  this.current.ycoords =
                                    [];
                                },
                            },
                            {
                              key: "setStrokeColorN",
                              value:
                                function setStrokeColorN(
                                  args
                                ) {
                                  this.current.strokeColor =
                                    this._makeColorN_Pattern(
                                      args
                                    );
                                },
                            },
                            {
                              key: "setFillColorN",
                              value:
                                function setFillColorN(
                                  args
                                ) {
                                  this.current.fillColor =
                                    this._makeColorN_Pattern(
                                      args
                                    );
                                },
                            },
                            {
                              key: "shadingFill",
                              value:
                                function shadingFill(
                                  args
                                ) {
                                  var width =
                                    this.viewport
                                      .width;
                                  var height =
                                    this.viewport
                                      .height;

                                  var inv =
                                    _util.Util.inverseTransform(
                                      this
                                        .transformMatrix
                                    );

                                  var bl =
                                    _util.Util.applyTransform(
                                      [0, 0],
                                      inv
                                    );

                                  var br =
                                    _util.Util.applyTransform(
                                      [0, height],
                                      inv
                                    );

                                  var ul =
                                    _util.Util.applyTransform(
                                      [width, 0],
                                      inv
                                    );

                                  var ur =
                                    _util.Util.applyTransform(
                                      [
                                        width,
                                        height,
                                      ],
                                      inv
                                    );

                                  var x0 =
                                    Math.min(
                                      bl[0],
                                      br[0],
                                      ul[0],
                                      ur[0]
                                    );
                                  var y0 =
                                    Math.min(
                                      bl[1],
                                      br[1],
                                      ul[1],
                                      ur[1]
                                    );
                                  var x1 =
                                    Math.max(
                                      bl[0],
                                      br[0],
                                      ul[0],
                                      ur[0]
                                    );
                                  var y1 =
                                    Math.max(
                                      bl[1],
                                      br[1],
                                      ul[1],
                                      ur[1]
                                    );
                                  var rect =
                                    this.svgFactory.createElement(
                                      "svg:rect"
                                    );
                                  rect.setAttributeNS(
                                    null,
                                    "x",
                                    x0
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "y",
                                    y0
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "width",
                                    x1 - x0
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "height",
                                    y1 - y0
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "fill",
                                    this._makeShadingPattern(
                                      args
                                    )
                                  );

                                  if (
                                    this.current
                                      .fillAlpha <
                                    1
                                  ) {
                                    rect.setAttributeNS(
                                      null,
                                      "fill-opacity",
                                      this.current
                                        .fillAlpha
                                    );
                                  }

                                  this._ensureTransformGroup().appendChild(
                                    rect
                                  );
                                },
                            },
                            {
                              key: "_makeColorN_Pattern",
                              value:
                                function _makeColorN_Pattern(
                                  args
                                ) {
                                  if (
                                    args[0] ===
                                    "TilingPattern"
                                  ) {
                                    return this._makeTilingPattern(
                                      args
                                    );
                                  }

                                  return this._makeShadingPattern(
                                    args
                                  );
                                },
                            },
                            {
                              key: "_makeTilingPattern",
                              value:
                                function _makeTilingPattern(
                                  args
                                ) {
                                  var color =
                                    args[1];
                                  var operatorList =
                                    args[2];
                                  var matrix =
                                    args[3] ||
                                    _util.IDENTITY_MATRIX;

                                  var _args$ =
                                      _slicedToArray(
                                        args[4],
                                        4
                                      ),
                                    x0 =
                                      _args$[0],
                                    y0 =
                                      _args$[1],
                                    x1 =
                                      _args$[2],
                                    y1 =
                                      _args$[3];

                                  var xstep =
                                    args[5];
                                  var ystep =
                                    args[6];
                                  var paintType =
                                    args[7];
                                  var tilingId =
                                    "shading".concat(
                                      shadingCount++
                                    );

                                  var _Util$applyTransform =
                                      _util.Util.applyTransform(
                                        [x0, y0],
                                        matrix
                                      ),
                                    _Util$applyTransform2 =
                                      _slicedToArray(
                                        _Util$applyTransform,
                                        2
                                      ),
                                    tx0 =
                                      _Util$applyTransform2[0],
                                    ty0 =
                                      _Util$applyTransform2[1];

                                  var _Util$applyTransform3 =
                                      _util.Util.applyTransform(
                                        [x1, y1],
                                        matrix
                                      ),
                                    _Util$applyTransform4 =
                                      _slicedToArray(
                                        _Util$applyTransform3,
                                        2
                                      ),
                                    tx1 =
                                      _Util$applyTransform4[0],
                                    ty1 =
                                      _Util$applyTransform4[1];

                                  var _Util$singularValueDe =
                                      _util.Util.singularValueDecompose2dScale(
                                        matrix
                                      ),
                                    _Util$singularValueDe2 =
                                      _slicedToArray(
                                        _Util$singularValueDe,
                                        2
                                      ),
                                    xscale =
                                      _Util$singularValueDe2[0],
                                    yscale =
                                      _Util$singularValueDe2[1];

                                  var txstep =
                                    xstep *
                                    xscale;
                                  var tystep =
                                    ystep *
                                    yscale;
                                  var tiling =
                                    this.svgFactory.createElement(
                                      "svg:pattern"
                                    );
                                  tiling.setAttributeNS(
                                    null,
                                    "id",
                                    tilingId
                                  );
                                  tiling.setAttributeNS(
                                    null,
                                    "patternUnits",
                                    "userSpaceOnUse"
                                  );
                                  tiling.setAttributeNS(
                                    null,
                                    "width",
                                    txstep
                                  );
                                  tiling.setAttributeNS(
                                    null,
                                    "height",
                                    tystep
                                  );
                                  tiling.setAttributeNS(
                                    null,
                                    "x",
                                    "".concat(tx0)
                                  );
                                  tiling.setAttributeNS(
                                    null,
                                    "y",
                                    "".concat(ty0)
                                  );
                                  var svg =
                                    this.svg;
                                  var transformMatrix =
                                    this
                                      .transformMatrix;
                                  var fillColor =
                                    this.current
                                      .fillColor;
                                  var strokeColor =
                                    this.current
                                      .strokeColor;
                                  var bbox =
                                    this.svgFactory.create(
                                      tx1 - tx0,
                                      ty1 - ty0
                                    );
                                  this.svg = bbox;
                                  this.transformMatrix =
                                    matrix;

                                  if (
                                    paintType ===
                                    2
                                  ) {
                                    var cssColor =
                                      _util.Util.makeHexColor.apply(
                                        _util.Util,
                                        _toConsumableArray(
                                          color
                                        )
                                      );

                                    this.current.fillColor =
                                      cssColor;
                                    this.current.strokeColor =
                                      cssColor;
                                  }

                                  this.executeOpTree(
                                    this.convertOpList(
                                      operatorList
                                    )
                                  );
                                  this.svg = svg;
                                  this.transformMatrix =
                                    transformMatrix;
                                  this.current.fillColor =
                                    fillColor;
                                  this.current.strokeColor =
                                    strokeColor;
                                  tiling.appendChild(
                                    bbox
                                      .childNodes[0]
                                  );
                                  this.defs.appendChild(
                                    tiling
                                  );
                                  return "url(#".concat(
                                    tilingId,
                                    ")"
                                  );
                                },
                            },
                            {
                              key: "_makeShadingPattern",
                              value:
                                function _makeShadingPattern(
                                  args
                                ) {
                                  switch (
                                    args[0]
                                  ) {
                                    case "RadialAxial":
                                      var shadingId =
                                        "shading".concat(
                                          shadingCount++
                                        );
                                      var colorStops =
                                        args[3];
                                      var gradient;

                                      switch (
                                        args[1]
                                      ) {
                                        case "axial":
                                          var point0 =
                                            args[4];
                                          var point1 =
                                            args[5];
                                          gradient =
                                            this.svgFactory.createElement(
                                              "svg:linearGradient"
                                            );
                                          gradient.setAttributeNS(
                                            null,
                                            "id",
                                            shadingId
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "gradientUnits",
                                            "userSpaceOnUse"
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "x1",
                                            point0[0]
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "y1",
                                            point0[1]
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "x2",
                                            point1[0]
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "y2",
                                            point1[1]
                                          );
                                          break;

                                        case "radial":
                                          var focalPoint =
                                            args[4];
                                          var circlePoint =
                                            args[5];
                                          var focalRadius =
                                            args[6];
                                          var circleRadius =
                                            args[7];
                                          gradient =
                                            this.svgFactory.createElement(
                                              "svg:radialGradient"
                                            );
                                          gradient.setAttributeNS(
                                            null,
                                            "id",
                                            shadingId
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "gradientUnits",
                                            "userSpaceOnUse"
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "cx",
                                            circlePoint[0]
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "cy",
                                            circlePoint[1]
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "r",
                                            circleRadius
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "fx",
                                            focalPoint[0]
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "fy",
                                            focalPoint[1]
                                          );
                                          gradient.setAttributeNS(
                                            null,
                                            "fr",
                                            focalRadius
                                          );
                                          break;

                                        default:
                                          throw new Error(
                                            "Unknown RadialAxial type: ".concat(
                                              args[1]
                                            )
                                          );
                                      }

                                      var _iterator5 =
                                          _createForOfIteratorHelper(
                                            colorStops
                                          ),
                                        _step5;

                                      try {
                                        for (
                                          _iterator5.s();
                                          !(_step5 =
                                            _iterator5.n())
                                            .done;

                                        ) {
                                          var colorStop =
                                            _step5.value;
                                          var stop =
                                            this.svgFactory.createElement(
                                              "svg:stop"
                                            );
                                          stop.setAttributeNS(
                                            null,
                                            "offset",
                                            colorStop[0]
                                          );
                                          stop.setAttributeNS(
                                            null,
                                            "stop-color",
                                            colorStop[1]
                                          );
                                          gradient.appendChild(
                                            stop
                                          );
                                        }
                                      } catch (err) {
                                        _iterator5.e(
                                          err
                                        );
                                      } finally {
                                        _iterator5.f();
                                      }

                                      this.defs.appendChild(
                                        gradient
                                      );
                                      return "url(#".concat(
                                        shadingId,
                                        ")"
                                      );

                                    case "Mesh":
                                      (0,
                                      _util.warn)(
                                        "Unimplemented pattern Mesh"
                                      );
                                      return null;

                                    case "Dummy":
                                      return "hotpink";

                                    default:
                                      throw new Error(
                                        "Unknown IR type: ".concat(
                                          args[0]
                                        )
                                      );
                                  }
                                },
                            },
                            {
                              key: "setDash",
                              value:
                                function setDash(
                                  dashArray,
                                  dashPhase
                                ) {
                                  this.current.dashArray =
                                    dashArray;
                                  this.current.dashPhase =
                                    dashPhase;
                                },
                            },
                            {
                              key: "constructPath",
                              value:
                                function constructPath(
                                  ops,
                                  args
                                ) {
                                  var current =
                                    this.current;
                                  var x =
                                      current.x,
                                    y = current.y;
                                  var d = [];
                                  var j = 0;

                                  var _iterator6 =
                                      _createForOfIteratorHelper(
                                        ops
                                      ),
                                    _step6;

                                  try {
                                    for (
                                      _iterator6.s();
                                      !(_step6 =
                                        _iterator6.n())
                                        .done;

                                    ) {
                                      var op =
                                        _step6.value;

                                      switch (
                                        op | 0
                                      ) {
                                        case _util
                                          .OPS
                                          .rectangle:
                                          x =
                                            args[
                                              j++
                                            ];
                                          y =
                                            args[
                                              j++
                                            ];
                                          var width =
                                            args[
                                              j++
                                            ];
                                          var height =
                                            args[
                                              j++
                                            ];
                                          var xw =
                                            x +
                                            width;
                                          var yh =
                                            y +
                                            height;
                                          d.push(
                                            "M",
                                            pf(x),
                                            pf(y),
                                            "L",
                                            pf(
                                              xw
                                            ),
                                            pf(y),
                                            "L",
                                            pf(
                                              xw
                                            ),
                                            pf(
                                              yh
                                            ),
                                            "L",
                                            pf(x),
                                            pf(
                                              yh
                                            ),
                                            "Z"
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .moveTo:
                                          x =
                                            args[
                                              j++
                                            ];
                                          y =
                                            args[
                                              j++
                                            ];
                                          d.push(
                                            "M",
                                            pf(x),
                                            pf(y)
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .lineTo:
                                          x =
                                            args[
                                              j++
                                            ];
                                          y =
                                            args[
                                              j++
                                            ];
                                          d.push(
                                            "L",
                                            pf(x),
                                            pf(y)
                                          );
                                          break;

                                        case _util
                                          .OPS
                                          .curveTo:
                                          x =
                                            args[
                                              j +
                                                4
                                            ];
                                          y =
                                            args[
                                              j +
                                                5
                                            ];
                                          d.push(
                                            "C",
                                            pf(
                                              args[
                                                j
                                              ]
                                            ),
                                            pf(
                                              args[
                                                j +
                                                  1
                                              ]
                                            ),
                                            pf(
                                              args[
                                                j +
                                                  2
                                              ]
                                            ),
                                            pf(
                                              args[
                                                j +
                                                  3
                                              ]
                                            ),
                                            pf(x),
                                            pf(y)
                                          );
                                          j += 6;
                                          break;

                                        case _util
                                          .OPS
                                          .curveTo2:
                                          d.push(
                                            "C",
                                            pf(x),
                                            pf(y),
                                            pf(
                                              args[
                                                j
                                              ]
                                            ),
                                            pf(
                                              args[
                                                j +
                                                  1
                                              ]
                                            ),
                                            pf(
                                              args[
                                                j +
                                                  2
                                              ]
                                            ),
                                            pf(
                                              args[
                                                j +
                                                  3
                                              ]
                                            )
                                          );
                                          x =
                                            args[
                                              j +
                                                2
                                            ];
                                          y =
                                            args[
                                              j +
                                                3
                                            ];
                                          j += 4;
                                          break;

                                        case _util
                                          .OPS
                                          .curveTo3:
                                          x =
                                            args[
                                              j +
                                                2
                                            ];
                                          y =
                                            args[
                                              j +
                                                3
                                            ];
                                          d.push(
                                            "C",
                                            pf(
                                              args[
                                                j
                                              ]
                                            ),
                                            pf(
                                              args[
                                                j +
                                                  1
                                              ]
                                            ),
                                            pf(x),
                                            pf(y),
                                            pf(x),
                                            pf(y)
                                          );
                                          j += 4;
                                          break;

                                        case _util
                                          .OPS
                                          .closePath:
                                          d.push(
                                            "Z"
                                          );
                                          break;
                                      }
                                    }
                                  } catch (err) {
                                    _iterator6.e(
                                      err
                                    );
                                  } finally {
                                    _iterator6.f();
                                  }

                                  d = d.join(" ");

                                  if (
                                    current.path &&
                                    ops.length >
                                      0 &&
                                    ops[0] !==
                                      _util.OPS
                                        .rectangle &&
                                    ops[0] !==
                                      _util.OPS
                                        .moveTo
                                  ) {
                                    d =
                                      current.path.getAttributeNS(
                                        null,
                                        "d"
                                      ) + d;
                                  } else {
                                    current.path =
                                      this.svgFactory.createElement(
                                        "svg:path"
                                      );

                                    this._ensureTransformGroup().appendChild(
                                      current.path
                                    );
                                  }

                                  current.path.setAttributeNS(
                                    null,
                                    "d",
                                    d
                                  );
                                  current.path.setAttributeNS(
                                    null,
                                    "fill",
                                    "none"
                                  );
                                  current.element =
                                    current.path;
                                  current.setCurrentPoint(
                                    x,
                                    y
                                  );
                                },
                            },
                            {
                              key: "endPath",
                              value:
                                function endPath() {
                                  var current =
                                    this.current;
                                  current.path =
                                    null;

                                  if (
                                    !this
                                      .pendingClip
                                  ) {
                                    return;
                                  }

                                  if (
                                    !current.element
                                  ) {
                                    this.pendingClip =
                                      null;
                                    return;
                                  }

                                  var clipId =
                                    "clippath".concat(
                                      clipCount++
                                    );
                                  var clipPath =
                                    this.svgFactory.createElement(
                                      "svg:clipPath"
                                    );
                                  clipPath.setAttributeNS(
                                    null,
                                    "id",
                                    clipId
                                  );
                                  clipPath.setAttributeNS(
                                    null,
                                    "transform",
                                    pm(
                                      this
                                        .transformMatrix
                                    )
                                  );
                                  var clipElement =
                                    current.element.cloneNode(
                                      true
                                    );

                                  if (
                                    this
                                      .pendingClip ===
                                    "evenodd"
                                  ) {
                                    clipElement.setAttributeNS(
                                      null,
                                      "clip-rule",
                                      "evenodd"
                                    );
                                  } else {
                                    clipElement.setAttributeNS(
                                      null,
                                      "clip-rule",
                                      "nonzero"
                                    );
                                  }

                                  this.pendingClip =
                                    null;
                                  clipPath.appendChild(
                                    clipElement
                                  );
                                  this.defs.appendChild(
                                    clipPath
                                  );

                                  if (
                                    current.activeClipUrl
                                  ) {
                                    current.clipGroup =
                                      null;
                                    this.extraStack.forEach(
                                      function (
                                        prev
                                      ) {
                                        prev.clipGroup =
                                          null;
                                      }
                                    );
                                    clipPath.setAttributeNS(
                                      null,
                                      "clip-path",
                                      current.activeClipUrl
                                    );
                                  }

                                  current.activeClipUrl =
                                    "url(#".concat(
                                      clipId,
                                      ")"
                                    );
                                  this.tgrp =
                                    null;
                                },
                            },
                            {
                              key: "clip",
                              value:
                                function clip(
                                  type
                                ) {
                                  this.pendingClip =
                                    type;
                                },
                            },
                            {
                              key: "closePath",
                              value:
                                function closePath() {
                                  var current =
                                    this.current;

                                  if (
                                    current.path
                                  ) {
                                    var d =
                                      "".concat(
                                        current.path.getAttributeNS(
                                          null,
                                          "d"
                                        ),
                                        "Z"
                                      );
                                    current.path.setAttributeNS(
                                      null,
                                      "d",
                                      d
                                    );
                                  }
                                },
                            },
                            {
                              key: "setLeading",
                              value:
                                function setLeading(
                                  leading
                                ) {
                                  this.current.leading =
                                    -leading;
                                },
                            },
                            {
                              key: "setTextRise",
                              value:
                                function setTextRise(
                                  textRise
                                ) {
                                  this.current.textRise =
                                    textRise;
                                },
                            },
                            {
                              key: "setTextRenderingMode",
                              value:
                                function setTextRenderingMode(
                                  textRenderingMode
                                ) {
                                  this.current.textRenderingMode =
                                    textRenderingMode;
                                },
                            },
                            {
                              key: "setHScale",
                              value:
                                function setHScale(
                                  scale
                                ) {
                                  this.current.textHScale =
                                    scale / 100;
                                },
                            },
                            {
                              key: "setRenderingIntent",
                              value:
                                function setRenderingIntent(
                                  intent
                                ) {},
                            },
                            {
                              key: "setFlatness",
                              value:
                                function setFlatness(
                                  flatness
                                ) {},
                            },
                            {
                              key: "setGState",
                              value:
                                function setGState(
                                  states
                                ) {
                                  var _iterator7 =
                                      _createForOfIteratorHelper(
                                        states
                                      ),
                                    _step7;

                                  try {
                                    for (
                                      _iterator7.s();
                                      !(_step7 =
                                        _iterator7.n())
                                        .done;

                                    ) {
                                      var _step7$value =
                                          _slicedToArray(
                                            _step7.value,
                                            2
                                          ),
                                        key =
                                          _step7$value[0],
                                        value =
                                          _step7$value[1];

                                      switch (
                                        key
                                      ) {
                                        case "LW":
                                          this.setLineWidth(
                                            value
                                          );
                                          break;

                                        case "LC":
                                          this.setLineCap(
                                            value
                                          );
                                          break;

                                        case "LJ":
                                          this.setLineJoin(
                                            value
                                          );
                                          break;

                                        case "ML":
                                          this.setMiterLimit(
                                            value
                                          );
                                          break;

                                        case "D":
                                          this.setDash(
                                            value[0],
                                            value[1]
                                          );
                                          break;

                                        case "RI":
                                          this.setRenderingIntent(
                                            value
                                          );
                                          break;

                                        case "FL":
                                          this.setFlatness(
                                            value
                                          );
                                          break;

                                        case "Font":
                                          this.setFont(
                                            value
                                          );
                                          break;

                                        case "CA":
                                          this.setStrokeAlpha(
                                            value
                                          );
                                          break;

                                        case "ca":
                                          this.setFillAlpha(
                                            value
                                          );
                                          break;

                                        default:
                                          (0,
                                          _util.warn)(
                                            "Unimplemented graphic state operator ".concat(
                                              key
                                            )
                                          );
                                          break;
                                      }
                                    }
                                  } catch (err) {
                                    _iterator7.e(
                                      err
                                    );
                                  } finally {
                                    _iterator7.f();
                                  }
                                },
                            },
                            {
                              key: "fill",
                              value:
                                function fill() {
                                  var current =
                                    this.current;

                                  if (
                                    current.element
                                  ) {
                                    current.element.setAttributeNS(
                                      null,
                                      "fill",
                                      current.fillColor
                                    );
                                    current.element.setAttributeNS(
                                      null,
                                      "fill-opacity",
                                      current.fillAlpha
                                    );
                                    this.endPath();
                                  }
                                },
                            },
                            {
                              key: "stroke",
                              value:
                                function stroke() {
                                  var current =
                                    this.current;

                                  if (
                                    current.element
                                  ) {
                                    this._setStrokeAttributes(
                                      current.element
                                    );

                                    current.element.setAttributeNS(
                                      null,
                                      "fill",
                                      "none"
                                    );
                                    this.endPath();
                                  }
                                },
                            },
                            {
                              key: "_setStrokeAttributes",
                              value:
                                function _setStrokeAttributes(
                                  element
                                ) {
                                  var lineWidthScale =
                                    arguments.length >
                                      1 &&
                                    arguments[1] !==
                                      undefined
                                      ? arguments[1]
                                      : 1;
                                  var current =
                                    this.current;
                                  var dashArray =
                                    current.dashArray;

                                  if (
                                    lineWidthScale !==
                                      1 &&
                                    dashArray.length >
                                      0
                                  ) {
                                    dashArray =
                                      dashArray.map(
                                        function (
                                          value
                                        ) {
                                          return (
                                            lineWidthScale *
                                            value
                                          );
                                        }
                                      );
                                  }

                                  element.setAttributeNS(
                                    null,
                                    "stroke",
                                    current.strokeColor
                                  );
                                  element.setAttributeNS(
                                    null,
                                    "stroke-opacity",
                                    current.strokeAlpha
                                  );
                                  element.setAttributeNS(
                                    null,
                                    "stroke-miterlimit",
                                    pf(
                                      current.miterLimit
                                    )
                                  );
                                  element.setAttributeNS(
                                    null,
                                    "stroke-linecap",
                                    current.lineCap
                                  );
                                  element.setAttributeNS(
                                    null,
                                    "stroke-linejoin",
                                    current.lineJoin
                                  );
                                  element.setAttributeNS(
                                    null,
                                    "stroke-width",
                                    pf(
                                      lineWidthScale *
                                        current.lineWidth
                                    ) + "px"
                                  );
                                  element.setAttributeNS(
                                    null,
                                    "stroke-dasharray",
                                    dashArray
                                      .map(pf)
                                      .join(" ")
                                  );
                                  element.setAttributeNS(
                                    null,
                                    "stroke-dashoffset",
                                    pf(
                                      lineWidthScale *
                                        current.dashPhase
                                    ) + "px"
                                  );
                                },
                            },
                            {
                              key: "eoFill",
                              value:
                                function eoFill() {
                                  if (
                                    this.current
                                      .element
                                  ) {
                                    this.current.element.setAttributeNS(
                                      null,
                                      "fill-rule",
                                      "evenodd"
                                    );
                                  }

                                  this.fill();
                                },
                            },
                            {
                              key: "fillStroke",
                              value:
                                function fillStroke() {
                                  this.stroke();
                                  this.fill();
                                },
                            },
                            {
                              key: "eoFillStroke",
                              value:
                                function eoFillStroke() {
                                  if (
                                    this.current
                                      .element
                                  ) {
                                    this.current.element.setAttributeNS(
                                      null,
                                      "fill-rule",
                                      "evenodd"
                                    );
                                  }

                                  this.fillStroke();
                                },
                            },
                            {
                              key: "closeStroke",
                              value:
                                function closeStroke() {
                                  this.closePath();
                                  this.stroke();
                                },
                            },
                            {
                              key: "closeFillStroke",
                              value:
                                function closeFillStroke() {
                                  this.closePath();
                                  this.fillStroke();
                                },
                            },
                            {
                              key: "closeEOFillStroke",
                              value:
                                function closeEOFillStroke() {
                                  this.closePath();
                                  this.eoFillStroke();
                                },
                            },
                            {
                              key: "paintSolidColorImageMask",
                              value:
                                function paintSolidColorImageMask() {
                                  var rect =
                                    this.svgFactory.createElement(
                                      "svg:rect"
                                    );
                                  rect.setAttributeNS(
                                    null,
                                    "x",
                                    "0"
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "y",
                                    "0"
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "width",
                                    "1px"
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "height",
                                    "1px"
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "fill",
                                    this.current
                                      .fillColor
                                  );

                                  this._ensureTransformGroup().appendChild(
                                    rect
                                  );
                                },
                            },
                            {
                              key: "paintImageXObject",
                              value:
                                function paintImageXObject(
                                  objId
                                ) {
                                  var imgData =
                                    objId.startsWith(
                                      "g_"
                                    )
                                      ? this.commonObjs.get(
                                          objId
                                        )
                                      : this.objs.get(
                                          objId
                                        );

                                  if (!imgData) {
                                    (0,
                                    _util.warn)(
                                      "Dependent image with object ID ".concat(
                                        objId,
                                        " is not ready yet"
                                      )
                                    );
                                    return;
                                  }

                                  this.paintInlineImageXObject(
                                    imgData
                                  );
                                },
                            },
                            {
                              key: "paintInlineImageXObject",
                              value:
                                function paintInlineImageXObject(
                                  imgData,
                                  mask
                                ) {
                                  var width =
                                    imgData.width;
                                  var height =
                                    imgData.height;
                                  var imgSrc =
                                    convertImgDataToPng(
                                      imgData,
                                      this
                                        .forceDataSchema,
                                      !!mask
                                    );
                                  var cliprect =
                                    this.svgFactory.createElement(
                                      "svg:rect"
                                    );
                                  cliprect.setAttributeNS(
                                    null,
                                    "x",
                                    "0"
                                  );
                                  cliprect.setAttributeNS(
                                    null,
                                    "y",
                                    "0"
                                  );
                                  cliprect.setAttributeNS(
                                    null,
                                    "width",
                                    pf(width)
                                  );
                                  cliprect.setAttributeNS(
                                    null,
                                    "height",
                                    pf(height)
                                  );
                                  this.current.element =
                                    cliprect;
                                  this.clip(
                                    "nonzero"
                                  );
                                  var imgEl =
                                    this.svgFactory.createElement(
                                      "svg:image"
                                    );
                                  imgEl.setAttributeNS(
                                    XLINK_NS,
                                    "xlink:href",
                                    imgSrc
                                  );
                                  imgEl.setAttributeNS(
                                    null,
                                    "x",
                                    "0"
                                  );
                                  imgEl.setAttributeNS(
                                    null,
                                    "y",
                                    pf(-height)
                                  );
                                  imgEl.setAttributeNS(
                                    null,
                                    "width",
                                    pf(width) +
                                      "px"
                                  );
                                  imgEl.setAttributeNS(
                                    null,
                                    "height",
                                    pf(height) +
                                      "px"
                                  );
                                  imgEl.setAttributeNS(
                                    null,
                                    "transform",
                                    "scale("
                                      .concat(
                                        pf(
                                          1 /
                                            width
                                        ),
                                        " "
                                      )
                                      .concat(
                                        pf(
                                          -1 /
                                            height
                                        ),
                                        ")"
                                      )
                                  );

                                  if (mask) {
                                    mask.appendChild(
                                      imgEl
                                    );
                                  } else {
                                    this._ensureTransformGroup().appendChild(
                                      imgEl
                                    );
                                  }
                                },
                            },
                            {
                              key: "paintImageMaskXObject",
                              value:
                                function paintImageMaskXObject(
                                  imgData
                                ) {
                                  var current =
                                    this.current;
                                  var width =
                                    imgData.width;
                                  var height =
                                    imgData.height;
                                  var fillColor =
                                    current.fillColor;
                                  current.maskId =
                                    "mask".concat(
                                      maskCount++
                                    );
                                  var mask =
                                    this.svgFactory.createElement(
                                      "svg:mask"
                                    );
                                  mask.setAttributeNS(
                                    null,
                                    "id",
                                    current.maskId
                                  );
                                  var rect =
                                    this.svgFactory.createElement(
                                      "svg:rect"
                                    );
                                  rect.setAttributeNS(
                                    null,
                                    "x",
                                    "0"
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "y",
                                    "0"
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "width",
                                    pf(width)
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "height",
                                    pf(height)
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "fill",
                                    fillColor
                                  );
                                  rect.setAttributeNS(
                                    null,
                                    "mask",
                                    "url(#".concat(
                                      current.maskId,
                                      ")"
                                    )
                                  );
                                  this.defs.appendChild(
                                    mask
                                  );

                                  this._ensureTransformGroup().appendChild(
                                    rect
                                  );

                                  this.paintInlineImageXObject(
                                    imgData,
                                    mask
                                  );
                                },
                            },
                            {
                              key: "paintFormXObjectBegin",
                              value:
                                function paintFormXObjectBegin(
                                  matrix,
                                  bbox
                                ) {
                                  if (
                                    Array.isArray(
                                      matrix
                                    ) &&
                                    matrix.length ===
                                      6
                                  ) {
                                    this.transform(
                                      matrix[0],
                                      matrix[1],
                                      matrix[2],
                                      matrix[3],
                                      matrix[4],
                                      matrix[5]
                                    );
                                  }

                                  if (bbox) {
                                    var width =
                                      bbox[2] -
                                      bbox[0];
                                    var height =
                                      bbox[3] -
                                      bbox[1];
                                    var cliprect =
                                      this.svgFactory.createElement(
                                        "svg:rect"
                                      );
                                    cliprect.setAttributeNS(
                                      null,
                                      "x",
                                      bbox[0]
                                    );
                                    cliprect.setAttributeNS(
                                      null,
                                      "y",
                                      bbox[1]
                                    );
                                    cliprect.setAttributeNS(
                                      null,
                                      "width",
                                      pf(width)
                                    );
                                    cliprect.setAttributeNS(
                                      null,
                                      "height",
                                      pf(height)
                                    );
                                    this.current.element =
                                      cliprect;
                                    this.clip(
                                      "nonzero"
                                    );
                                    this.endPath();
                                  }
                                },
                            },
                            {
                              key: "paintFormXObjectEnd",
                              value:
                                function paintFormXObjectEnd() {},
                            },
                            {
                              key: "_initialize",
                              value:
                                function _initialize(
                                  viewport
                                ) {
                                  var svg =
                                    this.svgFactory.create(
                                      viewport.width,
                                      viewport.height
                                    );
                                  var definitions =
                                    this.svgFactory.createElement(
                                      "svg:defs"
                                    );
                                  svg.appendChild(
                                    definitions
                                  );
                                  this.defs =
                                    definitions;
                                  var rootGroup =
                                    this.svgFactory.createElement(
                                      "svg:g"
                                    );
                                  rootGroup.setAttributeNS(
                                    null,
                                    "transform",
                                    pm(
                                      viewport.transform
                                    )
                                  );
                                  svg.appendChild(
                                    rootGroup
                                  );
                                  this.svg =
                                    rootGroup;
                                  return svg;
                                },
                            },
                            {
                              key: "_ensureClipGroup",
                              value:
                                function _ensureClipGroup() {
                                  if (
                                    !this.current
                                      .clipGroup
                                  ) {
                                    var clipGroup =
                                      this.svgFactory.createElement(
                                        "svg:g"
                                      );
                                    clipGroup.setAttributeNS(
                                      null,
                                      "clip-path",
                                      this.current
                                        .activeClipUrl
                                    );
                                    this.svg.appendChild(
                                      clipGroup
                                    );
                                    this.current.clipGroup =
                                      clipGroup;
                                  }

                                  return this
                                    .current
                                    .clipGroup;
                                },
                            },
                            {
                              key: "_ensureTransformGroup",
                              value:
                                function _ensureTransformGroup() {
                                  if (
                                    !this.tgrp
                                  ) {
                                    this.tgrp =
                                      this.svgFactory.createElement(
                                        "svg:g"
                                      );
                                    this.tgrp.setAttributeNS(
                                      null,
                                      "transform",
                                      pm(
                                        this
                                          .transformMatrix
                                      )
                                    );

                                    if (
                                      this.current
                                        .activeClipUrl
                                    ) {
                                      this._ensureClipGroup().appendChild(
                                        this.tgrp
                                      );
                                    } else {
                                      this.svg.appendChild(
                                        this.tgrp
                                      );
                                    }
                                  }

                                  return this
                                    .tgrp;
                                },
                            },
                          ]
                        );

                        return SVGGraphics;
                      })();
                }

                /***/
              },
              /* 153 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (
                    typeof Symbol ===
                      "function" &&
                    typeof Symbol.iterator ===
                      "symbol"
                  ) {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return typeof obj;
                    };
                  } else {
                    _typeof = function _typeof(
                      obj
                    ) {
                      return obj &&
                        typeof Symbol ===
                          "function" &&
                        obj.constructor ===
                          Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    };
                  }
                  return _typeof(obj);
                }

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.PDFNodeStream = void 0;

                var _regenerator =
                  _interopRequireDefault(
                    __w_pdfjs_require__(2)
                  );

                var _util =
                  __w_pdfjs_require__(4);

                var _network_utils =
                  __w_pdfjs_require__(154);

                function _interopRequireDefault(
                  obj
                ) {
                  return obj && obj.__esModule
                    ? obj
                    : { default: obj };
                }

                function _inherits(
                  subClass,
                  superClass
                ) {
                  if (
                    typeof superClass !==
                      "function" &&
                    superClass !== null
                  ) {
                    throw new TypeError(
                      "Super expression must either be null or a function"
                    );
                  }
                  subClass.prototype =
                    Object.create(
                      superClass &&
                        superClass.prototype,
                      {
                        constructor: {
                          value: subClass,
                          writable: true,
                          configurable: true,
                        },
                      }
                    );
                  if (superClass)
                    _setPrototypeOf(
                      subClass,
                      superClass
                    );
                }

                function _setPrototypeOf(o, p) {
                  _setPrototypeOf =
                    Object.setPrototypeOf ||
                    function _setPrototypeOf(
                      o,
                      p
                    ) {
                      o.__proto__ = p;
                      return o;
                    };
                  return _setPrototypeOf(o, p);
                }

                function _createSuper(Derived) {
                  var hasNativeReflectConstruct =
                    _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super =
                        _getPrototypeOf(Derived),
                      result;
                    if (
                      hasNativeReflectConstruct
                    ) {
                      var NewTarget =
                        _getPrototypeOf(
                          this
                        ).constructor;
                      result = Reflect.construct(
                        Super,
                        arguments,
                        NewTarget
                      );
                    } else {
                      result = Super.apply(
                        this,
                        arguments
                      );
                    }
                    return _possibleConstructorReturn(
                      this,
                      result
                    );
                  };
                }

                function _possibleConstructorReturn(
                  self,
                  call
                ) {
                  if (
                    call &&
                    (_typeof(call) === "object" ||
                      typeof call === "function")
                  ) {
                    return call;
                  }
                  return _assertThisInitialized(
                    self
                  );
                }

                function _assertThisInitialized(
                  self
                ) {
                  if (self === void 0) {
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  }
                  return self;
                }

                function _isNativeReflectConstruct() {
                  if (
                    typeof Reflect ===
                      "undefined" ||
                    !Reflect.construct
                  )
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(
                      Reflect.construct(
                        Date,
                        [],
                        function () {}
                      )
                    );
                    return true;
                  } catch (e) {
                    return false;
                  }
                }

                function _getPrototypeOf(o) {
                  _getPrototypeOf =
                    Object.setPrototypeOf
                      ? Object.getPrototypeOf
                      : function _getPrototypeOf(
                          o
                        ) {
                          return (
                            o.__proto__ ||
                            Object.getPrototypeOf(
                              o
                            )
                          );
                        };
                  return _getPrototypeOf(o);
                }

                function asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  key,
                  arg
                ) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(
                      _next,
                      _throw
                    );
                  }
                }

                function _asyncToGenerator(fn) {
                  return function () {
                    var self = this,
                      args = arguments;
                    return new Promise(function (
                      resolve,
                      reject
                    ) {
                      var gen = fn.apply(
                        self,
                        args
                      );
                      function _next(value) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "next",
                          value
                        );
                      }
                      function _throw(err) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "throw",
                          err
                        );
                      }
                      _next(undefined);
                    });
                  };
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var fs = __webpack_require__(
                  /*! fs */ "?6e49"
                );

                var http = __webpack_require__(
                  /*! http */ "?0b3b"
                );

                var https = __webpack_require__(
                  /*! https */ "?bfb0"
                );

                var url = __webpack_require__(
                  /*! url */ "?a42f"
                );

                var fileUriRegex =
                  /^file:\/\/\/[a-zA-Z]:\//;

                function parseUrl(sourceUrl) {
                  var parsedUrl =
                    url.parse(sourceUrl);

                  if (
                    parsedUrl.protocol ===
                      "file:" ||
                    parsedUrl.host
                  ) {
                    return parsedUrl;
                  }

                  if (
                    /^[a-z]:[/\\]/i.test(
                      sourceUrl
                    )
                  ) {
                    return url.parse(
                      "file:///".concat(sourceUrl)
                    );
                  }

                  if (!parsedUrl.host) {
                    parsedUrl.protocol = "file:";
                  }

                  return parsedUrl;
                }

                var PDFNodeStream =
                  /*#__PURE__*/ (function () {
                    function PDFNodeStream(
                      source
                    ) {
                      _classCallCheck(
                        this,
                        PDFNodeStream
                      );

                      this.source = source;
                      this.url = parseUrl(
                        source.url
                      );
                      this.isHttp =
                        this.url.protocol ===
                          "http:" ||
                        this.url.protocol ===
                          "https:";
                      this.isFsUrl =
                        this.url.protocol ===
                        "file:";
                      this.httpHeaders =
                        (this.isHttp &&
                          source.httpHeaders) ||
                        {};
                      this._fullRequestReader =
                        null;
                      this._rangeRequestReaders =
                        [];
                    }

                    _createClass(PDFNodeStream, [
                      {
                        key: "_progressiveDataLength",
                        get: function get() {
                          var _this$_fullRequestRea,
                            _this$_fullRequestRea2;

                          return (_this$_fullRequestRea =
                            (_this$_fullRequestRea2 =
                              this
                                ._fullRequestReader) ===
                              null ||
                            _this$_fullRequestRea2 ===
                              void 0
                              ? void 0
                              : _this$_fullRequestRea2._loaded) !==
                            null &&
                            _this$_fullRequestRea !==
                              void 0
                            ? _this$_fullRequestRea
                            : 0;
                        },
                      },
                      {
                        key: "getFullReader",
                        value:
                          function getFullReader() {
                            (0, _util.assert)(
                              !this
                                ._fullRequestReader,
                              "PDFNodeStream.getFullReader can only be called once."
                            );
                            this._fullRequestReader =
                              this.isFsUrl
                                ? new PDFNodeStreamFsFullReader(
                                    this
                                  )
                                : new PDFNodeStreamFullReader(
                                    this
                                  );
                            return this
                              ._fullRequestReader;
                          },
                      },
                      {
                        key: "getRangeReader",
                        value:
                          function getRangeReader(
                            start,
                            end
                          ) {
                            if (
                              end <=
                              this
                                ._progressiveDataLength
                            ) {
                              return null;
                            }

                            var rangeReader = this
                              .isFsUrl
                              ? new PDFNodeStreamFsRangeReader(
                                  this,
                                  start,
                                  end
                                )
                              : new PDFNodeStreamRangeReader(
                                  this,
                                  start,
                                  end
                                );

                            this._rangeRequestReaders.push(
                              rangeReader
                            );

                            return rangeReader;
                          },
                      },
                      {
                        key: "cancelAllRequests",
                        value:
                          function cancelAllRequests(
                            reason
                          ) {
                            if (
                              this
                                ._fullRequestReader
                            ) {
                              this._fullRequestReader.cancel(
                                reason
                              );
                            }

                            var readers =
                              this._rangeRequestReaders.slice(
                                0
                              );

                            readers.forEach(
                              function (reader) {
                                reader.cancel(
                                  reason
                                );
                              }
                            );
                          },
                      },
                    ]);

                    return PDFNodeStream;
                  })();

                exports.PDFNodeStream =
                  PDFNodeStream;

                var BaseFullReader =
                  /*#__PURE__*/ (function () {
                    function BaseFullReader(
                      stream
                    ) {
                      _classCallCheck(
                        this,
                        BaseFullReader
                      );

                      this._url = stream.url;
                      this._done = false;
                      this._storedError = null;
                      this.onProgress = null;
                      var source = stream.source;
                      this._contentLength =
                        source.length;
                      this._loaded = 0;
                      this._filename = null;
                      this._disableRange =
                        source.disableRange ||
                        false;
                      this._rangeChunkSize =
                        source.rangeChunkSize;

                      if (
                        !this._rangeChunkSize &&
                        !this._disableRange
                      ) {
                        this._disableRange = true;
                      }

                      this._isStreamingSupported =
                        !source.disableStream;
                      this._isRangeSupported =
                        !source.disableRange;
                      this._readableStream = null;
                      this._readCapability = (0,
                      _util.createPromiseCapability)();
                      this._headersCapability =
                        (0,
                        _util.createPromiseCapability)();
                    }

                    _createClass(BaseFullReader, [
                      {
                        key: "headersReady",
                        get: function get() {
                          return this
                            ._headersCapability
                            .promise;
                        },
                      },
                      {
                        key: "filename",
                        get: function get() {
                          return this._filename;
                        },
                      },
                      {
                        key: "contentLength",
                        get: function get() {
                          return this
                            ._contentLength;
                        },
                      },
                      {
                        key: "isRangeSupported",
                        get: function get() {
                          return this
                            ._isRangeSupported;
                        },
                      },
                      {
                        key: "isStreamingSupported",
                        get: function get() {
                          return this
                            ._isStreamingSupported;
                        },
                      },
                      {
                        key: "read",
                        value: (function () {
                          var _read =
                            _asyncToGenerator(
                              /*#__PURE__*/ _regenerator[
                                "default"
                              ].mark(
                                function _callee() {
                                  var chunk,
                                    buffer;
                                  return _regenerator[
                                    "default"
                                  ].wrap(
                                    function _callee$(
                                      _context
                                    ) {
                                      while (1) {
                                        switch (
                                          (_context.prev =
                                            _context.next)
                                        ) {
                                          case 0:
                                            _context.next = 2;
                                            return this
                                              ._readCapability
                                              .promise;

                                          case 2:
                                            if (
                                              !this
                                                ._done
                                            ) {
                                              _context.next = 4;
                                              break;
                                            }

                                            return _context.abrupt(
                                              "return",
                                              {
                                                value:
                                                  undefined,
                                                done: true,
                                              }
                                            );

                                          case 4:
                                            if (
                                              !this
                                                ._storedError
                                            ) {
                                              _context.next = 6;
                                              break;
                                            }

                                            throw this
                                              ._storedError;

                                          case 6:
                                            chunk =
                                              this._readableStream.read();

                                            if (
                                              !(
                                                chunk ===
                                                null
                                              )
                                            ) {
                                              _context.next = 10;
                                              break;
                                            }

                                            this._readCapability =
                                              (0,
                                              _util.createPromiseCapability)();
                                            return _context.abrupt(
                                              "return",
                                              this.read()
                                            );

                                          case 10:
                                            this._loaded +=
                                              chunk.length;

                                            if (
                                              this
                                                .onProgress
                                            ) {
                                              this.onProgress(
                                                {
                                                  loaded:
                                                    this
                                                      ._loaded,
                                                  total:
                                                    this
                                                      ._contentLength,
                                                }
                                              );
                                            }

                                            buffer =
                                              new Uint8Array(
                                                chunk
                                              )
                                                .buffer;
                                            return _context.abrupt(
                                              "return",
                                              {
                                                value:
                                                  buffer,
                                                done: false,
                                              }
                                            );

                                          case 14:
                                          case "end":
                                            return _context.stop();
                                        }
                                      }
                                    },
                                    _callee,
                                    this
                                  );
                                }
                              )
                            );

                          function read() {
                            return _read.apply(
                              this,
                              arguments
                            );
                          }

                          return read;
                        })(),
                      },
                      {
                        key: "cancel",
                        value: function cancel(
                          reason
                        ) {
                          if (
                            !this._readableStream
                          ) {
                            this._error(reason);

                            return;
                          }

                          this._readableStream.destroy(
                            reason
                          );
                        },
                      },
                      {
                        key: "_error",
                        value: function _error(
                          reason
                        ) {
                          this._storedError =
                            reason;

                          this._readCapability.resolve();
                        },
                      },
                      {
                        key: "_setReadableStream",
                        value:
                          function _setReadableStream(
                            readableStream
                          ) {
                            var _this = this;

                            this._readableStream =
                              readableStream;
                            readableStream.on(
                              "readable",
                              function () {
                                _this._readCapability.resolve();
                              }
                            );
                            readableStream.on(
                              "end",
                              function () {
                                readableStream.destroy();
                                _this._done = true;

                                _this._readCapability.resolve();
                              }
                            );
                            readableStream.on(
                              "error",
                              function (reason) {
                                _this._error(
                                  reason
                                );
                              }
                            );

                            if (
                              !this
                                ._isStreamingSupported &&
                              this
                                ._isRangeSupported
                            ) {
                              this._error(
                                new _util.AbortException(
                                  "streaming is disabled"
                                )
                              );
                            }

                            if (
                              this._storedError
                            ) {
                              this._readableStream.destroy(
                                this._storedError
                              );
                            }
                          },
                      },
                    ]);

                    return BaseFullReader;
                  })();

                var BaseRangeReader =
                  /*#__PURE__*/ (function () {
                    function BaseRangeReader(
                      stream
                    ) {
                      _classCallCheck(
                        this,
                        BaseRangeReader
                      );

                      this._url = stream.url;
                      this._done = false;
                      this._storedError = null;
                      this.onProgress = null;
                      this._loaded = 0;
                      this._readableStream = null;
                      this._readCapability = (0,
                      _util.createPromiseCapability)();
                      var source = stream.source;
                      this._isStreamingSupported =
                        !source.disableStream;
                    }

                    _createClass(
                      BaseRangeReader,
                      [
                        {
                          key: "isStreamingSupported",
                          get: function get() {
                            return this
                              ._isStreamingSupported;
                          },
                        },
                        {
                          key: "read",
                          value: (function () {
                            var _read2 =
                              _asyncToGenerator(
                                /*#__PURE__*/ _regenerator[
                                  "default"
                                ].mark(
                                  function _callee2() {
                                    var chunk,
                                      buffer;
                                    return _regenerator[
                                      "default"
                                    ].wrap(
                                      function _callee2$(
                                        _context2
                                      ) {
                                        while (
                                          1
                                        ) {
                                          switch (
                                            (_context2.prev =
                                              _context2.next)
                                          ) {
                                            case 0:
                                              _context2.next = 2;
                                              return this
                                                ._readCapability
                                                .promise;

                                            case 2:
                                              if (
                                                !this
                                                  ._done
                                              ) {
                                                _context2.next = 4;
                                                break;
                                              }

                                              return _context2.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    undefined,
                                                  done: true,
                                                }
                                              );

                                            case 4:
                                              if (
                                                !this
                                                  ._storedError
                                              ) {
                                                _context2.next = 6;
                                                break;
                                              }

                                              throw this
                                                ._storedError;

                                            case 6:
                                              chunk =
                                                this._readableStream.read();

                                              if (
                                                !(
                                                  chunk ===
                                                  null
                                                )
                                              ) {
                                                _context2.next = 10;
                                                break;
                                              }

                                              this._readCapability =
                                                (0,
                                                _util.createPromiseCapability)();
                                              return _context2.abrupt(
                                                "return",
                                                this.read()
                                              );

                                            case 10:
                                              this._loaded +=
                                                chunk.length;

                                              if (
                                                this
                                                  .onProgress
                                              ) {
                                                this.onProgress(
                                                  {
                                                    loaded:
                                                      this
                                                        ._loaded,
                                                  }
                                                );
                                              }

                                              buffer =
                                                new Uint8Array(
                                                  chunk
                                                )
                                                  .buffer;
                                              return _context2.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    buffer,
                                                  done: false,
                                                }
                                              );

                                            case 14:
                                            case "end":
                                              return _context2.stop();
                                          }
                                        }
                                      },
                                      _callee2,
                                      this
                                    );
                                  }
                                )
                              );

                            function read() {
                              return _read2.apply(
                                this,
                                arguments
                              );
                            }

                            return read;
                          })(),
                        },
                        {
                          key: "cancel",
                          value: function cancel(
                            reason
                          ) {
                            if (
                              !this
                                ._readableStream
                            ) {
                              this._error(reason);

                              return;
                            }

                            this._readableStream.destroy(
                              reason
                            );
                          },
                        },
                        {
                          key: "_error",
                          value: function _error(
                            reason
                          ) {
                            this._storedError =
                              reason;

                            this._readCapability.resolve();
                          },
                        },
                        {
                          key: "_setReadableStream",
                          value:
                            function _setReadableStream(
                              readableStream
                            ) {
                              var _this2 = this;

                              this._readableStream =
                                readableStream;
                              readableStream.on(
                                "readable",
                                function () {
                                  _this2._readCapability.resolve();
                                }
                              );
                              readableStream.on(
                                "end",
                                function () {
                                  readableStream.destroy();
                                  _this2._done = true;

                                  _this2._readCapability.resolve();
                                }
                              );
                              readableStream.on(
                                "error",
                                function (
                                  reason
                                ) {
                                  _this2._error(
                                    reason
                                  );
                                }
                              );

                              if (
                                this._storedError
                              ) {
                                this._readableStream.destroy(
                                  this
                                    ._storedError
                                );
                              }
                            },
                        },
                      ]
                    );

                    return BaseRangeReader;
                  })();

                function createRequestOptions(
                  parsedUrl,
                  headers
                ) {
                  return {
                    protocol: parsedUrl.protocol,
                    auth: parsedUrl.auth,
                    host: parsedUrl.hostname,
                    port: parsedUrl.port,
                    path: parsedUrl.path,
                    method: "GET",
                    headers: headers,
                  };
                }

                var PDFNodeStreamFullReader =
                  /*#__PURE__*/ (function (
                    _BaseFullReader
                  ) {
                    _inherits(
                      PDFNodeStreamFullReader,
                      _BaseFullReader
                    );

                    var _super = _createSuper(
                      PDFNodeStreamFullReader
                    );

                    function PDFNodeStreamFullReader(
                      stream
                    ) {
                      var _this3;

                      _classCallCheck(
                        this,
                        PDFNodeStreamFullReader
                      );

                      _this3 = _super.call(
                        this,
                        stream
                      );

                      var handleResponse =
                        function handleResponse(
                          response
                        ) {
                          if (
                            response.statusCode ===
                            404
                          ) {
                            var error =
                              new _util.MissingPDFException(
                                'Missing PDF "'.concat(
                                  _this3._url,
                                  '".'
                                )
                              );
                            _this3._storedError =
                              error;

                            _this3._headersCapability.reject(
                              error
                            );

                            return;
                          }

                          _this3._headersCapability.resolve();

                          _this3._setReadableStream(
                            response
                          );

                          var getResponseHeader =
                            function getResponseHeader(
                              name
                            ) {
                              return _this3
                                ._readableStream
                                .headers[
                                name.toLowerCase()
                              ];
                            };

                          var _validateRangeRequest =
                              (0,
                              _network_utils.validateRangeRequestCapabilities)(
                                {
                                  getResponseHeader:
                                    getResponseHeader,
                                  isHttp:
                                    stream.isHttp,
                                  rangeChunkSize:
                                    _this3._rangeChunkSize,
                                  disableRange:
                                    _this3._disableRange,
                                }
                              ),
                            allowRangeRequests =
                              _validateRangeRequest.allowRangeRequests,
                            suggestedLength =
                              _validateRangeRequest.suggestedLength;

                          _this3._isRangeSupported =
                            allowRangeRequests;
                          _this3._contentLength =
                            suggestedLength ||
                            _this3._contentLength;
                          _this3._filename = (0,
                          _network_utils.extractFilenameFromHeader)(
                            getResponseHeader
                          );
                        };

                      _this3._request = null;

                      if (
                        _this3._url.protocol ===
                        "http:"
                      ) {
                        _this3._request =
                          http.request(
                            createRequestOptions(
                              _this3._url,
                              stream.httpHeaders
                            ),
                            handleResponse
                          );
                      } else {
                        _this3._request =
                          https.request(
                            createRequestOptions(
                              _this3._url,
                              stream.httpHeaders
                            ),
                            handleResponse
                          );
                      }

                      _this3._request.on(
                        "error",
                        function (reason) {
                          _this3._storedError =
                            reason;

                          _this3._headersCapability.reject(
                            reason
                          );
                        }
                      );

                      _this3._request.end();

                      return _this3;
                    }

                    return PDFNodeStreamFullReader;
                  })(BaseFullReader);

                var PDFNodeStreamRangeReader =
                  /*#__PURE__*/ (function (
                    _BaseRangeReader
                  ) {
                    _inherits(
                      PDFNodeStreamRangeReader,
                      _BaseRangeReader
                    );

                    var _super2 = _createSuper(
                      PDFNodeStreamRangeReader
                    );

                    function PDFNodeStreamRangeReader(
                      stream,
                      start,
                      end
                    ) {
                      var _this4;

                      _classCallCheck(
                        this,
                        PDFNodeStreamRangeReader
                      );

                      _this4 = _super2.call(
                        this,
                        stream
                      );
                      _this4._httpHeaders = {};

                      for (var property in stream.httpHeaders) {
                        var value =
                          stream.httpHeaders[
                            property
                          ];

                        if (
                          typeof value ===
                          "undefined"
                        ) {
                          continue;
                        }

                        _this4._httpHeaders[
                          property
                        ] = value;
                      }

                      _this4._httpHeaders.Range =
                        "bytes="
                          .concat(start, "-")
                          .concat(end - 1);

                      var handleResponse =
                        function handleResponse(
                          response
                        ) {
                          if (
                            response.statusCode ===
                            404
                          ) {
                            var error =
                              new _util.MissingPDFException(
                                'Missing PDF "'.concat(
                                  _this4._url,
                                  '".'
                                )
                              );
                            _this4._storedError =
                              error;
                            return;
                          }

                          _this4._setReadableStream(
                            response
                          );
                        };

                      _this4._request = null;

                      if (
                        _this4._url.protocol ===
                        "http:"
                      ) {
                        _this4._request =
                          http.request(
                            createRequestOptions(
                              _this4._url,
                              _this4._httpHeaders
                            ),
                            handleResponse
                          );
                      } else {
                        _this4._request =
                          https.request(
                            createRequestOptions(
                              _this4._url,
                              _this4._httpHeaders
                            ),
                            handleResponse
                          );
                      }

                      _this4._request.on(
                        "error",
                        function (reason) {
                          _this4._storedError =
                            reason;
                        }
                      );

                      _this4._request.end();

                      return _this4;
                    }

                    return PDFNodeStreamRangeReader;
                  })(BaseRangeReader);

                var PDFNodeStreamFsFullReader =
                  /*#__PURE__*/ (function (
                    _BaseFullReader2
                  ) {
                    _inherits(
                      PDFNodeStreamFsFullReader,
                      _BaseFullReader2
                    );

                    var _super3 = _createSuper(
                      PDFNodeStreamFsFullReader
                    );

                    function PDFNodeStreamFsFullReader(
                      stream
                    ) {
                      var _this5;

                      _classCallCheck(
                        this,
                        PDFNodeStreamFsFullReader
                      );

                      _this5 = _super3.call(
                        this,
                        stream
                      );
                      var path =
                        decodeURIComponent(
                          _this5._url.path
                        );

                      if (
                        fileUriRegex.test(
                          _this5._url.href
                        )
                      ) {
                        path = path.replace(
                          /^\//,
                          ""
                        );
                      }

                      fs.lstat(
                        path,
                        function (error, stat) {
                          if (error) {
                            if (
                              error.code ===
                              "ENOENT"
                            ) {
                              error =
                                new _util.MissingPDFException(
                                  'Missing PDF "'.concat(
                                    path,
                                    '".'
                                  )
                                );
                            }

                            _this5._storedError =
                              error;

                            _this5._headersCapability.reject(
                              error
                            );

                            return;
                          }

                          _this5._contentLength =
                            stat.size;

                          _this5._setReadableStream(
                            fs.createReadStream(
                              path
                            )
                          );

                          _this5._headersCapability.resolve();
                        }
                      );
                      return _this5;
                    }

                    return PDFNodeStreamFsFullReader;
                  })(BaseFullReader);

                var PDFNodeStreamFsRangeReader =
                  /*#__PURE__*/ (function (
                    _BaseRangeReader2
                  ) {
                    _inherits(
                      PDFNodeStreamFsRangeReader,
                      _BaseRangeReader2
                    );

                    var _super4 = _createSuper(
                      PDFNodeStreamFsRangeReader
                    );

                    function PDFNodeStreamFsRangeReader(
                      stream,
                      start,
                      end
                    ) {
                      var _this6;

                      _classCallCheck(
                        this,
                        PDFNodeStreamFsRangeReader
                      );

                      _this6 = _super4.call(
                        this,
                        stream
                      );
                      var path =
                        decodeURIComponent(
                          _this6._url.path
                        );

                      if (
                        fileUriRegex.test(
                          _this6._url.href
                        )
                      ) {
                        path = path.replace(
                          /^\//,
                          ""
                        );
                      }

                      _this6._setReadableStream(
                        fs.createReadStream(
                          path,
                          {
                            start: start,
                            end: end - 1,
                          }
                        )
                      );

                      return _this6;
                    }

                    return PDFNodeStreamFsRangeReader;
                  })(BaseRangeReader);

                /***/
              },
              /* 154 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.createResponseStatusError =
                  createResponseStatusError;
                exports.extractFilenameFromHeader =
                  extractFilenameFromHeader;
                exports.validateRangeRequestCapabilities =
                  validateRangeRequestCapabilities;
                exports.validateResponseStatus =
                  validateResponseStatus;

                var _util =
                  __w_pdfjs_require__(4);

                var _content_disposition =
                  __w_pdfjs_require__(155);

                function validateRangeRequestCapabilities(
                  _ref
                ) {
                  var getResponseHeader =
                      _ref.getResponseHeader,
                    isHttp = _ref.isHttp,
                    rangeChunkSize =
                      _ref.rangeChunkSize,
                    disableRange =
                      _ref.disableRange;
                  (0, _util.assert)(
                    rangeChunkSize > 0,
                    "Range chunk size must be larger than zero"
                  );
                  var returnValues = {
                    allowRangeRequests: false,
                    suggestedLength: undefined,
                  };
                  var length = parseInt(
                    getResponseHeader(
                      "Content-Length"
                    ),
                    10
                  );

                  if (!Number.isInteger(length)) {
                    return returnValues;
                  }

                  returnValues.suggestedLength =
                    length;

                  if (
                    length <=
                    2 * rangeChunkSize
                  ) {
                    return returnValues;
                  }

                  if (disableRange || !isHttp) {
                    return returnValues;
                  }

                  if (
                    getResponseHeader(
                      "Accept-Ranges"
                    ) !== "bytes"
                  ) {
                    return returnValues;
                  }

                  var contentEncoding =
                    getResponseHeader(
                      "Content-Encoding"
                    ) || "identity";

                  if (
                    contentEncoding !== "identity"
                  ) {
                    return returnValues;
                  }

                  returnValues.allowRangeRequests = true;
                  return returnValues;
                }

                function extractFilenameFromHeader(
                  getResponseHeader
                ) {
                  var contentDisposition =
                    getResponseHeader(
                      "Content-Disposition"
                    );

                  if (contentDisposition) {
                    var filename = (0,
                    _content_disposition.getFilenameFromContentDispositionHeader)(
                      contentDisposition
                    );

                    if (filename.includes("%")) {
                      try {
                        filename =
                          decodeURIComponent(
                            filename
                          );
                      } catch (ex) {}
                    }

                    if (
                      /\.pdf$/i.test(filename)
                    ) {
                      return filename;
                    }
                  }

                  return null;
                }

                function createResponseStatusError(
                  status,
                  url
                ) {
                  if (
                    status === 404 ||
                    (status === 0 &&
                      url.startsWith("file:"))
                  ) {
                    return new _util.MissingPDFException(
                      'Missing PDF "' + url + '".'
                    );
                  }

                  return new _util.UnexpectedResponseException(
                    "Unexpected server response (" +
                      status +
                      ') while retrieving PDF "' +
                      url +
                      '".',
                    status
                  );
                }

                function validateResponseStatus(
                  status
                ) {
                  return (
                    status === 200 ||
                    status === 206
                  );
                }

                /***/
              },
              /* 155 */
              /***/ function (
                __unused_webpack_module,
                exports
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.getFilenameFromContentDispositionHeader =
                  getFilenameFromContentDispositionHeader;

                function _slicedToArray(arr, i) {
                  return (
                    _arrayWithHoles(arr) ||
                    _iterableToArrayLimit(
                      arr,
                      i
                    ) ||
                    _unsupportedIterableToArray(
                      arr,
                      i
                    ) ||
                    _nonIterableRest()
                  );
                }

                function _nonIterableRest() {
                  throw new TypeError(
                    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }

                function _unsupportedIterableToArray(
                  o,
                  minLen
                ) {
                  if (!o) return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                  var n =
                    Object.prototype.toString
                      .call(o)
                      .slice(8, -1);
                  if (
                    n === "Object" &&
                    o.constructor
                  )
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (
                    n === "Arguments" ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                      n
                    )
                  )
                    return _arrayLikeToArray(
                      o,
                      minLen
                    );
                }

                function _arrayLikeToArray(
                  arr,
                  len
                ) {
                  if (
                    len == null ||
                    len > arr.length
                  )
                    len = arr.length;
                  for (
                    var i = 0,
                      arr2 = new Array(len);
                    i < len;
                    i++
                  ) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }

                function _iterableToArrayLimit(
                  arr,
                  i
                ) {
                  if (
                    typeof Symbol ===
                      "undefined" ||
                    !(
                      Symbol.iterator in
                      Object(arr)
                    )
                  )
                    return;
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = undefined;
                  try {
                    for (
                      var _i =
                          arr[Symbol.iterator](),
                        _s;
                      !(_n = (_s = _i.next())
                        .done);
                      _n = true
                    ) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (
                        !_n &&
                        _i["return"] != null
                      )
                        _i["return"]();
                    } finally {
                      if (_d) throw _e;
                    }
                  }
                  return _arr;
                }

                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }

                function getFilenameFromContentDispositionHeader(
                  contentDisposition
                ) {
                  var needsEncodingFixup = true;
                  var tmp = toParamRegExp(
                    "filename\\*",
                    "i"
                  ).exec(contentDisposition);

                  if (tmp) {
                    tmp = tmp[1];
                    var filename =
                      rfc2616unquote(tmp);
                    filename = unescape(filename);
                    filename =
                      rfc5987decode(filename);
                    filename =
                      rfc2047decode(filename);
                    return fixupEncoding(
                      filename
                    );
                  }

                  tmp = rfc2231getparam(
                    contentDisposition
                  );

                  if (tmp) {
                    var _filename =
                      rfc2047decode(tmp);

                    return fixupEncoding(
                      _filename
                    );
                  }

                  tmp = toParamRegExp(
                    "filename",
                    "i"
                  ).exec(contentDisposition);

                  if (tmp) {
                    tmp = tmp[1];

                    var _filename2 =
                      rfc2616unquote(tmp);

                    _filename2 =
                      rfc2047decode(_filename2);
                    return fixupEncoding(
                      _filename2
                    );
                  }

                  function toParamRegExp(
                    attributePattern,
                    flags
                  ) {
                    return new RegExp(
                      "(?:^|;)\\s*" +
                        attributePattern +
                        "\\s*=\\s*" +
                        "(" +
                        '[^";\\s][^;\\s]*' +
                        "|" +
                        '"(?:[^"\\\\]|\\\\"?)+"?' +
                        ")",
                      flags
                    );
                  }

                  function textdecode(
                    encoding,
                    value
                  ) {
                    if (encoding) {
                      if (
                        !/^[\x00-\xFF]+$/.test(
                          value
                        )
                      ) {
                        return value;
                      }

                      try {
                        var decoder =
                          new TextDecoder(
                            encoding,
                            {
                              fatal: true,
                            }
                          );
                        var bytes = Array.from(
                          value,
                          function (ch) {
                            return (
                              ch.charCodeAt(0) &
                              0xff
                            );
                          }
                        );
                        value = decoder.decode(
                          new Uint8Array(bytes)
                        );
                        needsEncodingFixup = false;
                      } catch (e) {
                        if (
                          /^utf-?8$/i.test(
                            encoding
                          )
                        ) {
                          try {
                            value =
                              decodeURIComponent(
                                escape(value)
                              );
                            needsEncodingFixup = false;
                          } catch (err) {}
                        }
                      }
                    }

                    return value;
                  }

                  function fixupEncoding(value) {
                    if (
                      needsEncodingFixup &&
                      /[\x80-\xff]/.test(value)
                    ) {
                      value = textdecode(
                        "utf-8",
                        value
                      );

                      if (needsEncodingFixup) {
                        value = textdecode(
                          "iso-8859-1",
                          value
                        );
                      }
                    }

                    return value;
                  }

                  function rfc2231getparam(
                    contentDispositionStr
                  ) {
                    var matches = [];
                    var match;
                    var iter = toParamRegExp(
                      "filename\\*((?!0\\d)\\d+)(\\*?)",
                      "ig"
                    );

                    while (
                      (match = iter.exec(
                        contentDispositionStr
                      )) !== null
                    ) {
                      var _match = match,
                        _match2 = _slicedToArray(
                          _match,
                          4
                        ),
                        n = _match2[1],
                        quot = _match2[2],
                        part = _match2[3];

                      n = parseInt(n, 10);

                      if (n in matches) {
                        if (n === 0) {
                          break;
                        }

                        continue;
                      }

                      matches[n] = [quot, part];
                    }

                    var parts = [];

                    for (
                      var _n2 = 0;
                      _n2 < matches.length;
                      ++_n2
                    ) {
                      if (!(_n2 in matches)) {
                        break;
                      }

                      var _matches$_n =
                          _slicedToArray(
                            matches[_n2],
                            2
                          ),
                        _quot = _matches$_n[0],
                        _part = _matches$_n[1];

                      _part =
                        rfc2616unquote(_part);

                      if (_quot) {
                        _part = unescape(_part);

                        if (_n2 === 0) {
                          _part =
                            rfc5987decode(_part);
                        }
                      }

                      parts.push(_part);
                    }

                    return parts.join("");
                  }

                  function rfc2616unquote(value) {
                    if (value.startsWith('"')) {
                      var parts = value
                        .slice(1)
                        .split('\\"');

                      for (
                        var i = 0;
                        i < parts.length;
                        ++i
                      ) {
                        var quotindex =
                          parts[i].indexOf('"');

                        if (quotindex !== -1) {
                          parts[i] = parts[
                            i
                          ].slice(0, quotindex);
                          parts.length = i + 1;
                        }

                        parts[i] = parts[
                          i
                        ].replace(/\\(.)/g, "$1");
                      }

                      value = parts.join('"');
                    }

                    return value;
                  }

                  function rfc5987decode(
                    extvalue
                  ) {
                    var encodingend =
                      extvalue.indexOf("'");

                    if (encodingend === -1) {
                      return extvalue;
                    }

                    var encoding = extvalue.slice(
                      0,
                      encodingend
                    );
                    var langvalue =
                      extvalue.slice(
                        encodingend + 1
                      );
                    var value = langvalue.replace(
                      /^[^']*'/,
                      ""
                    );
                    return textdecode(
                      encoding,
                      value
                    );
                  }

                  function rfc2047decode(value) {
                    if (
                      !value.startsWith("=?") ||
                      /[\x00-\x19\x80-\xff]/.test(
                        value
                      )
                    ) {
                      return value;
                    }

                    return value.replace(
                      /=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g,
                      function (
                        matches,
                        charset,
                        encoding,
                        text
                      ) {
                        if (
                          encoding === "q" ||
                          encoding === "Q"
                        ) {
                          text = text.replace(
                            /_/g,
                            " "
                          );
                          text = text.replace(
                            /=([0-9a-fA-F]{2})/g,
                            function (
                              match,
                              hex
                            ) {
                              return String.fromCharCode(
                                parseInt(hex, 16)
                              );
                            }
                          );
                          return textdecode(
                            charset,
                            text
                          );
                        }

                        try {
                          text = atob(text);
                        } catch (e) {}

                        return textdecode(
                          charset,
                          text
                        );
                      }
                    );
                  }

                  return "";
                }

                /***/
              },
              /* 156 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.PDFNetworkStream = void 0;

                var _regenerator =
                  _interopRequireDefault(
                    __w_pdfjs_require__(2)
                  );

                var _util =
                  __w_pdfjs_require__(4);

                var _network_utils =
                  __w_pdfjs_require__(154);

                function _interopRequireDefault(
                  obj
                ) {
                  return obj && obj.__esModule
                    ? obj
                    : { default: obj };
                }

                function asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  key,
                  arg
                ) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(
                      _next,
                      _throw
                    );
                  }
                }

                function _asyncToGenerator(fn) {
                  return function () {
                    var self = this,
                      args = arguments;
                    return new Promise(function (
                      resolve,
                      reject
                    ) {
                      var gen = fn.apply(
                        self,
                        args
                      );
                      function _next(value) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "next",
                          value
                        );
                      }
                      function _throw(err) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "throw",
                          err
                        );
                      }
                      _next(undefined);
                    });
                  };
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                var OK_RESPONSE = 200;
                var PARTIAL_CONTENT_RESPONSE = 206;

                function getArrayBuffer(xhr) {
                  var data = xhr.response;

                  if (typeof data !== "string") {
                    return data;
                  }

                  var array = (0,
                  _util.stringToBytes)(data);
                  return array.buffer;
                }

                var NetworkManager =
                  /*#__PURE__*/ (function () {
                    function NetworkManager(
                      url,
                      args
                    ) {
                      _classCallCheck(
                        this,
                        NetworkManager
                      );

                      this.url = url;
                      args = args || {};
                      this.isHttp =
                        /^https?:/i.test(url);
                      this.httpHeaders =
                        (this.isHttp &&
                          args.httpHeaders) ||
                        {};
                      this.withCredentials =
                        args.withCredentials ||
                        false;

                      this.getXhr =
                        args.getXhr ||
                        function NetworkManager_getXhr() {
                          return new XMLHttpRequest();
                        };

                      this.currXhrId = 0;
                      this.pendingRequests =
                        Object.create(null);
                    }

                    _createClass(NetworkManager, [
                      {
                        key: "requestRange",
                        value:
                          function requestRange(
                            begin,
                            end,
                            listeners
                          ) {
                            var args = {
                              begin: begin,
                              end: end,
                            };

                            for (var prop in listeners) {
                              args[prop] =
                                listeners[prop];
                            }

                            return this.request(
                              args
                            );
                          },
                      },
                      {
                        key: "requestFull",
                        value:
                          function requestFull(
                            listeners
                          ) {
                            return this.request(
                              listeners
                            );
                          },
                      },
                      {
                        key: "request",
                        value: function request(
                          args
                        ) {
                          var xhr = this.getXhr();
                          var xhrId = this
                            .currXhrId++;
                          var pendingRequest =
                            (this.pendingRequests[
                              xhrId
                            ] = {
                              xhr: xhr,
                            });
                          xhr.open(
                            "GET",
                            this.url
                          );
                          xhr.withCredentials =
                            this.withCredentials;

                          for (var property in this
                            .httpHeaders) {
                            var value =
                              this.httpHeaders[
                                property
                              ];

                            if (
                              typeof value ===
                              "undefined"
                            ) {
                              continue;
                            }

                            xhr.setRequestHeader(
                              property,
                              value
                            );
                          }

                          if (
                            this.isHttp &&
                            "begin" in args &&
                            "end" in args
                          ) {
                            xhr.setRequestHeader(
                              "Range",
                              "bytes="
                                .concat(
                                  args.begin,
                                  "-"
                                )
                                .concat(
                                  args.end - 1
                                )
                            );
                            pendingRequest.expectedStatus =
                              PARTIAL_CONTENT_RESPONSE;
                          } else {
                            pendingRequest.expectedStatus =
                              OK_RESPONSE;
                          }

                          xhr.responseType =
                            "arraybuffer";

                          if (args.onError) {
                            xhr.onerror =
                              function (evt) {
                                args.onError(
                                  xhr.status
                                );
                              };
                          }

                          xhr.onreadystatechange =
                            this.onStateChange.bind(
                              this,
                              xhrId
                            );
                          xhr.onprogress =
                            this.onProgress.bind(
                              this,
                              xhrId
                            );
                          pendingRequest.onHeadersReceived =
                            args.onHeadersReceived;
                          pendingRequest.onDone =
                            args.onDone;
                          pendingRequest.onError =
                            args.onError;
                          pendingRequest.onProgress =
                            args.onProgress;
                          xhr.send(null);
                          return xhrId;
                        },
                      },
                      {
                        key: "onProgress",
                        value:
                          function onProgress(
                            xhrId,
                            evt
                          ) {
                            var pendingRequest =
                              this
                                .pendingRequests[
                                xhrId
                              ];

                            if (!pendingRequest) {
                              return;
                            }

                            if (
                              pendingRequest.onProgress
                            ) {
                              pendingRequest.onProgress(
                                evt
                              );
                            }
                          },
                      },
                      {
                        key: "onStateChange",
                        value:
                          function onStateChange(
                            xhrId,
                            evt
                          ) {
                            var pendingRequest =
                              this
                                .pendingRequests[
                                xhrId
                              ];

                            if (!pendingRequest) {
                              return;
                            }

                            var xhr =
                              pendingRequest.xhr;

                            if (
                              xhr.readyState >=
                                2 &&
                              pendingRequest.onHeadersReceived
                            ) {
                              pendingRequest.onHeadersReceived();
                              delete pendingRequest.onHeadersReceived;
                            }

                            if (
                              xhr.readyState !== 4
                            ) {
                              return;
                            }

                            if (
                              !(
                                xhrId in
                                this
                                  .pendingRequests
                              )
                            ) {
                              return;
                            }

                            delete this
                              .pendingRequests[
                              xhrId
                            ];

                            if (
                              xhr.status === 0 &&
                              this.isHttp
                            ) {
                              if (
                                pendingRequest.onError
                              ) {
                                pendingRequest.onError(
                                  xhr.status
                                );
                              }

                              return;
                            }

                            var xhrStatus =
                              xhr.status ||
                              OK_RESPONSE;
                            var ok_response_on_range_request =
                              xhrStatus ===
                                OK_RESPONSE &&
                              pendingRequest.expectedStatus ===
                                PARTIAL_CONTENT_RESPONSE;

                            if (
                              !ok_response_on_range_request &&
                              xhrStatus !==
                                pendingRequest.expectedStatus
                            ) {
                              if (
                                pendingRequest.onError
                              ) {
                                pendingRequest.onError(
                                  xhr.status
                                );
                              }

                              return;
                            }

                            var chunk =
                              getArrayBuffer(xhr);

                            if (
                              xhrStatus ===
                              PARTIAL_CONTENT_RESPONSE
                            ) {
                              var rangeHeader =
                                xhr.getResponseHeader(
                                  "Content-Range"
                                );
                              var matches =
                                /bytes (\d+)-(\d+)\/(\d+)/.exec(
                                  rangeHeader
                                );
                              pendingRequest.onDone(
                                {
                                  begin: parseInt(
                                    matches[1],
                                    10
                                  ),
                                  chunk: chunk,
                                }
                              );
                            } else if (chunk) {
                              pendingRequest.onDone(
                                {
                                  begin: 0,
                                  chunk: chunk,
                                }
                              );
                            } else if (
                              pendingRequest.onError
                            ) {
                              pendingRequest.onError(
                                xhr.status
                              );
                            }
                          },
                      },
                      {
                        key: "getRequestXhr",
                        value:
                          function getRequestXhr(
                            xhrId
                          ) {
                            return this
                              .pendingRequests[
                              xhrId
                            ].xhr;
                          },
                      },
                      {
                        key: "isPendingRequest",
                        value:
                          function isPendingRequest(
                            xhrId
                          ) {
                            return (
                              xhrId in
                              this.pendingRequests
                            );
                          },
                      },
                      {
                        key: "abortRequest",
                        value:
                          function abortRequest(
                            xhrId
                          ) {
                            var xhr =
                              this
                                .pendingRequests[
                                xhrId
                              ].xhr;
                            delete this
                              .pendingRequests[
                              xhrId
                            ];
                            xhr.abort();
                          },
                      },
                    ]);

                    return NetworkManager;
                  })();

                var PDFNetworkStream =
                  /*#__PURE__*/ (function () {
                    function PDFNetworkStream(
                      source
                    ) {
                      _classCallCheck(
                        this,
                        PDFNetworkStream
                      );

                      this._source = source;
                      this._manager =
                        new NetworkManager(
                          source.url,
                          {
                            httpHeaders:
                              source.httpHeaders,
                            withCredentials:
                              source.withCredentials,
                          }
                        );
                      this._rangeChunkSize =
                        source.rangeChunkSize;
                      this._fullRequestReader =
                        null;
                      this._rangeRequestReaders =
                        [];
                    }

                    _createClass(
                      PDFNetworkStream,
                      [
                        {
                          key: "_onRangeRequestReaderClosed",
                          value:
                            function _onRangeRequestReaderClosed(
                              reader
                            ) {
                              var i =
                                this._rangeRequestReaders.indexOf(
                                  reader
                                );

                              if (i >= 0) {
                                this._rangeRequestReaders.splice(
                                  i,
                                  1
                                );
                              }
                            },
                        },
                        {
                          key: "getFullReader",
                          value:
                            function getFullReader() {
                              (0, _util.assert)(
                                !this
                                  ._fullRequestReader,
                                "PDFNetworkStream.getFullReader can only be called once."
                              );
                              this._fullRequestReader =
                                new PDFNetworkStreamFullRequestReader(
                                  this._manager,
                                  this._source
                                );
                              return this
                                ._fullRequestReader;
                            },
                        },
                        {
                          key: "getRangeReader",
                          value:
                            function getRangeReader(
                              begin,
                              end
                            ) {
                              var reader =
                                new PDFNetworkStreamRangeRequestReader(
                                  this._manager,
                                  begin,
                                  end
                                );
                              reader.onClosed =
                                this._onRangeRequestReaderClosed.bind(
                                  this
                                );

                              this._rangeRequestReaders.push(
                                reader
                              );

                              return reader;
                            },
                        },
                        {
                          key: "cancelAllRequests",
                          value:
                            function cancelAllRequests(
                              reason
                            ) {
                              if (
                                this
                                  ._fullRequestReader
                              ) {
                                this._fullRequestReader.cancel(
                                  reason
                                );
                              }

                              var readers =
                                this._rangeRequestReaders.slice(
                                  0
                                );

                              readers.forEach(
                                function (
                                  reader
                                ) {
                                  reader.cancel(
                                    reason
                                  );
                                }
                              );
                            },
                        },
                      ]
                    );

                    return PDFNetworkStream;
                  })();

                exports.PDFNetworkStream =
                  PDFNetworkStream;

                var PDFNetworkStreamFullRequestReader =
                  /*#__PURE__*/ (function () {
                    function PDFNetworkStreamFullRequestReader(
                      manager,
                      source
                    ) {
                      _classCallCheck(
                        this,
                        PDFNetworkStreamFullRequestReader
                      );

                      this._manager = manager;
                      var args = {
                        onHeadersReceived:
                          this._onHeadersReceived.bind(
                            this
                          ),
                        onDone:
                          this._onDone.bind(this),
                        onError:
                          this._onError.bind(
                            this
                          ),
                        onProgress:
                          this._onProgress.bind(
                            this
                          ),
                      };
                      this._url = source.url;
                      this._fullRequestId =
                        manager.requestFull(args);
                      this._headersReceivedCapability =
                        (0,
                        _util.createPromiseCapability)();
                      this._disableRange =
                        source.disableRange ||
                        false;
                      this._contentLength =
                        source.length;
                      this._rangeChunkSize =
                        source.rangeChunkSize;

                      if (
                        !this._rangeChunkSize &&
                        !this._disableRange
                      ) {
                        this._disableRange = true;
                      }

                      this._isStreamingSupported = false;
                      this._isRangeSupported = false;
                      this._cachedChunks = [];
                      this._requests = [];
                      this._done = false;
                      this._storedError =
                        undefined;
                      this._filename = null;
                      this.onProgress = null;
                    }

                    _createClass(
                      PDFNetworkStreamFullRequestReader,
                      [
                        {
                          key: "_onHeadersReceived",
                          value:
                            function _onHeadersReceived() {
                              var fullRequestXhrId =
                                this
                                  ._fullRequestId;

                              var fullRequestXhr =
                                this._manager.getRequestXhr(
                                  fullRequestXhrId
                                );

                              var getResponseHeader =
                                function getResponseHeader(
                                  name
                                ) {
                                  return fullRequestXhr.getResponseHeader(
                                    name
                                  );
                                };

                              var _validateRangeRequest =
                                  (0,
                                  _network_utils.validateRangeRequestCapabilities)(
                                    {
                                      getResponseHeader:
                                        getResponseHeader,
                                      isHttp:
                                        this
                                          ._manager
                                          .isHttp,
                                      rangeChunkSize:
                                        this
                                          ._rangeChunkSize,
                                      disableRange:
                                        this
                                          ._disableRange,
                                    }
                                  ),
                                allowRangeRequests =
                                  _validateRangeRequest.allowRangeRequests,
                                suggestedLength =
                                  _validateRangeRequest.suggestedLength;

                              if (
                                allowRangeRequests
                              ) {
                                this._isRangeSupported = true;
                              }

                              this._contentLength =
                                suggestedLength ||
                                this
                                  ._contentLength;
                              this._filename = (0,
                              _network_utils.extractFilenameFromHeader)(
                                getResponseHeader
                              );

                              if (
                                this
                                  ._isRangeSupported
                              ) {
                                this._manager.abortRequest(
                                  fullRequestXhrId
                                );
                              }

                              this._headersReceivedCapability.resolve();
                            },
                        },
                        {
                          key: "_onDone",
                          value: function _onDone(
                            args
                          ) {
                            if (args) {
                              if (
                                this._requests
                                  .length > 0
                              ) {
                                var requestCapability =
                                  this._requests.shift();

                                requestCapability.resolve(
                                  {
                                    value:
                                      args.chunk,
                                    done: false,
                                  }
                                );
                              } else {
                                this._cachedChunks.push(
                                  args.chunk
                                );
                              }
                            }

                            this._done = true;

                            if (
                              this._cachedChunks
                                .length > 0
                            ) {
                              return;
                            }

                            this._requests.forEach(
                              function (
                                requestCapability
                              ) {
                                requestCapability.resolve(
                                  {
                                    value:
                                      undefined,
                                    done: true,
                                  }
                                );
                              }
                            );

                            this._requests = [];
                          },
                        },
                        {
                          key: "_onError",
                          value:
                            function _onError(
                              status
                            ) {
                              var url = this._url;
                              var exception = (0,
                              _network_utils.createResponseStatusError)(
                                status,
                                url
                              );
                              this._storedError =
                                exception;

                              this._headersReceivedCapability.reject(
                                exception
                              );

                              this._requests.forEach(
                                function (
                                  requestCapability
                                ) {
                                  requestCapability.reject(
                                    exception
                                  );
                                }
                              );

                              this._requests = [];
                              this._cachedChunks =
                                [];
                            },
                        },
                        {
                          key: "_onProgress",
                          value:
                            function _onProgress(
                              data
                            ) {
                              if (
                                this.onProgress
                              ) {
                                this.onProgress({
                                  loaded:
                                    data.loaded,
                                  total:
                                    data.lengthComputable
                                      ? data.total
                                      : this
                                          ._contentLength,
                                });
                              }
                            },
                        },
                        {
                          key: "filename",
                          get: function get() {
                            return this._filename;
                          },
                        },
                        {
                          key: "isRangeSupported",
                          get: function get() {
                            return this
                              ._isRangeSupported;
                          },
                        },
                        {
                          key: "isStreamingSupported",
                          get: function get() {
                            return this
                              ._isStreamingSupported;
                          },
                        },
                        {
                          key: "contentLength",
                          get: function get() {
                            return this
                              ._contentLength;
                          },
                        },
                        {
                          key: "headersReady",
                          get: function get() {
                            return this
                              ._headersReceivedCapability
                              .promise;
                          },
                        },
                        {
                          key: "read",
                          value: (function () {
                            var _read =
                              _asyncToGenerator(
                                /*#__PURE__*/ _regenerator[
                                  "default"
                                ].mark(
                                  function _callee() {
                                    var chunk,
                                      requestCapability;
                                    return _regenerator[
                                      "default"
                                    ].wrap(
                                      function _callee$(
                                        _context
                                      ) {
                                        while (
                                          1
                                        ) {
                                          switch (
                                            (_context.prev =
                                              _context.next)
                                          ) {
                                            case 0:
                                              if (
                                                !this
                                                  ._storedError
                                              ) {
                                                _context.next = 2;
                                                break;
                                              }

                                              throw this
                                                ._storedError;

                                            case 2:
                                              if (
                                                !(
                                                  this
                                                    ._cachedChunks
                                                    .length >
                                                  0
                                                )
                                              ) {
                                                _context.next = 5;
                                                break;
                                              }

                                              chunk =
                                                this._cachedChunks.shift();
                                              return _context.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    chunk,
                                                  done: false,
                                                }
                                              );

                                            case 5:
                                              if (
                                                !this
                                                  ._done
                                              ) {
                                                _context.next = 7;
                                                break;
                                              }

                                              return _context.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    undefined,
                                                  done: true,
                                                }
                                              );

                                            case 7:
                                              requestCapability =
                                                (0,
                                                _util.createPromiseCapability)();

                                              this._requests.push(
                                                requestCapability
                                              );

                                              return _context.abrupt(
                                                "return",
                                                requestCapability.promise
                                              );

                                            case 10:
                                            case "end":
                                              return _context.stop();
                                          }
                                        }
                                      },
                                      _callee,
                                      this
                                    );
                                  }
                                )
                              );

                            function read() {
                              return _read.apply(
                                this,
                                arguments
                              );
                            }

                            return read;
                          })(),
                        },
                        {
                          key: "cancel",
                          value: function cancel(
                            reason
                          ) {
                            this._done = true;

                            this._headersReceivedCapability.reject(
                              reason
                            );

                            this._requests.forEach(
                              function (
                                requestCapability
                              ) {
                                requestCapability.resolve(
                                  {
                                    value:
                                      undefined,
                                    done: true,
                                  }
                                );
                              }
                            );

                            this._requests = [];

                            if (
                              this._manager.isPendingRequest(
                                this
                                  ._fullRequestId
                              )
                            ) {
                              this._manager.abortRequest(
                                this
                                  ._fullRequestId
                              );
                            }

                            this._fullRequestReader =
                              null;
                          },
                        },
                      ]
                    );

                    return PDFNetworkStreamFullRequestReader;
                  })();

                var PDFNetworkStreamRangeRequestReader =
                  /*#__PURE__*/ (function () {
                    function PDFNetworkStreamRangeRequestReader(
                      manager,
                      begin,
                      end
                    ) {
                      _classCallCheck(
                        this,
                        PDFNetworkStreamRangeRequestReader
                      );

                      this._manager = manager;
                      var args = {
                        onDone:
                          this._onDone.bind(this),
                        onProgress:
                          this._onProgress.bind(
                            this
                          ),
                      };
                      this._requestId =
                        manager.requestRange(
                          begin,
                          end,
                          args
                        );
                      this._requests = [];
                      this._queuedChunk = null;
                      this._done = false;
                      this.onProgress = null;
                      this.onClosed = null;
                    }

                    _createClass(
                      PDFNetworkStreamRangeRequestReader,
                      [
                        {
                          key: "_close",
                          value:
                            function _close() {
                              if (this.onClosed) {
                                this.onClosed(
                                  this
                                );
                              }
                            },
                        },
                        {
                          key: "_onDone",
                          value: function _onDone(
                            data
                          ) {
                            var chunk =
                              data.chunk;

                            if (
                              this._requests
                                .length > 0
                            ) {
                              var requestCapability =
                                this._requests.shift();

                              requestCapability.resolve(
                                {
                                  value: chunk,
                                  done: false,
                                }
                              );
                            } else {
                              this._queuedChunk =
                                chunk;
                            }

                            this._done = true;

                            this._requests.forEach(
                              function (
                                requestCapability
                              ) {
                                requestCapability.resolve(
                                  {
                                    value:
                                      undefined,
                                    done: true,
                                  }
                                );
                              }
                            );

                            this._requests = [];

                            this._close();
                          },
                        },
                        {
                          key: "_onProgress",
                          value:
                            function _onProgress(
                              evt
                            ) {
                              if (
                                !this
                                  .isStreamingSupported &&
                                this.onProgress
                              ) {
                                this.onProgress({
                                  loaded:
                                    evt.loaded,
                                });
                              }
                            },
                        },
                        {
                          key: "isStreamingSupported",
                          get: function get() {
                            return false;
                          },
                        },
                        {
                          key: "read",
                          value: (function () {
                            var _read2 =
                              _asyncToGenerator(
                                /*#__PURE__*/ _regenerator[
                                  "default"
                                ].mark(
                                  function _callee2() {
                                    var chunk,
                                      requestCapability;
                                    return _regenerator[
                                      "default"
                                    ].wrap(
                                      function _callee2$(
                                        _context2
                                      ) {
                                        while (
                                          1
                                        ) {
                                          switch (
                                            (_context2.prev =
                                              _context2.next)
                                          ) {
                                            case 0:
                                              if (
                                                !(
                                                  this
                                                    ._queuedChunk !==
                                                  null
                                                )
                                              ) {
                                                _context2.next = 4;
                                                break;
                                              }

                                              chunk =
                                                this
                                                  ._queuedChunk;
                                              this._queuedChunk =
                                                null;
                                              return _context2.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    chunk,
                                                  done: false,
                                                }
                                              );

                                            case 4:
                                              if (
                                                !this
                                                  ._done
                                              ) {
                                                _context2.next = 6;
                                                break;
                                              }

                                              return _context2.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    undefined,
                                                  done: true,
                                                }
                                              );

                                            case 6:
                                              requestCapability =
                                                (0,
                                                _util.createPromiseCapability)();

                                              this._requests.push(
                                                requestCapability
                                              );

                                              return _context2.abrupt(
                                                "return",
                                                requestCapability.promise
                                              );

                                            case 9:
                                            case "end":
                                              return _context2.stop();
                                          }
                                        }
                                      },
                                      _callee2,
                                      this
                                    );
                                  }
                                )
                              );

                            function read() {
                              return _read2.apply(
                                this,
                                arguments
                              );
                            }

                            return read;
                          })(),
                        },
                        {
                          key: "cancel",
                          value: function cancel(
                            reason
                          ) {
                            this._done = true;

                            this._requests.forEach(
                              function (
                                requestCapability
                              ) {
                                requestCapability.resolve(
                                  {
                                    value:
                                      undefined,
                                    done: true,
                                  }
                                );
                              }
                            );

                            this._requests = [];

                            if (
                              this._manager.isPendingRequest(
                                this._requestId
                              )
                            ) {
                              this._manager.abortRequest(
                                this._requestId
                              );
                            }

                            this._close();
                          },
                        },
                      ]
                    );

                    return PDFNetworkStreamRangeRequestReader;
                  })();

                /***/
              },
              /* 157 */
              /***/ function (
                __unused_webpack_module,
                exports,
                __w_pdfjs_require__
              ) {
                "use strict";

                Object.defineProperty(
                  exports,
                  "__esModule",
                  {
                    value: true,
                  }
                );
                exports.PDFFetchStream = void 0;

                var _regenerator =
                  _interopRequireDefault(
                    __w_pdfjs_require__(2)
                  );

                var _util =
                  __w_pdfjs_require__(4);

                var _network_utils =
                  __w_pdfjs_require__(154);

                function _interopRequireDefault(
                  obj
                ) {
                  return obj && obj.__esModule
                    ? obj
                    : { default: obj };
                }

                function asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  key,
                  arg
                ) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(
                      _next,
                      _throw
                    );
                  }
                }

                function _asyncToGenerator(fn) {
                  return function () {
                    var self = this,
                      args = arguments;
                    return new Promise(function (
                      resolve,
                      reject
                    ) {
                      var gen = fn.apply(
                        self,
                        args
                      );
                      function _next(value) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "next",
                          value
                        );
                      }
                      function _throw(err) {
                        asyncGeneratorStep(
                          gen,
                          resolve,
                          reject,
                          _next,
                          _throw,
                          "throw",
                          err
                        );
                      }
                      _next(undefined);
                    });
                  };
                }

                function _classCallCheck(
                  instance,
                  Constructor
                ) {
                  if (
                    !(
                      instance instanceof
                      Constructor
                    )
                  ) {
                    throw new TypeError(
                      "Cannot call a class as a function"
                    );
                  }
                }

                function _defineProperties(
                  target,
                  props
                ) {
                  for (
                    var i = 0;
                    i < props.length;
                    i++
                  ) {
                    var descriptor = props[i];
                    descriptor.enumerable =
                      descriptor.enumerable ||
                      false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(
                      target,
                      descriptor.key,
                      descriptor
                    );
                  }
                }

                function _createClass(
                  Constructor,
                  protoProps,
                  staticProps
                ) {
                  if (protoProps)
                    _defineProperties(
                      Constructor.prototype,
                      protoProps
                    );
                  if (staticProps)
                    _defineProperties(
                      Constructor,
                      staticProps
                    );
                  return Constructor;
                }

                function createFetchOptions(
                  headers,
                  withCredentials,
                  abortController
                ) {
                  return {
                    method: "GET",
                    headers: headers,
                    signal:
                      abortController === null ||
                      abortController === void 0
                        ? void 0
                        : abortController.signal,
                    mode: "cors",
                    credentials: withCredentials
                      ? "include"
                      : "same-origin",
                    redirect: "follow",
                  };
                }

                function createHeaders(
                  httpHeaders
                ) {
                  var headers = new Headers();

                  for (var property in httpHeaders) {
                    var value =
                      httpHeaders[property];

                    if (
                      typeof value === "undefined"
                    ) {
                      continue;
                    }

                    headers.append(
                      property,
                      value
                    );
                  }

                  return headers;
                }

                var PDFFetchStream =
                  /*#__PURE__*/ (function () {
                    function PDFFetchStream(
                      source
                    ) {
                      _classCallCheck(
                        this,
                        PDFFetchStream
                      );

                      this.source = source;
                      this.isHttp =
                        /^https?:/i.test(
                          source.url
                        );
                      this.httpHeaders =
                        (this.isHttp &&
                          source.httpHeaders) ||
                        {};
                      this._fullRequestReader =
                        null;
                      this._rangeRequestReaders =
                        [];
                    }

                    _createClass(PDFFetchStream, [
                      {
                        key: "_progressiveDataLength",
                        get: function get() {
                          var _this$_fullRequestRea,
                            _this$_fullRequestRea2;

                          return (_this$_fullRequestRea =
                            (_this$_fullRequestRea2 =
                              this
                                ._fullRequestReader) ===
                              null ||
                            _this$_fullRequestRea2 ===
                              void 0
                              ? void 0
                              : _this$_fullRequestRea2._loaded) !==
                            null &&
                            _this$_fullRequestRea !==
                              void 0
                            ? _this$_fullRequestRea
                            : 0;
                        },
                      },
                      {
                        key: "getFullReader",
                        value:
                          function getFullReader() {
                            (0, _util.assert)(
                              !this
                                ._fullRequestReader,
                              "PDFFetchStream.getFullReader can only be called once."
                            );
                            this._fullRequestReader =
                              new PDFFetchStreamReader(
                                this
                              );
                            return this
                              ._fullRequestReader;
                          },
                      },
                      {
                        key: "getRangeReader",
                        value:
                          function getRangeReader(
                            begin,
                            end
                          ) {
                            if (
                              end <=
                              this
                                ._progressiveDataLength
                            ) {
                              return null;
                            }

                            var reader =
                              new PDFFetchStreamRangeReader(
                                this,
                                begin,
                                end
                              );

                            this._rangeRequestReaders.push(
                              reader
                            );

                            return reader;
                          },
                      },
                      {
                        key: "cancelAllRequests",
                        value:
                          function cancelAllRequests(
                            reason
                          ) {
                            if (
                              this
                                ._fullRequestReader
                            ) {
                              this._fullRequestReader.cancel(
                                reason
                              );
                            }

                            var readers =
                              this._rangeRequestReaders.slice(
                                0
                              );

                            readers.forEach(
                              function (reader) {
                                reader.cancel(
                                  reason
                                );
                              }
                            );
                          },
                      },
                    ]);

                    return PDFFetchStream;
                  })();

                exports.PDFFetchStream =
                  PDFFetchStream;

                var PDFFetchStreamReader =
                  /*#__PURE__*/ (function () {
                    function PDFFetchStreamReader(
                      stream
                    ) {
                      var _this = this;

                      _classCallCheck(
                        this,
                        PDFFetchStreamReader
                      );

                      this._stream = stream;
                      this._reader = null;
                      this._loaded = 0;
                      this._filename = null;
                      var source = stream.source;
                      this._withCredentials =
                        source.withCredentials ||
                        false;
                      this._contentLength =
                        source.length;
                      this._headersCapability =
                        (0,
                        _util.createPromiseCapability)();
                      this._disableRange =
                        source.disableRange ||
                        false;
                      this._rangeChunkSize =
                        source.rangeChunkSize;

                      if (
                        !this._rangeChunkSize &&
                        !this._disableRange
                      ) {
                        this._disableRange = true;
                      }

                      if (
                        typeof AbortController !==
                        "undefined"
                      ) {
                        this._abortController =
                          new AbortController();
                      }

                      this._isStreamingSupported =
                        !source.disableStream;
                      this._isRangeSupported =
                        !source.disableRange;
                      this._headers =
                        createHeaders(
                          this._stream.httpHeaders
                        );
                      var url = source.url;
                      fetch(
                        url,
                        createFetchOptions(
                          this._headers,
                          this._withCredentials,
                          this._abortController
                        )
                      )
                        .then(function (
                          response
                        ) {
                          if (
                            !(0,
                            _network_utils.validateResponseStatus)(
                              response.status
                            )
                          ) {
                            throw (0,
                            _network_utils.createResponseStatusError)(
                              response.status,
                              url
                            );
                          }

                          _this._reader =
                            response.body.getReader();

                          _this._headersCapability.resolve();

                          var getResponseHeader =
                            function getResponseHeader(
                              name
                            ) {
                              return response.headers.get(
                                name
                              );
                            };

                          var _validateRangeRequest =
                              (0,
                              _network_utils.validateRangeRequestCapabilities)(
                                {
                                  getResponseHeader:
                                    getResponseHeader,
                                  isHttp:
                                    _this._stream
                                      .isHttp,
                                  rangeChunkSize:
                                    _this._rangeChunkSize,
                                  disableRange:
                                    _this._disableRange,
                                }
                              ),
                            allowRangeRequests =
                              _validateRangeRequest.allowRangeRequests,
                            suggestedLength =
                              _validateRangeRequest.suggestedLength;

                          _this._isRangeSupported =
                            allowRangeRequests;
                          _this._contentLength =
                            suggestedLength ||
                            _this._contentLength;
                          _this._filename = (0,
                          _network_utils.extractFilenameFromHeader)(
                            getResponseHeader
                          );

                          if (
                            !_this._isStreamingSupported &&
                            _this._isRangeSupported
                          ) {
                            _this.cancel(
                              new _util.AbortException(
                                "Streaming is disabled."
                              )
                            );
                          }
                        })
                        ["catch"](
                          this._headersCapability
                            .reject
                        );
                      this.onProgress = null;
                    }

                    _createClass(
                      PDFFetchStreamReader,
                      [
                        {
                          key: "headersReady",
                          get: function get() {
                            return this
                              ._headersCapability
                              .promise;
                          },
                        },
                        {
                          key: "filename",
                          get: function get() {
                            return this._filename;
                          },
                        },
                        {
                          key: "contentLength",
                          get: function get() {
                            return this
                              ._contentLength;
                          },
                        },
                        {
                          key: "isRangeSupported",
                          get: function get() {
                            return this
                              ._isRangeSupported;
                          },
                        },
                        {
                          key: "isStreamingSupported",
                          get: function get() {
                            return this
                              ._isStreamingSupported;
                          },
                        },
                        {
                          key: "read",
                          value: (function () {
                            var _read =
                              _asyncToGenerator(
                                /*#__PURE__*/ _regenerator[
                                  "default"
                                ].mark(
                                  function _callee() {
                                    var _yield$this$_reader$r,
                                      value,
                                      done,
                                      buffer;

                                    return _regenerator[
                                      "default"
                                    ].wrap(
                                      function _callee$(
                                        _context
                                      ) {
                                        while (
                                          1
                                        ) {
                                          switch (
                                            (_context.prev =
                                              _context.next)
                                          ) {
                                            case 0:
                                              _context.next = 2;
                                              return this
                                                ._headersCapability
                                                .promise;

                                            case 2:
                                              _context.next = 4;
                                              return this._reader.read();

                                            case 4:
                                              _yield$this$_reader$r =
                                                _context.sent;
                                              value =
                                                _yield$this$_reader$r.value;
                                              done =
                                                _yield$this$_reader$r.done;

                                              if (
                                                !done
                                              ) {
                                                _context.next = 9;
                                                break;
                                              }

                                              return _context.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    value,
                                                  done: done,
                                                }
                                              );

                                            case 9:
                                              this._loaded +=
                                                value.byteLength;

                                              if (
                                                this
                                                  .onProgress
                                              ) {
                                                this.onProgress(
                                                  {
                                                    loaded:
                                                      this
                                                        ._loaded,
                                                    total:
                                                      this
                                                        ._contentLength,
                                                  }
                                                );
                                              }

                                              buffer =
                                                new Uint8Array(
                                                  value
                                                )
                                                  .buffer;
                                              return _context.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    buffer,
                                                  done: false,
                                                }
                                              );

                                            case 13:
                                            case "end":
                                              return _context.stop();
                                          }
                                        }
                                      },
                                      _callee,
                                      this
                                    );
                                  }
                                )
                              );

                            function read() {
                              return _read.apply(
                                this,
                                arguments
                              );
                            }

                            return read;
                          })(),
                        },
                        {
                          key: "cancel",
                          value: function cancel(
                            reason
                          ) {
                            if (this._reader) {
                              this._reader.cancel(
                                reason
                              );
                            }

                            if (
                              this
                                ._abortController
                            ) {
                              this._abortController.abort();
                            }
                          },
                        },
                      ]
                    );

                    return PDFFetchStreamReader;
                  })();

                var PDFFetchStreamRangeReader =
                  /*#__PURE__*/ (function () {
                    function PDFFetchStreamRangeReader(
                      stream,
                      begin,
                      end
                    ) {
                      var _this2 = this;

                      _classCallCheck(
                        this,
                        PDFFetchStreamRangeReader
                      );

                      this._stream = stream;
                      this._reader = null;
                      this._loaded = 0;
                      var source = stream.source;
                      this._withCredentials =
                        source.withCredentials ||
                        false;
                      this._readCapability = (0,
                      _util.createPromiseCapability)();
                      this._isStreamingSupported =
                        !source.disableStream;

                      if (
                        typeof AbortController !==
                        "undefined"
                      ) {
                        this._abortController =
                          new AbortController();
                      }

                      this._headers =
                        createHeaders(
                          this._stream.httpHeaders
                        );

                      this._headers.append(
                        "Range",
                        "bytes="
                          .concat(begin, "-")
                          .concat(end - 1)
                      );

                      var url = source.url;
                      fetch(
                        url,
                        createFetchOptions(
                          this._headers,
                          this._withCredentials,
                          this._abortController
                        )
                      )
                        .then(function (
                          response
                        ) {
                          if (
                            !(0,
                            _network_utils.validateResponseStatus)(
                              response.status
                            )
                          ) {
                            throw (0,
                            _network_utils.createResponseStatusError)(
                              response.status,
                              url
                            );
                          }

                          _this2._readCapability.resolve();

                          _this2._reader =
                            response.body.getReader();
                        })
                        ["catch"](function (
                          reason
                        ) {
                          if (
                            (reason === null ||
                            reason === void 0
                              ? void 0
                              : reason.name) ===
                            "AbortError"
                          ) {
                            return;
                          }

                          throw reason;
                        });
                      this.onProgress = null;
                    }

                    _createClass(
                      PDFFetchStreamRangeReader,
                      [
                        {
                          key: "isStreamingSupported",
                          get: function get() {
                            return this
                              ._isStreamingSupported;
                          },
                        },
                        {
                          key: "read",
                          value: (function () {
                            var _read2 =
                              _asyncToGenerator(
                                /*#__PURE__*/ _regenerator[
                                  "default"
                                ].mark(
                                  function _callee2() {
                                    var _yield$this$_reader$r2,
                                      value,
                                      done,
                                      buffer;

                                    return _regenerator[
                                      "default"
                                    ].wrap(
                                      function _callee2$(
                                        _context2
                                      ) {
                                        while (
                                          1
                                        ) {
                                          switch (
                                            (_context2.prev =
                                              _context2.next)
                                          ) {
                                            case 0:
                                              _context2.next = 2;
                                              return this
                                                ._readCapability
                                                .promise;

                                            case 2:
                                              _context2.next = 4;
                                              return this._reader.read();

                                            case 4:
                                              _yield$this$_reader$r2 =
                                                _context2.sent;
                                              value =
                                                _yield$this$_reader$r2.value;
                                              done =
                                                _yield$this$_reader$r2.done;

                                              if (
                                                !done
                                              ) {
                                                _context2.next = 9;
                                                break;
                                              }

                                              return _context2.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    value,
                                                  done: done,
                                                }
                                              );

                                            case 9:
                                              this._loaded +=
                                                value.byteLength;

                                              if (
                                                this
                                                  .onProgress
                                              ) {
                                                this.onProgress(
                                                  {
                                                    loaded:
                                                      this
                                                        ._loaded,
                                                  }
                                                );
                                              }

                                              buffer =
                                                new Uint8Array(
                                                  value
                                                )
                                                  .buffer;
                                              return _context2.abrupt(
                                                "return",
                                                {
                                                  value:
                                                    buffer,
                                                  done: false,
                                                }
                                              );

                                            case 13:
                                            case "end":
                                              return _context2.stop();
                                          }
                                        }
                                      },
                                      _callee2,
                                      this
                                    );
                                  }
                                )
                              );

                            function read() {
                              return _read2.apply(
                                this,
                                arguments
                              );
                            }

                            return read;
                          })(),
                        },
                        {
                          key: "cancel",
                          value: function cancel(
                            reason
                          ) {
                            if (this._reader) {
                              this._reader.cancel(
                                reason
                              );
                            }

                            if (
                              this
                                ._abortController
                            ) {
                              this._abortController.abort();
                            }
                          },
                        },
                      ]
                    );

                    return PDFFetchStreamRangeReader;
                  })();

                /***/
              },
              /******/
            ];
            /************************************************************************/
            /******/ // The module cache
            /******/ var __webpack_module_cache__ =
              {};
            /******/
            /******/ // The require function
            /******/ function __w_pdfjs_require__(
              moduleId
            ) {
              /******/ // Check if module is in cache
              /******/ if (
                __webpack_module_cache__[moduleId]
              ) {
                /******/ return __webpack_module_cache__[
                  moduleId
                ].exports;
                /******/
              }
              /******/ // Create a new module (and put it into the cache)
              /******/ var module =
                (__webpack_module_cache__[
                  moduleId
                ] = {
                  /******/ id: moduleId,
                  /******/ loaded: false,
                  /******/ exports: {},
                  /******/
                });
              /******/
              /******/ // Execute the module function
              /******/ __webpack_modules__[
                moduleId
              ].call(
                module.exports,
                module,
                module.exports,
                __w_pdfjs_require__
              );
              /******/
              /******/ // Flag the module as loaded
              /******/ module.loaded = true;
              /******/
              /******/ // Return the exports of the module
              /******/ return module.exports;
              /******/
            }
            /******/
            /************************************************************************/
            /******/ /* webpack/runtime/node module decorator */ /******/ !(function () {
              /******/ __w_pdfjs_require__.nmd =
                function (module) {
                  /******/ module.paths = [];
                  /******/ if (!module.children)
                    module.children = [];
                  /******/ return module;
                  /******/
                };
              /******/
            })();
            /******/
            /************************************************************************/
            /******/ // module exports must be returned from runtime so entry inlining is disabled
            /******/ // startup
            /******/ // Load entry module and return exports
            /******/ return __w_pdfjs_require__(
              0
            );
            /******/
          })();
        });
        //# sourceMappingURL=pdf.js.map

        /***/
      },

    /***/ "./extensions/PDF/PDFFontExtractor.js":
      /*!********************************************!*\
  !*** ./extensions/PDF/PDFFontExtractor.js ***!
  \********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        "use strict";
        __webpack_require__.r(
          __webpack_exports__
        );
        /* harmony export */ __webpack_require__.d(
          __webpack_exports__,
          {
            /* harmony export */ cssFontExtractor:
              () =>
                /* binding */ cssFontExtractor,
            /* harmony export */
          }
        );
        /* harmony import */ var opentype_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! opentype.js */ "./node_modules/opentype.js/dist/opentype.js"
          );
        /* harmony import */ var opentype_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            opentype_js__WEBPACK_IMPORTED_MODULE_0__
          );

        /**
         * In PDF, text encoding was handled differently, all the char code was transcoded
         * When we want to show the text in the browser, we have to transcode it back
         * Then user can see the correct font type and also can do selection/copy
         * If we don't transcode it back, we have to do the unicode for each text,
         * and select/copy will not be possible
         *
         * @param {Number} encoded
         * @param {PDF.FontFaceObject} fontInfo
         */
        function locateCharacter(
          encoded,
          fontFace
        ) {
          // Locate the index of the charecter
          let index = -1;
          for (
            var i = 0;
            i < fontFace.toFontChar.length;
            i++
          ) {
            if (
              fontFace.toFontChar[i] === encoded
            ) {
              index = i;
              break;
            }
          }

          if (
            index != -1 &&
            fontFace.toUnicode._map
          ) {
            let character =
              fontFace.toUnicode._map[index];
            let width = fontFace.widths[index];
            return {
              character,
              width,
            };
          } else {
            // it might be white space or font part
          }
        }

        function cssFontExtractor(
          page,
          loadedFonts
        ) {
          loadedFonts = loadedFonts || {};
          var commonObjs = page.commonObjs.objs;
          var fonts = [];
          for (let key in commonObjs) {
            var obj = commonObjs[key].data;
            // check it is a font
            if (
              obj.loadedName &&
              obj.fallbackName &&
              obj.data
            ) {
              if (loadedFonts[obj.loadedName]) {
                continue;
              }

              let font =
                opentype_js__WEBPACK_IMPORTED_MODULE_0__.parse(
                  obj.data.buffer
                );

              // need to locate the charector and change the glyph
              // PDF use swapped charactor code mapping, in order to make browser work
              // we have to change the glyph back to the original ascii/unicode value
              let glyphs = font.glyphs.glyphs;
              for (let glyphKey in glyphs) {
                let glyph = glyphs[glyphKey];
                if (
                  !glyph.name &&
                  !glyph.unicode
                ) {
                  // undefined name will trigger exception in the encoding stage
                  glyph.name = "";
                } else {
                  let charInfo = locateCharacter(
                    glyph.unicode,
                    obj
                  );
                  if (
                    !charInfo ||
                    charInfo.character ==
                      undefined
                  ) {
                    // undefined name will trigger exception in the encoding stage
                    glyph.name = "";
                  } else {
                    glyph.name =
                      charInfo.character;
                    glyph.unicode =
                      charInfo.character.charCodeAt(
                        0
                      );
                    glyph.unicodes = [
                      glyph.unicode,
                    ];
                  }
                }
              }
              fonts.push({
                fontName: key,
                data: font,
              });
              font.names.fontFamily.en = key;
              font.names.fontSubfamily.en =
                "Regular";
            }
          }

          var promises = fonts.map((font) => {
            return new Promise(
              (resolve, reject) => {
                var reader = new FileReader();
                // font.data.toArrayBuffer is slow
                // Forked the opentype.js and make the encoding part much faster
                // Consider to do a PR to opentype.js in future
                var dataView = new DataView(
                  font.data.toArrayBuffer()
                );
                var blob = new Blob([dataView], {
                  type: "font/opentype",
                });
                reader.readAsDataURL(blob);
                reader.onloadend = function () {
                  resolve({
                    css: `
                    @font-face {
                        font-family: ${font.fontName};
                        src: url('${reader.result}');
                    }`,
                    name: font.fontName,
                  });
                };
              }
            );
          });

          return Promise.all(promises).then(
            (data) => {
              return data;
            }
          );
        }

        /***/
      },

    /***/ "./extensions/PDF/PDFLoader.js":
      /*!*************************************!*\
  !*** ./extensions/PDF/PDFLoader.js ***!
  \*************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        "use strict";
        __webpack_require__.r(
          __webpack_exports__
        );
        /* harmony export */ __webpack_require__.d(
          __webpack_exports__,
          {
            /* harmony export */ PDFLoader: () =>
              /* binding */ PDFLoader,
            /* harmony export */
          }
        );
        /* harmony import */ var _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! @adsk/pdfjs-dist */ "./node_modules/@adsk/pdfjs-dist/legacy/build/pdf.js"
          );
        /* harmony import */ var _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _font_engine__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./font-engine */ "./extensions/PDF/font-engine.js"
          );

        // Delay-init variables that require Autodesk.Extension.CompGeom
        let LmvCanvasContext = null;
        let isRef = null;
        let refKey = null;
        const MOBILE_DIM_CAP = 2048;
        const FIREFOX_DIM_CAP = 4096;
        const DEFAULT_DIM_CAP = 8192;

        const initCompGeom = () => {
          LmvCanvasContext =
            Autodesk.Extensions.CompGeom
              .LmvCanvasContext;
          isRef = LmvCanvasContext.isRef;
          refKey = LmvCanvasContext.refKey;
        };

        // LMV-5060 When user change model, we don't know the intent why?
        // User might navigate to another page in the same PDF or trying to load a new different model
        // In order to save loading time, we need to use this object try to defer the destroy method of previous PDF worker
        // Then we can try to avoid memory leak in the meantime to make it much faster to navigate between pages
        const PDFWorkingReferenceMap = {};
        const DefferedDestroyTime = 3000; // 3 seconds

        const av = Autodesk.Viewing;
        const avp = av.Private;

        // FOR IE11 ONLY, LMV-5380
        if (
          typeof document !== "undefined" &&
          document.currentScript === undefined
        ) {
          const ext = false ? 0 : "js";
          _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc =
            avp.getResourceUrl(
              "extensions/PDF/PDF.worker." + ext
            );
        }

        /** @constructor */
        function PDFLoader(parent) {
          initCompGeom();

          this.isPdfLoader = true; // For QA only
          this.viewer3DImpl = parent;
          this.setGlobalManager(
            this.viewer3DImpl.globalManager
          );
          this.loading = false;
          this.tmpMatrix = new THREE.Matrix4();

          this.logger = avp.logger;
          this.loadTime = 0;
          this.notifiesFirstPixel = true;

          this.dtor = this.dtor.bind(this);
          this.viewer3DImpl.api.addEventListener(
            av.VIEWER_UNINITIALIZED,
            this.dtor,
            { once: true }
          );
        }

        av.GlobalManagerMixin.call(
          PDFLoader.prototype
        );

        /**
         * BubbleNode Structure for PDF data will help to do page navigation
         * @param {PDF} pdf PDF object from pdf.js
         */
        PDFLoader.prototype.createPDFDocument =
          function (pdf) {
            var numPages = pdf.numPages;
            var guid = pdf.fingerprint;
            var me = this;
            // Let the generator stay along with document lifecycle, it will give us a chance to maximum the caching
            // to get the best performance
            var parent = {
              guid: guid,
              type: "design",
              hasThumbnail: "false",
              progress: "complete",
              status: "success",
              success: "100%",
              name: "PDF",
              isVectorPDF: true,
              role: "viewable",
              totalRasterPixels: 0,
              getPDF: function () {
                // this can avoid issue in searilization
                if (
                  pdf &&
                  pdf._transport &&
                  !pdf._transport.destroyed
                ) {
                  return pdf;
                } else {
                  return null;
                }
              },
            };

            var children = [];

            for (var i = 1; i <= numPages; i++) {
              children.push({
                guid: guid + "/" + i,
                type: "geometry",
                role: "2d",
                status: "success",
                progress: "complete",
                viewableID: guid + "/" + i,
                name: av.i18n.translate(
                  "Page %(i)",
                  { i }
                ),
                page: i,
                children: [
                  {
                    role: av.BubbleNode
                      .PDF_PAGE_NODE.role,
                    page: i,
                    type: "geometry",
                    status: "success",
                    progress: "commplete",
                    urn: me.svfUrn,
                  },
                ],
              });
            }

            parent.children = children;
            return new av.Document(parent);
          };

        PDFLoader.prototype.dtor = function () {
          if (this.svf && this.svf.propDbLoader) {
            this.svf.propDbLoader.dtor();
            this.svf.propDbLoader = null;
          }

          this.currentLoadPath = null;
          this.isf2d = undefined;
          this.viewer3DImpl.api.removeEventListener(
            av.VIEWER_UNINITIALIZED,
            this.dtor
          );

          if (this.pdf) {
            // Reset the flag synchronized here
            delete PDFWorkingReferenceMap[
              this.pdf.fingerprint
            ];
            setTimeout(() => {
              // If the PDF is used in DefferedDestroyTime time, the PDF will be still alive
              // Otherwise the pdf worker is gonna be destroyed, and the document has been load again.
              if (
                !PDFWorkingReferenceMap[
                  this.pdf.fingerprint
                ]
              ) {
                this.pdf.destroy();
                this.pdf = null;
              }
            }, DefferedDestroyTime);
          }

          if (this._renderTask) {
            this._renderTask.cancel();
            this._renderTask = null;
          }

          this.svf = null;
          this.options = null;
          avp.logger.log("PDFLoader destroy");
        };

        PDFLoader.prototype.loadFile = function (
          path,
          options,
          onSuccess,
          onWorkerStart
        ) {
          if (this.loading) {
            avp.logger.log(
              "Loading of PDF already in progress. Ignoring new request."
            );
            return false;
          }
          this.loading = true;

          const urnIdx = path.indexOf("urn:");
          if (urnIdx !== -1) {
            // Extract urn:adsk.viewing:foo.bar.whateverjunks out of the path URL and bind it to logger.
            // From now on, we can send logs to viewing service, and logs are grouped by urn to make Splunk work.
            path = decodeURIComponent(path);
            const urn = path.substr(
              urnIdx,
              path.substr(urnIdx).indexOf("/")
            );
            avp.logger.log(
              "Extracted URN: " + urn
            );

            // Extract urn(just base64 code)
            const _index = urn.lastIndexOf(":");
            this.svfUrn = urn.substr(_index + 1);

            //V2 only accepts URL encoded paths
            const qIdx = path.indexOf(
              "?",
              urnIdx
            );
            if (qIdx !== -1) {
              path =
                path.slice(0, urnIdx) +
                encodeURIComponent(
                  path.slice(urnIdx, qIdx)
                ) +
                path.slice(qIdx);
            } else {
              path =
                path.slice(0, urnIdx) +
                encodeURIComponent(
                  path.slice(urnIdx)
                );
            }
          } else {
            this.svfUrn = path;
          }

          this.sharedDbPath =
            options.sharedPropertyDbPath;
          this.currentLoadPath = path;
          this.acmSessionId =
            options.acmSessionId;

          //This is done to avoid CORS errors on content served from proxy or browser cache
          //The cache will respond with a previously received response, but the Access-Control-Allow-Origin
          //response header might not match the current Origin header (e.g. localhost vs. developer.api.autodesk.com)
          //which will cause a CORS error on the second request for the same resource.
          this.queryParams = [
            this.acmSessionId &&
              `acmsession=${this.acmSessionId}`,
            av.endpoint.getQueryParams(),
          ]
            .filter((p) => p)
            .join("&");

          this.options = options;

          if (this.options.placementTransform) {
            //NOTE: The scale of the placement transform is not always sufficient to
            //determine the correct scale for line widths. This is because when a 2D model (in inches) is
            //loaded into a 3d scene in feet, the transform includes all the scaling needed to get into feet
            //but the model space line weight for the drawing is relative to the drawing itself, so an extra
            //factor of 12 would be needed in such case to cancel out the 1/12 needed for inch->foot.
            //This could probably be automatically derived, but in an error prone way, so I'm leaving it
            //up to the application layer that does the model aggregation to pass in the right model scale as an option.
            this.modelScale =
              this.options.modelScale ||
              this.options.placementTransform.getMaxScaleOnAxis();
          } else {
            this.modelScale =
              this.options.modelScale || 1;
          }

          var scope = this;

          scope.loadFydoCB(
            path,
            options,
            onSuccess,
            onWorkerStart
          );

          return true;
        };

        PDFLoader.prototype.getDocument =
          function () {
            return this.options.bubbleNode.getRootNode()
              .data;
          };

        PDFLoader.prototype.getFontGenerator =
          function () {
            return this.viewer3DImpl.api
              .loadExtension("Autodesk.MSDF")
              .then(() => {
                const generator =
                  new Autodesk.MSDF.Generator();
                generator.setGlobalManager(
                  this.globalManager
                );
                return generator;
              });
          };

        PDFLoader.prototype.createFontAtlas =
          function (page, cacheKey) {
            if (PDFLoader.enableMSDFText) {
              // Fetching the operation list will trigger the font loading
              // The loaded font event will be trigger in next tick
              // So we need use timeout to let the app continue
              return new Promise(
                (resolve, reject) => {
                  this.getOperatorList(page).then(
                    () => {
                      setTimeout(() => {
                        this.getFontGenerator().then(
                          (generator) => {
                            generator
                              .createFontAtlasForPDF(
                                page,
                                cacheKey
                              )
                              .then(
                                (fontAtlas) => {
                                  resolve(
                                    fontAtlas
                                  );
                                }
                              );
                          }
                        );
                      }, 0);
                    }
                  );
                }
              );
            } else {
              return Promise.resolve();
            }
          };

        PDFLoader.prototype.evaluatePageLineStyles =
          function (page) {
            return this.getOperatorList(
              page
            ).then((data) => {
              let w = 0;
              let cacheSet = new Set();

              for (
                var i = 0;
                i < data.fnArray.length;
                i++
              ) {
                if (
                  data.fnArray[i] ==
                  _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                    .OPS.setDash
                ) {
                  w = Math.max(
                    w,
                    data.argsArray[i][0].length
                  );
                  let key =
                    data.argsArray[i].join("/");
                  cacheSet.add(key);
                }
              }

              let h = cacheSet.size + 1;
              this.pageLineStyleParams = {
                width: w,
                height: h,
              };
            });
          };

        PDFLoader.prototype.detectSmallImageSequences =
          function (page) {
            const MAX_OP_DISTANCE = 12;
            const MIN_OPS = 5 * MAX_OP_DISTANCE;
            const MAX_PAGE_UNIT_DISTANCE = 100;

            //console.time("detectSmallImageSequences");
            return this.getOperatorList(page)
              .then((data) => {
                function isSmallImage(index) {
                  const op = data.fnArray[index];
                  if (
                    op ===
                      _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.paintJpegXObject ||
                    op ===
                      _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.paintImageXObject
                  ) {
                    const w =
                      data.argsArray[index][1];
                    const h =
                      data.argsArray[index][2];
                    return w <= 2 || h <= 2;
                  }
                  if (
                    op ===
                      _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS
                        .paintImageMaskXObject ||
                    op ===
                      _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS
                        .paintInlineImageXObject
                  ) {
                    const w =
                      data.argsArray[index][0]
                        .width;
                    const h =
                      data.argsArray[index][0]
                        .height;
                    return w <= 2 || h <= 2;
                  }
                  return false;
                }

                function findSequenceStart(
                  index
                ) {
                  // scan backwards for at most MAX_OP_DISTANCE ops and find the first PDFJS.OPS.save
                  // on the way, no PDFJS.OPS.restore or anything text-related must be found
                  // this logic is supposed to detect cases like (index points to "image")
                  //   - save transform image restore
                  //   - save transform constructpath clip endpath save transform image restore restore
                  const end = Math.max(
                    -1,
                    index - MAX_OP_DISTANCE
                  );
                  let i = index - 1;
                  let q = -1; // if no PDFJS.OPS.save is found, -1 will signal "no sequence"
                  let qCount = 0;
                  for (; i > end; i--) {
                    const op = data.fnArray[i];
                    switch (op) {
                      case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.save:
                        q = i;
                        qCount++;
                        break;
                      case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.showText:
                      case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.showSpacedText:
                      case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.nextLineShowText:
                      case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS
                        .nextLineSetSpacingShowText:
                      case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.restore:
                        i = end;
                        break;
                    }
                  }

                  return { q, qCount };
                }

                function findSequenceEnd(
                  index,
                  qCount
                ) {
                  // scan forwards for at most MAX_OP_DISTANCE ops and find the qCount'th PDFJS.OPS.restore
                  const end = Math.min(
                    data.fnArray.length,
                    index + MAX_OP_DISTANCE
                  );
                  let i = index + 1;
                  let q = index + 1;
                  for (
                    ;
                    i < end && qCount > 0;
                    i++
                  ) {
                    const op = data.fnArray[i];
                    if (
                      op ==
                      _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.restore
                    ) {
                      q = i;
                      qCount--;
                    }
                  }

                  // if not enough PDFJS.OPS.restore are found, mark sequence as broken
                  return qCount > 0 ? -1 : q;
                }

                function addPointBBox(
                  bbox,
                  x,
                  y
                ) {
                  bbox[0] = Math.min(bbox[0], x);
                  bbox[1] = Math.min(bbox[1], y);
                  bbox[2] = Math.max(bbox[2], x);
                  bbox[3] = Math.max(bbox[3], y);
                }

                function addImageBBox(
                  bbox,
                  xform
                ) {
                  // images use a fixed [0, 0]x[1, 1] space => transform each corner and add to bbox
                  // xform uses the canvas context convention: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/transform
                  addPointBBox(
                    bbox,
                    xform[4],
                    xform[5]
                  );
                  addPointBBox(
                    bbox,
                    1 * xform[2] + xform[4],
                    1 * xform[3] + xform[5]
                  );
                  addPointBBox(
                    bbox,
                    1 * xform[0] + xform[4],
                    1 * xform[1] + xform[5]
                  );
                  addPointBBox(
                    bbox,
                    1 * xform[0] +
                      1 * xform[2] +
                      xform[4],
                    1 * xform[1] +
                      1 * xform[3] +
                      xform[5]
                  );
                }

                function process() {
                  let sequenceStart = {
                    q: -1,
                    qCount: 0,
                  };
                  let lastSmallImage = -1;
                  let smallImageSequences = [];
                  let currXform = [
                    1, 0, 0, 1, 0, 0,
                  ];
                  let xformStack = [];
                  let bbox = [
                    1e10, 1e10, -1e10, -1e10,
                  ]; // [minx, miny, maxx, maxy]

                  const beginSequence = function (
                    i
                  ) {
                    sequenceStart =
                      findSequenceStart(i);
                    lastSmallImage = i;
                    bbox = [
                      1e10, 1e10, -1e10, -1e10,
                    ];
                  };

                  const endSequence =
                    function () {
                      const end = findSequenceEnd(
                        lastSmallImage,
                        sequenceStart.qCount
                      );
                      // if the sequence is too short, ignore it (performance gain would be too small)
                      if (
                        end >= 0 &&
                        end >
                          sequenceStart.q +
                            MIN_OPS
                      ) {
                        // sequence ended correctly
                        smallImageSequences.push({
                          start: sequenceStart.q,
                          end,
                          bbox,
                        });
                      }
                    };

                  for (
                    let i = 0;
                    i < data.fnArray.length;
                    i++
                  ) {
                    const op = data.fnArray[i];
                    if (
                      op ==
                      _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.save
                    ) {
                      xformStack.push(currXform);
                      currXform = currXform.slice(
                        0,
                        6
                      );
                    } else if (
                      op ==
                      _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.transform
                    ) {
                      const m = currXform;
                      const a = data.argsArray[i];
                      currXform = [
                        m[0] * a[0] + m[2] * a[1],
                        m[1] * a[0] + m[3] * a[1],
                        m[0] * a[2] + m[2] * a[3],
                        m[1] * a[2] + m[3] * a[3],
                        m[0] * a[4] +
                          m[2] * a[5] +
                          m[4],
                        m[1] * a[4] +
                          m[3] * a[5] +
                          m[5],
                      ];
                    } else if (
                      op ==
                      _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                        .OPS.restore
                    ) {
                      currXform =
                        xformStack.pop() || [
                          1, 0, 0, 1, 0, 0,
                        ];
                    } else if (isSmallImage(i)) {
                      // is this a new sequence?
                      if (sequenceStart.q < 0) {
                        beginSequence(i);
                      } else if (
                        i >
                        lastSmallImage +
                          MAX_OP_DISTANCE
                      ) {
                        // too many operators between the previous small image and the current -> end sequence and start a new one
                        endSequence();
                        beginSequence(i);
                      } else {
                        // check if the image is too far away from last image (i.e., it should start new sequence)
                        let bboxImg = [
                          1e10, 1e10, -1e10,
                          -1e10,
                        ];
                        addImageBBox(
                          bboxImg,
                          currXform
                        );
                        // skip the check for the first few images as the sequence needs to establish a reasonable line length first
                        if (
                          i - sequenceStart.q >
                            MIN_OPS &&
                          (bboxImg[2] <
                            bbox[0] -
                              MAX_PAGE_UNIT_DISTANCE ||
                            bboxImg[0] >
                              bbox[2] +
                                MAX_PAGE_UNIT_DISTANCE ||
                            bboxImg[3] <
                              bbox[1] -
                                MAX_PAGE_UNIT_DISTANCE ||
                            bboxImg[1] >
                              bbox[3] +
                                MAX_PAGE_UNIT_DISTANCE)
                        ) {
                          // end sequence and start a new one
                          endSequence();
                          beginSequence(i);
                        } else {
                          // just add to current sequence
                          lastSmallImage = i;
                        }
                      }

                      if (lastSmallImage >= 0) {
                        addImageBBox(
                          bbox,
                          currXform
                        );
                      }
                    }
                  }

                  // end last sequence
                  if (lastSmallImage >= 0) {
                    endSequence();
                  }

                  return smallImageSequences;
                }

                this.smallImageSequences =
                  process();
                //console.timeEnd("detectSmallImageSequences");
              })
              .catch(console.error);
          };

        /**
         * When we do synchronized loading pdf referenced object, it might return empty if that content was not loaded
         * Asynchronized way is better, but it increases the complexity of loading it
         * This function is prefly for parsing those references
         */
        PDFLoader.prototype.loadMarkedContentPropertiesReferences =
          function (pdf, page) {
            var referenceObjMap = {};

            function getRefObj(ref) {
              return pdf
                .getObject(ref)
                .then((data) => {
                  referenceObjMap[
                    refKey(data.key)
                  ] = data.value;
                  // loop in one more level for dictionary
                  var childPromises = [];
                  if (data.isDictionary) {
                    for (let itemKey in data.value) {
                      if (
                        isRef(data.value[itemKey])
                      ) {
                        if (
                          referenceObjMap[
                            refKey(
                              data.value[itemKey]
                            )
                          ]
                        ) {
                          data.value[itemKey] =
                            referenceObjMap[
                              refKey(
                                data.value[
                                  itemKey
                                ]
                              )
                            ];
                        } else {
                          childPromises.push(
                            pdf
                              .getObject(
                                data.value[
                                  itemKey
                                ]
                              )
                              .then((data1) => {
                                data.value[
                                  itemKey
                                ] = data1.value;
                                referenceObjMap[
                                  refKey(
                                    data1.key
                                  )
                                ] = data1.value;
                              })
                              .catch(
                                avp.logger.log
                              )
                          );
                        }
                      }
                    }
                  }

                  return Promise.all(
                    childPromises
                  );
                })
                .catch(avp.logger.log); // for any missing reference object, just ignore and continue
            }

            return this.getOperatorList(
              page
            ).then((ops) => {
              var promises = [];
              for (
                var i = 0;
                i < ops.fnArray.length;
                i++
              ) {
                if (
                  ops.fnArray[i] ==
                    _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                      .OPS.beginMarkedContent ||
                  ops.fnArray[i] ==
                    _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                      .OPS.beginMarkedContentProps
                ) {
                  var args1 = ops.argsArray[i];
                  for (
                    let j = 0;
                    args1 && j < args1.length;
                    j++
                  ) {
                    if (isRef(args1[j])) {
                      let promise = getRefObj(
                        args1[j]
                      );
                      promises.push(promise);
                    } else if (
                      typeof args1[j] == "object"
                    ) {
                      for (let key in args1[j]) {
                        if (
                          isRef(args1[j][key])
                        ) {
                          let promise = getRefObj(
                            args1[j][key]
                          );
                          promises.push(promise);
                        }
                      }
                    }
                  }
                }
              }

              return (
                Promise.all(promises)
                  // This is a nice to have feature, in case of anything wrong, ust ignore and continue
                  .catch(avp.logger.log)
                  .then(() => {
                    return referenceObjMap;
                  })
              );
            });
          };

        PDFLoader.prototype.loadFydoCB =
          function (
            path,
            options,
            onSuccess,
            onWorkerStart
          ) {
            this.t0 = Date.now();

            var svfPath = avp.pathToURL(path);
            if (this.queryParams) {
              svfPath += "?" + this.queryParams;
            }

            var scope = this;

            if (onWorkerStart) onWorkerStart();

            let cMapUrl = options.cMapUrl;
            let cMapPacked = options.cMapPacked;
            if (!cMapUrl) {
              cMapUrl = avp.getResourceUrl(
                "extensions/PDF/cmaps/"
              );
              cMapPacked = true;
            }

            var params = {
              url: svfPath,
              disableFontFace: true,
              stopAtErrors: false,
              cMapUrl,
              cMapPacked,
            };

            if (av.endpoint.getUseCookie()) {
              params.withCredentials = true;
            } else {
              params.httpHeaders =
                av.endpoint.HTTP_REQUEST_HEADERS;
            }

            this.viewer3DImpl._signalNoMeshes();

            let fe =
              _font_engine__WEBPACK_IMPORTED_MODULE_1__.theFontEngine;

            //Start loading fonts.
            let loadFontsAsync = fe.loadFonts();

            function getInternalLinks(pdf, page) {
              return page
                .getAnnotations()
                .then((annotations) => {
                  if (
                    annotations &&
                    annotations.length > 0
                  ) {
                    return Promise.all(
                      annotations.map(
                        (annotation) => {
                          // internal page link
                          if (
                            annotation.subtype ==
                              "Link" &&
                            !annotation.url
                          ) {
                            var pageIndexPromise;

                            // So far I found 2 ways of annotion destination, it might be more, extend this part if we have new case
                            if (
                              typeof annotation.dest ==
                              "string"
                            ) {
                              pageIndexPromise =
                                pdf
                                  .getDestination(
                                    annotation.dest
                                  )
                                  .then(
                                    (
                                      destInfo
                                    ) => {
                                      return pdf.getPageIndex(
                                        destInfo[0]
                                      );
                                    }
                                  );
                            } else {
                              if (
                                annotation.dest instanceof
                                Array
                              ) {
                                pageIndexPromise =
                                  pdf.getPageIndex(
                                    annotation
                                      .dest[0]
                                  );
                              }
                            }
                            if (
                              pageIndexPromise
                            ) {
                              return pageIndexPromise.then(
                                (pageIndex) => {
                                  // need to register the rect to pageIndex
                                  // pdf getPage function start from 1, so here need add extra 1
                                  annotation.pageIndex =
                                    pageIndex + 1;
                                  return annotation;
                                }
                              );
                            }
                          } else {
                            // external link, will add support here, if needed
                          }
                        }
                      )
                    )
                      .then((internalLinks) => {
                        return internalLinks.filter(
                          (item) =>
                            item != undefined
                        );
                      })
                      .catch((error) => {
                        // If we have difficulty of parsing annotations, we should let the loading continue
                        return [];
                      });
                  }
                });
            }

            function updateLinkBounds(
              renderContext,
              viewport,
              internalLinks
            ) {
              var dbIdLinks = [];
              // Use negative dbId since hotArea is added by us
              var dbId = -2;
              var transform =
                renderContext.getCurrentTransform();
              for (
                var i = 0;
                internalLinks &&
                i < internalLinks.length;
                i++
              ) {
                const rect =
                  createRectByViewportTransform(
                    renderContext,
                    transform,
                    viewport,
                    internalLinks[i].rect
                  );
                var linkNode =
                  scope.svf.loadOptions.bubbleNode.getRootNode()
                    .children[
                    internalLinks[i].pageIndex - 1
                  ];
                dbIdLinks.push({
                  dbId: dbId--,
                  properties: [
                    {
                      displayValue:
                        linkNode.data.viewableID,
                    },
                  ],
                  box: [
                    Math.min(rect[0], rect[2]),
                    Math.min(rect[1], rect[3]),
                    Math.max(rect[0], rect[2]),
                    Math.max(rect[1], rect[3]),
                  ],
                });
              }
              scope.dbIdLinks = dbIdLinks;
            }

            function createRectByViewportTransform(
              renderContext,
              transform,
              viewport,
              tempRect
            ) {
              let rect =
                viewport.convertToViewportRectangle(
                  tempRect
                );
              rect = [
                renderContext.tx(
                  rect[0],
                  rect[1],
                  transform
                ),
                renderContext.ty(
                  rect[0],
                  rect[1],
                  transform
                ),
                renderContext.tx(
                  rect[2],
                  rect[3],
                  transform
                ),
                renderContext.ty(
                  rect[2],
                  rect[3],
                  transform
                ),
              ];
              return rect;
            }

            function rotateAround(
              p,
              center,
              angle
            ) {
              let c = Math.cos(angle);
              let s = Math.sin(angle);

              let x = p.x - center.x;
              let y = p.y - center.y;

              p.x = x * c - y * s + center.x;
              p.y = x * s + y * c + center.y;
            }

            /**
             * Format strings output from PDF page
             * @param {Object} renderCtx - Render context of current page rendering.
             * @param {Object} pageInfo - dimensions of current page.
             * @param {Object} viewport - Viewport based on Page properties.
             * @param {Array} vectorStrings - Array with all strings from Vector PDF.
             * @param {Object} formattedGlyphs - Object which contains glyphs and their properties.
             * @returns {Object} - Object with list of strings and their stringBoxes.
             */
            function formatVectorPdfStrings(
              renderCtx,
              pageInfo,
              viewport,
              vectorStrings,
              formattedGlyphs
            ) {
              const strings = [];
              const stringBoxes = [];
              const stringAngles = [];
              const stringCharWidths = [];
              const stringPositions = [];
              const stringHeights = [];
              const stringWidths = [];
              const renderCtxTransform =
                renderCtx.viewport.transform;
              const currentTransform =
                renderCtx.getCurrentTransform();

              // Transform function that combines values from Render Context Transform and Transform of a string
              const transformFunc = (m1, m2) => {
                return [
                  m1[0] * m2[0] + m1[2] * m2[1],
                  m1[1] * m2[0] + m1[3] * m2[1],
                  m1[0] * m2[2] + m1[2] * m2[3],
                  m1[1] * m2[2] + m1[3] * m2[3],
                  m1[0] * m2[4] +
                    m1[2] * m2[5] +
                    m1[4],
                  m1[1] * m2[4] +
                    m1[3] * m2[5] +
                    m1[5],
                ];
              };

              //Strings in PDF.js are grouped, hence 2 loops needed to extract every expression.
              for (
                let i = 0;
                i < vectorStrings.length;
                i++
              ) {
                if (vectorStrings[i].items) {
                  const items =
                    vectorStrings[i].items;

                  for (
                    let j = 0;
                    j < items.length;
                    j++
                  ) {
                    const tempObject = items[j];
                    const tempCharWidth = [];
                    // tempObject contains characters map with corresponding width values for each char
                    // formattedGlyphs stores font families by name and char and widths
                    for (
                      let k = 0;
                      k < tempObject.str.length;
                      k++
                    ) {
                      const tempFontName =
                        formattedGlyphs[
                          tempObject.fontName
                        ];
                      const tempString =
                        tempObject.str[k];
                      // Fix for BLMV-5151, need to verify that specific character exist, otherwise it can prevent PDF from loading
                      if (
                        !tempFontName[tempString]
                      ) {
                        console.warn(
                          `Cannot find ${tempString}'s width in glyph dictionary`
                        );
                        tempCharWidth.push(0);
                      } else {
                        tempCharWidth.push(
                          tempFontName[tempString]
                            .width
                        );
                      }
                    }
                    stringCharWidths.push(
                      tempCharWidth
                    );
                    const textWidth =
                      tempObject.width;
                    const textHeight =
                      tempObject.height;

                    // Get bounding box's angle of a string by using viewport and strings transform
                    // Rotation of bbox applied on UI side based on angle
                    const strTx = transformFunc(
                      renderCtxTransform,
                      tempObject.transform
                    );
                    const strAngle = Math.atan2(
                      strTx[1],
                      strTx[0]
                    );

                    // Creating Bounding box based on transform values from pdf.js object
                    // 4-th place in array is vertical offset of string
                    // 5-th place in array is horizontal offset of string
                    const minX =
                      tempObject.transform[4];
                    const maxX =
                      tempObject.transform[4] +
                      textWidth;
                    const minY =
                      tempObject.transform[5];
                    const maxY =
                      tempObject.transform[5] +
                      textHeight;

                    const box =
                      new THREE.Box2().setFromPoints(
                        [
                          new THREE.Vector2(
                            minX,
                            minY
                          ),
                          new THREE.Vector2(
                            maxX,
                            maxY
                          ),
                        ]
                      );
                    rotateAround(
                      box.max,
                      box.min,
                      THREE.Math.degToRad(
                        pageInfo.rotate
                      )
                    );

                    const tempRect = [
                      box.min.x,
                      box.min.y,
                      box.max.x,
                      box.max.y,
                    ];

                    const rect =
                      createRectByViewportTransform(
                        renderCtx,
                        currentTransform,
                        viewport,
                        tempRect
                      );

                    strings.push(tempObject.str);
                    stringBoxes.push(
                      rect[0],
                      rect[1],
                      rect[2],
                      rect[3]
                    );
                    stringAngles.push(strAngle);
                    stringPositions.push([
                      rect[0],
                      rect[1],
                    ]);
                    stringHeights.push(
                      textHeight
                    );
                    stringWidths.push(textWidth);
                  }
                }
              }
              return {
                strings,
                stringBoxes,
                stringAngles,
                stringCharWidths,
                stringPositions,
                stringHeights,
                stringWidths,
              };
            }

            /**
             * Extracts the viewports from the PDF
             * @param {PDFPageProxy} page
             * @param {LmvCanvasContext} renderContext
             * @returns {Object[]} The extracted viewports
             */
            PDFLoader.prototype.buildViewports =
              function (page, renderContext) {
                let viewports = [];
                return this.getOperatorList(
                  page
                ).then((ops) => {
                  for (
                    let i = 0;
                    i < ops.fnArray.length;
                    i++
                  ) {
                    if (
                      ops.fnArray[i] ==
                        _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                          .OPS
                          .beginMarkedContent ||
                      ops.fnArray[i] ==
                        _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                          .OPS
                          .beginMarkedContentProps
                    ) {
                      if (ops.argsArray[i]) {
                        let properties =
                          ops.fnArray[i] ==
                          _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                            .OPS
                            .beginMarkedContent
                            ? ops.argsArray[i][0]
                            : ops.argsArray[i][1];

                        if (properties) {
                          properties =
                            renderContext._processProperties(
                              properties
                            );

                          if (properties.VP) {
                            const vp =
                              renderContext._getModelToViewportMatrix(
                                properties.VP,
                                !!properties.UNITS
                              );
                            viewports.push(
                              renderContext.createViewPortData(
                                vp,
                                properties.UNITS,
                                properties.PRECISION
                              )
                            );
                          }
                        }
                      }
                    }
                  }
                  return viewports;
                });
              };

            function buildLayers(page) {
              return (
                scope
                  .getOperatorList(page)
                  .then((ops) => {
                    let fnArray = ops.fnArray;
                    let argsArray = ops.argsArray;
                    let layers = {};
                    let layerStartIndex = 1;

                    for (
                      var i = 0;
                      fnArray &&
                      i < fnArray.length;
                      i++
                    ) {
                      let fn = fnArray[i];
                      if (
                        fn ===
                        _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                          .OPS
                          .beginMarkedContentProps
                      ) {
                        if (
                          argsArray[i] &&
                          argsArray[i][0] ==
                            "OC" &&
                          argsArray[i][1] !== null
                        ) {
                          let key;
                          if (
                            typeof argsArray[
                              i
                            ][1] == "object"
                          ) {
                            key =
                              argsArray[i][1]
                                .ocgId;
                          } else {
                            key = argsArray[i][1];
                          }
                          if (
                            layers[key] ===
                            undefined
                          ) {
                            layers[key] =
                              layerStartIndex++;
                          }
                        }
                      }
                    }
                    return layers;
                  })
                  // It should not have error, but we don't test enough for PDF
                  // In case of potential error happened, we still want to show the contents
                  .catch(avp.logger.log)
                  .then((layers) => {
                    return scope.pdf
                      .getPageOCGNames(page.ref)
                      .catch(avp.logger.log)
                      .then((layerNameMap) => {
                        layerNameMap =
                          layerNameMap || {};
                        var layersRoot = {
                          name: "root",
                          id: "root",
                          children: [],
                          isLayer: false,
                        };
                        var layersMap = { 0: 0 };
                        var layerCount = 1;
                        for (var layerId in layers) {
                          var l =
                            layerNameMap[layerId];
                          if (!l) {
                            // when we did not find corresponding layer data, we should override the layerId to 0
                            // and draw the content to layer 0. LMV-5242
                            layers[layerId] = 0;
                          } else {
                            var name =
                              typeof l ===
                                "object" &&
                              Object.prototype.hasOwnProperty.call(
                                l,
                                "name"
                              )
                                ? l.name
                                : layerId;
                            var layer = {
                              name: name,
                              id:
                                "group-" +
                                layers[layerId],
                              isLayer: true,
                              index:
                                layers[layerId],
                              visible: l.visible,
                              children: [],
                            };
                            // for layers, the first drawing layer should be at the bottom of the list
                            layersRoot.children.unshift(
                              layer
                            );
                            layerCount++;
                            layersMap[
                              layers[layerId]
                            ] = layers[layerId];
                          }
                        }

                        return {
                          layerCount,
                          layersRoot,
                          layersMap,
                          layers,
                        };
                      });
                  })
              );
            }

            function getStrings(page) {
              const documentStrings = [];
              const readableStream =
                page.streamTextContent({
                  normalizeWhitespace: true,
                  combineTextItems: true,
                });
              return new Promise(
                (resolve, reject) => {
                  let pump = () => {
                    reader.read().then((_ref) => {
                      let { value, done } = _ref;
                      if (done) {
                        resolve(documentStrings);
                        return;
                      }
                      documentStrings.push(value);
                      pump();
                    }, reject);
                  };
                  const reader =
                    readableStream.getReader();
                  pump();
                }
              );
            }

            function renderPage(pageNumber) {
              var pdf = scope.pdf;
              PDFWorkingReferenceMap[
                pdf.fingerprint
              ] = 1;

              if (
                pageNumber <= 0 ||
                pageNumber > pdf.numPages
              ) {
                pageNumber = 1;
              }

              if (scope.model) {
                scope.viewer3DImpl.unloadModel(
                  scope.model
                );
                scope.model = undefined;
              }
              var context = {};
              let documentStrings = [];
              return pdf
                .getPage(pageNumber)
                .then((page) => {
                  return scope
                    .createFontAtlas(
                      page,
                      pdf.fingerprint
                    )
                    .then((fontAtlas) => {
                      context.fontAtlas =
                        fontAtlas;
                      return getInternalLinks(
                        pdf,
                        page
                      ).then((internalLinks) => {
                        context.internalLinks =
                          internalLinks;
                      });
                    })
                    .then(() => {
                      // Get PDF strings from page
                      // options Feature Flag disables by default PDF.js strings fetch
                      return options.extendStringsFetching
                        ? getStrings(page)
                        : [];
                    })
                    .then((strings) => {
                      documentStrings = strings;
                      return scope.detectCircle(
                        page
                      );
                    })
                    .then(() => {
                      // Load any large font files that need to be used by the current PDF.
                      return scope.loadOnDemandFonts(
                        page,
                        fe
                      );
                    })
                    .then(() => {
                      return scope
                        .loadMarkedContentPropertiesReferences(
                          pdf,
                          page
                        )
                        .then((map) => {
                          context.pdfRefObjMap =
                            map;
                        });
                    })
                    .then(() => {
                      return scope.evaluatePageLineStyles(
                        page
                      );
                    })
                    .then(() => {
                      return scope.detectSmallImageSequences(
                        page
                      );
                    })
                    .then(() => {
                      var _scope$options$bubble,
                        _scope$options$placem,
                        _scope$options$placem2;
                      let internalLinks =
                        context.internalLinks;
                      var view = page.view;
                      view = view.slice(0);

                      // LMV-5149: Apply the page rotation to the page_width and page_height
                      var rotationMatrix =
                        new THREE.Matrix4().makeRotationZ(
                          (page.rotate / 180) *
                            Math.PI
                        );
                      var rotatedViewVec1 =
                        new THREE.Vector3(
                          view[0],
                          view[1],
                          0
                        ).applyMatrix4(
                          rotationMatrix
                        );
                      var rotatedViewVec2 =
                        new THREE.Vector3(
                          view[2],
                          view[3],
                          0
                        ).applyMatrix4(
                          rotationMatrix
                        );

                      // Apply the rotation vector to the view
                      // These values are used to calculate the page_width and the page_height
                      view[0] = Math.min(
                        rotatedViewVec1.x,
                        rotatedViewVec2.x
                      );
                      view[1] = Math.min(
                        rotatedViewVec1.y,
                        rotatedViewVec2.y
                      );
                      view[2] = Math.max(
                        rotatedViewVec1.x,
                        rotatedViewVec2.x
                      );
                      view[3] = Math.max(
                        rotatedViewVec1.y,
                        rotatedViewVec2.y
                      );

                      // need to put a cap on 1 dimention : 8192 for desktop / 4096 for firefox / 2048 for mobile
                      // LMV-4731: If we set the viewport too large, it will fail to load in Firefox
                      var maxDim = Math.max(
                        view[2] - view[0],
                        view[3] - view[1]
                      );
                      const capDim =
                        av.isMobileDevice()
                          ? MOBILE_DIM_CAP
                          : av.isFirefox()
                          ? FIREFOX_DIM_CAP
                          : DEFAULT_DIM_CAP;
                      const scaleByDim =
                        capDim / maxDim;

                      const DPI = 300;
                      //Render the PDF at 300 pixels/inch instead of 72 points/inch.
                      //This seems to match what Adobe Reader does at max zoom.
                      const scaleByDPI = DPI / 72;

                      // scale as much as possible without exceeding capDim
                      const pageToCanvasScale =
                        Math.min(
                          scaleByDPI,
                          scaleByDim
                        );

                      // Important: the measure tool expects inches
                      // take userUnit into account: PDF specs define userUnit as a factor on the size of a pt, so the conversion to inches is not 1/72, but userUnit/72
                      const userUnit =
                        page.userUnit || 1;
                      const canvasToInchesScale =
                        userUnit /
                        72 /
                        pageToCanvasScale;

                      // Convert to source file unit's if supplied in the bubble.
                      let targetUnits =
                        ((_scope$options$bubble =
                          scope.options
                            .bubbleNode) ===
                          null ||
                        _scope$options$bubble ===
                          void 0
                          ? void 0
                          : _scope$options$bubble.getSourceFileUnits()) ||
                        avp.ModelUnits.INCH;

                      const inchesToTargetUnitsScale =
                        Autodesk.Viewing.Private.convertUnits(
                          avp.ModelUnits.INCH,
                          targetUnits,
                          1,
                          1
                        );
                      const canvasToTargetUnitScale =
                        canvasToInchesScale *
                        inchesToTargetUnitsScale;

                      //Negative rotation because we skip the y-flip.
                      //TODO: need to check if this is right for all rotations, if not just let it flip y and negate that in the canvas context.
                      // viewport will use canvas units
                      var options = {
                        scale: pageToCanvasScale,
                        rotation: -page.rotate,
                        dontFlip: true,
                      };
                      var viewport =
                        page.getViewport(options);
                      viewport.clipToViewport = true;

                      scope.renderContext =
                        new LmvCanvasContext(
                          viewport,
                          canvasToTargetUnitScale,
                          scope.processReceivedMesh2D.bind(
                            scope
                          ),
                          fe,
                          PDFLoader.useTextLayer,
                          context.fontAtlas,
                          context.pdfRefObjMap
                        );

                      // update lineStyles
                      scope.renderContext.setLineStyleParam(
                        scope.pageLineStyleParams
                      );
                      scope.viewer3DImpl
                        .matman()
                        .setLineStyleTexture(
                          scope.renderContext
                            .lineStyleTexture
                        );
                      scope.renderContext.setSmallImageSequences(
                        scope.smallImageSequences
                      );

                      scope.renderContext.setCircleInfo(
                        scope.circleInfo
                      );

                      // Assign consecutive dbIds. The only purpose of these IDs is to split the page down into smaller shapes, so that
                      // we can use the ID buffer to quickly find shapes for snapping.
                      scope.renderContext.consecutiveIds = true;

                      const bounds =
                        scope.renderContext
                          .bounds;

                      scope.svf = {
                        is2d: true,
                        isPdf: true,
                        viewports: [],
                        layersMap: { 0: 0 },
                        layerCount: 1,
                        bbox: new THREE.Box3(
                          new THREE.Vector3(
                            bounds.x,
                            bounds.y,
                            0
                          ),
                          new THREE.Vector3(
                            bounds.z,
                            bounds.w,
                            0
                          )
                        ),
                        metadata: {
                          page_dimensions: {
                            page_width:
                              ((view[2] -
                                view[0]) *
                                inchesToTargetUnitsScale *
                                userUnit) /
                              72,
                            page_height:
                              ((view[3] -
                                view[1]) *
                                inchesToTargetUnitsScale *
                                userUnit) /
                              72,
                            logical_width:
                              viewport.width *
                              inchesToTargetUnitsScale,
                            logical_height:
                              viewport.height *
                              inchesToTargetUnitsScale,
                            logical_offset_x:
                              viewport.offsetX *
                              inchesToTargetUnitsScale,
                            logical_offset_y:
                              viewport.offsetY *
                              inchesToTargetUnitsScale,
                            page_units:
                              targetUnits,
                            rotation:
                              viewport.rotation,
                          },
                          currentPage: pageNumber,
                        },
                        placementTransform:
                          (_scope$options$placem =
                            scope.options
                              .placementTransform) ===
                            null ||
                          _scope$options$placem ===
                            void 0
                            ? void 0
                            : _scope$options$placem.clone(),
                        placementWithOffset:
                          (_scope$options$placem2 =
                            scope.options
                              .placementTransform) ===
                            null ||
                          _scope$options$placem2 ===
                            void 0
                            ? void 0
                            : _scope$options$placem2.clone(),
                        strings: [],
                        stringDbIds: [],
                        getPDF: function () {
                          return scope.pdf;
                        },
                      };

                      var t0 = performance.now();

                      // layers information is required before we call onSuccess
                      buildLayers(page)
                        .then((layersInfo) => {
                          scope.svf.layersRoot =
                            layersInfo.layersRoot;
                          scope.svf.layerCount =
                            layersInfo.layerCount;
                          scope.svf.layersMap =
                            layersInfo.layersMap;
                          scope.renderContext.layers =
                            layersInfo.layers;
                        })
                        // Ignore any potential error and let the rendering continue
                        .catch(avp.logger.log)
                        .then(() =>
                          scope.buildViewports(
                            page,
                            scope.renderContext
                          )
                        )
                        .then((viewports) => {
                          // store viewports
                          scope.svf.viewports =
                            scope.renderContext.viewports =
                              scope.renderContext.viewports.concat(
                                viewports
                              );

                          if (
                            scope.currentLoadPath ===
                            null
                          ) {
                            const errorMsg =
                              "PDF loader was destroyed";
                            onSuccess &&
                              onSuccess(errorMsg);
                            return Promise.reject(
                              errorMsg
                            );
                          }

                          scope.onModelRootLoadDone(
                            scope.svf
                          );
                          if (onSuccess) {
                            onSuccess(
                              null,
                              scope.model
                            );
                          }
                          scope.viewer3DImpl.api.fireEvent(
                            {
                              type: av.MODEL_ROOT_LOADED_EVENT,
                              svf: scope.svf,
                              model: scope.model,
                            }
                          );
                        })
                        .then(() => {
                          //
                          // Render PDF page into canvas context
                          //
                          loadFontsAsync.then(
                            () => {
                              var renderTask =
                                (scope._renderTask =
                                  page.render(
                                    scope.renderContext,
                                    this
                                  ));
                              renderTask.promise
                                .then(() => {
                                  var _documentStrings,
                                    _model$getDocumentNod;
                                  if (
                                    internalLinks &&
                                    internalLinks.length >
                                      0
                                  ) {
                                    // render hot area in the canvas to enable internal links
                                    // Need to render the hotArea after main page was rendered,
                                    // because extra dbID will be assigned to hotArea
                                    if (
                                      PDFLoader.enableHyperlinks
                                    ) {
                                      updateLinkBounds(
                                        scope.renderContext,
                                        viewport,
                                        internalLinks
                                      );
                                      scope.svf.metadata.hyperLinks =
                                        scope.dbIdLinks;
                                      scope.viewer3DImpl.api.loadExtension(
                                        "Autodesk.Hyperlink"
                                      );
                                    }
                                  }

                                  // Format PDF document strings
                                  if (
                                    ((_documentStrings =
                                      documentStrings) ===
                                      null ||
                                    _documentStrings ===
                                      void 0
                                      ? void 0
                                      : _documentStrings.length) >
                                    0
                                  ) {
                                    var _page$commonObjs;
                                    const pdfObjects =
                                      page ===
                                        null ||
                                      page ===
                                        void 0 ||
                                      (_page$commonObjs =
                                        page.commonObjs) ===
                                        null ||
                                      _page$commonObjs ===
                                        void 0
                                        ? void 0
                                        : _page$commonObjs._objs;
                                    const formattedGlyphs =
                                      {};
                                    // pdfObjects contain information regarding fonts and their properties as size, width, style etc.
                                    // By iterating this object, we can obtain compact object with relevant characters for further calculations
                                    // Final structure of formattedGlyphs object: Family Name-> Character -> character width
                                    for (let pdfObject in pdfObjects) {
                                      var _pdfObjects$pdfObject;
                                      if (
                                        (_pdfObjects$pdfObject =
                                          pdfObjects[
                                            pdfObject
                                          ]
                                            .data) !==
                                          null &&
                                        _pdfObjects$pdfObject !==
                                          void 0 &&
                                        _pdfObjects$pdfObject.glyphCache
                                      ) {
                                        const glyphCache =
                                          pdfObjects[
                                            pdfObject
                                          ].data
                                            .glyphCache;
                                        const fontName =
                                          pdfObjects[
                                            pdfObject
                                          ].data
                                            .loadedName;
                                        const tempGlyphs =
                                          {};
                                        for (let char in glyphCache) {
                                          const unicodeChar =
                                            glyphCache[
                                              char
                                            ]
                                              .unicode;
                                          tempGlyphs[
                                            unicodeChar
                                          ] = {
                                            width:
                                              glyphCache[
                                                char
                                              ]
                                                .width,
                                          };
                                        }
                                        formattedGlyphs[
                                          fontName
                                        ] =
                                          Object.assign(
                                            {},
                                            tempGlyphs,
                                            formattedGlyphs[
                                              fontName
                                            ]
                                          );
                                      }
                                    }

                                    const formattedStrings =
                                      formatVectorPdfStrings(
                                        scope.renderContext,
                                        page._pageInfo,
                                        viewport,
                                        documentStrings,
                                        formattedGlyphs
                                      );
                                    scope.svf.strings =
                                      formattedStrings.strings;
                                    scope.svf.stringBoxes =
                                      formattedStrings.stringBoxes;
                                    scope.svf.stringAngles =
                                      formattedStrings.stringAngles;
                                    scope.svf.stringCharWidths =
                                      formattedStrings.stringCharWidths;
                                    scope.svf.stringPositions =
                                      formattedStrings.stringPositions;
                                    scope.svf.stringHeights =
                                      formattedStrings.stringHeights;
                                    scope.svf.stringWidths =
                                      formattedStrings.stringWidths;
                                  }

                                  scope.renderContext.finish();
                                  scope.svf.minLineWidth =
                                    scope.renderContext.currentVbb.minLineWidth;
                                  scope.svf.maxObjectNumber =
                                    scope.renderContext.maxDbId;
                                  scope.onGeomLoadDone();

                                  var t1 =
                                    performance.now();
                                  const pdfLoadTime =
                                    t1 - t0;
                                  console.log(
                                    "PDF load time",
                                    pdfLoadTime
                                  );

                                  const model =
                                    scope.model;
                                  const geomList =
                                    model.getGeometryList();

                                  const dataToTrack =
                                    {
                                      load_time:
                                        scope.loadTime,
                                      pdf_load_time:
                                        pdfLoadTime,
                                      polygons:
                                        geomList.geomPolyCount,
                                      fragments:
                                        model
                                          .getFragmentList()
                                          .getCount(),
                                      mem_usage:
                                        geomList.gpuMeshMemory,
                                      total_raster_pixels:
                                        (_model$getDocumentNod =
                                          model.getDocumentNode()) ===
                                          null ||
                                        _model$getDocumentNod ===
                                          void 0 ||
                                        (_model$getDocumentNod =
                                          _model$getDocumentNod.data) ===
                                          null ||
                                        _model$getDocumentNod ===
                                          void 0
                                          ? void 0
                                          : _model$getDocumentNod.totalRasterPixels,
                                      viewable_type:
                                        "2d",
                                    };
                                  avp.analytics.track(
                                    "viewer.model.loaded",
                                    dataToTrack
                                  );

                                  //These are needed in order to free the PDF loader context (it caches all PDF opcodes
                                  //in a giant array). Ideally we will modify the pdf.js library to not accumulate opcodes
                                  //that are already processed, so we don't spike memory at load time.
                                  renderTask._canvas =
                                    null;
                                })
                                .catch((err) => {
                                  // Usually happens when the switching to another PDF page while
                                  // the current one is still getting rendered.
                                  avp.logger.log(
                                    err
                                  );
                                })
                                .finally(() => {
                                  scope._renderTask =
                                    null;
                                  page.cleanup();
                                  scope.cleanup();
                                });
                            }
                          );
                        });
                    });
                })
                .catch((error) => {
                  return Promise.reject(error);
                });
            }

            Promise.resolve().then(() => {
              if (
                options.bubbleNode &&
                typeof options.bubbleNode.getRootNode()
                  .data.getPDF == "function" &&
                options.bubbleNode
                  .getRootNode()
                  .data.getPDF()
              ) {
                scope.pdf = options.bubbleNode
                  .getRootNode()
                  .data.getPDF();
                scope.loading = false;
                renderPage(
                  options.bubbleNode.data.page
                );
              } else {
                var pdfTask =
                  _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.getDocument(
                    params
                  );
                pdfTask.onProgress = (_ref2) => {
                  let { loaded, total } = _ref2;
                  const percentLoaded =
                    Math.round(
                      (loaded * 100) / total
                    );
                  scope.viewer3DImpl.signalProgress(
                    percentLoaded,
                    av.ProgressState.LOADING
                  );
                };
                // keep pdfTask reference for cleanup later
                scope.pdfTask = pdfTask;

                return pdfTask.promise
                  .then((pdf) => {
                    scope.pdf = pdf;
                    scope.loading = false;
                    var pageNumber =
                      options.page ||
                      parseInt(
                        avp.getParameterByName(
                          "page"
                        )
                      ) ||
                      1;

                    if (
                      scope.options &&
                      !scope.options.bubbleNode
                    ) {
                      var pdfMain =
                        scope.createPDFDocument(
                          pdf
                        );
                      scope.options.bubbleNode =
                        pdfMain.getRoot().children[
                          pageNumber - 1
                        ];
                    }

                    return renderPage(pageNumber);
                  })
                  .catch((error) => {
                    onSuccess && onSuccess(error);
                  });
              }
            });

            return true;
          };

        PDFLoader.prototype.loadOnDemandFonts =
          function (page, fe) {
            const commonObjs =
              page.commonObjs._objs;
            const loadedFonts = {};
            const loadPromises = [];
            for (let name in commonObjs) {
              var _font$data;
              const font = commonObjs[name];
              if (
                font !== null &&
                font !== void 0 &&
                (_font$data = font.data) !==
                  null &&
                _font$data !== void 0 &&
                _font$data.missingFile
              ) {
                var _font$data2;
                const fontName =
                  font === null ||
                  font === void 0 ||
                  (_font$data2 = font.data) ===
                    null ||
                  _font$data2 === void 0
                    ? void 0
                    : _font$data2.name;
                if (fontName) {
                  const fontDescriptor =
                    fe.getOnDemandFont(fontName);
                  if (
                    fontDescriptor &&
                    !loadedFonts[
                      fontDescriptor.name
                    ]
                  ) {
                    loadPromises.push(
                      fe.loadFont(fontDescriptor)
                    );
                    loadedFonts[
                      fontDescriptor.name
                    ] = true;
                  }
                }
              }
            }

            if (loadPromises.length === 0) {
              return;
            }

            return Promise.all(loadPromises);
          };

        /**
         * Loop all the operator command to detect whether it is a circle.
         */
        PDFLoader.prototype.detectCircle =
          function (page) {
            const threshold = 0.001;
            const magic =
              (4 / 3) * Math.tan(Math.PI / 8);
            const magic2 = magic * magic;
            let p1 = new THREE.Vector2();
            let p2 = new THREE.Vector2();
            let p3 = new THREE.Vector2();
            let p4 = new THREE.Vector2();

            function equal(a, b) {
              return Math.abs(a - b) <= threshold;
            }

            function relativelyEqual(a, b) {
              return (
                a > 0 &&
                b > 0 &&
                equal(
                  Math.abs(a - b) / a,
                  threshold
                )
              );
            }

            /**
             *  if it is a primitive circle
             *  it will have a 13, 15, 15, 15, 15, [18]
             *  Reference: https://stackoverflow.com/questions/1734745/how-to-create-circle-with-b%C3%A9zier-curves
             * @param {*} fnArray
             * @param {*} argsArray
             */
            function checkPattern(
              fnArray,
              argsArray
            ) {
              if (
                (fnArray.length == 5 ||
                  fnArray.length == 6) &&
                argsArray.length == 26
              ) {
                if (
                  fnArray[0] == 13 &&
                  fnArray[1] == 15 &&
                  fnArray[2] == 15 &&
                  fnArray[3] == 15 &&
                  fnArray[4] == 15 &&
                  (fnArray[5] == 18 ||
                    fnArray[5] == undefined)
                ) {
                  // do the math to figure out whether it is a circle
                  for (
                    let i = 0;
                    i < argsArray.length - 6;
                    i += 6
                  ) {
                    p1.set(
                      argsArray[i],
                      argsArray[i + 1]
                    );
                    p2.set(
                      argsArray[i + 2],
                      argsArray[i + 3]
                    );
                    p3.set(
                      argsArray[i + 4],
                      argsArray[i + 5]
                    );
                    p4.set(
                      argsArray[i + 6],
                      argsArray[i + 7]
                    );
                    if (
                      !checkQuaterCircle(
                        p1,
                        p2,
                        p3,
                        p4
                      )
                    ) {
                      return false;
                    }
                  }

                  return true;
                }
              }
              return false;
            }

            function checkQuaterCircle(
              p1,
              p2,
              p3,
              p4
            ) {
              let p12 = p2.clone().sub(p1);
              let p43 = p3.clone().sub(p4);
              let l12 = p12.lengthSq();
              let l43 = p43.lengthSq();
              let radius =
                p4.distanceToSquared(p1) / 2;

              let result =
                l12 > 0 &&
                l43 > 0 &&
                relativelyEqual(l12, l43) &&
                equal(
                  p12
                    .normalize()
                    .dot(p43.normalize()),
                  0
                ) &&
                equal(l12 / radius, magic2) &&
                equal(l43 / radius, magic2);

              return result;
            }

            return this.getOperatorList(
              page
            ).then((ops) => {
              let circleInfo = {};
              for (
                let i = 0;
                i < ops.fnArray.length;
                i++
              ) {
                if (
                  ops.fnArray[i] ==
                  _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__
                    .OPS.constructPath
                ) {
                  // need try to detect whether there is circle in this command
                  let fn1 = ops.argsArray[i][0];
                  let args1 = ops.argsArray[i][1];

                  if (checkPattern(fn1, args1)) {
                    p1.set(args1[0], args1[1]);
                    p2.set(args1[6], args1[7]);
                    p3.set(args1[12], args1[13]);
                    p4.set(args1[18], args1[19]);

                    let p12 = p2.clone().sub(p1);
                    let p23 = p3.clone().sub(p2);

                    let l12 = p12.lengthSq();
                    let l23 = p23.lengthSq();
                    let l34 =
                      p3.distanceToSquared(p4);
                    let l41 =
                      p4.distanceToSquared(p1);

                    // check the 4 points is a square
                    if (
                      relativelyEqual(l12, l23) &&
                      relativelyEqual(l34, l41) &&
                      relativelyEqual(l12, l41) &&
                      equal(
                        p12
                          .normalize()
                          .dot(p23.normalize()),
                        0
                      )
                    ) {
                      let x = 0,
                        y = 0;
                      for (
                        var k = 0;
                        k < args1.length - 6;
                        k += 6
                      ) {
                        x += args1[k];
                        y += args1[k + 1];
                      }

                      circleInfo[i] = [
                        x / 4,
                        y / 4,
                      ];
                    }
                  }
                }
              }

              this.circleInfo = circleInfo;
            });
          };

        PDFLoader.prototype.processReceivedMesh =
          function (mdata) {
            //Find all fragments that instance this mesh
            var meshid =
              mdata.packId +
              ":" +
              mdata.meshIndex;

            var svf = this.svf;
            var fragments = svf.fragments;

            var fragIndexes =
              fragments.mesh2frag[meshid];
            if (fragIndexes === undefined) {
              avp.logger.warn(
                "Mesh " +
                  meshid +
                  " was not referenced by any fragments."
              );
              return;
            }
            if (!Array.isArray(fragIndexes))
              fragIndexes = [fragIndexes];

            var rm = this.model;

            // Background dbid is -1. Hide it when hideBackground is set.
            // This line has to be before calling meshToGeometry, because mdata.mesh is set to null inside of it.
            if (
              mdata.mesh.dbIds[-1] &&
              this.options.hideBackground
            ) {
              rm.changePaperVisibility(false);
            }

            //Convert the received mesh to THREE buffer geometry
            const geometry =
              avp.BufferGeometryUtils.meshToGeometry(
                mdata
              );

            // Add geometry to ensure PDF data is taken into account for gpu memory limits
            rm.getGeometryList().addGeometry(
              geometry,
              fragIndexes.length,
              mdata.meshIndex + 1
            );

            const polyCount =
              avp.getPolygonCount(geometry);

            //For each fragment, add a mesh instance to the renderer
            for (
              var i = 0;
              i < fragIndexes.length;
              i++
            ) {
              var fragId = 0 | fragIndexes[i];

              //We get the matrix from the fragments and we set it back there
              //with the activateFragment call, but this is to maintain the
              //ability to add a plain THREE.Mesh -- otherwise it could be simpler
              rm.getFragmentList().getOriginalWorldMatrix(
                fragId,
                this.tmpMatrix
              );

              if (
                this.options.placementTransform
              ) {
                this.tmpMatrix =
                  new THREE.Matrix4().multiplyMatrices(
                    this.options
                      .placementTransform,
                    this.tmpMatrix
                  );
              }

              var materialId =
                fragments.materials[
                  fragId
                ].toString();

              if (fragments.polygonCounts)
                fragments.polygonCounts[fragId] =
                  polyCount;

              var m = this.viewer3DImpl.setupMesh(
                this.model,
                geometry,
                materialId,
                this.tmpMatrix
              );
              rm.activateFragment(fragId, m);
            }

            //don't need this mapping anymore.
            fragments.mesh2frag[meshid] = null;

            //Repaint and progress reporting
            fragments.numLoaded +=
              fragIndexes.length;

            var numLoaded = fragments.numLoaded;

            this.viewer3DImpl._signalMeshAvailable();

            //repaint every once in a while -- more initially, less as the load drags on.
            if (
              fragments.numLoaded >
              fragments.nextRepaint
            ) {
              //avp.logger.log("num loaded " + numLoaded);
              svf.numRepaints++;
              fragments.nextRepaint +=
                6 *
                Math.pow(1.75, svf.numRepaints);
              this.viewer3DImpl.api.dispatchEvent(
                {
                  type: av.LOADER_REPAINT_REQUEST_EVENT,
                  loader: this,
                  model: this.model,
                }
              );
            }
          };

        PDFLoader.prototype.processReceivedMesh2D =
          function (mesh, mindex) {
            var mdata = {
              mesh: mesh,
              is2d: true,
              packId: "0",
              meshIndex: mindex,
            };

            var meshId = "0:" + mindex;

            var frags = this.svf.fragments;

            //Remember the list of all dbIds referenced by this mesh.
            //In the 2D case this is 1->many (1 frag = many dbIds) mapping instead of
            // 1 dbId -> many fragments like in the SVF 3D case.
            var dbIds = Object.keys(
              mdata.mesh.dbIds
            ).map(function (item) {
              return parseInt(item);
            });
            frags.fragId2dbId[mindex] = dbIds;

            //TODO: dbId2fragId is not really necessary if we have a good instance tree for the 2D drawing (e.g. Revit, AutoCAD)
            //so we can get rid of this mapping if we can convert Viewer3DImpl.highlightFragment to use the same logic for 2D as for 3D.
            for (
              var j = 0;
              j < dbIds.length;
              j++
            ) {
              var dbId = dbIds[j];
              var fragIds =
                frags.dbId2fragId[dbId];
              if (Array.isArray(fragIds))
                fragIds.push(mindex);
              else if (
                typeof fragIds !== "undefined"
              ) {
                frags.dbId2fragId[dbId] = [
                  fragIds,
                  mindex,
                ];
              } else {
                frags.dbId2fragId[dbId] = mindex;
              }
            }

            const modelFrags =
              this.model.getFragmentList();

            frags.mesh2frag[meshId] = mindex;
            mesh.material.modelScale =
              this.modelScale;
            mesh.material.doNotCut =
              this.options.doNotCut ||
              (modelFrags === null ||
              modelFrags === void 0
                ? void 0
                : modelFrags.getDoNotCut());
            if (
              modelFrags !== null &&
              modelFrags !== void 0 &&
              modelFrags.viewBounds
            ) {
              const bounds =
                modelFrags.viewBounds;
              mesh.material.viewportBounds =
                new THREE.Vector4(
                  bounds.min.x,
                  bounds.min.y,
                  bounds.max.x,
                  bounds.max.y
                );
            }

            frags.materials[mindex] =
              this.viewer3DImpl
                .matman()
                .create2DMaterial(
                  this.model,
                  mesh.material
                );

            frags.length++;

            this.processReceivedMesh(mdata);
          };

        PDFLoader.prototype.onModelRootLoadDone =
          function (svf) {
            //In the 2d case we create and build up the fragments mapping
            //on the receiving end.
            svf.fragments = {};
            svf.fragments.mesh2frag = {};
            svf.fragments.materials = [];
            svf.fragments.fragId2dbId = [];
            svf.fragments.dbId2fragId = [];
            svf.fragments.length = 0;
            svf.fragments.initialized = true;

            svf.geomPolyCount = 0;
            svf.instancePolyCount = 0;
            svf.fragments.numLoaded = 0;
            svf.fragments.nextRepaint = 5;
            svf.meshCount = 0;

            svf.nextRepaintPolys = 10000;
            svf.numRepaints = 0;

            svf.urn = this.svfUrn;
            svf.acmSessionId = this.acmSessionId;

            svf.basePath = "";
            var lastSlash =
              this.currentLoadPath.lastIndexOf(
                "/"
              );
            if (lastSlash !== -1)
              svf.basePath =
                this.currentLoadPath.substr(
                  0,
                  lastSlash + 1
                );

            svf.loadOptions = this.options;

            var t1 = Date.now();
            avp.logger.log(
              "PDF root load: " + (t1 - this.t0)
            );

            this.t1 = t1;

            //The BBox object loses knowledge of its
            //type when going across the worker thread boundary...
            svf.bbox = new THREE.Box3().copy(
              svf.bbox
            );
            svf.modelSpaceBBox = svf.bbox.clone();

            if (svf.placementTransform) {
              svf.bbox.applyMatrix4(
                svf.placementTransform
              );
            }

            //Create the API Model object and its render proxy
            var model = (this.model =
              new av.Model(svf));
            model.loader = this;

            model.initialize();

            // Update viewport bounds according to model clipped bounds. (See LmvCanvasContext)
            model.setViewportBounds(
              this.viewer3DImpl.matman(),
              svf.modelSpaceBBox
            );

            if (!this.options.skipPropertyDb) {
              this.svf.propDbLoader =
                new avp.PropDbLoader(
                  this.sharedDbPath,
                  this.model,
                  this.viewer3DImpl.api
                );
            }

            avp.logger.log(
              "scene bounds: " +
                JSON.stringify(svf.bbox)
            );

            var metadataStats = {
              category: "metadata_load_stats",
              urn: svf.urn,
              layers: svf.layerCount,
            };
            avp.logger.track(metadataStats);

            this.viewer3DImpl.setDoNotCut(
              model,
              !!this.options.doNotCut
            );

            this.viewer3DImpl.signalProgress(
              5,
              av.ProgressState.ROOT_LOADED,
              model
            );
          };

        PDFLoader.prototype.onGeomLoadDone =
          function () {
            this.svf.loadDone = true;

            // Don't need these anymore
            this.svf.fragments.entityIndexes =
              null;
            this.svf.fragments.mesh2frag = null;

            var t2 = Date.now();
            var msg =
              "Fragments load time: " +
              (t2 - this.t1);
            this.loadTime = t2 - this.t0;

            if (!this.options.skipPropertyDb) {
              this.loadPropertyDb();
            }

            avp.logger.log(msg);

            var modelStats = {
              category: "model_load_stats",
              is_f2d: true,
              has_prism:
                this.viewer3DImpl.matman()
                  .hasPrism,
              load_time: this.loadTime,
              geometry_size:
                this.model.getGeometryList()
                  .geomMemory,
              meshes_count: this.model
                .getGeometryList()
                .getCount(),
              urn: this.svfUrn,
            };
            avp.logger.track(modelStats, true);

            this.viewer3DImpl.onLoadComplete(
              this.model
            );
          };

        PDFLoader.prototype.loadPropertyDb =
          function () {
            if (this.svf.propDbLoader) {
              // Skip loading if the shared db path is not set and dispatch
              // a failed event instead
              if (
                this.svf.propDbLoader
                  .sharedDbPath &&
                this.svf.propDbLoader.dbPath
              ) {
                this.svf.propDbLoader.load();
              } else {
                this.svf.propDbLoader.processLoadError(
                  {
                    code: av.ErrorCodes
                      .UNKNOWN_FAILURE, // TODO: Revisit this error code.
                    msg: "PDF doesn't provide a property DB",
                  }
                );
              }
            }
          };

        PDFLoader.prototype.is3d = function () {
          return false;
        };

        PDFLoader.prototype.cleanup =
          function () {
            if (this.renderContext) {
              this.renderContext.destroy();
              this.renderContext = null;
            }

            if (this.pdf) {
              this.pdf.cleanup();
            }
          };

        PDFLoader.prototype.getOperatorList =
          function (page) {
            // Use the same 'display' intent for everything, in order to save memory.
            return page.getOperatorList(
              "display"
            );
          };

        /***/
      },

    /***/ "./extensions/PDF/PDFTextLayer.js":
      /*!****************************************!*\
  !*** ./extensions/PDF/PDFTextLayer.js ***!
  \****************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        "use strict";
        __webpack_require__.r(
          __webpack_exports__
        );
        /* harmony export */ __webpack_require__.d(
          __webpack_exports__,
          {
            /* harmony export */ PDFTextLayer:
              () => /* binding */ PDFTextLayer,
            /* harmony export */
          }
        );
        /* harmony import */ var _textlayer_css__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./textlayer.css */ "./extensions/PDF/textlayer.css"
          );
        /* harmony import */ var _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! @adsk/pdfjs-dist */ "./node_modules/@adsk/pdfjs-dist/legacy/build/pdf.js"
          );
        /* harmony import */ var _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_1__
          );
        /* harmony import */ var _PDFFontExtractor__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./PDFFontExtractor */ "./extensions/PDF/PDFFontExtractor.js"
          );
        /**
         * PDF Text Layer is hiden on top of our drawings
         * And it will provide the possible user experience to select/hightlight/copy/search
         * From Vector PDF Document
         */

        var av = Autodesk.Viewing;
        var avu = Autodesk.Viewing.UI;

        function PDFTextLayer(
          viewer,
          usingTextLayer
        ) {
          this.viewer = viewer;
          this.setGlobalManager(
            viewer.globalManager
          );

          this.onModelLoaded =
            this.onModelLoaded.bind(this);
          this.onRenderFinished =
            this.onRenderFinished.bind(this);
          this.onModelUnload =
            this.onModelUnload.bind(this);

          viewer.addEventListener(
            av.GEOMETRY_LOADED_EVENT,
            this.onModelLoaded
          );
          viewer.addEventListener(
            av.PROGRESS_UPDATE_EVENT,
            this.onRenderFinished
          );
          viewer.addEventListener(
            av.MODEL_UNLOADED_EVENT,
            this.onModelUnload
          );

          this.usingTextLayer = usingTextLayer;
          this.textSelectionEnabled = false;
        }

        av.GlobalManagerMixin.call(
          PDFTextLayer.prototype
        );

        PDFTextLayer.prototype.addToolbarButton =
          function () {
            if (this.toolButtonAdded) return;
            this.toolButtonAdded = true;

            if (!this.viewer.getToolbar) return;
            var toolbar =
              this.viewer.getToolbar();
            if (!toolbar) return;
            var modelTools = toolbar.getControl(
              Autodesk.Viewing.TOOLBAR
                .MODELTOOLSID
            );
            if (!modelTools) return;

            var button = new avu.Button(
              "toolbar-pdf-text-selection"
            );
            // Need CSS for the ICON and the actual icon
            button.setIcon(
              "adsk-icon-pdf-textselection"
            );
            button.setToolTip("Select Text");
            modelTools.addControl(button);
            this.toolbarButton = button;

            button.onClick = () => {
              this.textSelectionEnabled =
                !this.textSelectionEnabled;
              if (this.textLayerDiv) {
                if (this.textSelectionEnabled) {
                  this.textLayerDiv.classList.add(
                    "enabled"
                  );
                  this.viewer.toolController.enableMouseButtons(
                    false
                  );
                } else {
                  this.textLayerDiv.classList.remove(
                    "enabled"
                  );
                  this.viewer.toolController.enableMouseButtons(
                    true
                  );
                  this.clearSelection();
                }
                this.toolbarButton.setState(
                  this.textSelectionEnabled
                    ? avu.Button.State.ACTIVE
                    : avu.Button.State.INACTIVE
                );
              }
            };
          };

        PDFTextLayer.prototype.clearSelection =
          function () {
            const _document = this.getDocument();
            const _window = this.getWindow();
            if (_window.getSelection) {
              if (_window.getSelection().empty) {
                // Chrome
                _window.getSelection().empty();
              } else if (
                _window.getSelection()
                  .removeAllRanges
              ) {
                // Firefox
                _window
                  .getSelection()
                  .removeAllRanges();
              }
            } else if (_document.selection) {
              // IE?
              _document.selection.empty();
            }
          };

        PDFTextLayer.prototype.destroy =
          function () {
            this.onModelUnload();

            this.viewer.removeEventListener(
              av.GEOMETRY_LOADED_EVENT,
              this.onModelLoaded
            );
            this.viewer.removeEventListener(
              av.PROGRESS_UPDATE_EVENT,
              this.onRenderFinished
            );
            this.viewer.removeEventListener(
              av.MODEL_UNLOADED_EVENT,
              this.onModelUnload
            );

            this.removeToolbarButton();
          };

        PDFTextLayer.prototype.removeToolbarButton =
          function () {
            if (this.toolbarButton) {
              this.toolbarButton.removeFromParent();
              this.toolbarButton = null;
            }
          };

        PDFTextLayer.prototype.onRenderFinished =
          function (event) {
            if (
              event.percent == 100 &&
              event.state ===
                av.ProgressState.RENDERING &&
              this.centerTextlayer
            ) {
              this.centerTextlayer();
            }
          };

        PDFTextLayer.prototype.onModelUnload =
          function () {
            this.centerTextlayer = null;
            if (this.textLayerDiv) {
              this.textLayerDiv.remove();
              this.textLayerDiv = null;
            }
          };

        PDFTextLayer.prototype.onModelLoaded =
          function (event) {
            if (
              this.viewer.model &&
              this.viewer.model.isPdf() &&
              typeof this.viewer.model.getData()
                .getPDF === "function"
            ) {
              const pageNumber =
                this.viewer.model.getData()
                  .metadata.currentPage;
              const pdf = this.viewer.model
                .getData()
                .getPDF();
              const model = this.viewer.model;
              pdf
                .getPage(pageNumber)
                .then((page) => {
                  // Note that the model might be unloaded or replaced by a (maybe non-pdf) one meanwhile.
                  if (
                    this.viewer.model !== model
                  ) {
                    return;
                  }

                  this.renderTextLayer(page);
                });
            }
          };

        PDFTextLayer.prototype.renderTextLayer =
          function renderTextlayer(page) {
            const _document = this.getDocument();
            const readableStream =
              page.streamTextContent({
                normalizeWhitespace: true,
                combineTextItems: true,
              });
            const textLayerDiv =
              _document.createElement("div");
            var options = {
              scale: 1,
              rotation: page.rotate,
              dontFlip: false,
            };
            const viewport =
              page.getViewport(options);
            textLayerDiv.style.height = `${viewport.height}px`;
            textLayerDiv.style.width = `${viewport.width}px`;
            textLayerDiv.classList.add(
              "pdf-textlayer"
            );

            var scope = this;

            this.viewer.canvasWrap.append(
              textLayerDiv
            );
            this.textLayerDiv = textLayerDiv;

            // loop the style to check whether this text was loaded
            function getLoadedFonts() {
              const _document =
                scope.getDocument();
              let nodes =
                _document.getElementsByTagName(
                  "style"
                );
              let names = {};
              for (
                let i = 0;
                i < nodes.length;
                i++
              ) {
                if (
                  nodes[i].getAttribute(
                    "datatype"
                  ) === "fonts"
                ) {
                  names[
                    nodes[i].getAttribute("id")
                  ] = 1;
                }
              }
              return names;
            }

            // need to make the html overlay the same position as canvas
            function mapModelBoundsToScreen() {
              let bounds =
                scope.viewer.model.getBoundingBox();
              let min =
                scope.viewer.worldToClient(
                  bounds.min
                );
              let max =
                scope.viewer.worldToClient(
                  bounds.max
                );

              return {
                min: {
                  x: Math.min(min.x, max.x),
                  y: Math.min(min.y, max.y),
                  z: Math.min(min.z, max.z),
                },
                max: {
                  x: Math.max(min.x, max.x),
                  y: Math.max(min.y, max.y),
                  z: Math.max(min.z, max.z),
                },
              };
            }

            function centerTextlayer() {
              // PDF model might have been removed meanwhile
              if (!scope.viewer.model) {
                return;
              }

              // get transform matrix for the textLayer
              // scale
              let screenBounds =
                mapModelBoundsToScreen();
              let width =
                screenBounds.max.x -
                screenBounds.min.x;
              let height =
                screenBounds.max.y -
                screenBounds.min.y;
              let scale1 = Math.min(
                width / viewport.width,
                height / viewport.height
              );

              let matrix =
                new THREE.Matrix4().makeTranslation(
                  viewport.width / 2,
                  viewport.height / 2,
                  0
                );
              matrix = new THREE.Matrix4()
                .makeScale(scale1, scale1, 1)
                .multiply(matrix);
              matrix = new THREE.Matrix4()
                .makeTranslation(
                  -viewport.width / 2,
                  -viewport.height / 2,
                  0
                )
                .multiply(matrix);
              let left = screenBounds.min.x;
              let top = screenBounds.min.y;

              matrix = new THREE.Matrix4()
                .makeTranslation(left, top, 0)
                .multiply(matrix);
              let el = matrix.elements;
              let transform1 = `matrix(${[
                el[0],
                el[1],
                el[4],
                el[5],
                el[12],
                el[13],
              ].join(",")})`;
              textLayerDiv.style.transform =
                transform1;
            }

            function render() {
              let textDivs = [];
              return _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_1__
                .renderTextLayer({
                  pageIndex: page.pageNumber,
                  textDivs: textDivs,
                  viewport,
                  enhanceTextSelection: true,
                  textContentStream:
                    readableStream,
                  container: textLayerDiv,
                })
                .promise.then(() => {
                  if (scope.usingTextLayer) {
                    textLayerDiv.classList.add(
                      "visible"
                    );
                  }
                  if (textDivs.length > 0) {
                    scope.addToolbarButton();
                  }
                  centerTextlayer();
                });
            }

            var promise = Promise.resolve();
            if (this.usingTextLayer) {
              // for now only extract the font library when we show the text layer
              // because it will increase the loading time, will not use it for selection
              // But, if we decide to use it for selection, the selection/highlight will be more accurate
              promise = (0,
              _PDFFontExtractor__WEBPACK_IMPORTED_MODULE_2__.cssFontExtractor)(
                page,
                getLoadedFonts()
              )
                .then((data) => {
                  var fonts = [];
                  const _document =
                    this.getDocument();
                  for (
                    var i = 0;
                    i < data.length;
                    i++
                  ) {
                    let fontStyle =
                      _document.createElement(
                        "style"
                      );
                    _document
                      .getElementsByTagName(
                        "head"
                      )[0]
                      .append(fontStyle);
                    fontStyle.innerHTML =
                      data[i].css;
                    fontStyle.setAttribute(
                      "id",
                      data[i].name
                    );
                    fontStyle.setAttribute(
                      "datatype",
                      "fonts"
                    );
                    fonts.push(data[i].name);
                  }

                  return fonts;
                })
                .then((names) => {
                  // preload the fonts
                  const _document =
                    this.getDocument();
                  var promises = names.map(
                    (name) => {
                      return _document.fonts.load(
                        `10pt ${name}`
                      );
                    }
                  );
                  return Promise.all(promises);
                })
                .catch();
            }

            promise.then(render);

            this.centerTextlayer =
              centerTextlayer;
          };

        /***/
      },

    /***/ "./extensions/PDF/font-engine.js":
      /*!***************************************!*\
  !*** ./extensions/PDF/font-engine.js ***!
  \***************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        "use strict";
        __webpack_require__.r(
          __webpack_exports__
        );
        /* harmony export */ __webpack_require__.d(
          __webpack_exports__,
          {
            /* harmony export */ theFontEngine:
              () => /* binding */ theFontEngine,
            /* harmony export */
          }
        );
        /* harmony import */ var opentype_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! opentype.js */ "./node_modules/opentype.js/dist/opentype.js"
          );
        /* harmony import */ var opentype_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            opentype_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _res_fonts_font_list__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../../res/fonts/font-list */ "./res/fonts/font-list.js"
          );

        const getResourceUrl =
          Autodesk.Viewing.Private.getResourceUrl;

        let FONTS_LOADER;
        const avp = Autodesk.Viewing.Private;

        class FontEngine {
          constructor() {
            this.fontCache = {};
          }

          loadFont(f) {
            return new Promise((resolve) => {
              opentype_js__WEBPACK_IMPORTED_MODULE_0__.load(
                getResourceUrl(f.url),
                (err, font) => {
                  if (!font) {
                    const warning = `Failed to load font ${f.name}`;
                    avp.logger.warn(warning);

                    // As we output a warning and not throw an error, we still want to resolve.
                    resolve(warning);
                    return;
                  }

                  font.pathCache = {};

                  this.fontCache[f.name] = font;

                  f.subs.forEach((s) => {
                    this.fontCache[s] = font;
                  });

                  resolve();
                }
              );
            });
          }

          loadFonts() {
            if (FONTS_LOADER) return FONTS_LOADER;

            let loaders =
              _res_fonts_font_list__WEBPACK_IMPORTED_MODULE_1__.FONT_LIST.map(
                (f) => {
                  if (f.url) {
                    return this.loadFont(f);
                  }
                }
              );

            FONTS_LOADER = Promise.all(loaders);
            return FONTS_LOADER;
          }

          mapFont(font) {
            let cachedFont =
              this.fontCache[
                font.name.toLowerCase()
              ];
            if (!cachedFont)
              cachedFont =
                this.fontCache[
                  font.loadedName.toLowerCase()
                ];
            if (!cachedFont)
              cachedFont =
                this.fontCache[
                  font.fallbackName.toLowerCase()
                ];

            if (!cachedFont) {
              avp.logger.warn(
                "Failed to map font",
                font.name
              );
            }

            return cachedFont;
          }

          drawText(
            ctx,
            text,
            x,
            y,
            font,
            fontSize
          ) {
            let cachedFont = this.mapFont(font);

            if (!cachedFont) return;

            if (text.length === 1) {
              let perSizeCache =
                cachedFont.pathCache[fontSize];

              let path =
                perSizeCache &&
                perSizeCache[text];

              if (!path) {
                path = cachedFont.getPath(
                  text,
                  0,
                  0,
                  fontSize
                );
                path.fill = null;
                path.stroke = null;

                if (!perSizeCache) {
                  perSizeCache =
                    cachedFont.pathCache[
                      fontSize
                    ] = {};
                }
                perSizeCache[text] = path;
              }

              ctx.beginPath(
                text,
                x,
                y,
                font,
                fontSize
              );
              for (
                let i = 0;
                i < path.commands.length;
                i += 1
              ) {
                const cmd = path.commands[i];
                if (cmd.type === "M") {
                  ctx.moveTo(
                    cmd.x + x,
                    cmd.y + y
                  );
                } else if (cmd.type === "L") {
                  ctx.lineTo(
                    cmd.x + x,
                    cmd.y + y
                  );
                } else if (cmd.type === "C") {
                  ctx.bezierCurveTo(
                    cmd.x1 + x,
                    cmd.y1 + y,
                    cmd.x2 + x,
                    cmd.y2 + y,
                    cmd.x + x,
                    cmd.y + y
                  );
                } else if (cmd.type === "Q") {
                  ctx.quadraticCurveTo(
                    cmd.x1 + x,
                    cmd.y1 + y,
                    cmd.x + x,
                    cmd.y + y
                  );
                } else if (cmd.type === "Z") {
                  ctx.closePath();
                }
              }
            } else {
              //TODO: No caching is attempted here. This code path should not be
              //called during normal PDF loading. If it every is, it needs to be optimized as above.
              avp.logger.warn(
                "Multi-character text rendering not fully implemented"
              );
              cachedFont.draw(
                ctx,
                text,
                x,
                y,
                fontSize
              );
            }
          }

          getOnDemandFont(name) {
            for (
              let i = 0;
              i <
              _res_fonts_font_list__WEBPACK_IMPORTED_MODULE_1__
                .ONDEMAND_FONT_LIST.length;
              i++
            ) {
              const entry =
                _res_fonts_font_list__WEBPACK_IMPORTED_MODULE_1__
                  .ONDEMAND_FONT_LIST[i];
              if (
                entry.name === name ||
                entry.subs.includes(
                  name.toLowerCase()
                )
              ) {
                return entry;
              }
            }
          }
        }

        const theFontEngine = new FontEngine();

        /***/
      },

    /***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./node_modules/css-unicode-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/PDF/textlayer.css":
      /*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./node_modules/css-unicode-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/PDF/textlayer.css ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
      /***/ (
        module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        "use strict";
        __webpack_require__.r(
          __webpack_exports__
        );
        /* harmony export */ __webpack_require__.d(
          __webpack_exports__,
          {
            /* harmony export */ default: () =>
              __WEBPACK_DEFAULT_EXPORT__,
            /* harmony export */
          }
        );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ "./node_modules/css-loader/dist/runtime/noSourceMaps.js"
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js"
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__
          );
        // Imports

        var ___CSS_LOADER_EXPORT___ =
          _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(
            _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()
          );
        // Module
        ___CSS_LOADER_EXPORT___.push([
          module.id,
          `.pdf-textlayer {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  overflow: hidden;
  /* opacity: 0.45; */
  /* line-height: 1.0; */
  -webkit-font-smoothing: subpixel-antialiased;
  display: none;
}

.pdf-textlayer > div {
  color: transparent;
  /* color: black; */
  position: absolute;
  white-space: pre;
  -webkit-transform-origin: 0% 0%;
  transform-origin: 0% 0%;
  user-select: text;
  -webkit-user-select: text;
  -webkit-text-size-adjust: none;
  text-size-adjust: none;
  display: inline;
}

.pdf-textlayer.enabled {
  display: block;
}

.pdf-textlayer.visible {
  display: block;
}

.pdf-textlayer.visible > div {
  display: block;
  color: black; /*default color for text in case not defined in pdf*/
}

.pdf-textlayer.enabled > div {
  cursor: text;
}

.pdf-textlayer .highlight {
  margin: -1px;
  padding: 1px;
  background-color: rgb(180, 0, 170);
  border-radius: 4px;
}

.pdf-textlayer .highlight.begin {
  border-radius: 4px 0px 0px 4px;
}

.pdf-textlayer .highlight.end {
  border-radius: 0px 4px 4px 0px;
}

.pdf-textlayer .highlight.middle {
  border-radius: 0px;
}

.pdf-textlayer .highlight.selected {
  background-color: rgb(0, 100, 0);
}

.pdf-textlayer ::-moz-selection {
  background: rgba(0, 0, 255, 0.45);
  color: transparent;
}

.pdf-textlayer ::selection {
  background: rgba(0, 0, 255, 0.45);
  color: transparent;
}

.pdf-textlayer.visible ::-moz-selection {
  background: rgba(0, 0, 255, 0.45);
  color: unset;
}

.pdf-textlayer.visible ::selection {
  background: rgba(0, 0, 255, 0.45);
  color: unset;
}

.pdf-textlayer .endOfContent {
  display: block;
  position: absolute;
  left: 0px;
  top: 100%;
  right: 0px;
  bottom: 0px;
  z-index: -1;
  cursor: default;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.pdf-textlayer .endOfContent.active {
  top: 0px;
}

.active .adsk-icon-pdf-textselection {
  background: url("data:image/svg+xml,%3C%3Fxml version%3D%221.0%22 encoding%3D%22UTF-8%22 standalone%3D%22no%22%3F%3E%3Csvg width%3D%2216px%22 height%3D%2216px%22 viewBox%3D%220 0 14 16%22 version%3D%221.1%22 xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E    %3C!-- Generator%3A Sketch 3.7.1 (28215) - http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch --%3E    %3Ctitle%3Eicon-text%3C%2Ftitle%3E    %3Cdesc%3ECreated with Sketch.%3C%2Fdesc%3E    %3Cdefs%3E%3C%2Fdefs%3E    %3Cg id%3D%22Page-1%22 stroke%3D%22none%22 stroke-width%3D%221%22 fill%3D%22none%22 fill-rule%3D%22evenodd%22%3E        %3Cg id%3D%22tools%22 transform%3D%22translate(-508.000000%2C -27.000000)%22 fill%3D%22%2300BFFF%22%3E            %3Cg id%3D%22text%22 transform%3D%22translate(500.000000%2C 20.000000)%22%3E                %3Cg id%3D%22icon-text%22 transform%3D%22translate(8.000000%2C 7.000000)%22%3E                    %3Cpath d%3D%22M13.6924546%2C0.948 C13.5289104%2C0.387 13.0022776%2C0 12.4036441%2C0 L8.02806554%2C0 L6.99948571%2C0 L1.59532731%2C0 C0.996693851%2C0 0.47006098%2C0.387 0.306516788%2C0.948 C0.306516788%2C0.948 0%2C2.844 0%2C3.375 C0%2C3.906 0.402174712%2C4 0.402174712%2C4 L1.02857983%2C4 L1.68687091%2C2.72 C1.91315847%2C2.279 2.37704798%2C2 2.88516641%2C2 L5.97090588%2C2 L5.97090588%2C13 L4.94232606%2C14 L2.88516641%2C14 L2.88516641%2C16 L11.113805%2C16 L11.113805%2C14 L9.05664536%2C14 L8.02806554%2C13 L8.02806554%2C2 L11.113805%2C2 C11.6219234%2C2 12.0858129%2C2.279 12.3131291%2C2.72 L12.9714202%2C4 L13.5978253%2C4 C13.5978253%2C4 14%2C3.906 14%2C3.375 C13.9989714%2C2.844 13.6924546%2C0.948 13.6924546%2C0.948 L13.6924546%2C0.948 Z%22 id%3D%22Shape%22%3E%3C%2Fpath%3E                %3C%2Fg%3E            %3C%2Fg%3E        %3C%2Fg%3E    %3C%2Fg%3E%3C%2Fsvg%3E");
  background-repeat: no-repeat;
  background-position: center;
}

.inactive .adsk-icon-pdf-textselection {
  background: url("data:image/svg+xml,%3C%3Fxml version%3D%221.0%22 encoding%3D%22UTF-8%22 standalone%3D%22no%22%3F%3E%3Csvg width%3D%2214px%22 height%3D%2216px%22 viewBox%3D%220 0 14 16%22 version%3D%221.1%22 xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E    %3C!-- Generator%3A Sketch 3.7.1 (28215) - http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch --%3E    %3Ctitle%3Eicon-text%3C%2Ftitle%3E    %3Cdesc%3ECreated with Sketch.%3C%2Fdesc%3E    %3Cdefs%3E%3C%2Fdefs%3E    %3Cg id%3D%22Page-1%22 stroke%3D%22none%22 stroke-width%3D%221%22 fill%3D%22none%22 fill-rule%3D%22evenodd%22%3E        %3Cg id%3D%22tools%22 transform%3D%22translate(-508.000000%2C -27.000000)%22 fill%3D%22%23F4F4F4%22%3E            %3Cg id%3D%22text%22 transform%3D%22translate(500.000000%2C 20.000000)%22%3E                %3Cg id%3D%22icon-text%22 transform%3D%22translate(8.000000%2C 7.000000)%22%3E                    %3Cpath d%3D%22M13.6924546%2C0.948 C13.5289104%2C0.387 13.0022776%2C0 12.4036441%2C0 L8.02806554%2C0 L6.99948571%2C0 L1.59532731%2C0 C0.996693851%2C0 0.47006098%2C0.387 0.306516788%2C0.948 C0.306516788%2C0.948 0%2C2.844 0%2C3.375 C0%2C3.906 0.402174712%2C4 0.402174712%2C4 L1.02857983%2C4 L1.68687091%2C2.72 C1.91315847%2C2.279 2.37704798%2C2 2.88516641%2C2 L5.97090588%2C2 L5.97090588%2C13 L4.94232606%2C14 L2.88516641%2C14 L2.88516641%2C16 L11.113805%2C16 L11.113805%2C14 L9.05664536%2C14 L8.02806554%2C13 L8.02806554%2C2 L11.113805%2C2 C11.6219234%2C2 12.0858129%2C2.279 12.3131291%2C2.72 L12.9714202%2C4 L13.5978253%2C4 C13.5978253%2C4 14%2C3.906 14%2C3.375 C13.9989714%2C2.844 13.6924546%2C0.948 13.6924546%2C0.948 L13.6924546%2C0.948 Z%22 id%3D%22Shape%22%3E%3C%2Fpath%3E                %3C%2Fg%3E            %3C%2Fg%3E        %3C%2Fg%3E    %3C%2Fg%3E%3C%2Fsvg%3E");
  background-repeat: no-repeat;
  background-position: center;
}

.adsk-viewing-viewer.light-theme .inactive .adsk-icon-pdf-textselection {
  background: url("data:image/svg+xml,%3C%3Fxml version%3D%221.0%22 encoding%3D%22UTF-8%22 standalone%3D%22no%22%3F%3E%3Csvg width%3D%2216px%22 height%3D%2216px%22 viewBox%3D%220 0 14 16%22 version%3D%221.1%22 xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E    %3C!-- Generator%3A Sketch 3.7.1 (28215) - http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch --%3E    %3Ctitle%3Eicon-text%3C%2Ftitle%3E    %3Cdesc%3ECreated with Sketch.%3C%2Fdesc%3E    %3Cdefs%3E%3C%2Fdefs%3E    %3Cg id%3D%22Page-1%22 stroke%3D%22none%22 stroke-width%3D%221%22 fill%3D%22none%22 fill-rule%3D%22evenodd%22%3E        %3Cg id%3D%22tools%22 transform%3D%22translate(-508.000000%2C -27.000000)%22 fill%3D%22%230A131C%22%3E            %3Cg id%3D%22text%22 transform%3D%22translate(500.000000%2C 20.000000)%22%3E                %3Cg id%3D%22icon-text%22 transform%3D%22translate(8.000000%2C 7.000000)%22%3E                    %3Cpath d%3D%22M13.6924546%2C0.948 C13.5289104%2C0.387 13.0022776%2C0 12.4036441%2C0 L8.02806554%2C0 L6.99948571%2C0 L1.59532731%2C0 C0.996693851%2C0 0.47006098%2C0.387 0.306516788%2C0.948 C0.306516788%2C0.948 0%2C2.844 0%2C3.375 C0%2C3.906 0.402174712%2C4 0.402174712%2C4 L1.02857983%2C4 L1.68687091%2C2.72 C1.91315847%2C2.279 2.37704798%2C2 2.88516641%2C2 L5.97090588%2C2 L5.97090588%2C13 L4.94232606%2C14 L2.88516641%2C14 L2.88516641%2C16 L11.113805%2C16 L11.113805%2C14 L9.05664536%2C14 L8.02806554%2C13 L8.02806554%2C2 L11.113805%2C2 C11.6219234%2C2 12.0858129%2C2.279 12.3131291%2C2.72 L12.9714202%2C4 L13.5978253%2C4 C13.5978253%2C4 14%2C3.906 14%2C3.375 C13.9989714%2C2.844 13.6924546%2C0.948 13.6924546%2C0.948 L13.6924546%2C0.948 Z%22 id%3D%22Shape%22%3E%3C%2Fpath%3E                %3C%2Fg%3E            %3C%2Fg%3E        %3C%2Fg%3E    %3C%2Fg%3E%3C%2Fsvg%3E");
  background-repeat: no-repeat;
  background-position: center;
}`,
          "",
        ]);
        // Exports
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          ___CSS_LOADER_EXPORT___;

        /***/
      },

    /***/ "./node_modules/css-loader/dist/runtime/api.js":
      /*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
      /***/ (module) => {
        "use strict";

        /*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
        module.exports = function (
          cssWithMappingToString
        ) {
          var list = [];

          // return the list of modules as css string
          list.toString = function toString() {
            return this.map(function (item) {
              var content = "";
              var needLayer =
                typeof item[5] !== "undefined";
              if (item[4]) {
                content += "@supports (".concat(
                  item[4],
                  ") {"
                );
              }
              if (item[2]) {
                content += "@media ".concat(
                  item[2],
                  " {"
                );
              }
              if (needLayer) {
                content += "@layer".concat(
                  item[5].length > 0
                    ? " ".concat(item[5])
                    : "",
                  " {"
                );
              }
              content +=
                cssWithMappingToString(item);
              if (needLayer) {
                content += "}";
              }
              if (item[2]) {
                content += "}";
              }
              if (item[4]) {
                content += "}";
              }
              return content;
            }).join("");
          };

          // import a list of modules into the list
          list.i = function i(
            modules,
            media,
            dedupe,
            supports,
            layer
          ) {
            if (typeof modules === "string") {
              modules = [
                [null, modules, undefined],
              ];
            }
            var alreadyImportedModules = {};
            if (dedupe) {
              for (
                var k = 0;
                k < this.length;
                k++
              ) {
                var id = this[k][0];
                if (id != null) {
                  alreadyImportedModules[
                    id
                  ] = true;
                }
              }
            }
            for (
              var _k = 0;
              _k < modules.length;
              _k++
            ) {
              var item = [].concat(modules[_k]);
              if (
                dedupe &&
                alreadyImportedModules[item[0]]
              ) {
                continue;
              }
              if (typeof layer !== "undefined") {
                if (
                  typeof item[5] === "undefined"
                ) {
                  item[5] = layer;
                } else {
                  item[1] = "@layer"
                    .concat(
                      item[5].length > 0
                        ? " ".concat(item[5])
                        : "",
                      " {"
                    )
                    .concat(item[1], "}");
                  item[5] = layer;
                }
              }
              if (media) {
                if (!item[2]) {
                  item[2] = media;
                } else {
                  item[1] = "@media "
                    .concat(item[2], " {")
                    .concat(item[1], "}");
                  item[2] = media;
                }
              }
              if (supports) {
                if (!item[4]) {
                  item[4] = "".concat(supports);
                } else {
                  item[1] = "@supports ("
                    .concat(item[4], ") {")
                    .concat(item[1], "}");
                  item[4] = supports;
                }
              }
              list.push(item);
            }
          };
          return list;
        };

        /***/
      },

    /***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
      /*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
      /***/ (module) => {
        "use strict";

        module.exports = function (i) {
          return i[1];
        };

        /***/
      },

    /***/ "./node_modules/opentype.js/dist/opentype.js":
      /*!***************************************************!*\
  !*** ./node_modules/opentype.js/dist/opentype.js ***!
  \***************************************************/
      /***/ function (
        __unused_webpack_module,
        exports,
        __webpack_require__
      ) {
        /**
         * https://opentype.js.org v0.9.0 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens
         */

        (function (global, factory) {
          true ? factory(exports) : 0;
        })(this, function (exports) {
          "use strict";

          /*! https://mths.be/codepointat v0.2.0 by @mathias */
          if (!String.prototype.codePointAt) {
            (function () {
              var defineProperty = (function () {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                  var object = {};
                  var $defineProperty =
                    Object.defineProperty;
                  var result =
                    $defineProperty(
                      object,
                      object,
                      object
                    ) && $defineProperty;
                } catch (error) {}
                return result;
              })();
              var codePointAt = function (
                position
              ) {
                if (this == null) {
                  throw TypeError();
                }
                var string = String(this);
                var size = string.length;
                // `ToInteger`
                var index = position
                  ? Number(position)
                  : 0;
                if (index != index) {
                  // better `isNaN`
                  index = 0;
                }
                // Account for out-of-bounds indices:
                if (index < 0 || index >= size) {
                  return undefined;
                }
                // Get the first code unit
                var first =
                  string.charCodeAt(index);
                var second;
                if (
                  // check if it’s the start of a surrogate pair
                  first >= 0xd800 &&
                  first <= 0xdbff && // high surrogate
                  size > index + 1 // there is a next code unit
                ) {
                  second = string.charCodeAt(
                    index + 1
                  );
                  if (
                    second >= 0xdc00 &&
                    second <= 0xdfff
                  ) {
                    // low surrogate
                    // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    return (
                      (first - 0xd800) * 0x400 +
                      second -
                      0xdc00 +
                      0x10000
                    );
                  }
                }
                return first;
              };
              if (defineProperty) {
                defineProperty(
                  String.prototype,
                  "codePointAt",
                  {
                    value: codePointAt,
                    configurable: true,
                    writable: true,
                  }
                );
              } else {
                String.prototype.codePointAt =
                  codePointAt;
              }
            })();
          }

          var TINF_OK = 0;
          var TINF_DATA_ERROR = -3;

          function Tree() {
            this.table = new Uint16Array(
              16
            ); /* table of code length counts */
            this.trans = new Uint16Array(
              288
            ); /* code -> symbol translation table */
          }

          function Data(source, dest) {
            this.source = source;
            this.sourceIndex = 0;
            this.tag = 0;
            this.bitcount = 0;

            this.dest = dest;
            this.destLen = 0;

            this.ltree =
              new Tree(); /* dynamic length/symbol tree */
            this.dtree =
              new Tree(); /* dynamic distance tree */
          }

          /* --------------------------------------------------- *
           * -- uninitialized global data (static structures) -- *
           * --------------------------------------------------- */

          var sltree = new Tree();
          var sdtree = new Tree();

          /* extra bits and base tables for length codes */
          var length_bits = new Uint8Array(30);
          var length_base = new Uint16Array(30);

          /* extra bits and base tables for distance codes */
          var dist_bits = new Uint8Array(30);
          var dist_base = new Uint16Array(30);

          /* special ordering of code length codes */
          var clcidx = new Uint8Array([
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11,
            4, 12, 3, 13, 2, 14, 1, 15,
          ]);

          /* used by tinf_decode_trees, avoids allocations every call */
          var code_tree = new Tree();
          var lengths = new Uint8Array(288 + 32);

          /* ----------------------- *
           * -- utility functions -- *
           * ----------------------- */

          /* build extra bits and base tables */
          function tinf_build_bits_base(
            bits,
            base,
            delta,
            first
          ) {
            var i, sum;

            /* build bits table */
            for (i = 0; i < delta; ++i) {
              bits[i] = 0;
            }
            for (i = 0; i < 30 - delta; ++i) {
              bits[i + delta] = (i / delta) | 0;
            }

            /* build base table */
            for (
              sum = first, i = 0;
              i < 30;
              ++i
            ) {
              base[i] = sum;
              sum += 1 << bits[i];
            }
          }

          /* build the fixed huffman trees */
          function tinf_build_fixed_trees(
            lt,
            dt
          ) {
            var i;

            /* build fixed length tree */
            for (i = 0; i < 7; ++i) {
              lt.table[i] = 0;
            }

            lt.table[7] = 24;
            lt.table[8] = 152;
            lt.table[9] = 112;

            for (i = 0; i < 24; ++i) {
              lt.trans[i] = 256 + i;
            }
            for (i = 0; i < 144; ++i) {
              lt.trans[24 + i] = i;
            }
            for (i = 0; i < 8; ++i) {
              lt.trans[24 + 144 + i] = 280 + i;
            }
            for (i = 0; i < 112; ++i) {
              lt.trans[24 + 144 + 8 + i] =
                144 + i;
            }

            /* build fixed distance tree */
            for (i = 0; i < 5; ++i) {
              dt.table[i] = 0;
            }

            dt.table[5] = 32;

            for (i = 0; i < 32; ++i) {
              dt.trans[i] = i;
            }
          }

          /* given an array of code lengths, build a tree */
          var offs = new Uint16Array(16);

          function tinf_build_tree(
            t,
            lengths,
            off,
            num
          ) {
            var i, sum;

            /* clear code length count table */
            for (i = 0; i < 16; ++i) {
              t.table[i] = 0;
            }

            /* scan symbol lengths, and sum code length counts */
            for (i = 0; i < num; ++i) {
              t.table[lengths[off + i]]++;
            }

            t.table[0] = 0;

            /* compute offset table for distribution sort */
            for (sum = 0, i = 0; i < 16; ++i) {
              offs[i] = sum;
              sum += t.table[i];
            }

            /* create code->symbol translation table (symbols sorted by code) */
            for (i = 0; i < num; ++i) {
              if (lengths[off + i]) {
                t.trans[
                  offs[lengths[off + i]]++
                ] = i;
              }
            }
          }

          /* ---------------------- *
           * -- decode functions -- *
           * ---------------------- */

          /* get one bit from source stream */
          function tinf_getbit(d) {
            /* check if tag is empty */
            if (!d.bitcount--) {
              /* load next tag */
              d.tag = d.source[d.sourceIndex++];
              d.bitcount = 7;
            }

            /* shift bit out of tag */
            var bit = d.tag & 1;
            d.tag >>>= 1;

            return bit;
          }

          /* read a num bit value from a stream and add base */
          function tinf_read_bits(d, num, base) {
            if (!num) {
              return base;
            }

            while (d.bitcount < 24) {
              d.tag |=
                d.source[d.sourceIndex++] <<
                d.bitcount;
              d.bitcount += 8;
            }

            var val =
              d.tag & (0xffff >>> (16 - num));
            d.tag >>>= num;
            d.bitcount -= num;
            return val + base;
          }

          /* given a data stream and a tree, decode a symbol */
          function tinf_decode_symbol(d, t) {
            while (d.bitcount < 24) {
              d.tag |=
                d.source[d.sourceIndex++] <<
                d.bitcount;
              d.bitcount += 8;
            }

            var sum = 0,
              cur = 0,
              len = 0;
            var tag = d.tag;

            /* get more bits while code value is above sum */
            do {
              cur = 2 * cur + (tag & 1);
              tag >>>= 1;
              ++len;

              sum += t.table[len];
              cur -= t.table[len];
            } while (cur >= 0);

            d.tag = tag;
            d.bitcount -= len;

            return t.trans[sum + cur];
          }

          /* given a data stream, decode dynamic trees from it */
          function tinf_decode_trees(d, lt, dt) {
            var hlit, hdist, hclen;
            var i, num, length;

            /* get 5 bits HLIT (257-286) */
            hlit = tinf_read_bits(d, 5, 257);

            /* get 5 bits HDIST (1-32) */
            hdist = tinf_read_bits(d, 5, 1);

            /* get 4 bits HCLEN (4-19) */
            hclen = tinf_read_bits(d, 4, 4);

            for (i = 0; i < 19; ++i) {
              lengths[i] = 0;
            }

            /* read code lengths for code length alphabet */
            for (i = 0; i < hclen; ++i) {
              /* get 3 bits code length (0-7) */
              var clen = tinf_read_bits(d, 3, 0);
              lengths[clcidx[i]] = clen;
            }

            /* build code length tree */
            tinf_build_tree(
              code_tree,
              lengths,
              0,
              19
            );

            /* decode code lengths for the dynamic trees */
            for (num = 0; num < hlit + hdist; ) {
              var sym = tinf_decode_symbol(
                d,
                code_tree
              );

              switch (sym) {
                case 16:
                  /* copy previous code length 3-6 times (read 2 bits) */
                  var prev = lengths[num - 1];
                  for (
                    length = tinf_read_bits(
                      d,
                      2,
                      3
                    );
                    length;
                    --length
                  ) {
                    lengths[num++] = prev;
                  }
                  break;
                case 17:
                  /* repeat code length 0 for 3-10 times (read 3 bits) */
                  for (
                    length = tinf_read_bits(
                      d,
                      3,
                      3
                    );
                    length;
                    --length
                  ) {
                    lengths[num++] = 0;
                  }
                  break;
                case 18:
                  /* repeat code length 0 for 11-138 times (read 7 bits) */
                  for (
                    length = tinf_read_bits(
                      d,
                      7,
                      11
                    );
                    length;
                    --length
                  ) {
                    lengths[num++] = 0;
                  }
                  break;
                default:
                  /* values 0-15 represent the actual code lengths */
                  lengths[num++] = sym;
                  break;
              }
            }

            /* build dynamic trees */
            tinf_build_tree(lt, lengths, 0, hlit);
            tinf_build_tree(
              dt,
              lengths,
              hlit,
              hdist
            );
          }

          /* ----------------------------- *
           * -- block inflate functions -- *
           * ----------------------------- */

          /* given a stream and two trees, inflate a block of data */
          function tinf_inflate_block_data(
            d,
            lt,
            dt
          ) {
            while (1) {
              var sym = tinf_decode_symbol(d, lt);

              /* check for end of block */
              if (sym === 256) {
                return TINF_OK;
              }

              if (sym < 256) {
                d.dest[d.destLen++] = sym;
              } else {
                var length, dist, offs;
                var i;

                sym -= 257;

                /* possibly get more bits from length code */
                length = tinf_read_bits(
                  d,
                  length_bits[sym],
                  length_base[sym]
                );

                dist = tinf_decode_symbol(d, dt);

                /* possibly get more bits from distance code */
                offs =
                  d.destLen -
                  tinf_read_bits(
                    d,
                    dist_bits[dist],
                    dist_base[dist]
                  );

                /* copy match */
                for (
                  i = offs;
                  i < offs + length;
                  ++i
                ) {
                  d.dest[d.destLen++] = d.dest[i];
                }
              }
            }
          }

          /* inflate an uncompressed block of data */
          function tinf_inflate_uncompressed_block(
            d
          ) {
            var length, invlength;
            var i;

            /* unread from bitbuffer */
            while (d.bitcount > 8) {
              d.sourceIndex--;
              d.bitcount -= 8;
            }

            /* get length */
            length = d.source[d.sourceIndex + 1];
            length =
              256 * length +
              d.source[d.sourceIndex];

            /* get one's complement of length */
            invlength =
              d.source[d.sourceIndex + 3];
            invlength =
              256 * invlength +
              d.source[d.sourceIndex + 2];

            /* check length */
            if (
              length !==
              (~invlength & 0x0000ffff)
            ) {
              return TINF_DATA_ERROR;
            }

            d.sourceIndex += 4;

            /* copy block */
            for (i = length; i; --i) {
              d.dest[d.destLen++] =
                d.source[d.sourceIndex++];
            }

            /* make sure we start next block on a byte boundary */
            d.bitcount = 0;

            return TINF_OK;
          }

          /* inflate stream from source to dest */
          function tinf_uncompress(source, dest) {
            var d = new Data(source, dest);
            var bfinal, btype, res;

            do {
              /* read final block flag */
              bfinal = tinf_getbit(d);

              /* read block type (2 bits) */
              btype = tinf_read_bits(d, 2, 0);

              /* decompress block */
              switch (btype) {
                case 0:
                  /* decompress uncompressed block */
                  res =
                    tinf_inflate_uncompressed_block(
                      d
                    );
                  break;
                case 1:
                  /* decompress block with fixed huffman trees */
                  res = tinf_inflate_block_data(
                    d,
                    sltree,
                    sdtree
                  );
                  break;
                case 2:
                  /* decompress block with dynamic huffman trees */
                  tinf_decode_trees(
                    d,
                    d.ltree,
                    d.dtree
                  );
                  res = tinf_inflate_block_data(
                    d,
                    d.ltree,
                    d.dtree
                  );
                  break;
                default:
                  res = TINF_DATA_ERROR;
              }

              if (res !== TINF_OK) {
                throw new Error("Data error");
              }
            } while (!bfinal);

            if (d.destLen < d.dest.length) {
              if (
                typeof d.dest.slice === "function"
              ) {
                return d.dest.slice(0, d.destLen);
              } else {
                return d.dest.subarray(
                  0,
                  d.destLen
                );
              }
            }

            return d.dest;
          }

          /* -------------------- *
           * -- initialization -- *
           * -------------------- */

          /* build fixed huffman trees */
          tinf_build_fixed_trees(sltree, sdtree);

          /* build extra bits and base tables */
          tinf_build_bits_base(
            length_bits,
            length_base,
            4,
            3
          );
          tinf_build_bits_base(
            dist_bits,
            dist_base,
            2,
            1
          );

          /* fix a special case */
          length_bits[28] = 0;
          length_base[28] = 258;

          var tinyInflate = tinf_uncompress;

          // The Bounding Box object

          function derive(v0, v1, v2, v3, t) {
            return (
              Math.pow(1 - t, 3) * v0 +
              3 * Math.pow(1 - t, 2) * t * v1 +
              3 * (1 - t) * Math.pow(t, 2) * v2 +
              Math.pow(t, 3) * v3
            );
          }
          /**
           * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
           * It is used to calculate the bounding box of a glyph or text path.
           *
           * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
           *
           * @exports opentype.BoundingBox
           * @class
           * @constructor
           */
          function BoundingBox() {
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;
          }

          /**
           * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
           */
          BoundingBox.prototype.isEmpty =
            function () {
              return (
                isNaN(this.x1) ||
                isNaN(this.y1) ||
                isNaN(this.x2) ||
                isNaN(this.y2)
              );
            };

          /**
           * Add the point to the bounding box.
           * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
           * @param {number} x - The X coordinate of the point.
           * @param {number} y - The Y coordinate of the point.
           */
          BoundingBox.prototype.addPoint =
            function (x, y) {
              if (typeof x === "number") {
                if (
                  isNaN(this.x1) ||
                  isNaN(this.x2)
                ) {
                  this.x1 = x;
                  this.x2 = x;
                }
                if (x < this.x1) {
                  this.x1 = x;
                }
                if (x > this.x2) {
                  this.x2 = x;
                }
              }
              if (typeof y === "number") {
                if (
                  isNaN(this.y1) ||
                  isNaN(this.y2)
                ) {
                  this.y1 = y;
                  this.y2 = y;
                }
                if (y < this.y1) {
                  this.y1 = y;
                }
                if (y > this.y2) {
                  this.y2 = y;
                }
              }
            };

          /**
           * Add a X coordinate to the bounding box.
           * This extends the bounding box to include the X coordinate.
           * This function is used internally inside of addBezier.
           * @param {number} x - The X coordinate of the point.
           */
          BoundingBox.prototype.addX = function (
            x
          ) {
            this.addPoint(x, null);
          };

          /**
           * Add a Y coordinate to the bounding box.
           * This extends the bounding box to include the Y coordinate.
           * This function is used internally inside of addBezier.
           * @param {number} y - The Y coordinate of the point.
           */
          BoundingBox.prototype.addY = function (
            y
          ) {
            this.addPoint(null, y);
          };

          /**
           * Add a Bézier curve to the bounding box.
           * This extends the bounding box to include the entire Bézier.
           * @param {number} x0 - The starting X coordinate.
           * @param {number} y0 - The starting Y coordinate.
           * @param {number} x1 - The X coordinate of the first control point.
           * @param {number} y1 - The Y coordinate of the first control point.
           * @param {number} x2 - The X coordinate of the second control point.
           * @param {number} y2 - The Y coordinate of the second control point.
           * @param {number} x - The ending X coordinate.
           * @param {number} y - The ending Y coordinate.
           */
          BoundingBox.prototype.addBezier =
            function (
              x0,
              y0,
              x1,
              y1,
              x2,
              y2,
              x,
              y
            ) {
              var this$1 = this;

              // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
              // and https://github.com/icons8/svg-path-bounding-box

              var p0 = [x0, y0];
              var p1 = [x1, y1];
              var p2 = [x2, y2];
              var p3 = [x, y];

              this.addPoint(x0, y0);
              this.addPoint(x, y);

              for (var i = 0; i <= 1; i++) {
                var b =
                  6 * p0[i] -
                  12 * p1[i] +
                  6 * p2[i];
                var a =
                  -3 * p0[i] +
                  9 * p1[i] -
                  9 * p2[i] +
                  3 * p3[i];
                var c = 3 * p1[i] - 3 * p0[i];

                if (a === 0) {
                  if (b === 0) {
                    continue;
                  }
                  var t = -c / b;
                  if (0 < t && t < 1) {
                    if (i === 0) {
                      this$1.addX(
                        derive(
                          p0[i],
                          p1[i],
                          p2[i],
                          p3[i],
                          t
                        )
                      );
                    }
                    if (i === 1) {
                      this$1.addY(
                        derive(
                          p0[i],
                          p1[i],
                          p2[i],
                          p3[i],
                          t
                        )
                      );
                    }
                  }
                  continue;
                }

                var b2ac =
                  Math.pow(b, 2) - 4 * c * a;
                if (b2ac < 0) {
                  continue;
                }
                var t1 =
                  (-b + Math.sqrt(b2ac)) /
                  (2 * a);
                if (0 < t1 && t1 < 1) {
                  if (i === 0) {
                    this$1.addX(
                      derive(
                        p0[i],
                        p1[i],
                        p2[i],
                        p3[i],
                        t1
                      )
                    );
                  }
                  if (i === 1) {
                    this$1.addY(
                      derive(
                        p0[i],
                        p1[i],
                        p2[i],
                        p3[i],
                        t1
                      )
                    );
                  }
                }
                var t2 =
                  (-b - Math.sqrt(b2ac)) /
                  (2 * a);
                if (0 < t2 && t2 < 1) {
                  if (i === 0) {
                    this$1.addX(
                      derive(
                        p0[i],
                        p1[i],
                        p2[i],
                        p3[i],
                        t2
                      )
                    );
                  }
                  if (i === 1) {
                    this$1.addY(
                      derive(
                        p0[i],
                        p1[i],
                        p2[i],
                        p3[i],
                        t2
                      )
                    );
                  }
                }
              }
            };

          /**
           * Add a quadratic curve to the bounding box.
           * This extends the bounding box to include the entire quadratic curve.
           * @param {number} x0 - The starting X coordinate.
           * @param {number} y0 - The starting Y coordinate.
           * @param {number} x1 - The X coordinate of the control point.
           * @param {number} y1 - The Y coordinate of the control point.
           * @param {number} x - The ending X coordinate.
           * @param {number} y - The ending Y coordinate.
           */
          BoundingBox.prototype.addQuad =
            function (x0, y0, x1, y1, x, y) {
              var cp1x = x0 + (2 / 3) * (x1 - x0);
              var cp1y = y0 + (2 / 3) * (y1 - y0);
              var cp2x =
                cp1x + (1 / 3) * (x - x0);
              var cp2y =
                cp1y + (1 / 3) * (y - y0);
              this.addBezier(
                x0,
                y0,
                cp1x,
                cp1y,
                cp2x,
                cp2y,
                x,
                y
              );
            };

          // Geometric objects

          /**
           * A bézier path containing a set of path commands similar to a SVG path.
           * Paths can be drawn on a context using `draw`.
           * @exports opentype.Path
           * @class
           * @constructor
           */
          function Path() {
            this.commands = [];
            this.fill = "black";
            this.stroke = null;
            this.strokeWidth = 1;
          }

          /**
           * @param  {number} x
           * @param  {number} y
           */
          Path.prototype.moveTo = function (
            x,
            y
          ) {
            this.commands.push({
              type: "M",
              x: x,
              y: y,
            });
          };

          /**
           * @param  {number} x
           * @param  {number} y
           */
          Path.prototype.lineTo = function (
            x,
            y
          ) {
            this.commands.push({
              type: "L",
              x: x,
              y: y,
            });
          };

          /**
           * Draws cubic curve
           * @function
           * curveTo
           * @memberof opentype.Path.prototype
           * @param  {number} x1 - x of control 1
           * @param  {number} y1 - y of control 1
           * @param  {number} x2 - x of control 2
           * @param  {number} y2 - y of control 2
           * @param  {number} x - x of path point
           * @param  {number} y - y of path point
           */

          /**
           * Draws cubic curve
           * @function
           * bezierCurveTo
           * @memberof opentype.Path.prototype
           * @param  {number} x1 - x of control 1
           * @param  {number} y1 - y of control 1
           * @param  {number} x2 - x of control 2
           * @param  {number} y2 - y of control 2
           * @param  {number} x - x of path point
           * @param  {number} y - y of path point
           * @see curveTo
           */
          Path.prototype.curveTo =
            Path.prototype.bezierCurveTo =
              function (x1, y1, x2, y2, x, y) {
                this.commands.push({
                  type: "C",
                  x1: x1,
                  y1: y1,
                  x2: x2,
                  y2: y2,
                  x: x,
                  y: y,
                });
              };

          /**
           * Draws quadratic curve
           * @function
           * quadraticCurveTo
           * @memberof opentype.Path.prototype
           * @param  {number} x1 - x of control
           * @param  {number} y1 - y of control
           * @param  {number} x - x of path point
           * @param  {number} y - y of path point
           */

          /**
           * Draws quadratic curve
           * @function
           * quadTo
           * @memberof opentype.Path.prototype
           * @param  {number} x1 - x of control
           * @param  {number} y1 - y of control
           * @param  {number} x - x of path point
           * @param  {number} y - y of path point
           */
          Path.prototype.quadTo =
            Path.prototype.quadraticCurveTo =
              function (x1, y1, x, y) {
                this.commands.push({
                  type: "Q",
                  x1: x1,
                  y1: y1,
                  x: x,
                  y: y,
                });
              };

          /**
           * Closes the path
           * @function closePath
           * @memberof opentype.Path.prototype
           */

          /**
           * Close the path
           * @function close
           * @memberof opentype.Path.prototype
           */
          Path.prototype.close =
            Path.prototype.closePath =
              function () {
                this.commands.push({
                  type: "Z",
                });
              };

          /**
           * Add the given path or list of commands to the commands of this path.
           * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
           */
          Path.prototype.extend = function (
            pathOrCommands
          ) {
            if (pathOrCommands.commands) {
              pathOrCommands =
                pathOrCommands.commands;
            } else if (
              pathOrCommands instanceof
              BoundingBox
            ) {
              var box = pathOrCommands;
              this.moveTo(box.x1, box.y1);
              this.lineTo(box.x2, box.y1);
              this.lineTo(box.x2, box.y2);
              this.lineTo(box.x1, box.y2);
              this.close();
              return;
            }

            Array.prototype.push.apply(
              this.commands,
              pathOrCommands
            );
          };

          /**
           * Calculate the bounding box of the path.
           * @returns {opentype.BoundingBox}
           */
          Path.prototype.getBoundingBox =
            function () {
              var this$1 = this;

              var box = new BoundingBox();

              var startX = 0;
              var startY = 0;
              var prevX = 0;
              var prevY = 0;
              for (
                var i = 0;
                i < this.commands.length;
                i++
              ) {
                var cmd = this$1.commands[i];
                switch (cmd.type) {
                  case "M":
                    box.addPoint(cmd.x, cmd.y);
                    startX = prevX = cmd.x;
                    startY = prevY = cmd.y;
                    break;
                  case "L":
                    box.addPoint(cmd.x, cmd.y);
                    prevX = cmd.x;
                    prevY = cmd.y;
                    break;
                  case "Q":
                    box.addQuad(
                      prevX,
                      prevY,
                      cmd.x1,
                      cmd.y1,
                      cmd.x,
                      cmd.y
                    );
                    prevX = cmd.x;
                    prevY = cmd.y;
                    break;
                  case "C":
                    box.addBezier(
                      prevX,
                      prevY,
                      cmd.x1,
                      cmd.y1,
                      cmd.x2,
                      cmd.y2,
                      cmd.x,
                      cmd.y
                    );
                    prevX = cmd.x;
                    prevY = cmd.y;
                    break;
                  case "Z":
                    prevX = startX;
                    prevY = startY;
                    break;
                  default:
                    throw new Error(
                      "Unexpected path command " +
                        cmd.type
                    );
                }
              }
              if (box.isEmpty()) {
                box.addPoint(0, 0);
              }
              return box;
            };

          /**
           * Draw the path to a 2D context.
           * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
           */
          Path.prototype.draw = function (ctx) {
            var this$1 = this;

            ctx.beginPath();
            for (
              var i = 0;
              i < this.commands.length;
              i += 1
            ) {
              var cmd = this$1.commands[i];
              if (cmd.type === "M") {
                ctx.moveTo(cmd.x, cmd.y);
              } else if (cmd.type === "L") {
                ctx.lineTo(cmd.x, cmd.y);
              } else if (cmd.type === "C") {
                ctx.bezierCurveTo(
                  cmd.x1,
                  cmd.y1,
                  cmd.x2,
                  cmd.y2,
                  cmd.x,
                  cmd.y
                );
              } else if (cmd.type === "Q") {
                ctx.quadraticCurveTo(
                  cmd.x1,
                  cmd.y1,
                  cmd.x,
                  cmd.y
                );
              } else if (cmd.type === "Z") {
                ctx.closePath();
              }
            }

            if (this.fill) {
              ctx.fillStyle = this.fill;
              ctx.fill();
            }

            if (this.stroke) {
              ctx.strokeStyle = this.stroke;
              ctx.lineWidth = this.strokeWidth;
              ctx.stroke();
            }
          };

          /**
           * Convert the Path to a string of path data instructions
           * See http://www.w3.org/TR/SVG/paths.html#PathData
           * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
           * @return {string}
           */
          Path.prototype.toPathData = function (
            decimalPlaces
          ) {
            var this$1 = this;

            decimalPlaces =
              decimalPlaces !== undefined
                ? decimalPlaces
                : 2;

            function floatToString(v) {
              if (Math.round(v) === v) {
                return "" + Math.round(v);
              } else {
                return v.toFixed(decimalPlaces);
              }
            }

            function packValues() {
              var arguments$1 = arguments;

              var s = "";
              for (
                var i = 0;
                i < arguments.length;
                i += 1
              ) {
                var v = arguments$1[i];
                if (v >= 0 && i > 0) {
                  s += " ";
                }

                s += floatToString(v);
              }

              return s;
            }

            var d = "";
            for (
              var i = 0;
              i < this.commands.length;
              i += 1
            ) {
              var cmd = this$1.commands[i];
              if (cmd.type === "M") {
                d +=
                  "M" + packValues(cmd.x, cmd.y);
              } else if (cmd.type === "L") {
                d +=
                  "L" + packValues(cmd.x, cmd.y);
              } else if (cmd.type === "C") {
                d +=
                  "C" +
                  packValues(
                    cmd.x1,
                    cmd.y1,
                    cmd.x2,
                    cmd.y2,
                    cmd.x,
                    cmd.y
                  );
              } else if (cmd.type === "Q") {
                d +=
                  "Q" +
                  packValues(
                    cmd.x1,
                    cmd.y1,
                    cmd.x,
                    cmd.y
                  );
              } else if (cmd.type === "Z") {
                d += "Z";
              }
            }

            return d;
          };

          /**
           * Convert the path to an SVG <path> element, as a string.
           * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
           * @return {string}
           */
          Path.prototype.toSVG = function (
            decimalPlaces
          ) {
            var svg = '<path d="';
            svg += this.toPathData(decimalPlaces);
            svg += '"';
            if (
              this.fill &&
              this.fill !== "black"
            ) {
              if (this.fill === null) {
                svg += ' fill="none"';
              } else {
                svg +=
                  ' fill="' + this.fill + '"';
              }
            }

            if (this.stroke) {
              svg +=
                ' stroke="' +
                this.stroke +
                '" stroke-width="' +
                this.strokeWidth +
                '"';
            }

            svg += "/>";
            return svg;
          };

          /**
           * Convert the path to a DOM element.
           * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
           * @return {SVGPathElement}
           */
          Path.prototype.toDOMElement = function (
            decimalPlaces
          ) {
            var temporaryPath = this.toPathData(
              decimalPlaces
            );
            var newPath =
              document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
              );

            newPath.setAttribute(
              "d",
              temporaryPath
            );

            return newPath;
          };

          // Run-time checking of preconditions.

          function fail(message) {
            throw new Error(message);
          }

          // Precondition function that checks if the given predicate is true.
          // If not, it will throw an error.
          function argument(predicate, message) {
            if (!predicate) {
              fail(message);
            }
          }
          var check = {
            fail: fail,
            argument: argument,
            assert: argument,
          };

          // Data types used in the OpenType font file.

          var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
          var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

          /**
           * @exports opentype.decode
           * @class
           */
          var decode = {};
          /**
           * @exports opentype.encode
           * @class
           */
          var encode = {};
          /**
           * @exports opentype.sizeOf
           * @class
           */
          var sizeOf = {};

          // Return a function that always returns the same value.
          function constant(v) {
            return function () {
              return v;
            };
          }

          // OpenType data types //////////////////////////////////////////////////////

          /**
           * Convert an 8-bit unsigned integer to a list of 1 byte.
           * @param {number}
           * @returns {Array}
           */
          encode.BYTE = function (v) {
            check.argument(
              v >= 0 && v <= 255,
              "Byte value should be between 0 and 255."
            );
            return [v];
          };
          /**
           * @constant
           * @type {number}
           */
          sizeOf.BYTE = constant(1);

          /**
           * Convert a 8-bit signed integer to a list of 1 byte.
           * @param {string}
           * @returns {Array}
           */
          encode.CHAR = function (v) {
            return [v.charCodeAt(0)];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.CHAR = constant(1);

          /**
           * Convert an ASCII string to a list of bytes.
           * @param {string}
           * @returns {Array}
           */
          encode.CHARARRAY = function (v) {
            var b = [];
            for (
              var i = 0;
              i < v.length;
              i += 1
            ) {
              b[i] = v.charCodeAt(i);
            }

            return b;
          };

          /**
           * @param {Array}
           * @returns {number}
           */
          sizeOf.CHARARRAY = function (v) {
            return v.length;
          };

          /**
           * Convert a 16-bit unsigned integer to a list of 2 bytes.
           * @param {number}
           * @returns {Array}
           */
          encode.USHORT = function (v) {
            return [(v >> 8) & 0xff, v & 0xff];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.USHORT = constant(2);

          /**
           * Convert a 16-bit signed integer to a list of 2 bytes.
           * @param {number}
           * @returns {Array}
           */
          encode.SHORT = function (v) {
            // Two's complement
            if (v >= LIMIT16) {
              v = -(2 * LIMIT16 - v);
            }

            return [(v >> 8) & 0xff, v & 0xff];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.SHORT = constant(2);

          /**
           * Convert a 24-bit unsigned integer to a list of 3 bytes.
           * @param {number}
           * @returns {Array}
           */
          encode.UINT24 = function (v) {
            return [
              (v >> 16) & 0xff,
              (v >> 8) & 0xff,
              v & 0xff,
            ];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.UINT24 = constant(3);

          /**
           * Convert a 32-bit unsigned integer to a list of 4 bytes.
           * @param {number}
           * @returns {Array}
           */
          encode.ULONG = function (v) {
            return [
              (v >> 24) & 0xff,
              (v >> 16) & 0xff,
              (v >> 8) & 0xff,
              v & 0xff,
            ];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.ULONG = constant(4);

          /**
           * Convert a 32-bit unsigned integer to a list of 4 bytes.
           * @param {number}
           * @returns {Array}
           */
          encode.LONG = function (v) {
            // Two's complement
            if (v >= LIMIT32) {
              v = -(2 * LIMIT32 - v);
            }

            return [
              (v >> 24) & 0xff,
              (v >> 16) & 0xff,
              (v >> 8) & 0xff,
              v & 0xff,
            ];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.LONG = constant(4);

          encode.FIXED = encode.ULONG;
          sizeOf.FIXED = sizeOf.ULONG;

          encode.FWORD = encode.SHORT;
          sizeOf.FWORD = sizeOf.SHORT;

          encode.UFWORD = encode.USHORT;
          sizeOf.UFWORD = sizeOf.USHORT;

          /**
           * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
           * @param {number}
           * @returns {Array}
           */
          encode.LONGDATETIME = function (v) {
            return [
              0,
              0,
              0,
              0,
              (v >> 24) & 0xff,
              (v >> 16) & 0xff,
              (v >> 8) & 0xff,
              v & 0xff,
            ];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.LONGDATETIME = constant(8);

          /**
           * Convert a 4-char tag to a list of 4 bytes.
           * @param {string}
           * @returns {Array}
           */
          encode.TAG = function (v) {
            check.argument(
              v.length === 4,
              "Tag should be exactly 4 ASCII characters."
            );
            return [
              v.charCodeAt(0),
              v.charCodeAt(1),
              v.charCodeAt(2),
              v.charCodeAt(3),
            ];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.TAG = constant(4);

          // CFF data types ///////////////////////////////////////////////////////////

          encode.Card8 = encode.BYTE;
          sizeOf.Card8 = sizeOf.BYTE;

          encode.Card16 = encode.USHORT;
          sizeOf.Card16 = sizeOf.USHORT;

          encode.OffSize = encode.BYTE;
          sizeOf.OffSize = sizeOf.BYTE;

          encode.SID = encode.USHORT;
          sizeOf.SID = sizeOf.USHORT;

          // Convert a numeric operand or charstring number to a variable-size list of bytes.
          /**
           * Convert a numeric operand or charstring number to a variable-size list of bytes.
           * @param {number}
           * @returns {Array}
           */
          encode.NUMBER = function (v) {
            if (v >= -107 && v <= 107) {
              return [v + 139];
            } else if (v >= 108 && v <= 1131) {
              v = v - 108;
              return [(v >> 8) + 247, v & 0xff];
            } else if (v >= -1131 && v <= -108) {
              v = -v - 108;
              return [(v >> 8) + 251, v & 0xff];
            } else if (
              v >= -32768 &&
              v <= 32767
            ) {
              return encode.NUMBER16(v);
            } else {
              return encode.NUMBER32(v);
            }
          };

          /**
           * @param {number}
           * @returns {number}
           */
          sizeOf.NUMBER = function (v) {
            return encode.NUMBER(v).length;
          };

          /**
           * Convert a signed number between -32768 and +32767 to a three-byte value.
           * This ensures we always use three bytes, but is not the most compact format.
           * @param {number}
           * @returns {Array}
           */
          encode.NUMBER16 = function (v) {
            return [
              28,
              (v >> 8) & 0xff,
              v & 0xff,
            ];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.NUMBER16 = constant(3);

          /**
           * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
           * This is useful if you want to be sure you always use four bytes,
           * at the expense of wasting a few bytes for smaller numbers.
           * @param {number}
           * @returns {Array}
           */
          encode.NUMBER32 = function (v) {
            return [
              29,
              (v >> 24) & 0xff,
              (v >> 16) & 0xff,
              (v >> 8) & 0xff,
              v & 0xff,
            ];
          };

          /**
           * @constant
           * @type {number}
           */
          sizeOf.NUMBER32 = constant(5);

          /**
           * @param {number}
           * @returns {Array}
           */
          encode.REAL = function (v) {
            var value = v.toString();

            // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
            // This code converts it back to a number without the epsilon.
            var m =
              /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(
                value
              );
            if (m) {
              var epsilon = parseFloat(
                "1e" +
                  ((m[2] ? +m[2] : 0) +
                    m[1].length)
              );
              value = (
                Math.round(v * epsilon) / epsilon
              ).toString();
            }

            var nibbles = "";
            for (
              var i = 0, ii = value.length;
              i < ii;
              i += 1
            ) {
              var c = value[i];
              if (c === "e") {
                nibbles +=
                  value[++i] === "-" ? "c" : "b";
              } else if (c === ".") {
                nibbles += "a";
              } else if (c === "-") {
                nibbles += "e";
              } else {
                nibbles += c;
              }
            }

            nibbles +=
              nibbles.length & 1 ? "f" : "ff";
            var out = [30];
            for (
              var i$1 = 0, ii$1 = nibbles.length;
              i$1 < ii$1;
              i$1 += 2
            ) {
              out.push(
                parseInt(
                  nibbles.substr(i$1, 2),
                  16
                )
              );
            }

            return out;
          };

          /**
           * @param {number}
           * @returns {number}
           */
          sizeOf.REAL = function (v) {
            return encode.REAL(v).length;
          };

          encode.NAME = encode.CHARARRAY;
          sizeOf.NAME = sizeOf.CHARARRAY;

          encode.STRING = encode.CHARARRAY;
          sizeOf.STRING = sizeOf.CHARARRAY;

          /**
           * @param {DataView} data
           * @param {number} offset
           * @param {number} numBytes
           * @returns {string}
           */
          decode.UTF8 = function (
            data,
            offset,
            numBytes
          ) {
            var codePoints = [];
            var numChars = numBytes;
            for (
              var j = 0;
              j < numChars;
              j++, offset += 1
            ) {
              codePoints[j] =
                data.getUint8(offset);
            }

            return String.fromCharCode.apply(
              null,
              codePoints
            );
          };

          /**
           * @param {DataView} data
           * @param {number} offset
           * @param {number} numBytes
           * @returns {string}
           */
          decode.UTF16 = function (
            data,
            offset,
            numBytes
          ) {
            var codePoints = [];
            var numChars = numBytes / 2;
            for (
              var j = 0;
              j < numChars;
              j++, offset += 2
            ) {
              codePoints[j] =
                data.getUint16(offset);
            }

            return String.fromCharCode.apply(
              null,
              codePoints
            );
          };

          /**
           * Convert a JavaScript string to UTF16-BE.
           * @param {string}
           * @returns {Array}
           */
          encode.UTF16 = function (v) {
            var b = [];
            for (
              var i = 0;
              i < v.length;
              i += 1
            ) {
              var codepoint = v.charCodeAt(i);
              b[b.length] =
                (codepoint >> 8) & 0xff;
              b[b.length] = codepoint & 0xff;
            }

            return b;
          };

          /**
           * @param {string}
           * @returns {number}
           */
          sizeOf.UTF16 = function (v) {
            return v.length * 2;
          };

          // Data for converting old eight-bit Macintosh encodings to Unicode.
          // This representation is optimized for decoding; encoding is slower
          // and needs more memory. The assumption is that all opentype.js users
          // want to open fonts, but saving a font will be comparatively rare
          // so it can be more expensive. Keyed by IANA character set name.
          //
          // Python script for generating these strings:
          //
          //     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
          //     print(s.encode('utf-8'))
          /**
           * @private
           */
          var eightBitMacEncodings = {
            // Python: 'mac_croatian'
            "x-mac-croatian":
              "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø" +
              "¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ",
            // Python: 'mac_cyrillic'
            "x-mac-cyrillic":
              "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ" +
              "јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю",
            // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
            "x-mac-gaelic":
              "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø" +
              "ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ",
            // Python: 'mac_greek'
            "x-mac-greek":
              "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ" +
              "άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\u00AD",
            // Python: 'mac_iceland'
            "x-mac-icelandic":
              "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø" +
              "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
            // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
            "x-mac-inuit":
              "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ" +
              "ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł",
            // Python: 'mac_latin2'
            "x-mac-ce":
              "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ" +
              "ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ",
            // Python: 'mac_roman'
            macintosh:
              "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø" +
              "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
            // Python: 'mac_romanian'
            "x-mac-romanian":
              "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș" +
              "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
            // Python: 'mac_turkish'
            "x-mac-turkish":
              "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø" +
              "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ",
          };

          /**
           * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
           * string, or 'undefined' if the encoding is unsupported. For example, we do
           * not support Chinese, Japanese or Korean because these would need large
           * mapping tables.
           * @param {DataView} dataView
           * @param {number} offset
           * @param {number} dataLength
           * @param {string} encoding
           * @returns {string}
           */
          decode.MACSTRING = function (
            dataView,
            offset,
            dataLength,
            encoding
          ) {
            var table =
              eightBitMacEncodings[encoding];
            if (table === undefined) {
              return undefined;
            }

            var result = "";
            for (var i = 0; i < dataLength; i++) {
              var c = dataView.getUint8(
                offset + i
              );
              // In all eight-bit Mac encodings, the characters 0x00..0x7F are
              // mapped to U+0000..U+007F; we only need to look up the others.
              if (c <= 0x7f) {
                result += String.fromCharCode(c);
              } else {
                result += table[c & 0x7f];
              }
            }

            return result;
          };

          // Helper function for encode.MACSTRING. Returns a dictionary for mapping
          // Unicode character codes to their 8-bit MacOS equivalent. This table
          // is not exactly a super cheap data structure, but we do not care because
          // encoding Macintosh strings is only rarely needed in typical applications.
          var macEncodingTableCache =
            typeof WeakMap === "function" &&
            new WeakMap();
          var macEncodingCacheKeys;
          var getMacEncodingTable = function (
            encoding
          ) {
            // Since we use encoding as a cache key for WeakMap, it has to be
            // a String object and not a literal. And at least on NodeJS 2.10.1,
            // WeakMap requires that the same String instance is passed for cache hits.
            if (!macEncodingCacheKeys) {
              macEncodingCacheKeys = {};
              for (var e in eightBitMacEncodings) {
                /*jshint -W053 */ // Suppress "Do not use String as a constructor."
                macEncodingCacheKeys[e] =
                  new String(e);
              }
            }

            var cacheKey =
              macEncodingCacheKeys[encoding];
            if (cacheKey === undefined) {
              return undefined;
            }

            // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
            // since garbage collection may run at any time, it could also kick in
            // between the calls to cache.has() and cache.get(). In that case,
            // we would return 'undefined' even though we do support the encoding.
            if (macEncodingTableCache) {
              var cachedTable =
                macEncodingTableCache.get(
                  cacheKey
                );
              if (cachedTable !== undefined) {
                return cachedTable;
              }
            }

            var decodingTable =
              eightBitMacEncodings[encoding];
            if (decodingTable === undefined) {
              return undefined;
            }

            var encodingTable = {};
            for (
              var i = 0;
              i < decodingTable.length;
              i++
            ) {
              encodingTable[
                decodingTable.charCodeAt(i)
              ] = i + 0x80;
            }

            if (macEncodingTableCache) {
              macEncodingTableCache.set(
                cacheKey,
                encodingTable
              );
            }

            return encodingTable;
          };

          /**
           * Encodes an old-style Macintosh string. Returns a byte array upon success.
           * If the requested encoding is unsupported, or if the input string contains
           * a character that cannot be expressed in the encoding, the function returns
           * 'undefined'.
           * @param {string} str
           * @param {string} encoding
           * @returns {Array}
           */
          encode.MACSTRING = function (
            str,
            encoding
          ) {
            var table =
              getMacEncodingTable(encoding);
            if (table === undefined) {
              return undefined;
            }

            var result = [];
            for (var i = 0; i < str.length; i++) {
              var c = str.charCodeAt(i);

              // In all eight-bit Mac encodings, the characters 0x00..0x7F are
              // mapped to U+0000..U+007F; we only need to look up the others.
              if (c >= 0x80) {
                c = table[c];
                if (c === undefined) {
                  // str contains a Unicode character that cannot be encoded
                  // in the requested encoding.
                  return undefined;
                }
              }
              result[i] = c;
              // result.push(c);
            }

            return result;
          };

          /**
           * @param {string} str
           * @param {string} encoding
           * @returns {number}
           */
          sizeOf.MACSTRING = function (
            str,
            encoding
          ) {
            var b = encode.MACSTRING(
              str,
              encoding
            );
            if (b !== undefined) {
              return b.length;
            } else {
              return 0;
            }
          };

          // Helper for encode.VARDELTAS
          function isByteEncodable(value) {
            return value >= -128 && value <= 127;
          }

          // Helper for encode.VARDELTAS
          function encodeVarDeltaRunAsZeroes(
            deltas,
            pos,
            result
          ) {
            var runLength = 0;
            var numDeltas = deltas.length;
            while (
              pos < numDeltas &&
              runLength < 64 &&
              deltas[pos] === 0
            ) {
              ++pos;
              ++runLength;
            }
            result.push(0x80 | (runLength - 1));
            return pos;
          }

          // Helper for encode.VARDELTAS
          function encodeVarDeltaRunAsBytes(
            deltas,
            offset,
            result
          ) {
            var runLength = 0;
            var numDeltas = deltas.length;
            var pos = offset;
            while (
              pos < numDeltas &&
              runLength < 64
            ) {
              var value = deltas[pos];
              if (!isByteEncodable(value)) {
                break;
              }

              // Within a byte-encoded run of deltas, a single zero is best
              // stored literally as 0x00 value. However, if we have two or
              // more zeroes in a sequence, it is better to start a new run.
              // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
              // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
              // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
              // when starting a new run.
              if (
                value === 0 &&
                pos + 1 < numDeltas &&
                deltas[pos + 1] === 0
              ) {
                break;
              }

              ++pos;
              ++runLength;
            }
            result.push(runLength - 1);
            for (var i = offset; i < pos; ++i) {
              result.push(
                (deltas[i] + 256) & 0xff
              );
            }
            return pos;
          }

          // Helper for encode.VARDELTAS
          function encodeVarDeltaRunAsWords(
            deltas,
            offset,
            result
          ) {
            var runLength = 0;
            var numDeltas = deltas.length;
            var pos = offset;
            while (
              pos < numDeltas &&
              runLength < 64
            ) {
              var value = deltas[pos];

              // Within a word-encoded run of deltas, it is easiest to start
              // a new run (with a different encoding) whenever we encounter
              // a zero value. For example, the sequence [0x6666, 0, 0x7777]
              // needs 7 bytes when storing the zero inside the current run
              // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
              // new run (40 66 66 80 40 77 77).
              if (value === 0) {
                break;
              }

              // Within a word-encoded run of deltas, a single value in the
              // range (-128..127) should be encoded within the current run
              // because it is more compact. For example, the sequence
              // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
              // literally (42 66 66 00 02 77 77), but 8 bytes when starting
              // a new run (40 66 66 00 02 40 77 77).
              if (
                isByteEncodable(value) &&
                pos + 1 < numDeltas &&
                isByteEncodable(deltas[pos + 1])
              ) {
                break;
              }

              ++pos;
              ++runLength;
            }
            result.push(0x40 | (runLength - 1));
            for (var i = offset; i < pos; ++i) {
              var val = deltas[i];
              result.push(
                ((val + 0x10000) >> 8) & 0xff,
                (val + 0x100) & 0xff
              );
            }
            return pos;
          }

          /**
           * Encode a list of variation adjustment deltas.
           *
           * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.
           * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted
           * when generating instances of variation fonts.
           *
           * @see https://www.microsoft.com/typography/otspec/gvar.htm
           * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
           * @param {Array}
           * @return {Array}
           */
          encode.VARDELTAS = function (deltas) {
            var pos = 0;
            var result = [];
            while (pos < deltas.length) {
              var value = deltas[pos];
              if (value === 0) {
                pos = encodeVarDeltaRunAsZeroes(
                  deltas,
                  pos,
                  result
                );
              } else if (
                value >= -128 &&
                value <= 127
              ) {
                pos = encodeVarDeltaRunAsBytes(
                  deltas,
                  pos,
                  result
                );
              } else {
                pos = encodeVarDeltaRunAsWords(
                  deltas,
                  pos,
                  result
                );
              }
            }
            return result;
          };

          // Convert a list of values to a CFF INDEX structure.
          // The values should be objects containing name / type / value.
          /**
           * @param {Array} l
           * @returns {Array}
           */
          encode.INDEX = function (l) {
            //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
            //    i, v;
            // Because we have to know which data type to use to encode the offsets,
            // we have to go through the values twice: once to encode the data and
            // calculate the offsets, then again to encode the offsets using the fitting data type.
            var offset = 1; // First offset is always 1.
            var offsets = [offset];
            var data = [];
            for (
              var i = 0;
              i < l.length;
              i += 1
            ) {
              var v = encode.OBJECT(l[i]);
              Array.prototype.push.apply(data, v);
              offset += v.length;
              offsets.push(offset);
            }

            if (data.length === 0) {
              return [0, 0];
            }

            var encodedOffsets = [];
            var offSize =
              (1 +
                Math.floor(
                  Math.log(offset) / Math.log(2)
                ) /
                  8) |
              0;
            var offsetEncoder = [
              undefined,
              encode.BYTE,
              encode.USHORT,
              encode.UINT24,
              encode.ULONG,
            ][offSize];
            for (
              var i$1 = 0;
              i$1 < offsets.length;
              i$1 += 1
            ) {
              var encodedOffset = offsetEncoder(
                offsets[i$1]
              );
              Array.prototype.push.apply(
                encodedOffsets,
                encodedOffset
              );
            }

            return Array.prototype.concat(
              encode.Card16(l.length),
              encode.OffSize(offSize),
              encodedOffsets,
              data
            );
          };

          /**
           * @param {Array}
           * @returns {number}
           */
          sizeOf.INDEX = function (v) {
            return encode.INDEX(v).length;
          };

          /**
           * Convert an object to a CFF DICT structure.
           * The keys should be numeric.
           * The values should be objects containing name / type / value.
           * @param {Object} m
           * @returns {Array}
           */
          encode.DICT = function (m) {
            var d = [];
            var keys = Object.keys(m);
            var length = keys.length;

            for (var i = 0; i < length; i += 1) {
              // Object.keys() return string keys, but our keys are always numeric.
              var k = parseInt(keys[i], 0);
              var v = m[k];
              // Value comes before the key.
              d = d.concat(
                encode.OPERAND(v.value, v.type)
              );
              d = d.concat(encode.OPERATOR(k));
            }

            return d;
          };

          /**
           * @param {Object}
           * @returns {number}
           */
          sizeOf.DICT = function (m) {
            return encode.DICT(m).length;
          };

          /**
           * @param {number}
           * @returns {Array}
           */
          encode.OPERATOR = function (v) {
            if (v < 1200) {
              return [v];
            } else {
              return [12, v - 1200];
            }
          };

          /**
           * @param {Array} v
           * @param {string}
           * @returns {Array}
           */
          encode.OPERAND = function (v, type) {
            var d = [];
            if (Array.isArray(type)) {
              for (
                var i = 0;
                i < type.length;
                i += 1
              ) {
                check.argument(
                  v.length === type.length,
                  "Not enough arguments given for type" +
                    type
                );
                d = d.concat(
                  encode.OPERAND(v[i], type[i])
                );
              }
            } else {
              if (type === "SID") {
                d = d.concat(encode.NUMBER(v));
              } else if (type === "offset") {
                // We make it easy for ourselves and always encode offsets as
                // 4 bytes. This makes offset calculation for the top dict easier.
                d = d.concat(encode.NUMBER32(v));
              } else if (type === "number") {
                d = d.concat(encode.NUMBER(v));
              } else if (type === "real") {
                d = d.concat(encode.REAL(v));
              } else {
                throw new Error(
                  "Unknown operand type " + type
                );
                // FIXME Add support for booleans
              }
            }

            return d;
          };

          encode.OP = encode.BYTE;
          sizeOf.OP = sizeOf.BYTE;

          // memoize charstring encoding using WeakMap if available
          var wmm =
            typeof WeakMap === "function" &&
            new WeakMap();

          /**
           * Convert a list of CharString operations to bytes.
           * @param {Array}
           * @returns {Array}
           */
          encode.CHARSTRING = function (ops) {
            // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
            if (wmm) {
              var cachedValue = wmm.get(ops);
              if (cachedValue !== undefined) {
                return cachedValue;
              }
            }

            var d = [];
            var length = ops.length;

            for (var i = 0; i < length; i += 1) {
              var op = ops[i];
              d = d.concat(
                encode[op.type](op.value)
              );
            }

            if (wmm) {
              wmm.set(ops, d);
            }

            return d;
          };

          /**
           * @param {Array}
           * @returns {number}
           */
          sizeOf.CHARSTRING = function (ops) {
            return encode.CHARSTRING(ops).length;
          };

          // Utility functions ////////////////////////////////////////////////////////

          /**
           * Convert an object containing name / type / value to bytes.
           * @param {Object}
           * @returns {Array}
           */
          encode.OBJECT = function (v) {
            var encodingFunction = encode[v.type];
            check.argument(
              encodingFunction !== undefined,
              "No encoding function for type " +
                v.type
            );
            return encodingFunction(v.value);
          };

          /**
           * @param {Object}
           * @returns {number}
           */
          sizeOf.OBJECT = function (v) {
            var sizeOfFunction = sizeOf[v.type];
            check.argument(
              sizeOfFunction !== undefined,
              "No sizeOf function for type " +
                v.type
            );
            return sizeOfFunction(v.value);
          };

          /**
           * Convert a table object to bytes.
           * A table contains a list of fields containing the metadata (name, type and default value).
           * The table itself has the field values set as attributes.
           * @param {opentype.Table}
           * @returns {Array}
           */
          encode.TABLE = function (table) {
            var d = [];
            var length = table.fields.length;
            var subtables = [];
            var subtableOffsets = [];

            for (var i = 0; i < length; i += 1) {
              var field = table.fields[i];
              var encodingFunction =
                encode[field.type];
              check.argument(
                encodingFunction !== undefined,
                "No encoding function for field type " +
                  field.type +
                  " (" +
                  field.name +
                  ")"
              );
              var value = table[field.name];
              if (value === undefined) {
                value = field.value;
              }

              var bytes = encodingFunction(value);

              if (field.type === "TABLE") {
                subtableOffsets.push(d.length);
                d = d.concat([0, 0]);
                subtables.push(bytes);
              } else {
                d = d.concat(bytes);
              }
            }

            for (
              var i$1 = 0;
              i$1 < subtables.length;
              i$1 += 1
            ) {
              var o = subtableOffsets[i$1];
              var offset = d.length;
              check.argument(
                offset < 65536,
                "Table " +
                  table.tableName +
                  " too big."
              );
              d[o] = offset >> 8;
              d[o + 1] = offset & 0xff;
              d = d.concat(subtables[i$1]);
            }

            return d;
          };

          /**
           * @param {opentype.Table}
           * @returns {number}
           */
          sizeOf.TABLE = function (table) {
            var numBytes = 0;
            var length = table.fields.length;

            for (var i = 0; i < length; i += 1) {
              var field = table.fields[i];
              var sizeOfFunction =
                sizeOf[field.type];
              check.argument(
                sizeOfFunction !== undefined,
                "No sizeOf function for field type " +
                  field.type +
                  " (" +
                  field.name +
                  ")"
              );
              var value = table[field.name];
              if (value === undefined) {
                value = field.value;
              }

              numBytes += sizeOfFunction(value);

              // Subtables take 2 more bytes for offsets.
              if (field.type === "TABLE") {
                numBytes += 2;
              }
            }

            return numBytes;
          };

          encode.RECORD = encode.TABLE;
          sizeOf.RECORD = sizeOf.TABLE;

          // Merge in a list of bytes.
          encode.LITERAL = function (v) {
            return v;
          };

          sizeOf.LITERAL = function (v) {
            return v.length;
          };

          // Table metadata

          /**
           * @exports opentype.Table
           * @class
           * @param {string} tableName
           * @param {Array} fields
           * @param {Object} options
           * @constructor
           */
          function Table(
            tableName,
            fields,
            options
          ) {
            var this$1 = this;

            for (
              var i = 0;
              i < fields.length;
              i += 1
            ) {
              var field = fields[i];
              this$1[field.name] = field.value;
            }

            this.tableName = tableName;
            this.fields = fields;
            if (options) {
              var optionKeys =
                Object.keys(options);
              for (
                var i$1 = 0;
                i$1 < optionKeys.length;
                i$1 += 1
              ) {
                var k = optionKeys[i$1];
                var v = options[k];
                if (this$1[k] !== undefined) {
                  this$1[k] = v;
                }
              }
            }
          }

          /**
           * Encodes the table and returns an array of bytes
           * @return {Array}
           */
          Table.prototype.encode = function () {
            return encode.TABLE(this);
          };

          /**
           * Get the size of the table.
           * @return {number}
           */
          Table.prototype.sizeOf = function () {
            return sizeOf.TABLE(this);
          };

          /**
           * @private
           */
          function ushortList(
            itemName,
            list,
            count
          ) {
            if (count === undefined) {
              count = list.length;
            }
            var fields = new Array(
              list.length + 1
            );
            fields[0] = {
              name: itemName + "Count",
              type: "USHORT",
              value: count,
            };
            for (
              var i = 0;
              i < list.length;
              i++
            ) {
              fields[i + 1] = {
                name: itemName + i,
                type: "USHORT",
                value: list[i],
              };
            }
            return fields;
          }

          /**
           * @private
           */
          function tableList(
            itemName,
            records,
            itemCallback
          ) {
            var count = records.length;
            var fields = new Array(count + 1);
            fields[0] = {
              name: itemName + "Count",
              type: "USHORT",
              value: count,
            };
            for (var i = 0; i < count; i++) {
              fields[i + 1] = {
                name: itemName + i,
                type: "TABLE",
                value: itemCallback(
                  records[i],
                  i
                ),
              };
            }
            return fields;
          }

          /**
           * @private
           */
          function recordList(
            itemName,
            records,
            itemCallback
          ) {
            var count = records.length;
            var fields = [];
            fields[0] = {
              name: itemName + "Count",
              type: "USHORT",
              value: count,
            };
            for (var i = 0; i < count; i++) {
              fields = fields.concat(
                itemCallback(records[i], i)
              );
            }
            return fields;
          }

          // Common Layout Tables

          /**
           * @exports opentype.Coverage
           * @class
           * @param {opentype.Table}
           * @constructor
           * @extends opentype.Table
           */
          function Coverage(coverageTable) {
            if (coverageTable.format === 1) {
              Table.call(
                this,
                "coverageTable",
                [
                  {
                    name: "coverageFormat",
                    type: "USHORT",
                    value: 1,
                  },
                ].concat(
                  ushortList(
                    "glyph",
                    coverageTable.glyphs
                  )
                )
              );
            } else {
              check.assert(
                false,
                "Can't create coverage table format 2 yet."
              );
            }
          }
          Coverage.prototype = Object.create(
            Table.prototype
          );
          Coverage.prototype.constructor =
            Coverage;

          function ScriptList(scriptListTable) {
            Table.call(
              this,
              "scriptListTable",
              recordList(
                "scriptRecord",
                scriptListTable,
                function (scriptRecord, i) {
                  var script =
                    scriptRecord.script;
                  var defaultLangSys =
                    script.defaultLangSys;
                  check.assert(
                    !!defaultLangSys,
                    "Unable to write GSUB: script " +
                      scriptRecord.tag +
                      " has no default language system."
                  );
                  return [
                    {
                      name: "scriptTag" + i,
                      type: "TAG",
                      value: scriptRecord.tag,
                    },
                    {
                      name: "script" + i,
                      type: "TABLE",
                      value: new Table(
                        "scriptTable",
                        [
                          {
                            name: "defaultLangSys",
                            type: "TABLE",
                            value: new Table(
                              "defaultLangSys",
                              [
                                {
                                  name: "lookupOrder",
                                  type: "USHORT",
                                  value: 0,
                                },
                                {
                                  name: "reqFeatureIndex",
                                  type: "USHORT",
                                  value:
                                    defaultLangSys.reqFeatureIndex,
                                },
                              ].concat(
                                ushortList(
                                  "featureIndex",
                                  defaultLangSys.featureIndexes
                                )
                              )
                            ),
                          },
                        ].concat(
                          recordList(
                            "langSys",
                            script.langSysRecords,
                            function (
                              langSysRecord,
                              i
                            ) {
                              var langSys =
                                langSysRecord.langSys;
                              return [
                                {
                                  name:
                                    "langSysTag" +
                                    i,
                                  type: "TAG",
                                  value:
                                    langSysRecord.tag,
                                },
                                {
                                  name:
                                    "langSys" + i,
                                  type: "TABLE",
                                  value:
                                    new Table(
                                      "langSys",
                                      [
                                        {
                                          name: "lookupOrder",
                                          type: "USHORT",
                                          value: 0,
                                        },
                                        {
                                          name: "reqFeatureIndex",
                                          type: "USHORT",
                                          value:
                                            langSys.reqFeatureIndex,
                                        },
                                      ].concat(
                                        ushortList(
                                          "featureIndex",
                                          langSys.featureIndexes
                                        )
                                      )
                                    ),
                                },
                              ];
                            }
                          )
                        )
                      ),
                    },
                  ];
                }
              )
            );
          }
          ScriptList.prototype = Object.create(
            Table.prototype
          );
          ScriptList.prototype.constructor =
            ScriptList;

          /**
           * @exports opentype.FeatureList
           * @class
           * @param {opentype.Table}
           * @constructor
           * @extends opentype.Table
           */
          function FeatureList(featureListTable) {
            Table.call(
              this,
              "featureListTable",
              recordList(
                "featureRecord",
                featureListTable,
                function (featureRecord, i) {
                  var feature =
                    featureRecord.feature;
                  return [
                    {
                      name: "featureTag" + i,
                      type: "TAG",
                      value: featureRecord.tag,
                    },
                    {
                      name: "feature" + i,
                      type: "TABLE",
                      value: new Table(
                        "featureTable",
                        [
                          {
                            name: "featureParams",
                            type: "USHORT",
                            value:
                              feature.featureParams,
                          },
                        ].concat(
                          ushortList(
                            "lookupListIndex",
                            feature.lookupListIndexes
                          )
                        )
                      ),
                    },
                  ];
                }
              )
            );
          }
          FeatureList.prototype = Object.create(
            Table.prototype
          );
          FeatureList.prototype.constructor =
            FeatureList;

          /**
           * @exports opentype.LookupList
           * @class
           * @param {opentype.Table}
           * @param {Object}
           * @constructor
           * @extends opentype.Table
           */
          function LookupList(
            lookupListTable,
            subtableMakers
          ) {
            Table.call(
              this,
              "lookupListTable",
              tableList(
                "lookup",
                lookupListTable,
                function (lookupTable) {
                  var subtableCallback =
                    subtableMakers[
                      lookupTable.lookupType
                    ];
                  check.assert(
                    !!subtableCallback,
                    "Unable to write GSUB lookup type " +
                      lookupTable.lookupType +
                      " tables."
                  );
                  return new Table(
                    "lookupTable",
                    [
                      {
                        name: "lookupType",
                        type: "USHORT",
                        value:
                          lookupTable.lookupType,
                      },
                      {
                        name: "lookupFlag",
                        type: "USHORT",
                        value:
                          lookupTable.lookupFlag,
                      },
                    ].concat(
                      tableList(
                        "subtable",
                        lookupTable.subtables,
                        subtableCallback
                      )
                    )
                  );
                }
              )
            );
          }
          LookupList.prototype = Object.create(
            Table.prototype
          );
          LookupList.prototype.constructor =
            LookupList;

          // Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
          // Don't use offsets inside Records (probable bug), only in Tables.
          var table = {
            Table: Table,
            Record: Table,
            Coverage: Coverage,
            ScriptList: ScriptList,
            FeatureList: FeatureList,
            LookupList: LookupList,
            ushortList: ushortList,
            tableList: tableList,
            recordList: recordList,
          };

          // Parsing utility functions

          // Retrieve an unsigned byte from the DataView.
          function getByte(dataView, offset) {
            return dataView.getUint8(offset);
          }

          // Retrieve an unsigned 16-bit short from the DataView.
          // The value is stored in big endian.
          function getUShort(dataView, offset) {
            return dataView.getUint16(
              offset,
              false
            );
          }

          // Retrieve a signed 16-bit short from the DataView.
          // The value is stored in big endian.
          function getShort(dataView, offset) {
            return dataView.getInt16(
              offset,
              false
            );
          }

          // Retrieve an unsigned 32-bit long from the DataView.
          // The value is stored in big endian.
          function getULong(dataView, offset) {
            return dataView.getUint32(
              offset,
              false
            );
          }

          // Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
          // The value is stored in big endian.
          function getFixed(dataView, offset) {
            var decimal = dataView.getInt16(
              offset,
              false
            );
            var fraction = dataView.getUint16(
              offset + 2,
              false
            );
            return decimal + fraction / 65535;
          }

          // Retrieve a 4-character tag from the DataView.
          // Tags are used to identify tables.
          function getTag(dataView, offset) {
            var tag = "";
            for (
              var i = offset;
              i < offset + 4;
              i += 1
            ) {
              tag += String.fromCharCode(
                dataView.getInt8(i)
              );
            }

            return tag;
          }

          // Retrieve an offset from the DataView.
          // Offsets are 1 to 4 bytes in length, depending on the offSize argument.
          function getOffset(
            dataView,
            offset,
            offSize
          ) {
            var v = 0;
            for (var i = 0; i < offSize; i += 1) {
              v <<= 8;
              v += dataView.getUint8(offset + i);
            }

            return v;
          }

          // Retrieve a number of bytes from start offset to the end offset from the DataView.
          function getBytes(
            dataView,
            startOffset,
            endOffset
          ) {
            var bytes = [];
            for (
              var i = startOffset;
              i < endOffset;
              i += 1
            ) {
              bytes.push(dataView.getUint8(i));
            }

            return bytes;
          }

          // Convert the list of bytes to a string.
          function bytesToString(bytes) {
            var s = "";
            for (
              var i = 0;
              i < bytes.length;
              i += 1
            ) {
              s += String.fromCharCode(bytes[i]);
            }

            return s;
          }

          var typeOffsets = {
            byte: 1,
            uShort: 2,
            short: 2,
            uLong: 4,
            fixed: 4,
            longDateTime: 8,
            tag: 4,
          };

          // A stateful parser that changes the offset whenever a value is retrieved.
          // The data is a DataView.
          function Parser(data, offset) {
            this.data = data;
            this.offset = offset;
            this.relativeOffset = 0;
          }

          Parser.prototype.parseByte =
            function () {
              var v = this.data.getUint8(
                this.offset + this.relativeOffset
              );
              this.relativeOffset += 1;
              return v;
            };

          Parser.prototype.parseChar =
            function () {
              var v = this.data.getInt8(
                this.offset + this.relativeOffset
              );
              this.relativeOffset += 1;
              return v;
            };

          Parser.prototype.parseCard8 =
            Parser.prototype.parseByte;

          Parser.prototype.parseUShort =
            function () {
              var v = this.data.getUint16(
                this.offset + this.relativeOffset
              );
              this.relativeOffset += 2;
              return v;
            };

          Parser.prototype.parseCard16 =
            Parser.prototype.parseUShort;
          Parser.prototype.parseSID =
            Parser.prototype.parseUShort;
          Parser.prototype.parseOffset16 =
            Parser.prototype.parseUShort;

          Parser.prototype.parseShort =
            function () {
              var v = this.data.getInt16(
                this.offset + this.relativeOffset
              );
              this.relativeOffset += 2;
              return v;
            };

          Parser.prototype.parseF2Dot14 =
            function () {
              var v =
                this.data.getInt16(
                  this.offset +
                    this.relativeOffset
                ) / 16384;
              this.relativeOffset += 2;
              return v;
            };

          Parser.prototype.parseULong =
            function () {
              var v = getULong(
                this.data,
                this.offset + this.relativeOffset
              );
              this.relativeOffset += 4;
              return v;
            };

          Parser.prototype.parseOffset32 =
            Parser.prototype.parseULong;

          Parser.prototype.parseFixed =
            function () {
              var v = getFixed(
                this.data,
                this.offset + this.relativeOffset
              );
              this.relativeOffset += 4;
              return v;
            };

          Parser.prototype.parseString =
            function (length) {
              var dataView = this.data;
              var offset =
                this.offset + this.relativeOffset;
              var string = "";
              this.relativeOffset += length;
              for (var i = 0; i < length; i++) {
                string += String.fromCharCode(
                  dataView.getUint8(offset + i)
                );
              }

              return string;
            };

          Parser.prototype.parseTag =
            function () {
              return this.parseString(4);
            };

          // LONGDATETIME is a 64-bit integer.
          // JavaScript and unix timestamps traditionally use 32 bits, so we
          // only take the last 32 bits.
          // + Since until 2038 those bits will be filled by zeros we can ignore them.
          Parser.prototype.parseLongDateTime =
            function () {
              var v = getULong(
                this.data,
                this.offset +
                  this.relativeOffset +
                  4
              );
              // Subtract seconds between 01/01/1904 and 01/01/1970
              // to convert Apple Mac timestamp to Standard Unix timestamp
              v -= 2082844800;
              this.relativeOffset += 8;
              return v;
            };

          Parser.prototype.parseVersion =
            function (minorBase) {
              var major = getUShort(
                this.data,
                this.offset + this.relativeOffset
              );

              // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
              // Default returns the correct number if minor = 0xN000 where N is 0-9
              // Set minorBase to 1 for tables that use minor = N where N is 0-9
              var minor = getUShort(
                this.data,
                this.offset +
                  this.relativeOffset +
                  2
              );
              this.relativeOffset += 4;
              if (minorBase === undefined) {
                minorBase = 0x1000;
              }
              return (
                major + minor / minorBase / 10
              );
            };

          Parser.prototype.skip = function (
            type,
            amount
          ) {
            if (amount === undefined) {
              amount = 1;
            }

            this.relativeOffset +=
              typeOffsets[type] * amount;
          };

          ///// Parsing lists and records ///////////////////////////////

          // Parse a list of 32 bit unsigned integers.
          Parser.prototype.parseULongList =
            function (count) {
              if (count === undefined) {
                count = this.parseULong();
              }
              var offsets = new Array(count);
              var dataView = this.data;
              var offset =
                this.offset + this.relativeOffset;
              for (var i = 0; i < count; i++) {
                offsets[i] =
                  dataView.getUint32(offset);
                offset += 4;
              }

              this.relativeOffset += count * 4;
              return offsets;
            };

          // Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
          // or provided as an argument.
          Parser.prototype.parseOffset16List =
            Parser.prototype.parseUShortList =
              function (count) {
                if (count === undefined) {
                  count = this.parseUShort();
                }
                var offsets = new Array(count);
                var dataView = this.data;
                var offset =
                  this.offset +
                  this.relativeOffset;
                for (var i = 0; i < count; i++) {
                  offsets[i] =
                    dataView.getUint16(offset);
                  offset += 2;
                }

                this.relativeOffset += count * 2;
                return offsets;
              };

          // Parses a list of 16 bit signed integers.
          Parser.prototype.parseShortList =
            function (count) {
              var list = new Array(count);
              var dataView = this.data;
              var offset =
                this.offset + this.relativeOffset;
              for (var i = 0; i < count; i++) {
                list[i] =
                  dataView.getInt16(offset);
                offset += 2;
              }

              this.relativeOffset += count * 2;
              return list;
            };

          // Parses a list of bytes.
          Parser.prototype.parseByteList =
            function (count) {
              var list = new Array(count);
              var dataView = this.data;
              var offset =
                this.offset + this.relativeOffset;
              for (var i = 0; i < count; i++) {
                list[i] = dataView.getUint8(
                  offset++
                );
              }

              this.relativeOffset += count;
              return list;
            };

          /**
           * Parse a list of items.
           * Record count is optional, if omitted it is read from the stream.
           * itemCallback is one of the Parser methods.
           */
          Parser.prototype.parseList = function (
            count,
            itemCallback
          ) {
            var this$1 = this;

            if (!itemCallback) {
              itemCallback = count;
              count = this.parseUShort();
            }
            var list = new Array(count);
            for (var i = 0; i < count; i++) {
              list[i] = itemCallback.call(this$1);
            }
            return list;
          };

          Parser.prototype.parseList32 =
            function (count, itemCallback) {
              var this$1 = this;

              if (!itemCallback) {
                itemCallback = count;
                count = this.parseULong();
              }
              var list = new Array(count);
              for (var i = 0; i < count; i++) {
                list[i] =
                  itemCallback.call(this$1);
              }
              return list;
            };

          /**
           * Parse a list of records.
           * Record count is optional, if omitted it is read from the stream.
           * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
           */
          Parser.prototype.parseRecordList =
            function (count, recordDescription) {
              var this$1 = this;

              // If the count argument is absent, read it in the stream.
              if (!recordDescription) {
                recordDescription = count;
                count = this.parseUShort();
              }
              var records = new Array(count);
              var fields = Object.keys(
                recordDescription
              );
              for (var i = 0; i < count; i++) {
                var rec = {};
                for (
                  var j = 0;
                  j < fields.length;
                  j++
                ) {
                  var fieldName = fields[j];
                  var fieldType =
                    recordDescription[fieldName];
                  rec[fieldName] =
                    fieldType.call(this$1);
                }
                records[i] = rec;
              }
              return records;
            };

          Parser.prototype.parseRecordList32 =
            function (count, recordDescription) {
              var this$1 = this;

              // If the count argument is absent, read it in the stream.
              if (!recordDescription) {
                recordDescription = count;
                count = this.parseULong();
              }
              var records = new Array(count);
              var fields = Object.keys(
                recordDescription
              );
              for (var i = 0; i < count; i++) {
                var rec = {};
                for (
                  var j = 0;
                  j < fields.length;
                  j++
                ) {
                  var fieldName = fields[j];
                  var fieldType =
                    recordDescription[fieldName];
                  rec[fieldName] =
                    fieldType.call(this$1);
                }
                records[i] = rec;
              }
              return records;
            };

          // Parse a data structure into an object
          // Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
          Parser.prototype.parseStruct =
            function (description) {
              var this$1 = this;

              if (
                typeof description === "function"
              ) {
                return description.call(this);
              } else {
                var fields =
                  Object.keys(description);
                var struct = {};
                for (
                  var j = 0;
                  j < fields.length;
                  j++
                ) {
                  var fieldName = fields[j];
                  var fieldType =
                    description[fieldName];
                  struct[fieldName] =
                    fieldType.call(this$1);
                }
                return struct;
              }
            };

          /**
           * Parse a GPOS valueRecord
           * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
           * valueFormat is optional, if omitted it is read from the stream.
           */
          Parser.prototype.parseValueRecord =
            function (valueFormat) {
              if (valueFormat === undefined) {
                valueFormat = this.parseUShort();
              }
              if (valueFormat === 0) {
                // valueFormat2 in kerning pairs is most often 0
                // in this case return undefined instead of an empty object, to save space
                return;
              }
              var valueRecord = {};

              if (valueFormat & 0x0001) {
                valueRecord.xPlacement =
                  this.parseShort();
              }
              if (valueFormat & 0x0002) {
                valueRecord.yPlacement =
                  this.parseShort();
              }
              if (valueFormat & 0x0004) {
                valueRecord.xAdvance =
                  this.parseShort();
              }
              if (valueFormat & 0x0008) {
                valueRecord.yAdvance =
                  this.parseShort();
              }

              // Device table (non-variable font) / VariationIndex table (variable font) not supported
              // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
              if (valueFormat & 0x0010) {
                valueRecord.xPlaDevice =
                  undefined;
                this.parseShort();
              }
              if (valueFormat & 0x0020) {
                valueRecord.yPlaDevice =
                  undefined;
                this.parseShort();
              }
              if (valueFormat & 0x0040) {
                valueRecord.xAdvDevice =
                  undefined;
                this.parseShort();
              }
              if (valueFormat & 0x0080) {
                valueRecord.yAdvDevice =
                  undefined;
                this.parseShort();
              }

              return valueRecord;
            };

          /**
           * Parse a list of GPOS valueRecords
           * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
           * valueFormat and valueCount are read from the stream.
           */
          Parser.prototype.parseValueRecordList =
            function () {
              var this$1 = this;

              var valueFormat =
                this.parseUShort();
              var valueCount = this.parseUShort();
              var values = new Array(valueCount);
              for (
                var i = 0;
                i < valueCount;
                i++
              ) {
                values[i] =
                  this$1.parseValueRecord(
                    valueFormat
                  );
              }
              return values;
            };

          Parser.prototype.parsePointer =
            function (description) {
              var structOffset =
                this.parseOffset16();
              if (structOffset > 0) {
                // NULL offset => return undefined
                return new Parser(
                  this.data,
                  this.offset + structOffset
                ).parseStruct(description);
              }
              return undefined;
            };

          Parser.prototype.parsePointer32 =
            function (description) {
              var structOffset =
                this.parseOffset32();
              if (structOffset > 0) {
                // NULL offset => return undefined
                return new Parser(
                  this.data,
                  this.offset + structOffset
                ).parseStruct(description);
              }
              return undefined;
            };

          /**
           * Parse a list of offsets to lists of 16-bit integers,
           * or a list of offsets to lists of offsets to any kind of items.
           * If itemCallback is not provided, a list of list of UShort is assumed.
           * If provided, itemCallback is called on each item and must parse the item.
           * See examples in tables/gsub.js
           */
          Parser.prototype.parseListOfLists =
            function (itemCallback) {
              var this$1 = this;

              var offsets =
                this.parseOffset16List();
              var count = offsets.length;
              var relativeOffset =
                this.relativeOffset;
              var list = new Array(count);
              for (var i = 0; i < count; i++) {
                var start = offsets[i];
                if (start === 0) {
                  // NULL offset
                  // Add i as owned property to list. Convenient with assert.
                  list[i] = undefined;
                  continue;
                }
                this$1.relativeOffset = start;
                if (itemCallback) {
                  var subOffsets =
                    this$1.parseOffset16List();
                  var subList = new Array(
                    subOffsets.length
                  );
                  for (
                    var j = 0;
                    j < subOffsets.length;
                    j++
                  ) {
                    this$1.relativeOffset =
                      start + subOffsets[j];
                    subList[j] =
                      itemCallback.call(this$1);
                  }
                  list[i] = subList;
                } else {
                  list[i] =
                    this$1.parseUShortList();
                }
              }
              this.relativeOffset =
                relativeOffset;
              return list;
            };

          ///// Complex tables parsing //////////////////////////////////

          // Parse a coverage table in a GSUB, GPOS or GDEF table.
          // https://www.microsoft.com/typography/OTSPEC/chapter2.htm
          // parser.offset must point to the start of the table containing the coverage.
          Parser.prototype.parseCoverage =
            function () {
              var this$1 = this;

              var startOffset =
                this.offset + this.relativeOffset;
              var format = this.parseUShort();
              var count = this.parseUShort();
              if (format === 1) {
                return {
                  format: 1,
                  glyphs:
                    this.parseUShortList(count),
                };
              } else if (format === 2) {
                var ranges = new Array(count);
                for (var i = 0; i < count; i++) {
                  ranges[i] = {
                    start: this$1.parseUShort(),
                    end: this$1.parseUShort(),
                    index: this$1.parseUShort(),
                  };
                }
                return {
                  format: 2,
                  ranges: ranges,
                };
              }
              throw new Error(
                "0x" +
                  startOffset.toString(16) +
                  ": Coverage format must be 1 or 2."
              );
            };

          // Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
          // https://www.microsoft.com/typography/OTSPEC/chapter2.htm
          Parser.prototype.parseClassDef =
            function () {
              var startOffset =
                this.offset + this.relativeOffset;
              var format = this.parseUShort();
              if (format === 1) {
                return {
                  format: 1,
                  startGlyph: this.parseUShort(),
                  classes: this.parseUShortList(),
                };
              } else if (format === 2) {
                return {
                  format: 2,
                  ranges: this.parseRecordList({
                    start: Parser.uShort,
                    end: Parser.uShort,
                    classId: Parser.uShort,
                  }),
                };
              }
              throw new Error(
                "0x" +
                  startOffset.toString(16) +
                  ": ClassDef format must be 1 or 2."
              );
            };

          ///// Static methods ///////////////////////////////////
          // These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

          Parser.list = function (
            count,
            itemCallback
          ) {
            return function () {
              return this.parseList(
                count,
                itemCallback
              );
            };
          };

          Parser.list32 = function (
            count,
            itemCallback
          ) {
            return function () {
              return this.parseList32(
                count,
                itemCallback
              );
            };
          };

          Parser.recordList = function (
            count,
            recordDescription
          ) {
            return function () {
              return this.parseRecordList(
                count,
                recordDescription
              );
            };
          };

          Parser.recordList32 = function (
            count,
            recordDescription
          ) {
            return function () {
              return this.parseRecordList32(
                count,
                recordDescription
              );
            };
          };

          Parser.pointer = function (
            description
          ) {
            return function () {
              return this.parsePointer(
                description
              );
            };
          };

          Parser.pointer32 = function (
            description
          ) {
            return function () {
              return this.parsePointer32(
                description
              );
            };
          };

          Parser.tag = Parser.prototype.parseTag;
          Parser.byte =
            Parser.prototype.parseByte;
          Parser.uShort = Parser.offset16 =
            Parser.prototype.parseUShort;
          Parser.uShortList =
            Parser.prototype.parseUShortList;
          Parser.uLong = Parser.offset32 =
            Parser.prototype.parseULong;
          Parser.uLongList =
            Parser.prototype.parseULongList;
          Parser.struct =
            Parser.prototype.parseStruct;
          Parser.coverage =
            Parser.prototype.parseCoverage;
          Parser.classDef =
            Parser.prototype.parseClassDef;

          ///// Script, Feature, Lookup lists ///////////////////////////////////////////////
          // https://www.microsoft.com/typography/OTSPEC/chapter2.htm

          var langSysTable = {
            reserved: Parser.uShort,
            reqFeatureIndex: Parser.uShort,
            featureIndexes: Parser.uShortList,
          };

          Parser.prototype.parseScriptList =
            function () {
              return (
                this.parsePointer(
                  Parser.recordList({
                    tag: Parser.tag,
                    script: Parser.pointer({
                      defaultLangSys:
                        Parser.pointer(
                          langSysTable
                        ),
                      langSysRecords:
                        Parser.recordList({
                          tag: Parser.tag,
                          langSys:
                            Parser.pointer(
                              langSysTable
                            ),
                        }),
                    }),
                  })
                ) || []
              );
            };

          Parser.prototype.parseFeatureList =
            function () {
              return (
                this.parsePointer(
                  Parser.recordList({
                    tag: Parser.tag,
                    feature: Parser.pointer({
                      featureParams:
                        Parser.offset16,
                      lookupListIndexes:
                        Parser.uShortList,
                    }),
                  })
                ) || []
              );
            };

          Parser.prototype.parseLookupList =
            function (lookupTableParsers) {
              return (
                this.parsePointer(
                  Parser.list(
                    Parser.pointer(function () {
                      var lookupType =
                        this.parseUShort();
                      check.argument(
                        1 <= lookupType &&
                          lookupType <= 9,
                        "GPOS/GSUB lookup type " +
                          lookupType +
                          " unknown."
                      );
                      var lookupFlag =
                        this.parseUShort();
                      var useMarkFilteringSet =
                        lookupFlag & 0x10;
                      return {
                        lookupType: lookupType,
                        lookupFlag: lookupFlag,
                        subtables: this.parseList(
                          Parser.pointer(
                            lookupTableParsers[
                              lookupType
                            ]
                          )
                        ),
                        markFilteringSet:
                          useMarkFilteringSet
                            ? this.parseUShort()
                            : undefined,
                      };
                    })
                  )
                ) || []
              );
            };

          Parser.prototype.parseFeatureVariationsList =
            function () {
              return (
                this.parsePointer32(function () {
                  var majorVersion =
                    this.parseUShort();
                  var minorVersion =
                    this.parseUShort();
                  check.argument(
                    majorVersion === 1 &&
                      minorVersion < 1,
                    "GPOS/GSUB feature variations table unknown."
                  );
                  var featureVariations =
                    this.parseRecordList32({
                      conditionSetOffset:
                        Parser.offset32,
                      featureTableSubstitutionOffset:
                        Parser.offset32,
                    });
                  return featureVariations;
                }) || []
              );
            };

          var parse = {
            getByte: getByte,
            getCard8: getByte,
            getUShort: getUShort,
            getCard16: getUShort,
            getShort: getShort,
            getULong: getULong,
            getFixed: getFixed,
            getTag: getTag,
            getOffset: getOffset,
            getBytes: getBytes,
            bytesToString: bytesToString,
            Parser: Parser,
          };

          // The `cmap` table stores the mappings from characters to glyphs.

          function parseCmapTableFormat12(
            cmap,
            p
          ) {
            //Skip reserved.
            p.parseUShort();

            // Length in bytes of the sub-tables.
            cmap.length = p.parseULong();
            cmap.language = p.parseULong();

            var groupCount;
            cmap.groupCount = groupCount =
              p.parseULong();
            cmap.glyphIndexMap = {};

            for (
              var i = 0;
              i < groupCount;
              i += 1
            ) {
              var startCharCode = p.parseULong();
              var endCharCode = p.parseULong();
              var startGlyphId = p.parseULong();

              for (
                var c = startCharCode;
                c <= endCharCode;
                c += 1
              ) {
                cmap.glyphIndexMap[c] =
                  startGlyphId;
                startGlyphId++;
              }
            }
          }

          function parseCmapTableFormat4(
            cmap,
            p,
            data,
            start,
            offset
          ) {
            // Length in bytes of the sub-tables.
            cmap.length = p.parseUShort();
            cmap.language = p.parseUShort();

            // segCount is stored x 2.
            var segCount;
            cmap.segCount = segCount =
              p.parseUShort() >> 1;

            // Skip searchRange, entrySelector, rangeShift.
            p.skip("uShort", 3);

            // The "unrolled" mapping from character codes to glyph indices.
            cmap.glyphIndexMap = {};
            var endCountParser = new parse.Parser(
              data,
              start + offset + 14
            );
            var startCountParser =
              new parse.Parser(
                data,
                start + offset + 16 + segCount * 2
              );
            var idDeltaParser = new parse.Parser(
              data,
              start + offset + 16 + segCount * 4
            );
            var idRangeOffsetParser =
              new parse.Parser(
                data,
                start + offset + 16 + segCount * 6
              );
            var glyphIndexOffset =
              start + offset + 16 + segCount * 8;
            for (
              var i = 0;
              i < segCount - 1;
              i += 1
            ) {
              var glyphIndex = void 0;
              var endCount =
                endCountParser.parseUShort();
              var startCount =
                startCountParser.parseUShort();
              var idDelta =
                idDeltaParser.parseShort();
              var idRangeOffset =
                idRangeOffsetParser.parseUShort();
              for (
                var c = startCount;
                c <= endCount;
                c += 1
              ) {
                if (idRangeOffset !== 0) {
                  // The idRangeOffset is relative to the current position in the idRangeOffset array.
                  // Take the current offset in the idRangeOffset array.
                  glyphIndexOffset =
                    idRangeOffsetParser.offset +
                    idRangeOffsetParser.relativeOffset -
                    2;

                  // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                  glyphIndexOffset +=
                    idRangeOffset;

                  // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                  glyphIndexOffset +=
                    (c - startCount) * 2;
                  glyphIndex = parse.getUShort(
                    data,
                    glyphIndexOffset
                  );
                  if (glyphIndex !== 0) {
                    glyphIndex =
                      (glyphIndex + idDelta) &
                      0xffff;
                  }
                } else {
                  glyphIndex =
                    (c + idDelta) & 0xffff;
                }

                cmap.glyphIndexMap[c] =
                  glyphIndex;
              }
            }
          }

          // Parse the `cmap` table. This table stores the mappings from characters to glyphs.
          // There are many available formats, but we only support the Windows format 4 and 12.
          // This function returns a `CmapEncoding` object or null if no supported format could be found.
          function parseCmapTable(data, start) {
            var cmap = {};
            cmap.version = parse.getUShort(
              data,
              start
            );
            check.argument(
              cmap.version === 0,
              "cmap table version should be 0."
            );

            // The cmap table can contain many sub-tables, each with their own format.
            // We're only interested in a "platform 0" (Unicode format) and "platform 3" (Windows format) table.
            cmap.numTables = parse.getUShort(
              data,
              start + 2
            );
            var offset = -1;
            for (
              var i = cmap.numTables - 1;
              i >= 0;
              i -= 1
            ) {
              var platformId = parse.getUShort(
                data,
                start + 4 + i * 8
              );
              var encodingId = parse.getUShort(
                data,
                start + 4 + i * 8 + 2
              );
              if (
                (platformId === 3 &&
                  (encodingId === 0 ||
                    encodingId === 1 ||
                    encodingId === 10)) ||
                (platformId === 0 &&
                  (encodingId === 0 ||
                    encodingId === 1 ||
                    encodingId === 2 ||
                    encodingId === 3 ||
                    encodingId === 4))
              ) {
                offset = parse.getULong(
                  data,
                  start + 4 + i * 8 + 4
                );
                break;
              }
            }

            if (offset === -1) {
              // There is no cmap table in the font that we support.
              throw new Error(
                "No valid cmap sub-tables found."
              );
            }

            var p = new parse.Parser(
              data,
              start + offset
            );
            cmap.format = p.parseUShort();

            if (cmap.format === 12) {
              parseCmapTableFormat12(cmap, p);
            } else if (cmap.format === 4) {
              parseCmapTableFormat4(
                cmap,
                p,
                data,
                start,
                offset
              );
            } else {
              throw new Error(
                "Only format 4 and 12 cmap tables are supported (found format " +
                  cmap.format +
                  ")."
              );
            }

            return cmap;
          }

          function addSegment(
            t,
            code,
            glyphIndex
          ) {
            t.segments.push({
              end: code,
              start: code,
              delta: -(code - glyphIndex),
              offset: 0,
              glyphIndex: glyphIndex,
            });
          }

          function addTerminatorSegment(t) {
            t.segments.push({
              end: 0xffff,
              start: 0xffff,
              delta: 1,
              offset: 0,
            });
          }

          // Make cmap table, format 4 by default, 12 if needed only
          function makeCmapTable(glyphs) {
            // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
            var isPlan0Only = true;
            var i;

            // Check if we need to add cmap format 12 or if format 4 only is fine
            for (
              i = glyphs.length - 1;
              i > 0;
              i -= 1
            ) {
              var g = glyphs.get(i);
              if (g.unicode > 65535) {
                console.log(
                  "Adding CMAP format 12 (needed!)"
                );
                isPlan0Only = false;
                break;
              }
            }

            var cmapTable = [
              {
                name: "version",
                type: "USHORT",
                value: 0,
              },
              {
                name: "numTables",
                type: "USHORT",
                value: isPlan0Only ? 1 : 2,
              },

              // CMAP 4 header
              {
                name: "platformID",
                type: "USHORT",
                value: 3,
              },
              {
                name: "encodingID",
                type: "USHORT",
                value: 1,
              },
              {
                name: "offset",
                type: "ULONG",
                value: isPlan0Only ? 12 : 12 + 8,
              },
            ];

            if (!isPlan0Only) {
              cmapTable = cmapTable.concat([
                // CMAP 12 header
                {
                  name: "cmap12PlatformID",
                  type: "USHORT",
                  value: 3,
                }, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
                {
                  name: "cmap12EncodingID",
                  type: "USHORT",
                  value: 10,
                },
                {
                  name: "cmap12Offset",
                  type: "ULONG",
                  value: 0,
                },
              ]);
            }

            cmapTable = cmapTable.concat([
              // CMAP 4 Subtable
              {
                name: "format",
                type: "USHORT",
                value: 4,
              },
              {
                name: "cmap4Length",
                type: "USHORT",
                value: 0,
              },
              {
                name: "language",
                type: "USHORT",
                value: 0,
              },
              {
                name: "segCountX2",
                type: "USHORT",
                value: 0,
              },
              {
                name: "searchRange",
                type: "USHORT",
                value: 0,
              },
              {
                name: "entrySelector",
                type: "USHORT",
                value: 0,
              },
              {
                name: "rangeShift",
                type: "USHORT",
                value: 0,
              },
            ]);

            var t = new table.Table(
              "cmap",
              cmapTable
            );

            t.segments = [];
            for (
              i = 0;
              i < glyphs.length;
              i += 1
            ) {
              var glyph = glyphs.get(i);
              for (
                var j = 0;
                j < glyph.unicodes.length;
                j += 1
              ) {
                addSegment(
                  t,
                  glyph.unicodes[j],
                  i
                );
              }

              t.segments = t.segments.sort(
                function (a, b) {
                  return a.start - b.start;
                }
              );
            }

            addTerminatorSegment(t);

            var segCount = t.segments.length;
            var segCountToRemove = 0;

            // CMAP 4
            // Set up parallel segment arrays.
            var endCounts = [];
            var startCounts = [];
            var idDeltas = [];
            var idRangeOffsets = [];
            var glyphIds = [];

            // CMAP 12
            var cmap12Groups = [];

            // Reminder this loop is not following the specification at 100%
            // The specification -> find suites of characters and make a group
            // Here we're doing one group for each letter
            // Doing as the spec can save 8 times (or more) space
            for (i = 0; i < segCount; i += 1) {
              var segment = t.segments[i];

              // CMAP 4
              if (
                segment.end <= 65535 &&
                segment.start <= 65535
              ) {
                endCounts = endCounts.concat({
                  name: "end_" + i,
                  type: "USHORT",
                  value: segment.end,
                });
                startCounts = startCounts.concat({
                  name: "start_" + i,
                  type: "USHORT",
                  value: segment.start,
                });
                idDeltas = idDeltas.concat({
                  name: "idDelta_" + i,
                  type: "SHORT",
                  value: segment.delta,
                });
                idRangeOffsets =
                  idRangeOffsets.concat({
                    name: "idRangeOffset_" + i,
                    type: "USHORT",
                    value: segment.offset,
                  });
                if (
                  segment.glyphId !== undefined
                ) {
                  glyphIds = glyphIds.concat({
                    name: "glyph_" + i,
                    type: "USHORT",
                    value: segment.glyphId,
                  });
                }
              } else {
                // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
                segCountToRemove += 1;
              }

              // CMAP 12
              // Skip Terminator Segment
              if (
                !isPlan0Only &&
                segment.glyphIndex !== undefined
              ) {
                cmap12Groups =
                  cmap12Groups.concat({
                    name: "cmap12Start_" + i,
                    type: "ULONG",
                    value: segment.start,
                  });
                cmap12Groups =
                  cmap12Groups.concat({
                    name: "cmap12End_" + i,
                    type: "ULONG",
                    value: segment.end,
                  });
                cmap12Groups =
                  cmap12Groups.concat({
                    name: "cmap12Glyph_" + i,
                    type: "ULONG",
                    value: segment.glyphIndex,
                  });
              }
            }

            // CMAP 4 Subtable
            t.segCountX2 =
              (segCount - segCountToRemove) * 2;
            t.searchRange =
              Math.pow(
                2,
                Math.floor(
                  Math.log(
                    segCount - segCountToRemove
                  ) / Math.log(2)
                )
              ) * 2;
            t.entrySelector =
              Math.log(t.searchRange / 2) /
              Math.log(2);
            t.rangeShift =
              t.segCountX2 - t.searchRange;

            t.fields = t.fields.concat(endCounts);
            t.fields.push({
              name: "reservedPad",
              type: "USHORT",
              value: 0,
            });
            t.fields =
              t.fields.concat(startCounts);
            t.fields = t.fields.concat(idDeltas);
            t.fields = t.fields.concat(
              idRangeOffsets
            );
            t.fields = t.fields.concat(glyphIds);

            t.cmap4Length =
              14 + // Subtable header
              endCounts.length * 2 +
              2 + // reservedPad
              startCounts.length * 2 +
              idDeltas.length * 2 +
              idRangeOffsets.length * 2 +
              glyphIds.length * 2;

            if (!isPlan0Only) {
              // CMAP 12 Subtable
              var cmap12Length =
                16 + // Subtable header
                cmap12Groups.length * 4;

              t.cmap12Offset =
                12 + 2 * 2 + 4 + t.cmap4Length;
              t.fields = t.fields.concat([
                {
                  name: "cmap12Format",
                  type: "USHORT",
                  value: 12,
                },
                {
                  name: "cmap12Reserved",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "cmap12Length",
                  type: "ULONG",
                  value: cmap12Length,
                },
                {
                  name: "cmap12Language",
                  type: "ULONG",
                  value: 0,
                },
                {
                  name: "cmap12nGroups",
                  type: "ULONG",
                  value: cmap12Groups.length / 3,
                },
              ]);

              t.fields =
                t.fields.concat(cmap12Groups);
            }

            return t;
          }

          var cmap = {
            parse: parseCmapTable,
            make: makeCmapTable,
          };

          // Glyph encoding

          var cffStandardStrings = [
            ".notdef",
            "space",
            "exclam",
            "quotedbl",
            "numbersign",
            "dollar",
            "percent",
            "ampersand",
            "quoteright",
            "parenleft",
            "parenright",
            "asterisk",
            "plus",
            "comma",
            "hyphen",
            "period",
            "slash",
            "zero",
            "one",
            "two",
            "three",
            "four",
            "five",
            "six",
            "seven",
            "eight",
            "nine",
            "colon",
            "semicolon",
            "less",
            "equal",
            "greater",
            "question",
            "at",
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z",
            "bracketleft",
            "backslash",
            "bracketright",
            "asciicircum",
            "underscore",
            "quoteleft",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "i",
            "j",
            "k",
            "l",
            "m",
            "n",
            "o",
            "p",
            "q",
            "r",
            "s",
            "t",
            "u",
            "v",
            "w",
            "x",
            "y",
            "z",
            "braceleft",
            "bar",
            "braceright",
            "asciitilde",
            "exclamdown",
            "cent",
            "sterling",
            "fraction",
            "yen",
            "florin",
            "section",
            "currency",
            "quotesingle",
            "quotedblleft",
            "guillemotleft",
            "guilsinglleft",
            "guilsinglright",
            "fi",
            "fl",
            "endash",
            "dagger",
            "daggerdbl",
            "periodcentered",
            "paragraph",
            "bullet",
            "quotesinglbase",
            "quotedblbase",
            "quotedblright",
            "guillemotright",
            "ellipsis",
            "perthousand",
            "questiondown",
            "grave",
            "acute",
            "circumflex",
            "tilde",
            "macron",
            "breve",
            "dotaccent",
            "dieresis",
            "ring",
            "cedilla",
            "hungarumlaut",
            "ogonek",
            "caron",
            "emdash",
            "AE",
            "ordfeminine",
            "Lslash",
            "Oslash",
            "OE",
            "ordmasculine",
            "ae",
            "dotlessi",
            "lslash",
            "oslash",
            "oe",
            "germandbls",
            "onesuperior",
            "logicalnot",
            "mu",
            "trademark",
            "Eth",
            "onehalf",
            "plusminus",
            "Thorn",
            "onequarter",
            "divide",
            "brokenbar",
            "degree",
            "thorn",
            "threequarters",
            "twosuperior",
            "registered",
            "minus",
            "eth",
            "multiply",
            "threesuperior",
            "copyright",
            "Aacute",
            "Acircumflex",
            "Adieresis",
            "Agrave",
            "Aring",
            "Atilde",
            "Ccedilla",
            "Eacute",
            "Ecircumflex",
            "Edieresis",
            "Egrave",
            "Iacute",
            "Icircumflex",
            "Idieresis",
            "Igrave",
            "Ntilde",
            "Oacute",
            "Ocircumflex",
            "Odieresis",
            "Ograve",
            "Otilde",
            "Scaron",
            "Uacute",
            "Ucircumflex",
            "Udieresis",
            "Ugrave",
            "Yacute",
            "Ydieresis",
            "Zcaron",
            "aacute",
            "acircumflex",
            "adieresis",
            "agrave",
            "aring",
            "atilde",
            "ccedilla",
            "eacute",
            "ecircumflex",
            "edieresis",
            "egrave",
            "iacute",
            "icircumflex",
            "idieresis",
            "igrave",
            "ntilde",
            "oacute",
            "ocircumflex",
            "odieresis",
            "ograve",
            "otilde",
            "scaron",
            "uacute",
            "ucircumflex",
            "udieresis",
            "ugrave",
            "yacute",
            "ydieresis",
            "zcaron",
            "exclamsmall",
            "Hungarumlautsmall",
            "dollaroldstyle",
            "dollarsuperior",
            "ampersandsmall",
            "Acutesmall",
            "parenleftsuperior",
            "parenrightsuperior",
            "266 ff",
            "onedotenleader",
            "zerooldstyle",
            "oneoldstyle",
            "twooldstyle",
            "threeoldstyle",
            "fouroldstyle",
            "fiveoldstyle",
            "sixoldstyle",
            "sevenoldstyle",
            "eightoldstyle",
            "nineoldstyle",
            "commasuperior",
            "threequartersemdash",
            "periodsuperior",
            "questionsmall",
            "asuperior",
            "bsuperior",
            "centsuperior",
            "dsuperior",
            "esuperior",
            "isuperior",
            "lsuperior",
            "msuperior",
            "nsuperior",
            "osuperior",
            "rsuperior",
            "ssuperior",
            "tsuperior",
            "ff",
            "ffi",
            "ffl",
            "parenleftinferior",
            "parenrightinferior",
            "Circumflexsmall",
            "hyphensuperior",
            "Gravesmall",
            "Asmall",
            "Bsmall",
            "Csmall",
            "Dsmall",
            "Esmall",
            "Fsmall",
            "Gsmall",
            "Hsmall",
            "Ismall",
            "Jsmall",
            "Ksmall",
            "Lsmall",
            "Msmall",
            "Nsmall",
            "Osmall",
            "Psmall",
            "Qsmall",
            "Rsmall",
            "Ssmall",
            "Tsmall",
            "Usmall",
            "Vsmall",
            "Wsmall",
            "Xsmall",
            "Ysmall",
            "Zsmall",
            "colonmonetary",
            "onefitted",
            "rupiah",
            "Tildesmall",
            "exclamdownsmall",
            "centoldstyle",
            "Lslashsmall",
            "Scaronsmall",
            "Zcaronsmall",
            "Dieresissmall",
            "Brevesmall",
            "Caronsmall",
            "Dotaccentsmall",
            "Macronsmall",
            "figuredash",
            "hypheninferior",
            "Ogoneksmall",
            "Ringsmall",
            "Cedillasmall",
            "questiondownsmall",
            "oneeighth",
            "threeeighths",
            "fiveeighths",
            "seveneighths",
            "onethird",
            "twothirds",
            "zerosuperior",
            "foursuperior",
            "fivesuperior",
            "sixsuperior",
            "sevensuperior",
            "eightsuperior",
            "ninesuperior",
            "zeroinferior",
            "oneinferior",
            "twoinferior",
            "threeinferior",
            "fourinferior",
            "fiveinferior",
            "sixinferior",
            "seveninferior",
            "eightinferior",
            "nineinferior",
            "centinferior",
            "dollarinferior",
            "periodinferior",
            "commainferior",
            "Agravesmall",
            "Aacutesmall",
            "Acircumflexsmall",
            "Atildesmall",
            "Adieresissmall",
            "Aringsmall",
            "AEsmall",
            "Ccedillasmall",
            "Egravesmall",
            "Eacutesmall",
            "Ecircumflexsmall",
            "Edieresissmall",
            "Igravesmall",
            "Iacutesmall",
            "Icircumflexsmall",
            "Idieresissmall",
            "Ethsmall",
            "Ntildesmall",
            "Ogravesmall",
            "Oacutesmall",
            "Ocircumflexsmall",
            "Otildesmall",
            "Odieresissmall",
            "OEsmall",
            "Oslashsmall",
            "Ugravesmall",
            "Uacutesmall",
            "Ucircumflexsmall",
            "Udieresissmall",
            "Yacutesmall",
            "Thornsmall",
            "Ydieresissmall",
            "001.000",
            "001.001",
            "001.002",
            "001.003",
            "Black",
            "Bold",
            "Book",
            "Light",
            "Medium",
            "Regular",
            "Roman",
            "Semibold",
          ];

          var cffStandardEncoding = [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "space",
            "exclam",
            "quotedbl",
            "numbersign",
            "dollar",
            "percent",
            "ampersand",
            "quoteright",
            "parenleft",
            "parenright",
            "asterisk",
            "plus",
            "comma",
            "hyphen",
            "period",
            "slash",
            "zero",
            "one",
            "two",
            "three",
            "four",
            "five",
            "six",
            "seven",
            "eight",
            "nine",
            "colon",
            "semicolon",
            "less",
            "equal",
            "greater",
            "question",
            "at",
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z",
            "bracketleft",
            "backslash",
            "bracketright",
            "asciicircum",
            "underscore",
            "quoteleft",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "i",
            "j",
            "k",
            "l",
            "m",
            "n",
            "o",
            "p",
            "q",
            "r",
            "s",
            "t",
            "u",
            "v",
            "w",
            "x",
            "y",
            "z",
            "braceleft",
            "bar",
            "braceright",
            "asciitilde",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "exclamdown",
            "cent",
            "sterling",
            "fraction",
            "yen",
            "florin",
            "section",
            "currency",
            "quotesingle",
            "quotedblleft",
            "guillemotleft",
            "guilsinglleft",
            "guilsinglright",
            "fi",
            "fl",
            "",
            "endash",
            "dagger",
            "daggerdbl",
            "periodcentered",
            "",
            "paragraph",
            "bullet",
            "quotesinglbase",
            "quotedblbase",
            "quotedblright",
            "guillemotright",
            "ellipsis",
            "perthousand",
            "",
            "questiondown",
            "",
            "grave",
            "acute",
            "circumflex",
            "tilde",
            "macron",
            "breve",
            "dotaccent",
            "dieresis",
            "",
            "ring",
            "cedilla",
            "",
            "hungarumlaut",
            "ogonek",
            "caron",
            "emdash",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "AE",
            "",
            "ordfeminine",
            "",
            "",
            "",
            "",
            "Lslash",
            "Oslash",
            "OE",
            "ordmasculine",
            "",
            "",
            "",
            "",
            "",
            "ae",
            "",
            "",
            "",
            "dotlessi",
            "",
            "",
            "lslash",
            "oslash",
            "oe",
            "germandbls",
          ];

          var cffExpertEncoding = [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "space",
            "exclamsmall",
            "Hungarumlautsmall",
            "",
            "dollaroldstyle",
            "dollarsuperior",
            "ampersandsmall",
            "Acutesmall",
            "parenleftsuperior",
            "parenrightsuperior",
            "twodotenleader",
            "onedotenleader",
            "comma",
            "hyphen",
            "period",
            "fraction",
            "zerooldstyle",
            "oneoldstyle",
            "twooldstyle",
            "threeoldstyle",
            "fouroldstyle",
            "fiveoldstyle",
            "sixoldstyle",
            "sevenoldstyle",
            "eightoldstyle",
            "nineoldstyle",
            "colon",
            "semicolon",
            "commasuperior",
            "threequartersemdash",
            "periodsuperior",
            "questionsmall",
            "",
            "asuperior",
            "bsuperior",
            "centsuperior",
            "dsuperior",
            "esuperior",
            "",
            "",
            "isuperior",
            "",
            "",
            "lsuperior",
            "msuperior",
            "nsuperior",
            "osuperior",
            "",
            "",
            "rsuperior",
            "ssuperior",
            "tsuperior",
            "",
            "ff",
            "fi",
            "fl",
            "ffi",
            "ffl",
            "parenleftinferior",
            "",
            "parenrightinferior",
            "Circumflexsmall",
            "hyphensuperior",
            "Gravesmall",
            "Asmall",
            "Bsmall",
            "Csmall",
            "Dsmall",
            "Esmall",
            "Fsmall",
            "Gsmall",
            "Hsmall",
            "Ismall",
            "Jsmall",
            "Ksmall",
            "Lsmall",
            "Msmall",
            "Nsmall",
            "Osmall",
            "Psmall",
            "Qsmall",
            "Rsmall",
            "Ssmall",
            "Tsmall",
            "Usmall",
            "Vsmall",
            "Wsmall",
            "Xsmall",
            "Ysmall",
            "Zsmall",
            "colonmonetary",
            "onefitted",
            "rupiah",
            "Tildesmall",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "exclamdownsmall",
            "centoldstyle",
            "Lslashsmall",
            "",
            "",
            "Scaronsmall",
            "Zcaronsmall",
            "Dieresissmall",
            "Brevesmall",
            "Caronsmall",
            "",
            "Dotaccentsmall",
            "",
            "",
            "Macronsmall",
            "",
            "",
            "figuredash",
            "hypheninferior",
            "",
            "",
            "Ogoneksmall",
            "Ringsmall",
            "Cedillasmall",
            "",
            "",
            "",
            "onequarter",
            "onehalf",
            "threequarters",
            "questiondownsmall",
            "oneeighth",
            "threeeighths",
            "fiveeighths",
            "seveneighths",
            "onethird",
            "twothirds",
            "",
            "",
            "zerosuperior",
            "onesuperior",
            "twosuperior",
            "threesuperior",
            "foursuperior",
            "fivesuperior",
            "sixsuperior",
            "sevensuperior",
            "eightsuperior",
            "ninesuperior",
            "zeroinferior",
            "oneinferior",
            "twoinferior",
            "threeinferior",
            "fourinferior",
            "fiveinferior",
            "sixinferior",
            "seveninferior",
            "eightinferior",
            "nineinferior",
            "centinferior",
            "dollarinferior",
            "periodinferior",
            "commainferior",
            "Agravesmall",
            "Aacutesmall",
            "Acircumflexsmall",
            "Atildesmall",
            "Adieresissmall",
            "Aringsmall",
            "AEsmall",
            "Ccedillasmall",
            "Egravesmall",
            "Eacutesmall",
            "Ecircumflexsmall",
            "Edieresissmall",
            "Igravesmall",
            "Iacutesmall",
            "Icircumflexsmall",
            "Idieresissmall",
            "Ethsmall",
            "Ntildesmall",
            "Ogravesmall",
            "Oacutesmall",
            "Ocircumflexsmall",
            "Otildesmall",
            "Odieresissmall",
            "OEsmall",
            "Oslashsmall",
            "Ugravesmall",
            "Uacutesmall",
            "Ucircumflexsmall",
            "Udieresissmall",
            "Yacutesmall",
            "Thornsmall",
            "Ydieresissmall",
          ];

          var standardNames = [
            ".notdef",
            ".null",
            "nonmarkingreturn",
            "space",
            "exclam",
            "quotedbl",
            "numbersign",
            "dollar",
            "percent",
            "ampersand",
            "quotesingle",
            "parenleft",
            "parenright",
            "asterisk",
            "plus",
            "comma",
            "hyphen",
            "period",
            "slash",
            "zero",
            "one",
            "two",
            "three",
            "four",
            "five",
            "six",
            "seven",
            "eight",
            "nine",
            "colon",
            "semicolon",
            "less",
            "equal",
            "greater",
            "question",
            "at",
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z",
            "bracketleft",
            "backslash",
            "bracketright",
            "asciicircum",
            "underscore",
            "grave",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "i",
            "j",
            "k",
            "l",
            "m",
            "n",
            "o",
            "p",
            "q",
            "r",
            "s",
            "t",
            "u",
            "v",
            "w",
            "x",
            "y",
            "z",
            "braceleft",
            "bar",
            "braceright",
            "asciitilde",
            "Adieresis",
            "Aring",
            "Ccedilla",
            "Eacute",
            "Ntilde",
            "Odieresis",
            "Udieresis",
            "aacute",
            "agrave",
            "acircumflex",
            "adieresis",
            "atilde",
            "aring",
            "ccedilla",
            "eacute",
            "egrave",
            "ecircumflex",
            "edieresis",
            "iacute",
            "igrave",
            "icircumflex",
            "idieresis",
            "ntilde",
            "oacute",
            "ograve",
            "ocircumflex",
            "odieresis",
            "otilde",
            "uacute",
            "ugrave",
            "ucircumflex",
            "udieresis",
            "dagger",
            "degree",
            "cent",
            "sterling",
            "section",
            "bullet",
            "paragraph",
            "germandbls",
            "registered",
            "copyright",
            "trademark",
            "acute",
            "dieresis",
            "notequal",
            "AE",
            "Oslash",
            "infinity",
            "plusminus",
            "lessequal",
            "greaterequal",
            "yen",
            "mu",
            "partialdiff",
            "summation",
            "product",
            "pi",
            "integral",
            "ordfeminine",
            "ordmasculine",
            "Omega",
            "ae",
            "oslash",
            "questiondown",
            "exclamdown",
            "logicalnot",
            "radical",
            "florin",
            "approxequal",
            "Delta",
            "guillemotleft",
            "guillemotright",
            "ellipsis",
            "nonbreakingspace",
            "Agrave",
            "Atilde",
            "Otilde",
            "OE",
            "oe",
            "endash",
            "emdash",
            "quotedblleft",
            "quotedblright",
            "quoteleft",
            "quoteright",
            "divide",
            "lozenge",
            "ydieresis",
            "Ydieresis",
            "fraction",
            "currency",
            "guilsinglleft",
            "guilsinglright",
            "fi",
            "fl",
            "daggerdbl",
            "periodcentered",
            "quotesinglbase",
            "quotedblbase",
            "perthousand",
            "Acircumflex",
            "Ecircumflex",
            "Aacute",
            "Edieresis",
            "Egrave",
            "Iacute",
            "Icircumflex",
            "Idieresis",
            "Igrave",
            "Oacute",
            "Ocircumflex",
            "apple",
            "Ograve",
            "Uacute",
            "Ucircumflex",
            "Ugrave",
            "dotlessi",
            "circumflex",
            "tilde",
            "macron",
            "breve",
            "dotaccent",
            "ring",
            "cedilla",
            "hungarumlaut",
            "ogonek",
            "caron",
            "Lslash",
            "lslash",
            "Scaron",
            "scaron",
            "Zcaron",
            "zcaron",
            "brokenbar",
            "Eth",
            "eth",
            "Yacute",
            "yacute",
            "Thorn",
            "thorn",
            "minus",
            "multiply",
            "onesuperior",
            "twosuperior",
            "threesuperior",
            "onehalf",
            "onequarter",
            "threequarters",
            "franc",
            "Gbreve",
            "gbreve",
            "Idotaccent",
            "Scedilla",
            "scedilla",
            "Cacute",
            "cacute",
            "Ccaron",
            "ccaron",
            "dcroat",
          ];

          /**
           * This is the encoding used for fonts created from scratch.
           * It loops through all glyphs and finds the appropriate unicode value.
           * Since it's linear time, other encodings will be faster.
           * @exports opentype.DefaultEncoding
           * @class
           * @constructor
           * @param {opentype.Font}
           */
          function DefaultEncoding(font) {
            this.font = font;
          }

          DefaultEncoding.prototype.charToGlyphIndex =
            function (c) {
              var code = c.codePointAt(0);
              var glyphs = this.font.glyphs;
              if (glyphs) {
                for (
                  var i = 0;
                  i < glyphs.length;
                  i += 1
                ) {
                  var glyph = glyphs.get(i);
                  for (
                    var j = 0;
                    j < glyph.unicodes.length;
                    j += 1
                  ) {
                    if (
                      glyph.unicodes[j] === code
                    ) {
                      return i;
                    }
                  }
                }
              }
              return null;
            };

          /**
           * @exports opentype.CmapEncoding
           * @class
           * @constructor
           * @param {Object} cmap - a object with the cmap encoded data
           */
          function CmapEncoding(cmap) {
            this.cmap = cmap;
          }

          /**
           * @param  {string} c - the character
           * @return {number} The glyph index.
           */
          CmapEncoding.prototype.charToGlyphIndex =
            function (c) {
              return (
                this.cmap.glyphIndexMap[
                  c.codePointAt(0)
                ] || 0
              );
            };

          /**
           * @exports opentype.CffEncoding
           * @class
           * @constructor
           * @param {string} encoding - The encoding
           * @param {Array} charset - The character set.
           */
          function CffEncoding(
            encoding,
            charset
          ) {
            this.encoding = encoding;
            this.charset = charset;
          }

          /**
           * @param  {string} s - The character
           * @return {number} The index.
           */
          CffEncoding.prototype.charToGlyphIndex =
            function (s) {
              var code = s.codePointAt(0);
              var charName = this.encoding[code];
              return this.charset.indexOf(
                charName
              );
            };

          /**
           * @exports opentype.GlyphNames
           * @class
           * @constructor
           * @param {Object} post
           */
          function GlyphNames(post) {
            var this$1 = this;

            switch (post.version) {
              case 1:
                this.names =
                  standardNames.slice();
                break;
              case 2:
                this.names = new Array(
                  post.numberOfGlyphs
                );
                for (
                  var i = 0;
                  i < post.numberOfGlyphs;
                  i++
                ) {
                  if (
                    post.glyphNameIndex[i] <
                    standardNames.length
                  ) {
                    this$1.names[i] =
                      standardNames[
                        post.glyphNameIndex[i]
                      ];
                  } else {
                    this$1.names[i] =
                      post.names[
                        post.glyphNameIndex[i] -
                          standardNames.length
                      ];
                  }
                }

                break;
              case 2.5:
                this.names = new Array(
                  post.numberOfGlyphs
                );
                for (
                  var i$1 = 0;
                  i$1 < post.numberOfGlyphs;
                  i$1++
                ) {
                  this$1.names[i$1] =
                    standardNames[
                      i$1 +
                        post.glyphNameIndex[i$1]
                    ];
                }

                break;
              case 3:
                this.names = [];
                break;
              default:
                this.names = [];
                break;
            }
          }

          /**
           * Gets the index of a glyph by name.
           * @param  {string} name - The glyph name
           * @return {number} The index
           */
          GlyphNames.prototype.nameToGlyphIndex =
            function (name) {
              return this.names.indexOf(name);
            };

          /**
           * @param  {number} gid
           * @return {string}
           */
          GlyphNames.prototype.glyphIndexToName =
            function (gid) {
              return this.names[gid];
            };

          /**
           * @alias opentype.addGlyphNames
           * @param {opentype.Font}
           */
          function addGlyphNames(font) {
            var glyph;
            var glyphIndexMap =
              font.tables.cmap.glyphIndexMap;
            var charCodes = Object.keys(
              glyphIndexMap
            );

            for (
              var i = 0;
              i < charCodes.length;
              i += 1
            ) {
              var c = charCodes[i];
              var glyphIndex = glyphIndexMap[c];
              glyph = font.glyphs.get(glyphIndex);
              glyph.addUnicode(parseInt(c));
            }

            for (
              var i$1 = 0;
              i$1 < font.glyphs.length;
              i$1 += 1
            ) {
              glyph = font.glyphs.get(i$1);
              if (font.cffEncoding) {
                if (font.isCIDFont) {
                  glyph.name = "gid" + i$1;
                } else {
                  glyph.name =
                    font.cffEncoding.charset[i$1];
                }
              } else if (font.glyphNames.names) {
                glyph.name =
                  font.glyphNames.glyphIndexToName(
                    i$1
                  );
              }
            }
          }

          // Drawing utility functions.

          // Draw a line on the given context from point `x1,y1` to point `x2,y2`.
          function line(ctx, x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          }

          var draw = { line: line };

          // The Glyph object
          // import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency

          function getPathDefinition(
            glyph,
            path
          ) {
            var _path = path || new Path();
            return {
              configurable: true,

              get: function () {
                if (typeof _path === "function") {
                  _path = _path();
                }

                return _path;
              },

              set: function (p) {
                _path = p;
              },
            };
          }
          /**
           * @typedef GlyphOptions
           * @type Object
           * @property {string} [name] - The glyph name
           * @property {number} [unicode]
           * @property {Array} [unicodes]
           * @property {number} [xMin]
           * @property {number} [yMin]
           * @property {number} [xMax]
           * @property {number} [yMax]
           * @property {number} [advanceWidth]
           */

          // A Glyph is an individual mark that often corresponds to a character.
          // Some glyphs, such as ligatures, are a combination of many characters.
          // Glyphs are the basic building blocks of a font.
          //
          // The `Glyph` class contains utility methods for drawing the path and its points.
          /**
           * @exports opentype.Glyph
           * @class
           * @param {GlyphOptions}
           * @constructor
           */
          function Glyph(options) {
            // By putting all the code on a prototype function (which is only declared once)
            // we reduce the memory requirements for larger fonts by some 2%
            this.bindConstructorValues(options);
          }

          /**
           * @param  {GlyphOptions}
           */
          Glyph.prototype.bindConstructorValues =
            function (options) {
              this.index = options.index || 0;

              // These three values cannot be deferred for memory optimization:
              this.name = options.name || null;
              this.unicode =
                options.unicode || undefined;
              this.unicodes =
                options.unicodes ||
                options.unicode !== undefined
                  ? [options.unicode]
                  : [];

              // But by binding these values only when necessary, we reduce can
              // the memory requirements by almost 3% for larger fonts.
              if (options.xMin) {
                this.xMin = options.xMin;
              }

              if (options.yMin) {
                this.yMin = options.yMin;
              }

              if (options.xMax) {
                this.xMax = options.xMax;
              }

              if (options.yMax) {
                this.yMax = options.yMax;
              }

              if (options.advanceWidth) {
                this.advanceWidth =
                  options.advanceWidth;
              }

              // The path for a glyph is the most memory intensive, and is bound as a value
              // with a getter/setter to ensure we actually do path parsing only once the
              // path is actually needed by anything.
              Object.defineProperty(
                this,
                "path",
                getPathDefinition(
                  this,
                  options.path
                )
              );
            };

          /**
           * @param {number}
           */
          Glyph.prototype.addUnicode = function (
            unicode
          ) {
            if (this.unicodes.length === 0) {
              this.unicode = unicode;
            }

            this.unicodes.push(unicode);
          };

          /**
           * Calculate the minimum bounding box for this glyph.
           * @return {opentype.BoundingBox}
           */
          Glyph.prototype.getBoundingBox =
            function () {
              return this.path.getBoundingBox();
            };

          /**
           * Convert the glyph to a Path we can draw on a drawing context.
           * @param  {number} [x=0] - Horizontal position of the beginning of the text.
           * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           * @param  {Object=} options - xScale, yScale to stretch the glyph.
           * @param  {opentype.Font} if hinting is to be used, the font
           * @return {opentype.Path}
           */
          Glyph.prototype.getPath = function (
            x,
            y,
            fontSize,
            options,
            font
          ) {
            x = x !== undefined ? x : 0;
            y = y !== undefined ? y : 0;
            fontSize =
              fontSize !== undefined
                ? fontSize
                : 72;
            var commands;
            var hPoints;
            if (!options) {
              options = {};
            }
            var xScale = options.xScale;
            var yScale = options.yScale;

            if (
              options.hinting &&
              font &&
              font.hinting
            ) {
              // in case of hinting, the hinting engine takes care
              // of scaling the points (not the path) before hinting.
              hPoints =
                this.path &&
                font.hinting.exec(this, fontSize);
              // in case the hinting engine failed hPoints is undefined
              // and thus reverts to plain rending
            }

            if (hPoints) {
              // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency
              commands =
                font.hinting.getCommands(hPoints);
              x = Math.round(x);
              y = Math.round(y);
              // TODO in case of hinting xyScaling is not yet supported
              xScale = yScale = 1;
            } else {
              commands = this.path.commands;
              var scale =
                (1 / this.path.unitsPerEm) *
                fontSize;
              if (xScale === undefined) {
                xScale = scale;
              }
              if (yScale === undefined) {
                yScale = scale;
              }
            }

            var p = new Path();
            for (
              var i = 0;
              i < commands.length;
              i += 1
            ) {
              var cmd = commands[i];
              if (cmd.type === "M") {
                p.moveTo(
                  x + cmd.x * xScale,
                  y + -cmd.y * yScale
                );
              } else if (cmd.type === "L") {
                p.lineTo(
                  x + cmd.x * xScale,
                  y + -cmd.y * yScale
                );
              } else if (cmd.type === "Q") {
                p.quadraticCurveTo(
                  x + cmd.x1 * xScale,
                  y + -cmd.y1 * yScale,
                  x + cmd.x * xScale,
                  y + -cmd.y * yScale
                );
              } else if (cmd.type === "C") {
                p.curveTo(
                  x + cmd.x1 * xScale,
                  y + -cmd.y1 * yScale,
                  x + cmd.x2 * xScale,
                  y + -cmd.y2 * yScale,
                  x + cmd.x * xScale,
                  y + -cmd.y * yScale
                );
              } else if (cmd.type === "Z") {
                p.closePath();
              }
            }

            return p;
          };

          /**
           * Split the glyph into contours.
           * This function is here for backwards compatibility, and to
           * provide raw access to the TrueType glyph outlines.
           * @return {Array}
           */
          Glyph.prototype.getContours =
            function () {
              var this$1 = this;

              if (this.points === undefined) {
                return [];
              }

              var contours = [];
              var currentContour = [];
              for (
                var i = 0;
                i < this.points.length;
                i += 1
              ) {
                var pt = this$1.points[i];
                currentContour.push(pt);
                if (pt.lastPointOfContour) {
                  contours.push(currentContour);
                  currentContour = [];
                }
              }

              check.argument(
                currentContour.length === 0,
                "There are still points left in the current contour."
              );
              return contours;
            };

          /**
           * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
           * @return {Object}
           */
          Glyph.prototype.getMetrics =
            function () {
              var commands = this.path.commands;
              var xCoords = [];
              var yCoords = [];
              for (
                var i = 0;
                i < commands.length;
                i += 1
              ) {
                var cmd = commands[i];
                if (cmd.type !== "Z") {
                  xCoords.push(cmd.x);
                  yCoords.push(cmd.y);
                }

                if (
                  cmd.type === "Q" ||
                  cmd.type === "C"
                ) {
                  xCoords.push(cmd.x1);
                  yCoords.push(cmd.y1);
                }

                if (cmd.type === "C") {
                  xCoords.push(cmd.x2);
                  yCoords.push(cmd.y2);
                }
              }

              var metrics = {
                xMin: Math.min.apply(
                  null,
                  xCoords
                ),
                yMin: Math.min.apply(
                  null,
                  yCoords
                ),
                xMax: Math.max.apply(
                  null,
                  xCoords
                ),
                yMax: Math.max.apply(
                  null,
                  yCoords
                ),
                leftSideBearing:
                  this.leftSideBearing,
              };

              if (!isFinite(metrics.xMin)) {
                metrics.xMin = 0;
              }

              if (!isFinite(metrics.xMax)) {
                metrics.xMax = this.advanceWidth;
              }

              if (!isFinite(metrics.yMin)) {
                metrics.yMin = 0;
              }

              if (!isFinite(metrics.yMax)) {
                metrics.yMax = 0;
              }

              metrics.rightSideBearing =
                this.advanceWidth -
                metrics.leftSideBearing -
                (metrics.xMax - metrics.xMin);
              return metrics;
            };

          /**
           * Draw the glyph on the given context.
           * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
           * @param  {number} [x=0] - Horizontal position of the beginning of the text.
           * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           * @param  {Object=} options - xScale, yScale to stretch the glyph.
           */
          Glyph.prototype.draw = function (
            ctx,
            x,
            y,
            fontSize,
            options
          ) {
            this.getPath(
              x,
              y,
              fontSize,
              options
            ).draw(ctx);
          };

          /**
           * Draw the points of the glyph.
           * On-curve points will be drawn in blue, off-curve points will be drawn in red.
           * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
           * @param  {number} [x=0] - Horizontal position of the beginning of the text.
           * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           */
          Glyph.prototype.drawPoints = function (
            ctx,
            x,
            y,
            fontSize
          ) {
            function drawCircles(l, x, y, scale) {
              var PI_SQ = Math.PI * 2;
              ctx.beginPath();
              for (
                var j = 0;
                j < l.length;
                j += 1
              ) {
                ctx.moveTo(
                  x + l[j].x * scale,
                  y + l[j].y * scale
                );
                ctx.arc(
                  x + l[j].x * scale,
                  y + l[j].y * scale,
                  2,
                  0,
                  PI_SQ,
                  false
                );
              }

              ctx.closePath();
              ctx.fill();
            }

            x = x !== undefined ? x : 0;
            y = y !== undefined ? y : 0;
            fontSize =
              fontSize !== undefined
                ? fontSize
                : 24;
            var scale =
              (1 / this.path.unitsPerEm) *
              fontSize;

            var blueCircles = [];
            var redCircles = [];
            var path = this.path;
            for (
              var i = 0;
              i < path.commands.length;
              i += 1
            ) {
              var cmd = path.commands[i];
              if (cmd.x !== undefined) {
                blueCircles.push({
                  x: cmd.x,
                  y: -cmd.y,
                });
              }

              if (cmd.x1 !== undefined) {
                redCircles.push({
                  x: cmd.x1,
                  y: -cmd.y1,
                });
              }

              if (cmd.x2 !== undefined) {
                redCircles.push({
                  x: cmd.x2,
                  y: -cmd.y2,
                });
              }
            }

            ctx.fillStyle = "blue";
            drawCircles(blueCircles, x, y, scale);
            ctx.fillStyle = "red";
            drawCircles(redCircles, x, y, scale);
          };

          /**
           * Draw lines indicating important font measurements.
           * Black lines indicate the origin of the coordinate system (point 0,0).
           * Blue lines indicate the glyph bounding box.
           * Green line indicates the advance width of the glyph.
           * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
           * @param  {number} [x=0] - Horizontal position of the beginning of the text.
           * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           */
          Glyph.prototype.drawMetrics = function (
            ctx,
            x,
            y,
            fontSize
          ) {
            var scale;
            x = x !== undefined ? x : 0;
            y = y !== undefined ? y : 0;
            fontSize =
              fontSize !== undefined
                ? fontSize
                : 24;
            scale =
              (1 / this.path.unitsPerEm) *
              fontSize;
            ctx.lineWidth = 1;

            // Draw the origin
            ctx.strokeStyle = "black";
            draw.line(ctx, x, -10000, x, 10000);
            draw.line(ctx, -10000, y, 10000, y);

            // This code is here due to memory optimization: by not using
            // defaults in the constructor, we save a notable amount of memory.
            var xMin = this.xMin || 0;
            var yMin = this.yMin || 0;
            var xMax = this.xMax || 0;
            var yMax = this.yMax || 0;
            var advanceWidth =
              this.advanceWidth || 0;

            // Draw the glyph box
            ctx.strokeStyle = "blue";
            draw.line(
              ctx,
              x + xMin * scale,
              -10000,
              x + xMin * scale,
              10000
            );
            draw.line(
              ctx,
              x + xMax * scale,
              -10000,
              x + xMax * scale,
              10000
            );
            draw.line(
              ctx,
              -10000,
              y + -yMin * scale,
              10000,
              y + -yMin * scale
            );
            draw.line(
              ctx,
              -10000,
              y + -yMax * scale,
              10000,
              y + -yMax * scale
            );

            // Draw the advance width
            ctx.strokeStyle = "green";
            draw.line(
              ctx,
              x + advanceWidth * scale,
              -10000,
              x + advanceWidth * scale,
              10000
            );
          };

          // The GlyphSet object

          // Define a property on the glyph that depends on the path being loaded.
          function defineDependentProperty(
            glyph,
            externalName,
            internalName
          ) {
            Object.defineProperty(
              glyph,
              externalName,
              {
                get: function () {
                  // Request the path property to make sure the path is loaded.
                  glyph.path; // jshint ignore:line
                  return glyph[internalName];
                },
                set: function (newValue) {
                  glyph[internalName] = newValue;
                },
                enumerable: true,
                configurable: true,
              }
            );
          }

          /**
           * A GlyphSet represents all glyphs available in the font, but modelled using
           * a deferred glyph loader, for retrieving glyphs only once they are absolutely
           * necessary, to keep the memory footprint down.
           * @exports opentype.GlyphSet
           * @class
           * @param {opentype.Font}
           * @param {Array}
           */
          function GlyphSet(font, glyphs) {
            var this$1 = this;

            this.font = font;
            this.glyphs = {};
            if (Array.isArray(glyphs)) {
              for (
                var i = 0;
                i < glyphs.length;
                i++
              ) {
                this$1.glyphs[i] = glyphs[i];
              }
            }

            this.length =
              (glyphs && glyphs.length) || 0;
          }

          /**
           * @param  {number} index
           * @return {opentype.Glyph}
           */
          GlyphSet.prototype.get = function (
            index
          ) {
            if (
              typeof this.glyphs[index] ===
              "function"
            ) {
              this.glyphs[index] =
                this.glyphs[index]();
            }

            return this.glyphs[index];
          };

          /**
           * @param  {number} index
           * @param  {Object}
           */
          GlyphSet.prototype.push = function (
            index,
            loader
          ) {
            this.glyphs[index] = loader;
            this.length++;
          };

          /**
           * @alias opentype.glyphLoader
           * @param  {opentype.Font} font
           * @param  {number} index
           * @return {opentype.Glyph}
           */
          function glyphLoader(font, index) {
            return new Glyph({
              index: index,
              font: font,
            });
          }

          /**
           * Generate a stub glyph that can be filled with all metadata *except*
           * the "points" and "path" properties, which must be loaded only once
           * the glyph's path is actually requested for text shaping.
           * @alias opentype.ttfGlyphLoader
           * @param  {opentype.Font} font
           * @param  {number} index
           * @param  {Function} parseGlyph
           * @param  {Object} data
           * @param  {number} position
           * @param  {Function} buildPath
           * @return {opentype.Glyph}
           */
          function ttfGlyphLoader(
            font,
            index,
            parseGlyph,
            data,
            position,
            buildPath
          ) {
            return function () {
              var glyph = new Glyph({
                index: index,
                font: font,
              });

              glyph.path = function () {
                parseGlyph(glyph, data, position);
                var path = buildPath(
                  font.glyphs,
                  glyph
                );
                path.unitsPerEm = font.unitsPerEm;
                return path;
              };

              defineDependentProperty(
                glyph,
                "xMin",
                "_xMin"
              );
              defineDependentProperty(
                glyph,
                "xMax",
                "_xMax"
              );
              defineDependentProperty(
                glyph,
                "yMin",
                "_yMin"
              );
              defineDependentProperty(
                glyph,
                "yMax",
                "_yMax"
              );

              return glyph;
            };
          }
          /**
           * @alias opentype.cffGlyphLoader
           * @param  {opentype.Font} font
           * @param  {number} index
           * @param  {Function} parseCFFCharstring
           * @param  {string} charstring
           * @return {opentype.Glyph}
           */
          function cffGlyphLoader(
            font,
            index,
            parseCFFCharstring,
            charstring
          ) {
            return function () {
              var glyph = new Glyph({
                index: index,
                font: font,
              });

              glyph.path = function () {
                var path = parseCFFCharstring(
                  font,
                  glyph,
                  charstring
                );
                path.unitsPerEm = font.unitsPerEm;
                return path;
              };

              return glyph;
            };
          }

          var glyphset = {
            GlyphSet: GlyphSet,
            glyphLoader: glyphLoader,
            ttfGlyphLoader: ttfGlyphLoader,
            cffGlyphLoader: cffGlyphLoader,
          };

          // The `CFF` table contains the glyph outlines in PostScript format.

          // Custom equals function that can also check lists.
          function equals(a, b) {
            if (a === b) {
              return true;
            } else if (
              Array.isArray(a) &&
              Array.isArray(b)
            ) {
              if (a.length !== b.length) {
                return false;
              }

              for (
                var i = 0;
                i < a.length;
                i += 1
              ) {
                if (!equals(a[i], b[i])) {
                  return false;
                }
              }

              return true;
            } else {
              return false;
            }
          }

          // Subroutines are encoded using the negative half of the number space.
          // See type 2 chapter 4.7 "Subroutine operators".
          function calcCFFSubroutineBias(subrs) {
            var bias;
            if (subrs.length < 1240) {
              bias = 107;
            } else if (subrs.length < 33900) {
              bias = 1131;
            } else {
              bias = 32768;
            }

            return bias;
          }

          // Parse a `CFF` INDEX array.
          // An index array consists of a list of offsets, then a list of objects at those offsets.
          function parseCFFIndex(
            data,
            start,
            conversionFn
          ) {
            var offsets = [];
            var objects = [];
            var count = parse.getCard16(
              data,
              start
            );
            var objectOffset;
            var endOffset;
            if (count !== 0) {
              var offsetSize = parse.getByte(
                data,
                start + 2
              );
              objectOffset =
                start +
                (count + 1) * offsetSize +
                2;
              var pos = start + 3;
              for (
                var i = 0;
                i < count + 1;
                i += 1
              ) {
                offsets.push(
                  parse.getOffset(
                    data,
                    pos,
                    offsetSize
                  )
                );
                pos += offsetSize;
              }

              // The total size of the index array is 4 header bytes + the value of the last offset.
              endOffset =
                objectOffset + offsets[count];
            } else {
              endOffset = start + 2;
            }

            for (
              var i$1 = 0;
              i$1 < offsets.length - 1;
              i$1 += 1
            ) {
              var value = parse.getBytes(
                data,
                objectOffset + offsets[i$1],
                objectOffset + offsets[i$1 + 1]
              );
              if (conversionFn) {
                value = conversionFn(value);
              }

              objects.push(value);
            }

            return {
              objects: objects,
              startOffset: start,
              endOffset: endOffset,
            };
          }

          // Parse a `CFF` DICT real value.
          function parseFloatOperand(parser) {
            var s = "";
            var eof = 15;
            var lookup = [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              ".",
              "E",
              "E-",
              null,
              "-",
            ];
            while (true) {
              var b = parser.parseByte();
              var n1 = b >> 4;
              var n2 = b & 15;

              if (n1 === eof) {
                break;
              }

              s += lookup[n1];

              if (n2 === eof) {
                break;
              }

              s += lookup[n2];
            }

            return parseFloat(s);
          }

          // Parse a `CFF` DICT operand.
          function parseOperand(parser, b0) {
            var b1;
            var b2;
            var b3;
            var b4;
            if (b0 === 28) {
              b1 = parser.parseByte();
              b2 = parser.parseByte();
              return (b1 << 8) | b2;
            }

            if (b0 === 29) {
              b1 = parser.parseByte();
              b2 = parser.parseByte();
              b3 = parser.parseByte();
              b4 = parser.parseByte();
              return (
                (b1 << 24) |
                (b2 << 16) |
                (b3 << 8) |
                b4
              );
            }

            if (b0 === 30) {
              return parseFloatOperand(parser);
            }

            if (b0 >= 32 && b0 <= 246) {
              return b0 - 139;
            }

            if (b0 >= 247 && b0 <= 250) {
              b1 = parser.parseByte();
              return (b0 - 247) * 256 + b1 + 108;
            }

            if (b0 >= 251 && b0 <= 254) {
              b1 = parser.parseByte();
              return -(b0 - 251) * 256 - b1 - 108;
            }

            throw new Error("Invalid b0 " + b0);
          }

          // Convert the entries returned by `parseDict` to a proper dictionary.
          // If a value is a list of one, it is unpacked.
          function entriesToObject(entries) {
            var o = {};
            for (
              var i = 0;
              i < entries.length;
              i += 1
            ) {
              var key = entries[i][0];
              var values = entries[i][1];
              var value = void 0;
              if (values.length === 1) {
                value = values[0];
              } else {
                value = values;
              }

              if (
                o.hasOwnProperty(key) &&
                !isNaN(o[key])
              ) {
                throw new Error(
                  "Object " +
                    o +
                    " already has key " +
                    key
                );
              }

              o[key] = value;
            }

            return o;
          }

          // Parse a `CFF` DICT object.
          // A dictionary contains key-value pairs in a compact tokenized format.
          function parseCFFDict(
            data,
            start,
            size
          ) {
            start =
              start !== undefined ? start : 0;
            var parser = new parse.Parser(
              data,
              start
            );
            var entries = [];
            var operands = [];
            size =
              size !== undefined
                ? size
                : data.length;

            while (parser.relativeOffset < size) {
              var op = parser.parseByte();

              // The first byte for each dict item distinguishes between operator (key) and operand (value).
              // Values <= 21 are operators.
              if (op <= 21) {
                // Two-byte operators have an initial escape byte of 12.
                if (op === 12) {
                  op = 1200 + parser.parseByte();
                }

                entries.push([op, operands]);
                operands = [];
              } else {
                // Since the operands (values) come before the operators (keys), we store all operands in a list
                // until we encounter an operator.
                operands.push(
                  parseOperand(parser, op)
                );
              }
            }

            return entriesToObject(entries);
          }

          // Given a String Index (SID), return the value of the string.
          // Strings below index 392 are standard CFF strings and are not encoded in the font.
          function getCFFString(strings, index) {
            if (index <= 390) {
              index = cffStandardStrings[index];
            } else {
              index = strings[index - 391];
            }

            return index;
          }

          // Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
          // This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
          function interpretDict(
            dict,
            meta,
            strings
          ) {
            var newDict = {};
            var value;

            // Because we also want to include missing values, we start out from the meta list
            // and lookup values in the dict.
            for (
              var i = 0;
              i < meta.length;
              i += 1
            ) {
              var m = meta[i];

              if (Array.isArray(m.type)) {
                var values = [];
                values.length = m.type.length;
                for (
                  var j = 0;
                  j < m.type.length;
                  j++
                ) {
                  value =
                    dict[m.op] !== undefined
                      ? dict[m.op][j]
                      : undefined;
                  if (value === undefined) {
                    value =
                      m.value !== undefined &&
                      m.value[j] !== undefined
                        ? m.value[j]
                        : null;
                  }
                  if (m.type[j] === "SID") {
                    value = getCFFString(
                      strings,
                      value
                    );
                  }
                  values[j] = value;
                }
                newDict[m.name] = values;
              } else {
                value = dict[m.op];
                if (value === undefined) {
                  value =
                    m.value !== undefined
                      ? m.value
                      : null;
                }

                if (m.type === "SID") {
                  value = getCFFString(
                    strings,
                    value
                  );
                }
                newDict[m.name] = value;
              }
            }

            return newDict;
          }

          // Parse the CFF header.
          function parseCFFHeader(data, start) {
            var header = {};
            header.formatMajor = parse.getCard8(
              data,
              start
            );
            header.formatMinor = parse.getCard8(
              data,
              start + 1
            );
            header.size = parse.getCard8(
              data,
              start + 2
            );
            header.offsetSize = parse.getCard8(
              data,
              start + 3
            );
            header.startOffset = start;
            header.endOffset = start + 4;
            return header;
          }

          var TOP_DICT_META = [
            {
              name: "version",
              op: 0,
              type: "SID",
            },
            {
              name: "notice",
              op: 1,
              type: "SID",
            },
            {
              name: "copyright",
              op: 1200,
              type: "SID",
            },
            {
              name: "fullName",
              op: 2,
              type: "SID",
            },
            {
              name: "familyName",
              op: 3,
              type: "SID",
            },
            {
              name: "weight",
              op: 4,
              type: "SID",
            },
            {
              name: "isFixedPitch",
              op: 1201,
              type: "number",
              value: 0,
            },
            {
              name: "italicAngle",
              op: 1202,
              type: "number",
              value: 0,
            },
            {
              name: "underlinePosition",
              op: 1203,
              type: "number",
              value: -100,
            },
            {
              name: "underlineThickness",
              op: 1204,
              type: "number",
              value: 50,
            },
            {
              name: "paintType",
              op: 1205,
              type: "number",
              value: 0,
            },
            {
              name: "charstringType",
              op: 1206,
              type: "number",
              value: 2,
            },
            {
              name: "fontMatrix",
              op: 1207,
              type: [
                "real",
                "real",
                "real",
                "real",
                "real",
                "real",
              ],
              value: [0.001, 0, 0, 0.001, 0, 0],
            },
            {
              name: "uniqueId",
              op: 13,
              type: "number",
            },
            {
              name: "fontBBox",
              op: 5,
              type: [
                "number",
                "number",
                "number",
                "number",
              ],
              value: [0, 0, 0, 0],
            },
            {
              name: "strokeWidth",
              op: 1208,
              type: "number",
              value: 0,
            },
            {
              name: "xuid",
              op: 14,
              type: [],
              value: null,
            },
            {
              name: "charset",
              op: 15,
              type: "offset",
              value: 0,
            },
            {
              name: "encoding",
              op: 16,
              type: "offset",
              value: 0,
            },
            {
              name: "charStrings",
              op: 17,
              type: "offset",
              value: 0,
            },
            {
              name: "private",
              op: 18,
              type: ["number", "offset"],
              value: [0, 0],
            },
            {
              name: "ros",
              op: 1230,
              type: ["SID", "SID", "number"],
            },
            {
              name: "cidFontVersion",
              op: 1231,
              type: "number",
              value: 0,
            },
            {
              name: "cidFontRevision",
              op: 1232,
              type: "number",
              value: 0,
            },
            {
              name: "cidFontType",
              op: 1233,
              type: "number",
              value: 0,
            },
            {
              name: "cidCount",
              op: 1234,
              type: "number",
              value: 8720,
            },
            {
              name: "uidBase",
              op: 1235,
              type: "number",
            },
            {
              name: "fdArray",
              op: 1236,
              type: "offset",
            },
            {
              name: "fdSelect",
              op: 1237,
              type: "offset",
            },
            {
              name: "fontName",
              op: 1238,
              type: "SID",
            },
          ];

          var PRIVATE_DICT_META = [
            {
              name: "subrs",
              op: 19,
              type: "offset",
              value: 0,
            },
            {
              name: "defaultWidthX",
              op: 20,
              type: "number",
              value: 0,
            },
            {
              name: "nominalWidthX",
              op: 21,
              type: "number",
              value: 0,
            },
          ];

          // Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
          // The top dictionary contains the essential metadata for the font, together with the private dictionary.
          function parseCFFTopDict(
            data,
            strings
          ) {
            var dict = parseCFFDict(
              data,
              0,
              data.byteLength
            );
            return interpretDict(
              dict,
              TOP_DICT_META,
              strings
            );
          }

          // Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
          function parseCFFPrivateDict(
            data,
            start,
            size,
            strings
          ) {
            var dict = parseCFFDict(
              data,
              start,
              size
            );
            return interpretDict(
              dict,
              PRIVATE_DICT_META,
              strings
            );
          }

          // Returns a list of "Top DICT"s found using an INDEX list.
          // Used to read both the usual high-level Top DICTs and also the FDArray
          // discovered inside CID-keyed fonts.  When a Top DICT has a reference to
          // a Private DICT that is read and saved into the Top DICT.
          //
          // In addition to the expected/optional values as outlined in TOP_DICT_META
          // the following values might be saved into the Top DICT.
          //
          //    _subrs []        array of local CFF subroutines from Private DICT
          //    _subrsBias       bias value computed from number of subroutines
          //                      (see calcCFFSubroutineBias() and parseCFFCharstring())
          //    _defaultWidthX   default widths for CFF characters
          //    _nominalWidthX   bias added to width embedded within glyph description
          //
          //    _privateDict     saved copy of parsed Private DICT from Top DICT
          function gatherCFFTopDicts(
            data,
            start,
            cffIndex,
            strings
          ) {
            var topDictArray = [];
            for (
              var iTopDict = 0;
              iTopDict < cffIndex.length;
              iTopDict += 1
            ) {
              var topDictData = new DataView(
                new Uint8Array(
                  cffIndex[iTopDict]
                ).buffer
              );
              var topDict = parseCFFTopDict(
                topDictData,
                strings
              );
              topDict._subrs = [];
              topDict._subrsBias = 0;
              var privateSize =
                topDict.private[0];
              var privateOffset =
                topDict.private[1];
              if (
                privateSize !== 0 &&
                privateOffset !== 0
              ) {
                var privateDict =
                  parseCFFPrivateDict(
                    data,
                    privateOffset + start,
                    privateSize,
                    strings
                  );
                topDict._defaultWidthX =
                  privateDict.defaultWidthX;
                topDict._nominalWidthX =
                  privateDict.nominalWidthX;
                if (privateDict.subrs !== 0) {
                  var subrOffset =
                    privateOffset +
                    privateDict.subrs;
                  var subrIndex = parseCFFIndex(
                    data,
                    subrOffset + start
                  );
                  topDict._subrs =
                    subrIndex.objects;
                  topDict._subrsBias =
                    calcCFFSubroutineBias(
                      topDict._subrs
                    );
                }
                topDict._privateDict =
                  privateDict;
              }
              topDictArray.push(topDict);
            }
            return topDictArray;
          }

          // Parse the CFF charset table, which contains internal names for all the glyphs.
          // This function will return a list of glyph names.
          // See Adobe TN #5176 chapter 13, "Charsets".
          function parseCFFCharset(
            data,
            start,
            nGlyphs,
            strings
          ) {
            var sid;
            var count;
            var parser = new parse.Parser(
              data,
              start
            );

            // The .notdef glyph is not included, so subtract 1.
            nGlyphs -= 1;
            var charset = [".notdef"];

            var format = parser.parseCard8();
            if (format === 0) {
              for (
                var i = 0;
                i < nGlyphs;
                i += 1
              ) {
                sid = parser.parseSID();
                charset.push(
                  getCFFString(strings, sid)
                );
              }
            } else if (format === 1) {
              while (charset.length <= nGlyphs) {
                sid = parser.parseSID();
                count = parser.parseCard8();
                for (
                  var i$1 = 0;
                  i$1 <= count;
                  i$1 += 1
                ) {
                  charset.push(
                    getCFFString(strings, sid)
                  );
                  sid += 1;
                }
              }
            } else if (format === 2) {
              while (charset.length <= nGlyphs) {
                sid = parser.parseSID();
                count = parser.parseCard16();
                for (
                  var i$2 = 0;
                  i$2 <= count;
                  i$2 += 1
                ) {
                  charset.push(
                    getCFFString(strings, sid)
                  );
                  sid += 1;
                }
              }
            } else {
              throw new Error(
                "Unknown charset format " + format
              );
            }

            return charset;
          }

          // Parse the CFF encoding data. Only one encoding can be specified per font.
          // See Adobe TN #5176 chapter 12, "Encodings".
          function parseCFFEncoding(
            data,
            start,
            charset
          ) {
            var code;
            var enc = {};
            var parser = new parse.Parser(
              data,
              start
            );
            var format = parser.parseCard8();
            if (format === 0) {
              var nCodes = parser.parseCard8();
              for (
                var i = 0;
                i < nCodes;
                i += 1
              ) {
                code = parser.parseCard8();
                enc[code] = i;
              }
            } else if (format === 1) {
              var nRanges = parser.parseCard8();
              code = 1;
              for (
                var i$1 = 0;
                i$1 < nRanges;
                i$1 += 1
              ) {
                var first = parser.parseCard8();
                var nLeft = parser.parseCard8();
                for (
                  var j = first;
                  j <= first + nLeft;
                  j += 1
                ) {
                  enc[j] = code;
                  code += 1;
                }
              }
            } else {
              throw new Error(
                "Unknown encoding format " +
                  format
              );
            }

            return new CffEncoding(enc, charset);
          }

          // Take in charstring code and return a Glyph object.
          // The encoding is described in the Type 2 Charstring Format
          // https://www.microsoft.com/typography/OTSPEC/charstr2.htm
          function parseCFFCharstring(
            font,
            glyph,
            code
          ) {
            var c1x;
            var c1y;
            var c2x;
            var c2y;
            var p = new Path();
            var stack = [];
            var nStems = 0;
            var haveWidth = false;
            var open = false;
            var x = 0;
            var y = 0;
            var subrs;
            var subrsBias;
            var defaultWidthX;
            var nominalWidthX;
            if (font.isCIDFont) {
              var fdIndex =
                font.tables.cff.topDict._fdSelect[
                  glyph.index
                ];
              var fdDict =
                font.tables.cff.topDict._fdArray[
                  fdIndex
                ];
              subrs = fdDict._subrs;
              subrsBias = fdDict._subrsBias;
              defaultWidthX =
                fdDict._defaultWidthX;
              nominalWidthX =
                fdDict._nominalWidthX;
            } else {
              subrs =
                font.tables.cff.topDict._subrs;
              subrsBias =
                font.tables.cff.topDict
                  ._subrsBias;
              defaultWidthX =
                font.tables.cff.topDict
                  ._defaultWidthX;
              nominalWidthX =
                font.tables.cff.topDict
                  ._nominalWidthX;
            }
            var width = defaultWidthX;

            function newContour(x, y) {
              if (open) {
                p.closePath();
              }

              p.moveTo(x, y);
              open = true;
            }

            function parseStems() {
              var hasWidthArg;

              // The number of stem operators on the stack is always even.
              // If the value is uneven, that means a width is specified.
              hasWidthArg =
                stack.length % 2 !== 0;
              if (hasWidthArg && !haveWidth) {
                width =
                  stack.shift() + nominalWidthX;
              }

              nStems += stack.length >> 1;
              stack.length = 0;
              haveWidth = true;
            }

            function parse$$1(code) {
              var b1;
              var b2;
              var b3;
              var b4;
              var codeIndex;
              var subrCode;
              var jpx;
              var jpy;
              var c3x;
              var c3y;
              var c4x;
              var c4y;

              var i = 0;
              while (i < code.length) {
                var v = code[i];
                i += 1;
                switch (v) {
                  case 1: // hstem
                    parseStems();
                    break;
                  case 3: // vstem
                    parseStems();
                    break;
                  case 4: // vmoveto
                    if (
                      stack.length > 1 &&
                      !haveWidth
                    ) {
                      width =
                        stack.shift() +
                        nominalWidthX;
                      haveWidth = true;
                    }

                    y += stack.pop();
                    newContour(x, y);
                    break;
                  case 5: // rlineto
                    while (stack.length > 0) {
                      x += stack.shift();
                      y += stack.shift();
                      p.lineTo(x, y);
                    }

                    break;
                  case 6: // hlineto
                    while (stack.length > 0) {
                      x += stack.shift();
                      p.lineTo(x, y);
                      if (stack.length === 0) {
                        break;
                      }

                      y += stack.shift();
                      p.lineTo(x, y);
                    }

                    break;
                  case 7: // vlineto
                    while (stack.length > 0) {
                      y += stack.shift();
                      p.lineTo(x, y);
                      if (stack.length === 0) {
                        break;
                      }

                      x += stack.shift();
                      p.lineTo(x, y);
                    }

                    break;
                  case 8: // rrcurveto
                    while (stack.length > 0) {
                      c1x = x + stack.shift();
                      c1y = y + stack.shift();
                      c2x = c1x + stack.shift();
                      c2y = c1y + stack.shift();
                      x = c2x + stack.shift();
                      y = c2y + stack.shift();
                      p.curveTo(
                        c1x,
                        c1y,
                        c2x,
                        c2y,
                        x,
                        y
                      );
                    }

                    break;
                  case 10: // callsubr
                    codeIndex =
                      stack.pop() + subrsBias;
                    subrCode = subrs[codeIndex];
                    if (subrCode) {
                      parse$$1(subrCode);
                    }

                    break;
                  case 11: // return
                    return;
                  case 12: // flex operators
                    v = code[i];
                    i += 1;
                    switch (v) {
                      case 35: // flex
                        // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                        c1x = x + stack.shift(); // dx1
                        c1y = y + stack.shift(); // dy1
                        c2x = c1x + stack.shift(); // dx2
                        c2y = c1y + stack.shift(); // dy2
                        jpx = c2x + stack.shift(); // dx3
                        jpy = c2y + stack.shift(); // dy3
                        c3x = jpx + stack.shift(); // dx4
                        c3y = jpy + stack.shift(); // dy4
                        c4x = c3x + stack.shift(); // dx5
                        c4y = c3y + stack.shift(); // dy5
                        x = c4x + stack.shift(); // dx6
                        y = c4y + stack.shift(); // dy6
                        stack.shift(); // flex depth
                        p.curveTo(
                          c1x,
                          c1y,
                          c2x,
                          c2y,
                          jpx,
                          jpy
                        );
                        p.curveTo(
                          c3x,
                          c3y,
                          c4x,
                          c4y,
                          x,
                          y
                        );
                        break;
                      case 34: // hflex
                        // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                        c1x = x + stack.shift(); // dx1
                        c1y = y; // dy1
                        c2x = c1x + stack.shift(); // dx2
                        c2y = c1y + stack.shift(); // dy2
                        jpx = c2x + stack.shift(); // dx3
                        jpy = c2y; // dy3
                        c3x = jpx + stack.shift(); // dx4
                        c3y = c2y; // dy4
                        c4x = c3x + stack.shift(); // dx5
                        c4y = y; // dy5
                        x = c4x + stack.shift(); // dx6
                        p.curveTo(
                          c1x,
                          c1y,
                          c2x,
                          c2y,
                          jpx,
                          jpy
                        );
                        p.curveTo(
                          c3x,
                          c3y,
                          c4x,
                          c4y,
                          x,
                          y
                        );
                        break;
                      case 36: // hflex1
                        // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                        c1x = x + stack.shift(); // dx1
                        c1y = y + stack.shift(); // dy1
                        c2x = c1x + stack.shift(); // dx2
                        c2y = c1y + stack.shift(); // dy2
                        jpx = c2x + stack.shift(); // dx3
                        jpy = c2y; // dy3
                        c3x = jpx + stack.shift(); // dx4
                        c3y = c2y; // dy4
                        c4x = c3x + stack.shift(); // dx5
                        c4y = c3y + stack.shift(); // dy5
                        x = c4x + stack.shift(); // dx6
                        p.curveTo(
                          c1x,
                          c1y,
                          c2x,
                          c2y,
                          jpx,
                          jpy
                        );
                        p.curveTo(
                          c3x,
                          c3y,
                          c4x,
                          c4y,
                          x,
                          y
                        );
                        break;
                      case 37: // flex1
                        // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                        c1x = x + stack.shift(); // dx1
                        c1y = y + stack.shift(); // dy1
                        c2x = c1x + stack.shift(); // dx2
                        c2y = c1y + stack.shift(); // dy2
                        jpx = c2x + stack.shift(); // dx3
                        jpy = c2y + stack.shift(); // dy3
                        c3x = jpx + stack.shift(); // dx4
                        c3y = jpy + stack.shift(); // dy4
                        c4x = c3x + stack.shift(); // dx5
                        c4y = c3y + stack.shift(); // dy5
                        if (
                          Math.abs(c4x - x) >
                          Math.abs(c4y - y)
                        ) {
                          x = c4x + stack.shift();
                        } else {
                          y = c4y + stack.shift();
                        }

                        p.curveTo(
                          c1x,
                          c1y,
                          c2x,
                          c2y,
                          jpx,
                          jpy
                        );
                        p.curveTo(
                          c3x,
                          c3y,
                          c4x,
                          c4y,
                          x,
                          y
                        );
                        break;
                      default:
                        console.log(
                          "Glyph " +
                            glyph.index +
                            ": unknown operator " +
                            1200 +
                            v
                        );
                        stack.length = 0;
                    }
                    break;
                  case 14: // endchar
                    if (
                      stack.length > 0 &&
                      !haveWidth
                    ) {
                      width =
                        stack.shift() +
                        nominalWidthX;
                      haveWidth = true;
                    }

                    if (open) {
                      p.closePath();
                      open = false;
                    }

                    break;
                  case 18: // hstemhm
                    parseStems();
                    break;
                  case 19: // hintmask
                  case 20: // cntrmask
                    parseStems();
                    i += (nStems + 7) >> 3;
                    break;
                  case 21: // rmoveto
                    if (
                      stack.length > 2 &&
                      !haveWidth
                    ) {
                      width =
                        stack.shift() +
                        nominalWidthX;
                      haveWidth = true;
                    }

                    y += stack.pop();
                    x += stack.pop();
                    newContour(x, y);
                    break;
                  case 22: // hmoveto
                    if (
                      stack.length > 1 &&
                      !haveWidth
                    ) {
                      width =
                        stack.shift() +
                        nominalWidthX;
                      haveWidth = true;
                    }

                    x += stack.pop();
                    newContour(x, y);
                    break;
                  case 23: // vstemhm
                    parseStems();
                    break;
                  case 24: // rcurveline
                    while (stack.length > 2) {
                      c1x = x + stack.shift();
                      c1y = y + stack.shift();
                      c2x = c1x + stack.shift();
                      c2y = c1y + stack.shift();
                      x = c2x + stack.shift();
                      y = c2y + stack.shift();
                      p.curveTo(
                        c1x,
                        c1y,
                        c2x,
                        c2y,
                        x,
                        y
                      );
                    }

                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                    break;
                  case 25: // rlinecurve
                    while (stack.length > 6) {
                      x += stack.shift();
                      y += stack.shift();
                      p.lineTo(x, y);
                    }

                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(
                      c1x,
                      c1y,
                      c2x,
                      c2y,
                      x,
                      y
                    );
                    break;
                  case 26: // vvcurveto
                    if (stack.length % 2) {
                      x += stack.shift();
                    }

                    while (stack.length > 0) {
                      c1x = x;
                      c1y = y + stack.shift();
                      c2x = c1x + stack.shift();
                      c2y = c1y + stack.shift();
                      x = c2x;
                      y = c2y + stack.shift();
                      p.curveTo(
                        c1x,
                        c1y,
                        c2x,
                        c2y,
                        x,
                        y
                      );
                    }

                    break;
                  case 27: // hhcurveto
                    if (stack.length % 2) {
                      y += stack.shift();
                    }

                    while (stack.length > 0) {
                      c1x = x + stack.shift();
                      c1y = y;
                      c2x = c1x + stack.shift();
                      c2y = c1y + stack.shift();
                      x = c2x + stack.shift();
                      y = c2y;
                      p.curveTo(
                        c1x,
                        c1y,
                        c2x,
                        c2y,
                        x,
                        y
                      );
                    }

                    break;
                  case 28: // shortint
                    b1 = code[i];
                    b2 = code[i + 1];
                    stack.push(
                      ((b1 << 24) | (b2 << 16)) >>
                        16
                    );
                    i += 2;
                    break;
                  case 29: // callgsubr
                    codeIndex =
                      stack.pop() +
                      font.gsubrsBias;
                    subrCode =
                      font.gsubrs[codeIndex];
                    if (subrCode) {
                      parse$$1(subrCode);
                    }

                    break;
                  case 30: // vhcurveto
                    while (stack.length > 0) {
                      c1x = x;
                      c1y = y + stack.shift();
                      c2x = c1x + stack.shift();
                      c2y = c1y + stack.shift();
                      x = c2x + stack.shift();
                      y =
                        c2y +
                        (stack.length === 1
                          ? stack.shift()
                          : 0);
                      p.curveTo(
                        c1x,
                        c1y,
                        c2x,
                        c2y,
                        x,
                        y
                      );
                      if (stack.length === 0) {
                        break;
                      }

                      c1x = x + stack.shift();
                      c1y = y;
                      c2x = c1x + stack.shift();
                      c2y = c1y + stack.shift();
                      y = c2y + stack.shift();
                      x =
                        c2x +
                        (stack.length === 1
                          ? stack.shift()
                          : 0);
                      p.curveTo(
                        c1x,
                        c1y,
                        c2x,
                        c2y,
                        x,
                        y
                      );
                    }

                    break;
                  case 31: // hvcurveto
                    while (stack.length > 0) {
                      c1x = x + stack.shift();
                      c1y = y;
                      c2x = c1x + stack.shift();
                      c2y = c1y + stack.shift();
                      y = c2y + stack.shift();
                      x =
                        c2x +
                        (stack.length === 1
                          ? stack.shift()
                          : 0);
                      p.curveTo(
                        c1x,
                        c1y,
                        c2x,
                        c2y,
                        x,
                        y
                      );
                      if (stack.length === 0) {
                        break;
                      }

                      c1x = x;
                      c1y = y + stack.shift();
                      c2x = c1x + stack.shift();
                      c2y = c1y + stack.shift();
                      x = c2x + stack.shift();
                      y =
                        c2y +
                        (stack.length === 1
                          ? stack.shift()
                          : 0);
                      p.curveTo(
                        c1x,
                        c1y,
                        c2x,
                        c2y,
                        x,
                        y
                      );
                    }

                    break;
                  default:
                    if (v < 32) {
                      console.log(
                        "Glyph " +
                          glyph.index +
                          ": unknown operator " +
                          v
                      );
                    } else if (v < 247) {
                      stack.push(v - 139);
                    } else if (v < 251) {
                      b1 = code[i];
                      i += 1;
                      stack.push(
                        (v - 247) * 256 + b1 + 108
                      );
                    } else if (v < 255) {
                      b1 = code[i];
                      i += 1;
                      stack.push(
                        -(v - 251) * 256 -
                          b1 -
                          108
                      );
                    } else {
                      b1 = code[i];
                      b2 = code[i + 1];
                      b3 = code[i + 2];
                      b4 = code[i + 3];
                      i += 4;
                      stack.push(
                        ((b1 << 24) |
                          (b2 << 16) |
                          (b3 << 8) |
                          b4) /
                          65536
                      );
                    }
                }
              }
            }

            parse$$1(code);

            glyph.advanceWidth = width;
            return p;
          }

          function parseCFFFDSelect(
            data,
            start,
            nGlyphs,
            fdArrayCount
          ) {
            var fdSelect = [];
            var fdIndex;
            var parser = new parse.Parser(
              data,
              start
            );
            var format = parser.parseCard8();
            if (format === 0) {
              // Simple list of nGlyphs elements
              for (
                var iGid = 0;
                iGid < nGlyphs;
                iGid++
              ) {
                fdIndex = parser.parseCard8();
                if (fdIndex >= fdArrayCount) {
                  throw new Error(
                    "CFF table CID Font FDSelect has bad FD index value " +
                      fdIndex +
                      " (FD count " +
                      fdArrayCount +
                      ")"
                  );
                }
                fdSelect.push(fdIndex);
              }
            } else if (format === 3) {
              // Ranges
              var nRanges = parser.parseCard16();
              var first = parser.parseCard16();
              if (first !== 0) {
                throw new Error(
                  "CFF Table CID Font FDSelect format 3 range has bad initial GID " +
                    first
                );
              }
              var next;
              for (
                var iRange = 0;
                iRange < nRanges;
                iRange++
              ) {
                fdIndex = parser.parseCard8();
                next = parser.parseCard16();
                if (fdIndex >= fdArrayCount) {
                  throw new Error(
                    "CFF table CID Font FDSelect has bad FD index value " +
                      fdIndex +
                      " (FD count " +
                      fdArrayCount +
                      ")"
                  );
                }
                if (next > nGlyphs) {
                  throw new Error(
                    "CFF Table CID Font FDSelect format 3 range has bad GID " +
                      next
                  );
                }
                for (; first < next; first++) {
                  fdSelect.push(fdIndex);
                }
                first = next;
              }
              if (next !== nGlyphs) {
                throw new Error(
                  "CFF Table CID Font FDSelect format 3 range has bad final GID " +
                    next
                );
              }
            } else {
              throw new Error(
                "CFF Table CID Font FDSelect table has unsupported format " +
                  format
              );
            }
            return fdSelect;
          }

          // Parse the `CFF` table, which contains the glyph outlines in PostScript format.
          function parseCFFTable(
            data,
            start,
            font
          ) {
            font.tables.cff = {};
            var header = parseCFFHeader(
              data,
              start
            );
            var nameIndex = parseCFFIndex(
              data,
              header.endOffset,
              parse.bytesToString
            );
            var topDictIndex = parseCFFIndex(
              data,
              nameIndex.endOffset
            );
            var stringIndex = parseCFFIndex(
              data,
              topDictIndex.endOffset,
              parse.bytesToString
            );
            var globalSubrIndex = parseCFFIndex(
              data,
              stringIndex.endOffset
            );
            font.gsubrs = globalSubrIndex.objects;
            font.gsubrsBias =
              calcCFFSubroutineBias(font.gsubrs);

            var topDictArray = gatherCFFTopDicts(
              data,
              start,
              topDictIndex.objects,
              stringIndex.objects
            );
            if (topDictArray.length !== 1) {
              throw new Error(
                "CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " +
                  topDictArray.length
              );
            }

            var topDict = topDictArray[0];
            font.tables.cff.topDict = topDict;

            if (topDict._privateDict) {
              font.defaultWidthX =
                topDict._privateDict.defaultWidthX;
              font.nominalWidthX =
                topDict._privateDict.nominalWidthX;
            }

            if (
              topDict.ros[0] !== undefined &&
              topDict.ros[1] !== undefined
            ) {
              font.isCIDFont = true;
            }

            if (font.isCIDFont) {
              var fdArrayOffset = topDict.fdArray;
              var fdSelectOffset =
                topDict.fdSelect;
              if (
                fdArrayOffset === 0 ||
                fdSelectOffset === 0
              ) {
                throw new Error(
                  "Font is marked as a CID font, but FDArray and/or FDSelect information is missing"
                );
              }
              fdArrayOffset += start;
              var fdArrayIndex = parseCFFIndex(
                data,
                fdArrayOffset
              );
              var fdArray = gatherCFFTopDicts(
                data,
                start,
                fdArrayIndex.objects,
                stringIndex.objects
              );
              topDict._fdArray = fdArray;
              fdSelectOffset += start;
              topDict._fdSelect =
                parseCFFFDSelect(
                  data,
                  fdSelectOffset,
                  font.numGlyphs,
                  fdArray.length
                );
            }

            var privateDictOffset =
              start + topDict.private[1];
            var privateDict = parseCFFPrivateDict(
              data,
              privateDictOffset,
              topDict.private[0],
              stringIndex.objects
            );
            font.defaultWidthX =
              privateDict.defaultWidthX;
            font.nominalWidthX =
              privateDict.nominalWidthX;

            if (privateDict.subrs !== 0) {
              var subrOffset =
                privateDictOffset +
                privateDict.subrs;
              var subrIndex = parseCFFIndex(
                data,
                subrOffset
              );
              font.subrs = subrIndex.objects;
              font.subrsBias =
                calcCFFSubroutineBias(font.subrs);
            } else {
              font.subrs = [];
              font.subrsBias = 0;
            }

            // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
            var charStringsIndex = parseCFFIndex(
              data,
              start + topDict.charStrings
            );
            font.nGlyphs =
              charStringsIndex.objects.length;

            var charset = parseCFFCharset(
              data,
              start + topDict.charset,
              font.nGlyphs,
              stringIndex.objects
            );
            if (topDict.encoding === 0) {
              // Standard encoding
              font.cffEncoding = new CffEncoding(
                cffStandardEncoding,
                charset
              );
            } else if (topDict.encoding === 1) {
              // Expert encoding
              font.cffEncoding = new CffEncoding(
                cffExpertEncoding,
                charset
              );
            } else {
              font.cffEncoding = parseCFFEncoding(
                data,
                start + topDict.encoding,
                charset
              );
            }

            // Prefer the CMAP encoding to the CFF encoding.
            font.encoding =
              font.encoding || font.cffEncoding;

            font.glyphs = new glyphset.GlyphSet(
              font
            );
            for (
              var i = 0;
              i < font.nGlyphs;
              i += 1
            ) {
              var charString =
                charStringsIndex.objects[i];
              font.glyphs.push(
                i,
                glyphset.cffGlyphLoader(
                  font,
                  i,
                  parseCFFCharstring,
                  charString
                )
              );
            }
          }

          // Convert a string to a String ID (SID).
          // The list of strings is modified in place.
          function encodeString(s, strings) {
            var sid;

            // Is the string in the CFF standard strings?
            var i = cffStandardStrings.indexOf(s);
            if (i >= 0) {
              sid = i;
            }

            // Is the string already in the string index?
            i = strings.indexOf(s);
            if (i >= 0) {
              sid = i + cffStandardStrings.length;
            } else {
              sid =
                cffStandardStrings.length +
                strings.length;
              strings.push(s);
            }

            return sid;
          }

          function makeHeader() {
            return new table.Record("Header", [
              {
                name: "major",
                type: "Card8",
                value: 1,
              },
              {
                name: "minor",
                type: "Card8",
                value: 0,
              },
              {
                name: "hdrSize",
                type: "Card8",
                value: 4,
              },
              {
                name: "major",
                type: "Card8",
                value: 1,
              },
            ]);
          }

          function makeNameIndex(fontNames) {
            var t = new table.Record(
              "Name INDEX",
              [
                {
                  name: "names",
                  type: "INDEX",
                  value: [],
                },
              ]
            );
            t.names = [];
            for (
              var i = 0;
              i < fontNames.length;
              i += 1
            ) {
              t.names.push({
                name: "name_" + i,
                type: "NAME",
                value: fontNames[i],
              });
            }

            return t;
          }

          // Given a dictionary's metadata, create a DICT structure.
          function makeDict(
            meta,
            attrs,
            strings
          ) {
            var m = {};
            for (
              var i = 0;
              i < meta.length;
              i += 1
            ) {
              var entry = meta[i];
              var value = attrs[entry.name];
              if (
                value !== undefined &&
                !equals(value, entry.value)
              ) {
                if (entry.type === "SID") {
                  value = encodeString(
                    value,
                    strings
                  );
                }

                m[entry.op] = {
                  name: entry.name,
                  type: entry.type,
                  value: value,
                };
              }
            }

            return m;
          }

          // The Top DICT houses the global font attributes.
          function makeTopDict(attrs, strings) {
            var t = new table.Record("Top DICT", [
              {
                name: "dict",
                type: "DICT",
                value: {},
              },
            ]);
            t.dict = makeDict(
              TOP_DICT_META,
              attrs,
              strings
            );
            return t;
          }

          function makeTopDictIndex(topDict) {
            var t = new table.Record(
              "Top DICT INDEX",
              [
                {
                  name: "topDicts",
                  type: "INDEX",
                  value: [],
                },
              ]
            );
            t.topDicts = [
              {
                name: "topDict_0",
                type: "TABLE",
                value: topDict,
              },
            ];
            return t;
          }

          function makeStringIndex(strings) {
            var t = new table.Record(
              "String INDEX",
              [
                {
                  name: "strings",
                  type: "INDEX",
                  value: [],
                },
              ]
            );
            t.strings = [];
            for (
              var i = 0;
              i < strings.length;
              i += 1
            ) {
              t.strings.push({
                name: "string_" + i,
                type: "STRING",
                value: strings[i],
              });
            }

            return t;
          }

          function makeGlobalSubrIndex() {
            // Currently we don't use subroutines.
            return new table.Record(
              "Global Subr INDEX",
              [
                {
                  name: "subrs",
                  type: "INDEX",
                  value: [],
                },
              ]
            );
          }

          function makeCharsets(
            glyphNames,
            strings
          ) {
            var t = new table.Record("Charsets", [
              {
                name: "format",
                type: "Card8",
                value: 0,
              },
            ]);
            for (
              var i = 0;
              i < glyphNames.length;
              i += 1
            ) {
              var glyphName = glyphNames[i];
              var glyphSID = encodeString(
                glyphName,
                strings
              );
              t.fields.push({
                name: "glyph_" + i,
                type: "SID",
                value: glyphSID,
              });
            }

            return t;
          }

          function glyphToOps(glyph) {
            var ops = [];
            var path = glyph.path;
            ops.push({
              name: "width",
              type: "NUMBER",
              value: glyph.advanceWidth,
            });
            var x = 0;
            var y = 0;
            for (
              var i = 0;
              i < path.commands.length;
              i += 1
            ) {
              var dx = void 0;
              var dy = void 0;
              var cmd = path.commands[i];
              if (cmd.type === "Q") {
                // CFF only supports bézier curves, so convert the quad to a bézier.
                var _13 = 1 / 3;
                var _23 = 2 / 3;

                // We're going to create a new command so we don't change the original path.
                cmd = {
                  type: "C",
                  x: cmd.x,
                  y: cmd.y,
                  x1: _13 * x + _23 * cmd.x1,
                  y1: _13 * y + _23 * cmd.y1,
                  x2: _13 * cmd.x + _23 * cmd.x1,
                  y2: _13 * cmd.y + _23 * cmd.y1,
                };
              }

              if (cmd.type === "M") {
                dx = Math.round(cmd.x - x);
                dy = Math.round(cmd.y - y);
                ops.push({
                  name: "dx",
                  type: "NUMBER",
                  value: dx,
                });
                ops.push({
                  name: "dy",
                  type: "NUMBER",
                  value: dy,
                });
                ops.push({
                  name: "rmoveto",
                  type: "OP",
                  value: 21,
                });
                x = Math.round(cmd.x);
                y = Math.round(cmd.y);
              } else if (cmd.type === "L") {
                dx = Math.round(cmd.x - x);
                dy = Math.round(cmd.y - y);
                ops.push({
                  name: "dx",
                  type: "NUMBER",
                  value: dx,
                });
                ops.push({
                  name: "dy",
                  type: "NUMBER",
                  value: dy,
                });
                ops.push({
                  name: "rlineto",
                  type: "OP",
                  value: 5,
                });
                x = Math.round(cmd.x);
                y = Math.round(cmd.y);
              } else if (cmd.type === "C") {
                var dx1 = Math.round(cmd.x1 - x);
                var dy1 = Math.round(cmd.y1 - y);
                var dx2 = Math.round(
                  cmd.x2 - cmd.x1
                );
                var dy2 = Math.round(
                  cmd.y2 - cmd.y1
                );
                dx = Math.round(cmd.x - cmd.x2);
                dy = Math.round(cmd.y - cmd.y2);
                ops.push({
                  name: "dx1",
                  type: "NUMBER",
                  value: dx1,
                });
                ops.push({
                  name: "dy1",
                  type: "NUMBER",
                  value: dy1,
                });
                ops.push({
                  name: "dx2",
                  type: "NUMBER",
                  value: dx2,
                });
                ops.push({
                  name: "dy2",
                  type: "NUMBER",
                  value: dy2,
                });
                ops.push({
                  name: "dx",
                  type: "NUMBER",
                  value: dx,
                });
                ops.push({
                  name: "dy",
                  type: "NUMBER",
                  value: dy,
                });
                ops.push({
                  name: "rrcurveto",
                  type: "OP",
                  value: 8,
                });
                x = Math.round(cmd.x);
                y = Math.round(cmd.y);
              }

              // Contours are closed automatically.
            }

            ops.push({
              name: "endchar",
              type: "OP",
              value: 14,
            });
            return ops;
          }

          function makeCharStringsIndex(glyphs) {
            var t = new table.Record(
              "CharStrings INDEX",
              [
                {
                  name: "charStrings",
                  type: "INDEX",
                  value: [],
                },
              ]
            );

            for (
              var i = 0;
              i < glyphs.length;
              i += 1
            ) {
              var glyph = glyphs.get(i);
              var ops = glyphToOps(glyph);
              t.charStrings.push({
                name: glyph.name,
                type: "CHARSTRING",
                value: ops,
              });
            }

            return t;
          }

          function makePrivateDict(
            attrs,
            strings
          ) {
            var t = new table.Record(
              "Private DICT",
              [
                {
                  name: "dict",
                  type: "DICT",
                  value: {},
                },
              ]
            );
            t.dict = makeDict(
              PRIVATE_DICT_META,
              attrs,
              strings
            );
            return t;
          }

          function makeCFFTable(glyphs, options) {
            var t = new table.Table("CFF ", [
              { name: "header", type: "RECORD" },
              {
                name: "nameIndex",
                type: "RECORD",
              },
              {
                name: "topDictIndex",
                type: "RECORD",
              },
              {
                name: "stringIndex",
                type: "RECORD",
              },
              {
                name: "globalSubrIndex",
                type: "RECORD",
              },
              {
                name: "charsets",
                type: "RECORD",
              },
              {
                name: "charStringsIndex",
                type: "RECORD",
              },
              {
                name: "privateDict",
                type: "RECORD",
              },
            ]);

            var fontScale =
              1 / options.unitsPerEm;
            // We use non-zero values for the offsets so that the DICT encodes them.
            // This is important because the size of the Top DICT plays a role in offset calculation,
            // and the size shouldn't change after we've written correct offsets.
            var attrs = {
              version: options.version,
              fullName: options.fullName,
              familyName: options.familyName,
              weight: options.weightName,
              fontBBox: options.fontBBox || [
                0, 0, 0, 0,
              ],
              fontMatrix: [
                fontScale,
                0,
                0,
                fontScale,
                0,
                0,
              ],
              charset: 999,
              encoding: 0,
              charStrings: 999,
              private: [0, 999],
            };

            var privateAttrs = {};

            var glyphNames = [];
            var glyph;

            // Skip first glyph (.notdef)
            for (
              var i = 1;
              i < glyphs.length;
              i += 1
            ) {
              glyph = glyphs.get(i);
              glyphNames.push(glyph.name);
            }

            var strings = [];

            t.header = makeHeader();
            t.nameIndex = makeNameIndex([
              options.postScriptName,
            ]);
            var topDict = makeTopDict(
              attrs,
              strings
            );
            t.topDictIndex =
              makeTopDictIndex(topDict);
            t.globalSubrIndex =
              makeGlobalSubrIndex();
            t.charsets = makeCharsets(
              glyphNames,
              strings
            );
            t.charStringsIndex =
              makeCharStringsIndex(glyphs);
            t.privateDict = makePrivateDict(
              privateAttrs,
              strings
            );

            // Needs to come at the end, to encode all custom strings used in the font.
            t.stringIndex =
              makeStringIndex(strings);

            var startOffset =
              t.header.sizeOf() +
              t.nameIndex.sizeOf() +
              t.topDictIndex.sizeOf() +
              t.stringIndex.sizeOf() +
              t.globalSubrIndex.sizeOf();
            attrs.charset = startOffset;

            // We use the CFF standard encoding; proper encoding will be handled in cmap.
            attrs.encoding = 0;
            attrs.charStrings =
              attrs.charset + t.charsets.sizeOf();
            attrs.private[1] =
              attrs.charStrings +
              t.charStringsIndex.sizeOf();

            // Recreate the Top DICT INDEX with the correct offsets.
            topDict = makeTopDict(attrs, strings);
            t.topDictIndex =
              makeTopDictIndex(topDict);

            return t;
          }

          var cff = {
            parse: parseCFFTable,
            make: makeCFFTable,
          };

          // The `head` table contains global information about the font.

          // Parse the header `head` table
          function parseHeadTable(data, start) {
            var head = {};
            var p = new parse.Parser(data, start);
            head.version = p.parseVersion();
            head.fontRevision =
              Math.round(p.parseFixed() * 1000) /
              1000;
            head.checkSumAdjustment =
              p.parseULong();
            head.magicNumber = p.parseULong();
            check.argument(
              head.magicNumber === 0x5f0f3cf5,
              "Font header has wrong magic number."
            );
            head.flags = p.parseUShort();
            head.unitsPerEm = p.parseUShort();
            head.created = p.parseLongDateTime();
            head.modified = p.parseLongDateTime();
            head.xMin = p.parseShort();
            head.yMin = p.parseShort();
            head.xMax = p.parseShort();
            head.yMax = p.parseShort();
            head.macStyle = p.parseUShort();
            head.lowestRecPPEM = p.parseUShort();
            head.fontDirectionHint =
              p.parseShort();
            head.indexToLocFormat =
              p.parseShort();
            head.glyphDataFormat = p.parseShort();
            return head;
          }

          function makeHeadTable(options) {
            // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
            var timestamp =
              Math.round(
                new Date().getTime() / 1000
              ) + 2082844800;
            var createdTimestamp = timestamp;

            if (options.createdTimestamp) {
              createdTimestamp =
                options.createdTimestamp +
                2082844800;
            }

            return new table.Table(
              "head",
              [
                {
                  name: "version",
                  type: "FIXED",
                  value: 0x00010000,
                },
                {
                  name: "fontRevision",
                  type: "FIXED",
                  value: 0x00010000,
                },
                {
                  name: "checkSumAdjustment",
                  type: "ULONG",
                  value: 0,
                },
                {
                  name: "magicNumber",
                  type: "ULONG",
                  value: 0x5f0f3cf5,
                },
                {
                  name: "flags",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "unitsPerEm",
                  type: "USHORT",
                  value: 1000,
                },
                {
                  name: "created",
                  type: "LONGDATETIME",
                  value: createdTimestamp,
                },
                {
                  name: "modified",
                  type: "LONGDATETIME",
                  value: timestamp,
                },
                {
                  name: "xMin",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "yMin",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "xMax",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "yMax",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "macStyle",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "lowestRecPPEM",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "fontDirectionHint",
                  type: "SHORT",
                  value: 2,
                },
                {
                  name: "indexToLocFormat",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "glyphDataFormat",
                  type: "SHORT",
                  value: 0,
                },
              ],
              options
            );
          }

          var head = {
            parse: parseHeadTable,
            make: makeHeadTable,
          };

          // The `hhea` table contains information for horizontal layout.

          // Parse the horizontal header `hhea` table
          function parseHheaTable(data, start) {
            var hhea = {};
            var p = new parse.Parser(data, start);
            hhea.version = p.parseVersion();
            hhea.ascender = p.parseShort();
            hhea.descender = p.parseShort();
            hhea.lineGap = p.parseShort();
            hhea.advanceWidthMax =
              p.parseUShort();
            hhea.minLeftSideBearing =
              p.parseShort();
            hhea.minRightSideBearing =
              p.parseShort();
            hhea.xMaxExtent = p.parseShort();
            hhea.caretSlopeRise = p.parseShort();
            hhea.caretSlopeRun = p.parseShort();
            hhea.caretOffset = p.parseShort();
            p.relativeOffset += 8;
            hhea.metricDataFormat =
              p.parseShort();
            hhea.numberOfHMetrics =
              p.parseUShort();
            return hhea;
          }

          function makeHheaTable(options) {
            return new table.Table(
              "hhea",
              [
                {
                  name: "version",
                  type: "FIXED",
                  value: 0x00010000,
                },
                {
                  name: "ascender",
                  type: "FWORD",
                  value: 0,
                },
                {
                  name: "descender",
                  type: "FWORD",
                  value: 0,
                },
                {
                  name: "lineGap",
                  type: "FWORD",
                  value: 0,
                },
                {
                  name: "advanceWidthMax",
                  type: "UFWORD",
                  value: 0,
                },
                {
                  name: "minLeftSideBearing",
                  type: "FWORD",
                  value: 0,
                },
                {
                  name: "minRightSideBearing",
                  type: "FWORD",
                  value: 0,
                },
                {
                  name: "xMaxExtent",
                  type: "FWORD",
                  value: 0,
                },
                {
                  name: "caretSlopeRise",
                  type: "SHORT",
                  value: 1,
                },
                {
                  name: "caretSlopeRun",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "caretOffset",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "reserved1",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "reserved2",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "reserved3",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "reserved4",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "metricDataFormat",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "numberOfHMetrics",
                  type: "USHORT",
                  value: 0,
                },
              ],
              options
            );
          }

          var hhea = {
            parse: parseHheaTable,
            make: makeHheaTable,
          };

          // The `hmtx` table contains the horizontal metrics for all glyphs.

          // Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
          // This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
          function parseHmtxTable(
            data,
            start,
            numMetrics,
            numGlyphs,
            glyphs
          ) {
            var advanceWidth;
            var leftSideBearing;
            var p = new parse.Parser(data, start);
            for (
              var i = 0;
              i < numGlyphs;
              i += 1
            ) {
              // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
              if (i < numMetrics) {
                advanceWidth = p.parseUShort();
                leftSideBearing = p.parseShort();
              }

              var glyph = glyphs.get(i);
              glyph.advanceWidth = advanceWidth;
              glyph.leftSideBearing =
                leftSideBearing;
            }
          }

          function makeHmtxTable(glyphs) {
            var t = new table.Table("hmtx", []);
            for (
              var i = 0;
              i < glyphs.length;
              i += 1
            ) {
              var glyph = glyphs.get(i);
              var advanceWidth =
                glyph.advanceWidth || 0;
              var leftSideBearing =
                glyph.leftSideBearing || 0;
              t.fields.push({
                name: "advanceWidth_" + i,
                type: "USHORT",
                value: advanceWidth,
              });
              t.fields.push({
                name: "leftSideBearing_" + i,
                type: "SHORT",
                value: leftSideBearing,
              });
            }

            return t;
          }

          var hmtx = {
            parse: parseHmtxTable,
            make: makeHmtxTable,
          };

          // The `ltag` table stores IETF BCP-47 language tags. It allows supporting

          function makeLtagTable(tags) {
            var result = new table.Table("ltag", [
              {
                name: "version",
                type: "ULONG",
                value: 1,
              },
              {
                name: "flags",
                type: "ULONG",
                value: 0,
              },
              {
                name: "numTags",
                type: "ULONG",
                value: tags.length,
              },
            ]);

            var stringPool = "";
            var stringPoolOffset =
              12 + tags.length * 4;
            for (
              var i = 0;
              i < tags.length;
              ++i
            ) {
              var pos = stringPool.indexOf(
                tags[i]
              );
              if (pos < 0) {
                pos = stringPool.length;
                stringPool += tags[i];
              }

              result.fields.push({
                name: "offset " + i,
                type: "USHORT",
                value: stringPoolOffset + pos,
              });
              result.fields.push({
                name: "length " + i,
                type: "USHORT",
                value: tags[i].length,
              });
            }

            result.fields.push({
              name: "stringPool",
              type: "CHARARRAY",
              value: stringPool,
            });
            return result;
          }

          function parseLtagTable(data, start) {
            var p = new parse.Parser(data, start);
            var tableVersion = p.parseULong();
            check.argument(
              tableVersion === 1,
              "Unsupported ltag table version."
            );
            // The 'ltag' specification does not define any flags; skip the field.
            p.skip("uLong", 1);
            var numTags = p.parseULong();

            var tags = [];
            for (var i = 0; i < numTags; i++) {
              var tag = "";
              var offset =
                start + p.parseUShort();
              var length = p.parseUShort();
              for (
                var j = offset;
                j < offset + length;
                ++j
              ) {
                tag += String.fromCharCode(
                  data.getInt8(j)
                );
              }

              tags.push(tag);
            }

            return tags;
          }

          var ltag = {
            make: makeLtagTable,
            parse: parseLtagTable,
          };

          // The `maxp` table establishes the memory requirements for the font.

          // Parse the maximum profile `maxp` table.
          function parseMaxpTable(data, start) {
            var maxp = {};
            var p = new parse.Parser(data, start);
            maxp.version = p.parseVersion();
            maxp.numGlyphs = p.parseUShort();
            if (maxp.version === 1.0) {
              maxp.maxPoints = p.parseUShort();
              maxp.maxContours = p.parseUShort();
              maxp.maxCompositePoints =
                p.parseUShort();
              maxp.maxCompositeContours =
                p.parseUShort();
              maxp.maxZones = p.parseUShort();
              maxp.maxTwilightPoints =
                p.parseUShort();
              maxp.maxStorage = p.parseUShort();
              maxp.maxFunctionDefs =
                p.parseUShort();
              maxp.maxInstructionDefs =
                p.parseUShort();
              maxp.maxStackElements =
                p.parseUShort();
              maxp.maxSizeOfInstructions =
                p.parseUShort();
              maxp.maxComponentElements =
                p.parseUShort();
              maxp.maxComponentDepth =
                p.parseUShort();
            }

            return maxp;
          }

          function makeMaxpTable(numGlyphs) {
            return new table.Table("maxp", [
              {
                name: "version",
                type: "FIXED",
                value: 0x00005000,
              },
              {
                name: "numGlyphs",
                type: "USHORT",
                value: numGlyphs,
              },
            ]);
          }

          var maxp = {
            parse: parseMaxpTable,
            make: makeMaxpTable,
          };

          // The `name` naming table.

          // NameIDs for the name table.
          var nameTableNames = [
            "copyright", // 0
            "fontFamily", // 1
            "fontSubfamily", // 2
            "uniqueID", // 3
            "fullName", // 4
            "version", // 5
            "postScriptName", // 6
            "trademark", // 7
            "manufacturer", // 8
            "designer", // 9
            "description", // 10
            "manufacturerURL", // 11
            "designerURL", // 12
            "license", // 13
            "licenseURL", // 14
            "reserved", // 15
            "preferredFamily", // 16
            "preferredSubfamily", // 17
            "compatibleFullName", // 18
            "sampleText", // 19
            "postScriptFindFontName", // 20
            "wwsFamily", // 21
            "wwsSubfamily", // 22
          ];

          var macLanguages = {
            0: "en",
            1: "fr",
            2: "de",
            3: "it",
            4: "nl",
            5: "sv",
            6: "es",
            7: "da",
            8: "pt",
            9: "no",
            10: "he",
            11: "ja",
            12: "ar",
            13: "fi",
            14: "el",
            15: "is",
            16: "mt",
            17: "tr",
            18: "hr",
            19: "zh-Hant",
            20: "ur",
            21: "hi",
            22: "th",
            23: "ko",
            24: "lt",
            25: "pl",
            26: "hu",
            27: "es",
            28: "lv",
            29: "se",
            30: "fo",
            31: "fa",
            32: "ru",
            33: "zh",
            34: "nl-BE",
            35: "ga",
            36: "sq",
            37: "ro",
            38: "cz",
            39: "sk",
            40: "si",
            41: "yi",
            42: "sr",
            43: "mk",
            44: "bg",
            45: "uk",
            46: "be",
            47: "uz",
            48: "kk",
            49: "az-Cyrl",
            50: "az-Arab",
            51: "hy",
            52: "ka",
            53: "mo",
            54: "ky",
            55: "tg",
            56: "tk",
            57: "mn-CN",
            58: "mn",
            59: "ps",
            60: "ks",
            61: "ku",
            62: "sd",
            63: "bo",
            64: "ne",
            65: "sa",
            66: "mr",
            67: "bn",
            68: "as",
            69: "gu",
            70: "pa",
            71: "or",
            72: "ml",
            73: "kn",
            74: "ta",
            75: "te",
            76: "si",
            77: "my",
            78: "km",
            79: "lo",
            80: "vi",
            81: "id",
            82: "tl",
            83: "ms",
            84: "ms-Arab",
            85: "am",
            86: "ti",
            87: "om",
            88: "so",
            89: "sw",
            90: "rw",
            91: "rn",
            92: "ny",
            93: "mg",
            94: "eo",
            128: "cy",
            129: "eu",
            130: "ca",
            131: "la",
            132: "qu",
            133: "gn",
            134: "ay",
            135: "tt",
            136: "ug",
            137: "dz",
            138: "jv",
            139: "su",
            140: "gl",
            141: "af",
            142: "br",
            143: "iu",
            144: "gd",
            145: "gv",
            146: "ga",
            147: "to",
            148: "el-polyton",
            149: "kl",
            150: "az",
            151: "nn",
          };

          // MacOS language ID → MacOS script ID
          //
          // Note that the script ID is not sufficient to determine what encoding
          // to use in TrueType files. For some languages, MacOS used a modification
          // of a mainstream script. For example, an Icelandic name would be stored
          // with smRoman in the TrueType naming table, but the actual encoding
          // is a special Icelandic version of the normal Macintosh Roman encoding.
          // As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
          // Syllables but MacOS had run out of available script codes, so this was
          // done as a (pretty radical) "modification" of Ethiopic.
          //
          // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
          var macLanguageToScript = {
            0: 0, // langEnglish → smRoman
            1: 0, // langFrench → smRoman
            2: 0, // langGerman → smRoman
            3: 0, // langItalian → smRoman
            4: 0, // langDutch → smRoman
            5: 0, // langSwedish → smRoman
            6: 0, // langSpanish → smRoman
            7: 0, // langDanish → smRoman
            8: 0, // langPortuguese → smRoman
            9: 0, // langNorwegian → smRoman
            10: 5, // langHebrew → smHebrew
            11: 1, // langJapanese → smJapanese
            12: 4, // langArabic → smArabic
            13: 0, // langFinnish → smRoman
            14: 6, // langGreek → smGreek
            15: 0, // langIcelandic → smRoman (modified)
            16: 0, // langMaltese → smRoman
            17: 0, // langTurkish → smRoman (modified)
            18: 0, // langCroatian → smRoman (modified)
            19: 2, // langTradChinese → smTradChinese
            20: 4, // langUrdu → smArabic
            21: 9, // langHindi → smDevanagari
            22: 21, // langThai → smThai
            23: 3, // langKorean → smKorean
            24: 29, // langLithuanian → smCentralEuroRoman
            25: 29, // langPolish → smCentralEuroRoman
            26: 29, // langHungarian → smCentralEuroRoman
            27: 29, // langEstonian → smCentralEuroRoman
            28: 29, // langLatvian → smCentralEuroRoman
            29: 0, // langSami → smRoman
            30: 0, // langFaroese → smRoman (modified)
            31: 4, // langFarsi → smArabic (modified)
            32: 7, // langRussian → smCyrillic
            33: 25, // langSimpChinese → smSimpChinese
            34: 0, // langFlemish → smRoman
            35: 0, // langIrishGaelic → smRoman (modified)
            36: 0, // langAlbanian → smRoman
            37: 0, // langRomanian → smRoman (modified)
            38: 29, // langCzech → smCentralEuroRoman
            39: 29, // langSlovak → smCentralEuroRoman
            40: 0, // langSlovenian → smRoman (modified)
            41: 5, // langYiddish → smHebrew
            42: 7, // langSerbian → smCyrillic
            43: 7, // langMacedonian → smCyrillic
            44: 7, // langBulgarian → smCyrillic
            45: 7, // langUkrainian → smCyrillic (modified)
            46: 7, // langByelorussian → smCyrillic
            47: 7, // langUzbek → smCyrillic
            48: 7, // langKazakh → smCyrillic
            49: 7, // langAzerbaijani → smCyrillic
            50: 4, // langAzerbaijanAr → smArabic
            51: 24, // langArmenian → smArmenian
            52: 23, // langGeorgian → smGeorgian
            53: 7, // langMoldavian → smCyrillic
            54: 7, // langKirghiz → smCyrillic
            55: 7, // langTajiki → smCyrillic
            56: 7, // langTurkmen → smCyrillic
            57: 27, // langMongolian → smMongolian
            58: 7, // langMongolianCyr → smCyrillic
            59: 4, // langPashto → smArabic
            60: 4, // langKurdish → smArabic
            61: 4, // langKashmiri → smArabic
            62: 4, // langSindhi → smArabic
            63: 26, // langTibetan → smTibetan
            64: 9, // langNepali → smDevanagari
            65: 9, // langSanskrit → smDevanagari
            66: 9, // langMarathi → smDevanagari
            67: 13, // langBengali → smBengali
            68: 13, // langAssamese → smBengali
            69: 11, // langGujarati → smGujarati
            70: 10, // langPunjabi → smGurmukhi
            71: 12, // langOriya → smOriya
            72: 17, // langMalayalam → smMalayalam
            73: 16, // langKannada → smKannada
            74: 14, // langTamil → smTamil
            75: 15, // langTelugu → smTelugu
            76: 18, // langSinhalese → smSinhalese
            77: 19, // langBurmese → smBurmese
            78: 20, // langKhmer → smKhmer
            79: 22, // langLao → smLao
            80: 30, // langVietnamese → smVietnamese
            81: 0, // langIndonesian → smRoman
            82: 0, // langTagalog → smRoman
            83: 0, // langMalayRoman → smRoman
            84: 4, // langMalayArabic → smArabic
            85: 28, // langAmharic → smEthiopic
            86: 28, // langTigrinya → smEthiopic
            87: 28, // langOromo → smEthiopic
            88: 0, // langSomali → smRoman
            89: 0, // langSwahili → smRoman
            90: 0, // langKinyarwanda → smRoman
            91: 0, // langRundi → smRoman
            92: 0, // langNyanja → smRoman
            93: 0, // langMalagasy → smRoman
            94: 0, // langEsperanto → smRoman
            128: 0, // langWelsh → smRoman (modified)
            129: 0, // langBasque → smRoman
            130: 0, // langCatalan → smRoman
            131: 0, // langLatin → smRoman
            132: 0, // langQuechua → smRoman
            133: 0, // langGuarani → smRoman
            134: 0, // langAymara → smRoman
            135: 7, // langTatar → smCyrillic
            136: 4, // langUighur → smArabic
            137: 26, // langDzongkha → smTibetan
            138: 0, // langJavaneseRom → smRoman
            139: 0, // langSundaneseRom → smRoman
            140: 0, // langGalician → smRoman
            141: 0, // langAfrikaans → smRoman
            142: 0, // langBreton → smRoman (modified)
            143: 28, // langInuktitut → smEthiopic (modified)
            144: 0, // langScottishGaelic → smRoman (modified)
            145: 0, // langManxGaelic → smRoman (modified)
            146: 0, // langIrishGaelicScript → smRoman (modified)
            147: 0, // langTongan → smRoman
            148: 6, // langGreekAncient → smRoman
            149: 0, // langGreenlandic → smRoman
            150: 0, // langAzerbaijanRoman → smRoman
            151: 0, // langNynorsk → smRoman
          };

          // While Microsoft indicates a region/country for all its language
          // IDs, we omit the region code if it's equal to the "most likely
          // region subtag" according to Unicode CLDR. For scripts, we omit
          // the subtag if it is equal to the Suppress-Script entry in the
          // IANA language subtag registry for IETF BCP 47.
          //
          // For example, Microsoft states that its language code 0x041A is
          // Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
          // and not 'hr-HR' because Croatia is the default country for Croatian,
          // according to Unicode CLDR. As another example, Microsoft states
          // that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
          // this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
          // for the Croatian language, according to IANA.
          //
          // http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
          // http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
          var windowsLanguages = {
            0x0436: "af",
            0x041c: "sq",
            0x0484: "gsw",
            0x045e: "am",
            0x1401: "ar-DZ",
            0x3c01: "ar-BH",
            0x0c01: "ar",
            0x0801: "ar-IQ",
            0x2c01: "ar-JO",
            0x3401: "ar-KW",
            0x3001: "ar-LB",
            0x1001: "ar-LY",
            0x1801: "ary",
            0x2001: "ar-OM",
            0x4001: "ar-QA",
            0x0401: "ar-SA",
            0x2801: "ar-SY",
            0x1c01: "aeb",
            0x3801: "ar-AE",
            0x2401: "ar-YE",
            0x042b: "hy",
            0x044d: "as",
            0x082c: "az-Cyrl",
            0x042c: "az",
            0x046d: "ba",
            0x042d: "eu",
            0x0423: "be",
            0x0845: "bn",
            0x0445: "bn-IN",
            0x201a: "bs-Cyrl",
            0x141a: "bs",
            0x047e: "br",
            0x0402: "bg",
            0x0403: "ca",
            0x0c04: "zh-HK",
            0x1404: "zh-MO",
            0x0804: "zh",
            0x1004: "zh-SG",
            0x0404: "zh-TW",
            0x0483: "co",
            0x041a: "hr",
            0x101a: "hr-BA",
            0x0405: "cs",
            0x0406: "da",
            0x048c: "prs",
            0x0465: "dv",
            0x0813: "nl-BE",
            0x0413: "nl",
            0x0c09: "en-AU",
            0x2809: "en-BZ",
            0x1009: "en-CA",
            0x2409: "en-029",
            0x4009: "en-IN",
            0x1809: "en-IE",
            0x2009: "en-JM",
            0x4409: "en-MY",
            0x1409: "en-NZ",
            0x3409: "en-PH",
            0x4809: "en-SG",
            0x1c09: "en-ZA",
            0x2c09: "en-TT",
            0x0809: "en-GB",
            0x0409: "en",
            0x3009: "en-ZW",
            0x0425: "et",
            0x0438: "fo",
            0x0464: "fil",
            0x040b: "fi",
            0x080c: "fr-BE",
            0x0c0c: "fr-CA",
            0x040c: "fr",
            0x140c: "fr-LU",
            0x180c: "fr-MC",
            0x100c: "fr-CH",
            0x0462: "fy",
            0x0456: "gl",
            0x0437: "ka",
            0x0c07: "de-AT",
            0x0407: "de",
            0x1407: "de-LI",
            0x1007: "de-LU",
            0x0807: "de-CH",
            0x0408: "el",
            0x046f: "kl",
            0x0447: "gu",
            0x0468: "ha",
            0x040d: "he",
            0x0439: "hi",
            0x040e: "hu",
            0x040f: "is",
            0x0470: "ig",
            0x0421: "id",
            0x045d: "iu",
            0x085d: "iu-Latn",
            0x083c: "ga",
            0x0434: "xh",
            0x0435: "zu",
            0x0410: "it",
            0x0810: "it-CH",
            0x0411: "ja",
            0x044b: "kn",
            0x043f: "kk",
            0x0453: "km",
            0x0486: "quc",
            0x0487: "rw",
            0x0441: "sw",
            0x0457: "kok",
            0x0412: "ko",
            0x0440: "ky",
            0x0454: "lo",
            0x0426: "lv",
            0x0427: "lt",
            0x082e: "dsb",
            0x046e: "lb",
            0x042f: "mk",
            0x083e: "ms-BN",
            0x043e: "ms",
            0x044c: "ml",
            0x043a: "mt",
            0x0481: "mi",
            0x047a: "arn",
            0x044e: "mr",
            0x047c: "moh",
            0x0450: "mn",
            0x0850: "mn-CN",
            0x0461: "ne",
            0x0414: "nb",
            0x0814: "nn",
            0x0482: "oc",
            0x0448: "or",
            0x0463: "ps",
            0x0415: "pl",
            0x0416: "pt",
            0x0816: "pt-PT",
            0x0446: "pa",
            0x046b: "qu-BO",
            0x086b: "qu-EC",
            0x0c6b: "qu",
            0x0418: "ro",
            0x0417: "rm",
            0x0419: "ru",
            0x243b: "smn",
            0x103b: "smj-NO",
            0x143b: "smj",
            0x0c3b: "se-FI",
            0x043b: "se",
            0x083b: "se-SE",
            0x203b: "sms",
            0x183b: "sma-NO",
            0x1c3b: "sms",
            0x044f: "sa",
            0x1c1a: "sr-Cyrl-BA",
            0x0c1a: "sr",
            0x181a: "sr-Latn-BA",
            0x081a: "sr-Latn",
            0x046c: "nso",
            0x0432: "tn",
            0x045b: "si",
            0x041b: "sk",
            0x0424: "sl",
            0x2c0a: "es-AR",
            0x400a: "es-BO",
            0x340a: "es-CL",
            0x240a: "es-CO",
            0x140a: "es-CR",
            0x1c0a: "es-DO",
            0x300a: "es-EC",
            0x440a: "es-SV",
            0x100a: "es-GT",
            0x480a: "es-HN",
            0x080a: "es-MX",
            0x4c0a: "es-NI",
            0x180a: "es-PA",
            0x3c0a: "es-PY",
            0x280a: "es-PE",
            0x500a: "es-PR",

            // Microsoft has defined two different language codes for
            // “Spanish with modern sorting” and “Spanish with traditional
            // sorting”. This makes sense for collation APIs, and it would be
            // possible to express this in BCP 47 language tags via Unicode
            // extensions (eg., es-u-co-trad is Spanish with traditional
            // sorting). However, for storing names in fonts, the distinction
            // does not make sense, so we give “es” in both cases.
            0x0c0a: "es",
            0x040a: "es",

            0x540a: "es-US",
            0x380a: "es-UY",
            0x200a: "es-VE",
            0x081d: "sv-FI",
            0x041d: "sv",
            0x045a: "syr",
            0x0428: "tg",
            0x085f: "tzm",
            0x0449: "ta",
            0x0444: "tt",
            0x044a: "te",
            0x041e: "th",
            0x0451: "bo",
            0x041f: "tr",
            0x0442: "tk",
            0x0480: "ug",
            0x0422: "uk",
            0x042e: "hsb",
            0x0420: "ur",
            0x0843: "uz-Cyrl",
            0x0443: "uz",
            0x042a: "vi",
            0x0452: "cy",
            0x0488: "wo",
            0x0485: "sah",
            0x0478: "ii",
            0x046a: "yo",
          };

          // Returns a IETF BCP 47 language code, for example 'zh-Hant'
          // for 'Chinese in the traditional script'.
          function getLanguageCode(
            platformID,
            languageID,
            ltag
          ) {
            switch (platformID) {
              case 0: // Unicode
                if (languageID === 0xffff) {
                  return "und";
                } else if (ltag) {
                  return ltag[languageID];
                }

                break;

              case 1: // Macintosh
                return macLanguages[languageID];

              case 3: // Windows
                return windowsLanguages[
                  languageID
                ];
            }

            return undefined;
          }

          var utf16 = "utf-16";

          // MacOS script ID → encoding. This table stores the default case,
          // which can be overridden by macLanguageEncodings.
          var macScriptEncodings = {
            0: "macintosh", // smRoman
            1: "x-mac-japanese", // smJapanese
            2: "x-mac-chinesetrad", // smTradChinese
            3: "x-mac-korean", // smKorean
            6: "x-mac-greek", // smGreek
            7: "x-mac-cyrillic", // smCyrillic
            9: "x-mac-devanagai", // smDevanagari
            10: "x-mac-gurmukhi", // smGurmukhi
            11: "x-mac-gujarati", // smGujarati
            12: "x-mac-oriya", // smOriya
            13: "x-mac-bengali", // smBengali
            14: "x-mac-tamil", // smTamil
            15: "x-mac-telugu", // smTelugu
            16: "x-mac-kannada", // smKannada
            17: "x-mac-malayalam", // smMalayalam
            18: "x-mac-sinhalese", // smSinhalese
            19: "x-mac-burmese", // smBurmese
            20: "x-mac-khmer", // smKhmer
            21: "x-mac-thai", // smThai
            22: "x-mac-lao", // smLao
            23: "x-mac-georgian", // smGeorgian
            24: "x-mac-armenian", // smArmenian
            25: "x-mac-chinesesimp", // smSimpChinese
            26: "x-mac-tibetan", // smTibetan
            27: "x-mac-mongolian", // smMongolian
            28: "x-mac-ethiopic", // smEthiopic
            29: "x-mac-ce", // smCentralEuroRoman
            30: "x-mac-vietnamese", // smVietnamese
            31: "x-mac-extarabic", // smExtArabic
          };

          // MacOS language ID → encoding. This table stores the exceptional
          // cases, which override macScriptEncodings. For writing MacOS naming
          // tables, we need to emit a MacOS script ID. Therefore, we cannot
          // merge macScriptEncodings into macLanguageEncodings.
          //
          // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
          var macLanguageEncodings = {
            15: "x-mac-icelandic", // langIcelandic
            17: "x-mac-turkish", // langTurkish
            18: "x-mac-croatian", // langCroatian
            24: "x-mac-ce", // langLithuanian
            25: "x-mac-ce", // langPolish
            26: "x-mac-ce", // langHungarian
            27: "x-mac-ce", // langEstonian
            28: "x-mac-ce", // langLatvian
            30: "x-mac-icelandic", // langFaroese
            37: "x-mac-romanian", // langRomanian
            38: "x-mac-ce", // langCzech
            39: "x-mac-ce", // langSlovak
            40: "x-mac-ce", // langSlovenian
            143: "x-mac-inuit", // langInuktitut
            146: "x-mac-gaelic", // langIrishGaelicScript
          };

          function getEncoding(
            platformID,
            encodingID,
            languageID
          ) {
            switch (platformID) {
              case 0: // Unicode
                return utf16;

              case 1: // Apple Macintosh
                return (
                  macLanguageEncodings[
                    languageID
                  ] ||
                  macScriptEncodings[encodingID]
                );

              case 3: // Microsoft Windows
                if (
                  encodingID === 1 ||
                  encodingID === 10
                ) {
                  return utf16;
                }

                break;
            }

            return undefined;
          }

          // Parse the naming `name` table.
          // FIXME: Format 1 additional fields are not supported yet.
          // ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
          function parseNameTable(
            data,
            start,
            ltag
          ) {
            var name = {};
            var p = new parse.Parser(data, start);
            var format = p.parseUShort();
            var count = p.parseUShort();
            var stringOffset =
              p.offset + p.parseUShort();
            for (var i = 0; i < count; i++) {
              var platformID = p.parseUShort();
              var encodingID = p.parseUShort();
              var languageID = p.parseUShort();
              var nameID = p.parseUShort();
              var property =
                nameTableNames[nameID] || nameID;
              var byteLength = p.parseUShort();
              var offset = p.parseUShort();
              var language = getLanguageCode(
                platformID,
                languageID,
                ltag
              );
              var encoding = getEncoding(
                platformID,
                encodingID,
                languageID
              );
              if (
                encoding !== undefined &&
                language !== undefined
              ) {
                var text = void 0;
                if (encoding === utf16) {
                  text = decode.UTF16(
                    data,
                    stringOffset + offset,
                    byteLength
                  );
                } else {
                  text = decode.MACSTRING(
                    data,
                    stringOffset + offset,
                    byteLength,
                    encoding
                  );
                }

                if (text) {
                  var translations =
                    name[property];
                  if (
                    translations === undefined
                  ) {
                    translations = name[
                      property
                    ] = {};
                  }

                  translations[language] = text;
                }
              }
            }

            var langTagCount = 0;
            if (format === 1) {
              // FIXME: Also handle Microsoft's 'name' table 1.
              langTagCount = p.parseUShort();
            }

            return name;
          }

          // {23: 'foo'} → {'foo': 23}
          // ['bar', 'baz'] → {'bar': 0, 'baz': 1}
          function reverseDict(dict) {
            var result = {};
            for (var key in dict) {
              result[dict[key]] = parseInt(key);
            }

            return result;
          }

          function makeNameRecord(
            platformID,
            encodingID,
            languageID,
            nameID,
            length,
            offset
          ) {
            return new table.Record(
              "NameRecord",
              [
                {
                  name: "platformID",
                  type: "USHORT",
                  value: platformID,
                },
                {
                  name: "encodingID",
                  type: "USHORT",
                  value: encodingID,
                },
                {
                  name: "languageID",
                  type: "USHORT",
                  value: languageID,
                },
                {
                  name: "nameID",
                  type: "USHORT",
                  value: nameID,
                },
                {
                  name: "length",
                  type: "USHORT",
                  value: length,
                },
                {
                  name: "offset",
                  type: "USHORT",
                  value: offset,
                },
              ]
            );
          }

          // Finds the position of needle in haystack, or -1 if not there.
          // Like String.indexOf(), but for arrays.
          function findSubArray(
            needle,
            haystack
          ) {
            var needleLength = needle.length;
            var limit =
              haystack.length - needleLength + 1;

            loop: for (
              var pos = 0;
              pos < limit;
              pos++
            ) {
              for (; pos < limit; pos++) {
                for (
                  var k = 0;
                  k < needleLength;
                  k++
                ) {
                  if (
                    haystack[pos + k] !==
                    needle[k]
                  ) {
                    continue loop;
                  }
                }

                return pos;
              }
            }

            return -1;
          }

          function addStringToPool(s, pool) {
            var offset = findSubArray(s, pool);
            if (offset < 0) {
              offset = pool.length;
              var i = 0;
              var len = s.length;
              for (; i < len; ++i) {
                pool.push(s[i]);
              }
            }

            return offset;
          }

          function makeNameTable(names, ltag) {
            var nameID;
            var nameIDs = [];

            var namesWithNumericKeys = {};
            var nameTableIds = reverseDict(
              nameTableNames
            );
            for (var key in names) {
              var id = nameTableIds[key];
              if (id === undefined) {
                id = key;
              }

              nameID = parseInt(id);

              if (isNaN(nameID)) {
                throw new Error(
                  'Name table entry "' +
                    key +
                    '" does not exist, see nameTableNames for complete list.'
                );
              }

              namesWithNumericKeys[nameID] =
                names[key];
              nameIDs.push(nameID);
            }

            var macLanguageIds =
              reverseDict(macLanguages);
            var windowsLanguageIds = reverseDict(
              windowsLanguages
            );

            var nameRecords = [];
            var stringPool = [];

            for (
              var i = 0;
              i < nameIDs.length;
              i++
            ) {
              nameID = nameIDs[i];
              var translations =
                namesWithNumericKeys[nameID];
              for (var lang in translations) {
                var text = translations[lang];

                // For MacOS, we try to emit the name in the form that was introduced
                // in the initial version of the TrueType spec (in the late 1980s).
                // However, this can fail for various reasons: the requested BCP 47
                // language code might not have an old-style Mac equivalent;
                // we might not have a codec for the needed character encoding;
                // or the name might contain characters that cannot be expressed
                // in the old-style Macintosh encoding. In case of failure, we emit
                // the name in a more modern fashion (Unicode encoding with BCP 47
                // language tags) that is recognized by MacOS 10.5, released in 2009.
                // If fonts were only read by operating systems, we could simply
                // emit all names in the modern form; this would be much easier.
                // However, there are many applications and libraries that read
                // 'name' tables directly, and these will usually only recognize
                // the ancient form (silently skipping the unrecognized names).
                var macPlatform = 1; // Macintosh
                var macLanguage =
                  macLanguageIds[lang];
                var macScript =
                  macLanguageToScript[
                    macLanguage
                  ];
                var macEncoding = getEncoding(
                  macPlatform,
                  macScript,
                  macLanguage
                );
                var macName = encode.MACSTRING(
                  text,
                  macEncoding
                );
                if (macName === undefined) {
                  macPlatform = 0; // Unicode
                  macLanguage =
                    ltag.indexOf(lang);
                  if (macLanguage < 0) {
                    macLanguage = ltag.length;
                    ltag.push(lang);
                  }

                  macScript = 4; // Unicode 2.0 and later
                  macName = encode.UTF16(text);
                }

                var macNameOffset =
                  addStringToPool(
                    macName,
                    stringPool
                  );
                nameRecords.push(
                  makeNameRecord(
                    macPlatform,
                    macScript,
                    macLanguage,
                    nameID,
                    macName.length,
                    macNameOffset
                  )
                );

                var winLanguage =
                  windowsLanguageIds[lang];
                if (winLanguage !== undefined) {
                  var winName =
                    encode.UTF16(text);
                  var winNameOffset =
                    addStringToPool(
                      winName,
                      stringPool
                    );
                  nameRecords.push(
                    makeNameRecord(
                      3,
                      1,
                      winLanguage,
                      nameID,
                      winName.length,
                      winNameOffset
                    )
                  );
                }
              }
            }

            nameRecords.sort(function (a, b) {
              return (
                a.platformID - b.platformID ||
                a.encodingID - b.encodingID ||
                a.languageID - b.languageID ||
                a.nameID - b.nameID
              );
            });

            var t = new table.Table("name", [
              {
                name: "format",
                type: "USHORT",
                value: 0,
              },
              {
                name: "count",
                type: "USHORT",
                value: nameRecords.length,
              },
              {
                name: "stringOffset",
                type: "USHORT",
                value:
                  6 + nameRecords.length * 12,
              },
            ]);

            for (
              var r = 0;
              r < nameRecords.length;
              r++
            ) {
              t.fields.push({
                name: "record_" + r,
                type: "RECORD",
                value: nameRecords[r],
              });
            }

            t.fields.push({
              name: "strings",
              type: "LITERAL",
              value: stringPool,
            });
            return t;
          }

          var _name = {
            parse: parseNameTable,
            make: makeNameTable,
          };

          // The `OS/2` table contains metrics required in OpenType fonts.

          var unicodeRanges = [
            { begin: 0x0000, end: 0x007f }, // Basic Latin
            { begin: 0x0080, end: 0x00ff }, // Latin-1 Supplement
            { begin: 0x0100, end: 0x017f }, // Latin Extended-A
            { begin: 0x0180, end: 0x024f }, // Latin Extended-B
            { begin: 0x0250, end: 0x02af }, // IPA Extensions
            { begin: 0x02b0, end: 0x02ff }, // Spacing Modifier Letters
            { begin: 0x0300, end: 0x036f }, // Combining Diacritical Marks
            { begin: 0x0370, end: 0x03ff }, // Greek and Coptic
            { begin: 0x2c80, end: 0x2cff }, // Coptic
            { begin: 0x0400, end: 0x04ff }, // Cyrillic
            { begin: 0x0530, end: 0x058f }, // Armenian
            { begin: 0x0590, end: 0x05ff }, // Hebrew
            { begin: 0xa500, end: 0xa63f }, // Vai
            { begin: 0x0600, end: 0x06ff }, // Arabic
            { begin: 0x07c0, end: 0x07ff }, // NKo
            { begin: 0x0900, end: 0x097f }, // Devanagari
            { begin: 0x0980, end: 0x09ff }, // Bengali
            { begin: 0x0a00, end: 0x0a7f }, // Gurmukhi
            { begin: 0x0a80, end: 0x0aff }, // Gujarati
            { begin: 0x0b00, end: 0x0b7f }, // Oriya
            { begin: 0x0b80, end: 0x0bff }, // Tamil
            { begin: 0x0c00, end: 0x0c7f }, // Telugu
            { begin: 0x0c80, end: 0x0cff }, // Kannada
            { begin: 0x0d00, end: 0x0d7f }, // Malayalam
            { begin: 0x0e00, end: 0x0e7f }, // Thai
            { begin: 0x0e80, end: 0x0eff }, // Lao
            { begin: 0x10a0, end: 0x10ff }, // Georgian
            { begin: 0x1b00, end: 0x1b7f }, // Balinese
            { begin: 0x1100, end: 0x11ff }, // Hangul Jamo
            { begin: 0x1e00, end: 0x1eff }, // Latin Extended Additional
            { begin: 0x1f00, end: 0x1fff }, // Greek Extended
            { begin: 0x2000, end: 0x206f }, // General Punctuation
            { begin: 0x2070, end: 0x209f }, // Superscripts And Subscripts
            { begin: 0x20a0, end: 0x20cf }, // Currency Symbol
            { begin: 0x20d0, end: 0x20ff }, // Combining Diacritical Marks For Symbols
            { begin: 0x2100, end: 0x214f }, // Letterlike Symbols
            { begin: 0x2150, end: 0x218f }, // Number Forms
            { begin: 0x2190, end: 0x21ff }, // Arrows
            { begin: 0x2200, end: 0x22ff }, // Mathematical Operators
            { begin: 0x2300, end: 0x23ff }, // Miscellaneous Technical
            { begin: 0x2400, end: 0x243f }, // Control Pictures
            { begin: 0x2440, end: 0x245f }, // Optical Character Recognition
            { begin: 0x2460, end: 0x24ff }, // Enclosed Alphanumerics
            { begin: 0x2500, end: 0x257f }, // Box Drawing
            { begin: 0x2580, end: 0x259f }, // Block Elements
            { begin: 0x25a0, end: 0x25ff }, // Geometric Shapes
            { begin: 0x2600, end: 0x26ff }, // Miscellaneous Symbols
            { begin: 0x2700, end: 0x27bf }, // Dingbats
            { begin: 0x3000, end: 0x303f }, // CJK Symbols And Punctuation
            { begin: 0x3040, end: 0x309f }, // Hiragana
            { begin: 0x30a0, end: 0x30ff }, // Katakana
            { begin: 0x3100, end: 0x312f }, // Bopomofo
            { begin: 0x3130, end: 0x318f }, // Hangul Compatibility Jamo
            { begin: 0xa840, end: 0xa87f }, // Phags-pa
            { begin: 0x3200, end: 0x32ff }, // Enclosed CJK Letters And Months
            { begin: 0x3300, end: 0x33ff }, // CJK Compatibility
            { begin: 0xac00, end: 0xd7af }, // Hangul Syllables
            { begin: 0xd800, end: 0xdfff }, // Non-Plane 0 *
            { begin: 0x10900, end: 0x1091f }, // Phoenicia
            { begin: 0x4e00, end: 0x9fff }, // CJK Unified Ideographs
            { begin: 0xe000, end: 0xf8ff }, // Private Use Area (plane 0)
            { begin: 0x31c0, end: 0x31ef }, // CJK Strokes
            { begin: 0xfb00, end: 0xfb4f }, // Alphabetic Presentation Forms
            { begin: 0xfb50, end: 0xfdff }, // Arabic Presentation Forms-A
            { begin: 0xfe20, end: 0xfe2f }, // Combining Half Marks
            { begin: 0xfe10, end: 0xfe1f }, // Vertical Forms
            { begin: 0xfe50, end: 0xfe6f }, // Small Form Variants
            { begin: 0xfe70, end: 0xfeff }, // Arabic Presentation Forms-B
            { begin: 0xff00, end: 0xffef }, // Halfwidth And Fullwidth Forms
            { begin: 0xfff0, end: 0xffff }, // Specials
            { begin: 0x0f00, end: 0x0fff }, // Tibetan
            { begin: 0x0700, end: 0x074f }, // Syriac
            { begin: 0x0780, end: 0x07bf }, // Thaana
            { begin: 0x0d80, end: 0x0dff }, // Sinhala
            { begin: 0x1000, end: 0x109f }, // Myanmar
            { begin: 0x1200, end: 0x137f }, // Ethiopic
            { begin: 0x13a0, end: 0x13ff }, // Cherokee
            { begin: 0x1400, end: 0x167f }, // Unified Canadian Aboriginal Syllabics
            { begin: 0x1680, end: 0x169f }, // Ogham
            { begin: 0x16a0, end: 0x16ff }, // Runic
            { begin: 0x1780, end: 0x17ff }, // Khmer
            { begin: 0x1800, end: 0x18af }, // Mongolian
            { begin: 0x2800, end: 0x28ff }, // Braille Patterns
            { begin: 0xa000, end: 0xa48f }, // Yi Syllables
            { begin: 0x1700, end: 0x171f }, // Tagalog
            { begin: 0x10300, end: 0x1032f }, // Old Italic
            { begin: 0x10330, end: 0x1034f }, // Gothic
            { begin: 0x10400, end: 0x1044f }, // Deseret
            { begin: 0x1d000, end: 0x1d0ff }, // Byzantine Musical Symbols
            { begin: 0x1d400, end: 0x1d7ff }, // Mathematical Alphanumeric Symbols
            { begin: 0xff000, end: 0xffffd }, // Private Use (plane 15)
            { begin: 0xfe00, end: 0xfe0f }, // Variation Selectors
            { begin: 0xe0000, end: 0xe007f }, // Tags
            { begin: 0x1900, end: 0x194f }, // Limbu
            { begin: 0x1950, end: 0x197f }, // Tai Le
            { begin: 0x1980, end: 0x19df }, // New Tai Lue
            { begin: 0x1a00, end: 0x1a1f }, // Buginese
            { begin: 0x2c00, end: 0x2c5f }, // Glagolitic
            { begin: 0x2d30, end: 0x2d7f }, // Tifinagh
            { begin: 0x4dc0, end: 0x4dff }, // Yijing Hexagram Symbols
            { begin: 0xa800, end: 0xa82f }, // Syloti Nagri
            { begin: 0x10000, end: 0x1007f }, // Linear B Syllabary
            { begin: 0x10140, end: 0x1018f }, // Ancient Greek Numbers
            { begin: 0x10380, end: 0x1039f }, // Ugaritic
            { begin: 0x103a0, end: 0x103df }, // Old Persian
            { begin: 0x10450, end: 0x1047f }, // Shavian
            { begin: 0x10480, end: 0x104af }, // Osmanya
            { begin: 0x10800, end: 0x1083f }, // Cypriot Syllabary
            { begin: 0x10a00, end: 0x10a5f }, // Kharoshthi
            { begin: 0x1d300, end: 0x1d35f }, // Tai Xuan Jing Symbols
            { begin: 0x12000, end: 0x123ff }, // Cuneiform
            { begin: 0x1d360, end: 0x1d37f }, // Counting Rod Numerals
            { begin: 0x1b80, end: 0x1bbf }, // Sundanese
            { begin: 0x1c00, end: 0x1c4f }, // Lepcha
            { begin: 0x1c50, end: 0x1c7f }, // Ol Chiki
            { begin: 0xa880, end: 0xa8df }, // Saurashtra
            { begin: 0xa900, end: 0xa92f }, // Kayah Li
            { begin: 0xa930, end: 0xa95f }, // Rejang
            { begin: 0xaa00, end: 0xaa5f }, // Cham
            { begin: 0x10190, end: 0x101cf }, // Ancient Symbols
            { begin: 0x101d0, end: 0x101ff }, // Phaistos Disc
            { begin: 0x102a0, end: 0x102df }, // Carian
            { begin: 0x1f030, end: 0x1f09f }, // Domino Tiles
          ];

          function getUnicodeRange(unicode) {
            for (
              var i = 0;
              i < unicodeRanges.length;
              i += 1
            ) {
              var range = unicodeRanges[i];
              if (
                unicode >= range.begin &&
                unicode < range.end
              ) {
                return i;
              }
            }

            return -1;
          }

          // Parse the OS/2 and Windows metrics `OS/2` table
          function parseOS2Table(data, start) {
            var os2 = {};
            var p = new parse.Parser(data, start);
            os2.version = p.parseUShort();
            os2.xAvgCharWidth = p.parseShort();
            os2.usWeightClass = p.parseUShort();
            os2.usWidthClass = p.parseUShort();
            os2.fsType = p.parseUShort();
            os2.ySubscriptXSize = p.parseShort();
            os2.ySubscriptYSize = p.parseShort();
            os2.ySubscriptXOffset =
              p.parseShort();
            os2.ySubscriptYOffset =
              p.parseShort();
            os2.ySuperscriptXSize =
              p.parseShort();
            os2.ySuperscriptYSize =
              p.parseShort();
            os2.ySuperscriptXOffset =
              p.parseShort();
            os2.ySuperscriptYOffset =
              p.parseShort();
            os2.yStrikeoutSize = p.parseShort();
            os2.yStrikeoutPosition =
              p.parseShort();
            os2.sFamilyClass = p.parseShort();
            os2.panose = [];
            for (var i = 0; i < 10; i++) {
              os2.panose[i] = p.parseByte();
            }

            os2.ulUnicodeRange1 = p.parseULong();
            os2.ulUnicodeRange2 = p.parseULong();
            os2.ulUnicodeRange3 = p.parseULong();
            os2.ulUnicodeRange4 = p.parseULong();
            os2.achVendID = String.fromCharCode(
              p.parseByte(),
              p.parseByte(),
              p.parseByte(),
              p.parseByte()
            );
            os2.fsSelection = p.parseUShort();
            os2.usFirstCharIndex =
              p.parseUShort();
            os2.usLastCharIndex = p.parseUShort();
            os2.sTypoAscender = p.parseShort();
            os2.sTypoDescender = p.parseShort();
            os2.sTypoLineGap = p.parseShort();
            os2.usWinAscent = p.parseUShort();
            os2.usWinDescent = p.parseUShort();
            if (os2.version >= 1) {
              os2.ulCodePageRange1 =
                p.parseULong();
              os2.ulCodePageRange2 =
                p.parseULong();
            }

            if (os2.version >= 2) {
              os2.sxHeight = p.parseShort();
              os2.sCapHeight = p.parseShort();
              os2.usDefaultChar = p.parseUShort();
              os2.usBreakChar = p.parseUShort();
              os2.usMaxContent = p.parseUShort();
            }

            return os2;
          }

          function makeOS2Table(options) {
            return new table.Table(
              "OS/2",
              [
                {
                  name: "version",
                  type: "USHORT",
                  value: 0x0003,
                },
                {
                  name: "xAvgCharWidth",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "usWeightClass",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "usWidthClass",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "fsType",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "ySubscriptXSize",
                  type: "SHORT",
                  value: 650,
                },
                {
                  name: "ySubscriptYSize",
                  type: "SHORT",
                  value: 699,
                },
                {
                  name: "ySubscriptXOffset",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "ySubscriptYOffset",
                  type: "SHORT",
                  value: 140,
                },
                {
                  name: "ySuperscriptXSize",
                  type: "SHORT",
                  value: 650,
                },
                {
                  name: "ySuperscriptYSize",
                  type: "SHORT",
                  value: 699,
                },
                {
                  name: "ySuperscriptXOffset",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "ySuperscriptYOffset",
                  type: "SHORT",
                  value: 479,
                },
                {
                  name: "yStrikeoutSize",
                  type: "SHORT",
                  value: 49,
                },
                {
                  name: "yStrikeoutPosition",
                  type: "SHORT",
                  value: 258,
                },
                {
                  name: "sFamilyClass",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "bFamilyType",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "bSerifStyle",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "bWeight",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "bProportion",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "bContrast",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "bStrokeVariation",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "bArmStyle",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "bLetterform",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "bMidline",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "bXHeight",
                  type: "BYTE",
                  value: 0,
                },
                {
                  name: "ulUnicodeRange1",
                  type: "ULONG",
                  value: 0,
                },
                {
                  name: "ulUnicodeRange2",
                  type: "ULONG",
                  value: 0,
                },
                {
                  name: "ulUnicodeRange3",
                  type: "ULONG",
                  value: 0,
                },
                {
                  name: "ulUnicodeRange4",
                  type: "ULONG",
                  value: 0,
                },
                {
                  name: "achVendID",
                  type: "CHARARRAY",
                  value: "XXXX",
                },
                {
                  name: "fsSelection",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "usFirstCharIndex",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "usLastCharIndex",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "sTypoAscender",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "sTypoDescender",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "sTypoLineGap",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "usWinAscent",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "usWinDescent",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "ulCodePageRange1",
                  type: "ULONG",
                  value: 0,
                },
                {
                  name: "ulCodePageRange2",
                  type: "ULONG",
                  value: 0,
                },
                {
                  name: "sxHeight",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "sCapHeight",
                  type: "SHORT",
                  value: 0,
                },
                {
                  name: "usDefaultChar",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "usBreakChar",
                  type: "USHORT",
                  value: 0,
                },
                {
                  name: "usMaxContext",
                  type: "USHORT",
                  value: 0,
                },
              ],
              options
            );
          }

          var os2 = {
            parse: parseOS2Table,
            make: makeOS2Table,
            unicodeRanges: unicodeRanges,
            getUnicodeRange: getUnicodeRange,
          };

          // The `post` table stores additional PostScript information, such as glyph names.

          // Parse the PostScript `post` table
          function parsePostTable(data, start) {
            var post = {};
            var p = new parse.Parser(data, start);
            post.version = p.parseVersion();
            post.italicAngle = p.parseFixed();
            post.underlinePosition =
              p.parseShort();
            post.underlineThickness =
              p.parseShort();
            post.isFixedPitch = p.parseULong();
            post.minMemType42 = p.parseULong();
            post.maxMemType42 = p.parseULong();
            post.minMemType1 = p.parseULong();
            post.maxMemType1 = p.parseULong();
            switch (post.version) {
              case 1:
                post.names =
                  standardNames.slice();
                break;
              case 2:
                post.numberOfGlyphs =
                  p.parseUShort();
                post.glyphNameIndex = new Array(
                  post.numberOfGlyphs
                );
                for (
                  var i = 0;
                  i < post.numberOfGlyphs;
                  i++
                ) {
                  post.glyphNameIndex[i] =
                    p.parseUShort();
                }

                post.names = [];
                for (
                  var i$1 = 0;
                  i$1 < post.numberOfGlyphs;
                  i$1++
                ) {
                  if (
                    post.glyphNameIndex[i$1] >=
                    standardNames.length
                  ) {
                    var nameLength =
                      p.parseChar();
                    post.names.push(
                      p.parseString(nameLength)
                    );
                  }
                }

                break;
              case 2.5:
                post.numberOfGlyphs =
                  p.parseUShort();
                post.offset = new Array(
                  post.numberOfGlyphs
                );
                for (
                  var i$2 = 0;
                  i$2 < post.numberOfGlyphs;
                  i$2++
                ) {
                  post.offset[i$2] =
                    p.parseChar();
                }

                break;
            }
            return post;
          }

          function makePostTable() {
            return new table.Table("post", [
              {
                name: "version",
                type: "FIXED",
                value: 0x00030000,
              },
              {
                name: "italicAngle",
                type: "FIXED",
                value: 0,
              },
              {
                name: "underlinePosition",
                type: "FWORD",
                value: 0,
              },
              {
                name: "underlineThickness",
                type: "FWORD",
                value: 0,
              },
              {
                name: "isFixedPitch",
                type: "ULONG",
                value: 0,
              },
              {
                name: "minMemType42",
                type: "ULONG",
                value: 0,
              },
              {
                name: "maxMemType42",
                type: "ULONG",
                value: 0,
              },
              {
                name: "minMemType1",
                type: "ULONG",
                value: 0,
              },
              {
                name: "maxMemType1",
                type: "ULONG",
                value: 0,
              },
            ]);
          }

          var post = {
            parse: parsePostTable,
            make: makePostTable,
          };

          // The `GSUB` table contains ligatures, among other things.

          var subtableParsers = new Array(9); // subtableParsers[0] is unused

          // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
          subtableParsers[1] =
            function parseLookup1() {
              var start =
                this.offset + this.relativeOffset;
              var substFormat =
                this.parseUShort();
              if (substFormat === 1) {
                return {
                  substFormat: 1,
                  coverage: this.parsePointer(
                    Parser.coverage
                  ),
                  deltaGlyphId:
                    this.parseUShort(),
                };
              } else if (substFormat === 2) {
                return {
                  substFormat: 2,
                  coverage: this.parsePointer(
                    Parser.coverage
                  ),
                  substitute:
                    this.parseOffset16List(),
                };
              }
              check.assert(
                false,
                "0x" +
                  start.toString(16) +
                  ": lookup type 1 format must be 1 or 2."
              );
            };

          // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
          subtableParsers[2] =
            function parseLookup2() {
              var substFormat =
                this.parseUShort();
              check.argument(
                substFormat === 1,
                "GSUB Multiple Substitution Subtable identifier-format must be 1"
              );
              return {
                substFormat: substFormat,
                coverage: this.parsePointer(
                  Parser.coverage
                ),
                sequences:
                  this.parseListOfLists(),
              };
            };

          // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
          subtableParsers[3] =
            function parseLookup3() {
              var substFormat =
                this.parseUShort();
              check.argument(
                substFormat === 1,
                "GSUB Alternate Substitution Subtable identifier-format must be 1"
              );
              return {
                substFormat: substFormat,
                coverage: this.parsePointer(
                  Parser.coverage
                ),
                alternateSets:
                  this.parseListOfLists(),
              };
            };

          // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
          subtableParsers[4] =
            function parseLookup4() {
              var substFormat =
                this.parseUShort();
              check.argument(
                substFormat === 1,
                "GSUB ligature table identifier-format must be 1"
              );
              return {
                substFormat: substFormat,
                coverage: this.parsePointer(
                  Parser.coverage
                ),
                ligatureSets:
                  this.parseListOfLists(
                    function () {
                      return {
                        ligGlyph:
                          this.parseUShort(),
                        components:
                          this.parseUShortList(
                            this.parseUShort() - 1
                          ),
                      };
                    }
                  ),
              };
            };

          var lookupRecordDesc = {
            sequenceIndex: Parser.uShort,
            lookupListIndex: Parser.uShort,
          };

          // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
          subtableParsers[5] =
            function parseLookup5() {
              var start =
                this.offset + this.relativeOffset;
              var substFormat =
                this.parseUShort();

              if (substFormat === 1) {
                return {
                  substFormat: substFormat,
                  coverage: this.parsePointer(
                    Parser.coverage
                  ),
                  ruleSets: this.parseListOfLists(
                    function () {
                      var glyphCount =
                        this.parseUShort();
                      var substCount =
                        this.parseUShort();
                      return {
                        input:
                          this.parseUShortList(
                            glyphCount - 1
                          ),
                        lookupRecords:
                          this.parseRecordList(
                            substCount,
                            lookupRecordDesc
                          ),
                      };
                    }
                  ),
                };
              } else if (substFormat === 2) {
                return {
                  substFormat: substFormat,
                  coverage: this.parsePointer(
                    Parser.coverage
                  ),
                  classDef: this.parsePointer(
                    Parser.classDef
                  ),
                  classSets:
                    this.parseListOfLists(
                      function () {
                        var glyphCount =
                          this.parseUShort();
                        var substCount =
                          this.parseUShort();
                        return {
                          classes:
                            this.parseUShortList(
                              glyphCount - 1
                            ),
                          lookupRecords:
                            this.parseRecordList(
                              substCount,
                              lookupRecordDesc
                            ),
                        };
                      }
                    ),
                };
              } else if (substFormat === 3) {
                var glyphCount =
                  this.parseUShort();
                var substCount =
                  this.parseUShort();
                return {
                  substFormat: substFormat,
                  coverages: this.parseList(
                    glyphCount,
                    Parser.pointer(
                      Parser.coverage
                    )
                  ),
                  lookupRecords:
                    this.parseRecordList(
                      substCount,
                      lookupRecordDesc
                    ),
                };
              }
              check.assert(
                false,
                "0x" +
                  start.toString(16) +
                  ": lookup type 5 format must be 1, 2 or 3."
              );
            };

          // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
          subtableParsers[6] =
            function parseLookup6() {
              var start =
                this.offset + this.relativeOffset;
              var substFormat =
                this.parseUShort();
              if (substFormat === 1) {
                return {
                  substFormat: 1,
                  coverage: this.parsePointer(
                    Parser.coverage
                  ),
                  chainRuleSets:
                    this.parseListOfLists(
                      function () {
                        return {
                          backtrack:
                            this.parseUShortList(),
                          input:
                            this.parseUShortList(
                              this.parseShort() -
                                1
                            ),
                          lookahead:
                            this.parseUShortList(),
                          lookupRecords:
                            this.parseRecordList(
                              lookupRecordDesc
                            ),
                        };
                      }
                    ),
                };
              } else if (substFormat === 2) {
                return {
                  substFormat: 2,
                  coverage: this.parsePointer(
                    Parser.coverage
                  ),
                  backtrackClassDef:
                    this.parsePointer(
                      Parser.classDef
                    ),
                  inputClassDef:
                    this.parsePointer(
                      Parser.classDef
                    ),
                  lookaheadClassDef:
                    this.parsePointer(
                      Parser.classDef
                    ),
                  chainClassSet:
                    this.parseListOfLists(
                      function () {
                        return {
                          backtrack:
                            this.parseUShortList(),
                          input:
                            this.parseUShortList(
                              this.parseShort() -
                                1
                            ),
                          lookahead:
                            this.parseUShortList(),
                          lookupRecords:
                            this.parseRecordList(
                              lookupRecordDesc
                            ),
                        };
                      }
                    ),
                };
              } else if (substFormat === 3) {
                return {
                  substFormat: 3,
                  backtrackCoverage:
                    this.parseList(
                      Parser.pointer(
                        Parser.coverage
                      )
                    ),
                  inputCoverage: this.parseList(
                    Parser.pointer(
                      Parser.coverage
                    )
                  ),
                  lookaheadCoverage:
                    this.parseList(
                      Parser.pointer(
                        Parser.coverage
                      )
                    ),
                  lookupRecords:
                    this.parseRecordList(
                      lookupRecordDesc
                    ),
                };
              }
              check.assert(
                false,
                "0x" +
                  start.toString(16) +
                  ": lookup type 6 format must be 1, 2 or 3."
              );
            };

          // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
          subtableParsers[7] =
            function parseLookup7() {
              // Extension Substitution subtable
              var substFormat =
                this.parseUShort();
              check.argument(
                substFormat === 1,
                "GSUB Extension Substitution subtable identifier-format must be 1"
              );
              var extensionLookupType =
                this.parseUShort();
              var extensionParser = new Parser(
                this.data,
                this.offset + this.parseULong()
              );
              return {
                substFormat: 1,
                lookupType: extensionLookupType,
                extension: subtableParsers[
                  extensionLookupType
                ].call(extensionParser),
              };
            };

          // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
          subtableParsers[8] =
            function parseLookup8() {
              var substFormat =
                this.parseUShort();
              check.argument(
                substFormat === 1,
                "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"
              );
              return {
                substFormat: substFormat,
                coverage: this.parsePointer(
                  Parser.coverage
                ),
                backtrackCoverage: this.parseList(
                  Parser.pointer(Parser.coverage)
                ),
                lookaheadCoverage: this.parseList(
                  Parser.pointer(Parser.coverage)
                ),
                substitutes:
                  this.parseUShortList(),
              };
            };

          // https://www.microsoft.com/typography/OTSPEC/gsub.htm
          function parseGsubTable(data, start) {
            start = start || 0;
            var p = new Parser(data, start);
            var tableVersion = p.parseVersion(1);
            check.argument(
              tableVersion === 1 ||
                tableVersion === 1.1,
              "Unsupported GSUB table version."
            );
            if (tableVersion === 1) {
              return {
                version: tableVersion,
                scripts: p.parseScriptList(),
                features: p.parseFeatureList(),
                lookups: p.parseLookupList(
                  subtableParsers
                ),
              };
            } else {
              return {
                version: tableVersion,
                scripts: p.parseScriptList(),
                features: p.parseFeatureList(),
                lookups: p.parseLookupList(
                  subtableParsers
                ),
                variations:
                  p.parseFeatureVariationsList(),
              };
            }
          }

          // GSUB Writing //////////////////////////////////////////////
          var subtableMakers = new Array(9);

          subtableMakers[1] =
            function makeLookup1(subtable) {
              if (subtable.substFormat === 1) {
                return new table.Table(
                  "substitutionTable",
                  [
                    {
                      name: "substFormat",
                      type: "USHORT",
                      value: 1,
                    },
                    {
                      name: "coverage",
                      type: "TABLE",
                      value: new table.Coverage(
                        subtable.coverage
                      ),
                    },
                    {
                      name: "deltaGlyphID",
                      type: "USHORT",
                      value:
                        subtable.deltaGlyphId,
                    },
                  ]
                );
              } else {
                return new table.Table(
                  "substitutionTable",
                  [
                    {
                      name: "substFormat",
                      type: "USHORT",
                      value: 2,
                    },
                    {
                      name: "coverage",
                      type: "TABLE",
                      value: new table.Coverage(
                        subtable.coverage
                      ),
                    },
                  ].concat(
                    table.ushortList(
                      "substitute",
                      subtable.substitute
                    )
                  )
                );
              }
              check.fail(
                "Lookup type 1 substFormat must be 1 or 2."
              );
            };

          subtableMakers[3] =
            function makeLookup3(subtable) {
              check.assert(
                subtable.substFormat === 1,
                "Lookup type 3 substFormat must be 1."
              );
              return new table.Table(
                "substitutionTable",
                [
                  {
                    name: "substFormat",
                    type: "USHORT",
                    value: 1,
                  },
                  {
                    name: "coverage",
                    type: "TABLE",
                    value: new table.Coverage(
                      subtable.coverage
                    ),
                  },
                ].concat(
                  table.tableList(
                    "altSet",
                    subtable.alternateSets,
                    function (alternateSet) {
                      return new table.Table(
                        "alternateSetTable",
                        table.ushortList(
                          "alternate",
                          alternateSet
                        )
                      );
                    }
                  )
                )
              );
            };

          subtableMakers[4] =
            function makeLookup4(subtable) {
              check.assert(
                subtable.substFormat === 1,
                "Lookup type 4 substFormat must be 1."
              );
              return new table.Table(
                "substitutionTable",
                [
                  {
                    name: "substFormat",
                    type: "USHORT",
                    value: 1,
                  },
                  {
                    name: "coverage",
                    type: "TABLE",
                    value: new table.Coverage(
                      subtable.coverage
                    ),
                  },
                ].concat(
                  table.tableList(
                    "ligSet",
                    subtable.ligatureSets,
                    function (ligatureSet) {
                      return new table.Table(
                        "ligatureSetTable",
                        table.tableList(
                          "ligature",
                          ligatureSet,
                          function (ligature) {
                            return new table.Table(
                              "ligatureTable",
                              [
                                {
                                  name: "ligGlyph",
                                  type: "USHORT",
                                  value:
                                    ligature.ligGlyph,
                                },
                              ].concat(
                                table.ushortList(
                                  "component",
                                  ligature.components,
                                  ligature
                                    .components
                                    .length + 1
                                )
                              )
                            );
                          }
                        )
                      );
                    }
                  )
                )
              );
            };

          function makeGsubTable(gsub) {
            return new table.Table("GSUB", [
              {
                name: "version",
                type: "ULONG",
                value: 0x10000,
              },
              {
                name: "scripts",
                type: "TABLE",
                value: new table.ScriptList(
                  gsub.scripts
                ),
              },
              {
                name: "features",
                type: "TABLE",
                value: new table.FeatureList(
                  gsub.features
                ),
              },
              {
                name: "lookups",
                type: "TABLE",
                value: new table.LookupList(
                  gsub.lookups,
                  subtableMakers
                ),
              },
            ]);
          }

          var gsub = {
            parse: parseGsubTable,
            make: makeGsubTable,
          };

          // The `GPOS` table contains kerning pairs, among other things.

          // Parse the metadata `meta` table.
          // https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
          function parseMetaTable(data, start) {
            var p = new parse.Parser(data, start);
            var tableVersion = p.parseULong();
            check.argument(
              tableVersion === 1,
              "Unsupported META table version."
            );
            p.parseULong(); // flags - currently unused and set to 0
            p.parseULong(); // tableOffset
            var numDataMaps = p.parseULong();

            var tags = {};
            for (
              var i = 0;
              i < numDataMaps;
              i++
            ) {
              var tag = p.parseTag();
              var dataOffset = p.parseULong();
              var dataLength = p.parseULong();
              var text = decode.UTF8(
                data,
                start + dataOffset,
                dataLength
              );

              tags[tag] = text;
            }
            return tags;
          }

          function makeMetaTable(tags) {
            var numTags =
              Object.keys(tags).length;
            var stringPool = "";
            var stringPoolOffset =
              16 + numTags * 12;

            var result = new table.Table("meta", [
              {
                name: "version",
                type: "ULONG",
                value: 1,
              },
              {
                name: "flags",
                type: "ULONG",
                value: 0,
              },
              {
                name: "offset",
                type: "ULONG",
                value: stringPoolOffset,
              },
              {
                name: "numTags",
                type: "ULONG",
                value: numTags,
              },
            ]);

            for (var tag in tags) {
              var pos = stringPool.length;
              stringPool += tags[tag];

              result.fields.push({
                name: "tag " + tag,
                type: "TAG",
                value: tag,
              });
              result.fields.push({
                name: "offset " + tag,
                type: "ULONG",
                value: stringPoolOffset + pos,
              });
              result.fields.push({
                name: "length " + tag,
                type: "ULONG",
                value: tags[tag].length,
              });
            }

            result.fields.push({
              name: "stringPool",
              type: "CHARARRAY",
              value: stringPool,
            });

            return result;
          }

          var meta = {
            parse: parseMetaTable,
            make: makeMetaTable,
          };

          // The `sfnt` wrapper provides organization for the tables in the font.

          function log2(v) {
            return (
              (Math.log(v) / Math.log(2)) | 0
            );
          }

          function computeCheckSum(bytes) {
            while (bytes.length % 4 !== 0) {
              bytes.push(0);
            }

            var sum = 0;
            for (
              var i = 0;
              i < bytes.length;
              i += 4
            ) {
              sum +=
                (bytes[i] << 24) +
                (bytes[i + 1] << 16) +
                (bytes[i + 2] << 8) +
                bytes[i + 3];
            }

            sum %= Math.pow(2, 32);
            return sum;
          }

          function makeTableRecord(
            tag,
            checkSum,
            offset,
            length
          ) {
            return new table.Record(
              "Table Record",
              [
                {
                  name: "tag",
                  type: "TAG",
                  value:
                    tag !== undefined ? tag : "",
                },
                {
                  name: "checkSum",
                  type: "ULONG",
                  value:
                    checkSum !== undefined
                      ? checkSum
                      : 0,
                },
                {
                  name: "offset",
                  type: "ULONG",
                  value:
                    offset !== undefined
                      ? offset
                      : 0,
                },
                {
                  name: "length",
                  type: "ULONG",
                  value:
                    length !== undefined
                      ? length
                      : 0,
                },
              ]
            );
          }

          function makeSfntTable(tables) {
            var sfnt = new table.Table("sfnt", [
              {
                name: "version",
                type: "TAG",
                value: "OTTO",
              },
              {
                name: "numTables",
                type: "USHORT",
                value: 0,
              },
              {
                name: "searchRange",
                type: "USHORT",
                value: 0,
              },
              {
                name: "entrySelector",
                type: "USHORT",
                value: 0,
              },
              {
                name: "rangeShift",
                type: "USHORT",
                value: 0,
              },
            ]);
            sfnt.tables = tables;
            sfnt.numTables = tables.length;
            var highestPowerOf2 = Math.pow(
              2,
              log2(sfnt.numTables)
            );
            sfnt.searchRange =
              16 * highestPowerOf2;
            sfnt.entrySelector = log2(
              highestPowerOf2
            );
            sfnt.rangeShift =
              sfnt.numTables * 16 -
              sfnt.searchRange;

            var recordFields = [];
            var tableFields = [];

            var offset =
              sfnt.sizeOf() +
              makeTableRecord().sizeOf() *
                sfnt.numTables;
            while (offset % 4 !== 0) {
              offset += 1;
              tableFields.push({
                name: "padding",
                type: "BYTE",
                value: 0,
              });
            }

            for (
              var i = 0;
              i < tables.length;
              i += 1
            ) {
              var t = tables[i];
              check.argument(
                t.tableName.length === 4,
                "Table name" +
                  t.tableName +
                  " is invalid."
              );
              var tableLength = t.sizeOf();
              var tableRecord = makeTableRecord(
                t.tableName,
                computeCheckSum(t.encode()),
                offset,
                tableLength
              );
              recordFields.push({
                name:
                  tableRecord.tag +
                  " Table Record",
                type: "RECORD",
                value: tableRecord,
              });
              tableFields.push({
                name: t.tableName + " table",
                type: "RECORD",
                value: t,
              });
              offset += tableLength;
              check.argument(
                !isNaN(offset),
                "Something went wrong calculating the offset."
              );
              while (offset % 4 !== 0) {
                offset += 1;
                tableFields.push({
                  name: "padding",
                  type: "BYTE",
                  value: 0,
                });
              }
            }

            // Table records need to be sorted alphabetically.
            recordFields.sort(function (r1, r2) {
              if (r1.value.tag > r2.value.tag) {
                return 1;
              } else {
                return -1;
              }
            });

            sfnt.fields =
              sfnt.fields.concat(recordFields);
            sfnt.fields =
              sfnt.fields.concat(tableFields);
            return sfnt;
          }

          // Get the metrics for a character. If the string has more than one character
          // this function returns metrics for the first available character.
          // You can provide optional fallback metrics if no characters are available.
          function metricsForChar(
            font,
            chars,
            notFoundMetrics
          ) {
            for (
              var i = 0;
              i < chars.length;
              i += 1
            ) {
              var glyphIndex =
                font.charToGlyphIndex(chars[i]);
              if (glyphIndex > 0) {
                var glyph =
                  font.glyphs.get(glyphIndex);
                return glyph.getMetrics();
              }
            }

            return notFoundMetrics;
          }

          function average(vs) {
            var sum = 0;
            for (
              var i = 0;
              i < vs.length;
              i += 1
            ) {
              sum += vs[i];
            }

            return sum / vs.length;
          }

          // Convert the font object to a SFNT data structure.
          // This structure contains all the necessary tables and metadata to create a binary OTF file.
          function fontToSfntTable(font) {
            var xMins = [];
            var yMins = [];
            var xMaxs = [];
            var yMaxs = [];
            var advanceWidths = [];
            var leftSideBearings = [];
            var rightSideBearings = [];
            var firstCharIndex;
            var lastCharIndex = 0;
            var ulUnicodeRange1 = 0;
            var ulUnicodeRange2 = 0;
            var ulUnicodeRange3 = 0;
            var ulUnicodeRange4 = 0;

            for (
              var i = 0;
              i < font.glyphs.length;
              i += 1
            ) {
              var glyph = font.glyphs.get(i);
              var unicode = glyph.unicode | 0;

              if (isNaN(glyph.advanceWidth)) {
                throw new Error(
                  "Glyph " +
                    glyph.name +
                    " (" +
                    i +
                    "): advanceWidth is not a number."
                );
              }

              if (
                firstCharIndex > unicode ||
                firstCharIndex === undefined
              ) {
                // ignore .notdef char
                if (unicode > 0) {
                  firstCharIndex = unicode;
                }
              }

              if (lastCharIndex < unicode) {
                lastCharIndex = unicode;
              }

              var position =
                os2.getUnicodeRange(unicode);
              if (position < 32) {
                ulUnicodeRange1 |= 1 << position;
              } else if (position < 64) {
                ulUnicodeRange2 |=
                  1 << (position - 32);
              } else if (position < 96) {
                ulUnicodeRange3 |=
                  1 << (position - 64);
              } else if (position < 123) {
                ulUnicodeRange4 |=
                  1 << (position - 96);
              } else {
                throw new Error(
                  "Unicode ranges bits > 123 are reserved for internal usage"
                );
              }
              // Skip non-important characters.
              if (glyph.name === ".notdef") {
                continue;
              }
              var metrics = glyph.getMetrics();
              xMins.push(metrics.xMin);
              yMins.push(metrics.yMin);
              xMaxs.push(metrics.xMax);
              yMaxs.push(metrics.yMax);
              leftSideBearings.push(
                metrics.leftSideBearing
              );
              rightSideBearings.push(
                metrics.rightSideBearing
              );
              advanceWidths.push(
                glyph.advanceWidth
              );
            }

            var globals = {
              xMin: Math.min.apply(null, xMins),
              yMin: Math.min.apply(null, yMins),
              xMax: Math.max.apply(null, xMaxs),
              yMax: Math.max.apply(null, yMaxs),
              advanceWidthMax: Math.max.apply(
                null,
                advanceWidths
              ),
              advanceWidthAvg: average(
                advanceWidths
              ),
              minLeftSideBearing: Math.min.apply(
                null,
                leftSideBearings
              ),
              maxLeftSideBearing: Math.max.apply(
                null,
                leftSideBearings
              ),
              minRightSideBearing: Math.min.apply(
                null,
                rightSideBearings
              ),
            };
            globals.ascender = font.ascender;
            globals.descender = font.descender;

            var headTable = head.make({
              flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
              unitsPerEm: font.unitsPerEm,
              xMin: globals.xMin,
              yMin: globals.yMin,
              xMax: globals.xMax,
              yMax: globals.yMax,
              lowestRecPPEM: 3,
              createdTimestamp:
                font.createdTimestamp,
            });

            var hheaTable = hhea.make({
              ascender: globals.ascender,
              descender: globals.descender,
              advanceWidthMax:
                globals.advanceWidthMax,
              minLeftSideBearing:
                globals.minLeftSideBearing,
              minRightSideBearing:
                globals.minRightSideBearing,
              xMaxExtent:
                globals.maxLeftSideBearing +
                (globals.xMax - globals.xMin),
              numberOfHMetrics:
                font.glyphs.length,
            });

            var maxpTable = maxp.make(
              font.glyphs.length
            );

            var os2Table = os2.make({
              xAvgCharWidth: Math.round(
                globals.advanceWidthAvg
              ),
              usWeightClass:
                font.tables.os2.usWeightClass,
              usWidthClass:
                font.tables.os2.usWidthClass,
              usFirstCharIndex: firstCharIndex,
              usLastCharIndex: lastCharIndex,
              ulUnicodeRange1: ulUnicodeRange1,
              ulUnicodeRange2: ulUnicodeRange2,
              ulUnicodeRange3: ulUnicodeRange3,
              ulUnicodeRange4: ulUnicodeRange4,
              fsSelection:
                font.tables.os2.fsSelection, // REGULAR
              // See http://typophile.com/node/13081 for more info on vertical metrics.
              // We get metrics for typical characters (such as "x" for xHeight).
              // We provide some fallback characters if characters are unavailable: their
              // ordering was chosen experimentally.
              sTypoAscender: globals.ascender,
              sTypoDescender: globals.descender,
              sTypoLineGap: 0,
              usWinAscent: globals.yMax,
              usWinDescent: Math.abs(
                globals.yMin
              ),
              ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
              sxHeight: metricsForChar(
                font,
                "xyvw",
                {
                  yMax: Math.round(
                    globals.ascender / 2
                  ),
                }
              ).yMax,
              sCapHeight: metricsForChar(
                font,
                "HIKLEFJMNTZBDPRAGOQSUVWXY",
                globals
              ).yMax,
              usDefaultChar: font.hasChar(" ")
                ? 32
                : 0, // Use space as the default character, if available.
              usBreakChar: font.hasChar(" ")
                ? 32
                : 0, // Use space as the break character, if available.
            });

            var hmtxTable = hmtx.make(
              font.glyphs
            );
            var cmapTable = cmap.make(
              font.glyphs
            );

            var englishFamilyName =
              font.getEnglishName("fontFamily");
            var englishStyleName =
              font.getEnglishName(
                "fontSubfamily"
              );
            var englishFullName =
              englishFamilyName +
              " " +
              englishStyleName;
            var postScriptName =
              font.getEnglishName(
                "postScriptName"
              );
            if (!postScriptName) {
              postScriptName =
                englishFamilyName.replace(
                  /\s/g,
                  ""
                ) +
                "-" +
                englishStyleName;
            }

            var names = {};
            for (var n in font.names) {
              names[n] = font.names[n];
            }

            if (!names.uniqueID) {
              names.uniqueID = {
                en:
                  font.getEnglishName(
                    "manufacturer"
                  ) +
                  ":" +
                  englishFullName,
              };
            }

            if (!names.postScriptName) {
              names.postScriptName = {
                en: postScriptName,
              };
            }

            if (!names.preferredFamily) {
              names.preferredFamily =
                font.names.fontFamily;
            }

            if (!names.preferredSubfamily) {
              names.preferredSubfamily =
                font.names.fontSubfamily;
            }

            var languageTags = [];
            var nameTable = _name.make(
              names,
              languageTags
            );
            var ltagTable =
              languageTags.length > 0
                ? ltag.make(languageTags)
                : undefined;

            var postTable = post.make();
            var cffTable = cff.make(font.glyphs, {
              version:
                font.getEnglishName("version"),
              fullName: englishFullName,
              familyName: englishFamilyName,
              weightName: englishStyleName,
              postScriptName: postScriptName,
              unitsPerEm: font.unitsPerEm,
              fontBBox: [
                0,
                globals.yMin,
                globals.ascender,
                globals.advanceWidthMax,
              ],
            });

            var metaTable =
              font.metas &&
              Object.keys(font.metas).length > 0
                ? meta.make(font.metas)
                : undefined;

            // The order does not matter because makeSfntTable() will sort them.
            var tables = [
              headTable,
              hheaTable,
              maxpTable,
              os2Table,
              nameTable,
              cmapTable,
              postTable,
              cffTable,
              hmtxTable,
            ];
            if (ltagTable) {
              tables.push(ltagTable);
            }
            // Optional tables
            if (font.tables.gsub) {
              tables.push(
                gsub.make(font.tables.gsub)
              );
            }
            if (metaTable) {
              tables.push(metaTable);
            }

            var sfntTable = makeSfntTable(tables);

            // Compute the font's checkSum and store it in head.checkSumAdjustment.
            var bytes = sfntTable.encode();
            var checkSum = computeCheckSum(bytes);
            var tableFields = sfntTable.fields;
            var checkSumAdjusted = false;
            for (
              var i$1 = 0;
              i$1 < tableFields.length;
              i$1 += 1
            ) {
              if (
                tableFields[i$1].name ===
                "head table"
              ) {
                tableFields[
                  i$1
                ].value.checkSumAdjustment =
                  0xb1b0afba - checkSum;
                checkSumAdjusted = true;
                break;
              }
            }

            if (!checkSumAdjusted) {
              throw new Error(
                "Could not find head table with checkSum to adjust."
              );
            }

            return sfntTable;
          }

          var sfnt = {
            make: makeSfntTable,
            fontToTable: fontToSfntTable,
            computeCheckSum: computeCheckSum,
          };

          // The Layout object is the prototype of Substitution objects, and provides

          function searchTag(arr, tag) {
            /* jshint bitwise: false */
            var imin = 0;
            var imax = arr.length - 1;
            while (imin <= imax) {
              var imid = (imin + imax) >>> 1;
              var val = arr[imid].tag;
              if (val === tag) {
                return imid;
              } else if (val < tag) {
                imin = imid + 1;
              } else {
                imax = imid - 1;
              }
            }
            // Not found: return -1-insertion point
            return -imin - 1;
          }

          function binSearch(arr, value) {
            /* jshint bitwise: false */
            var imin = 0;
            var imax = arr.length - 1;
            while (imin <= imax) {
              var imid = (imin + imax) >>> 1;
              var val = arr[imid];
              if (val === value) {
                return imid;
              } else if (val < value) {
                imin = imid + 1;
              } else {
                imax = imid - 1;
              }
            }
            // Not found: return -1-insertion point
            return -imin - 1;
          }

          // binary search in a list of ranges (coverage, class definition)
          function searchRange(ranges, value) {
            // jshint bitwise: false
            var range;
            var imin = 0;
            var imax = ranges.length - 1;
            while (imin <= imax) {
              var imid = (imin + imax) >>> 1;
              range = ranges[imid];
              var start = range.start;
              if (start === value) {
                return range;
              } else if (start < value) {
                imin = imid + 1;
              } else {
                imax = imid - 1;
              }
            }
            if (imin > 0) {
              range = ranges[imin - 1];
              if (value > range.end) {
                return 0;
              }
              return range;
            }
          }

          /**
           * @exports opentype.Layout
           * @class
           */
          function Layout(font, tableName) {
            this.font = font;
            this.tableName = tableName;
          }

          Layout.prototype = {
            /**
             * Binary search an object by "tag" property
             * @instance
             * @function searchTag
             * @memberof opentype.Layout
             * @param  {Array} arr
             * @param  {string} tag
             * @return {number}
             */
            searchTag: searchTag,

            /**
             * Binary search in a list of numbers
             * @instance
             * @function binSearch
             * @memberof opentype.Layout
             * @param  {Array} arr
             * @param  {number} value
             * @return {number}
             */
            binSearch: binSearch,

            /**
             * Get or create the Layout table (GSUB, GPOS etc).
             * @param  {boolean} create - Whether to create a new one.
             * @return {Object} The GSUB or GPOS table.
             */
            getTable: function (create) {
              var layout =
                this.font.tables[this.tableName];
              if (!layout && create) {
                layout = this.font.tables[
                  this.tableName
                ] = this.createDefaultTable();
              }
              return layout;
            },

            /**
             * Returns all scripts in the substitution table.
             * @instance
             * @return {Array}
             */
            getScriptNames: function () {
              var layout = this.getTable();
              if (!layout) {
                return [];
              }
              return layout.scripts.map(function (
                script
              ) {
                return script.tag;
              });
            },

            /**
             * Returns the best bet for a script name.
             * Returns 'DFLT' if it exists.
             * If not, returns 'latn' if it exists.
             * If neither exist, returns undefined.
             */
            getDefaultScriptName: function () {
              var layout = this.getTable();
              if (!layout) {
                return;
              }
              var hasLatn = false;
              for (
                var i = 0;
                i < layout.scripts.length;
                i++
              ) {
                var name = layout.scripts[i].tag;
                if (name === "DFLT") {
                  return name;
                }
                if (name === "latn") {
                  hasLatn = true;
                }
              }
              if (hasLatn) {
                return "latn";
              }
            },

            /**
             * Returns all LangSysRecords in the given script.
             * @instance
             * @param {string} [script='DFLT']
             * @param {boolean} create - forces the creation of this script table if it doesn't exist.
             * @return {Object} An object with tag and script properties.
             */
            getScriptTable: function (
              script,
              create
            ) {
              var layout = this.getTable(create);
              if (layout) {
                script = script || "DFLT";
                var scripts = layout.scripts;
                var pos = searchTag(
                  layout.scripts,
                  script
                );
                if (pos >= 0) {
                  return scripts[pos].script;
                } else if (create) {
                  var scr = {
                    tag: script,
                    script: {
                      defaultLangSys: {
                        reserved: 0,
                        reqFeatureIndex: 0xffff,
                        featureIndexes: [],
                      },
                      langSysRecords: [],
                    },
                  };
                  scripts.splice(
                    -1 - pos,
                    0,
                    scr
                  );
                  return scr.script;
                }
              }
            },

            /**
             * Returns a language system table
             * @instance
             * @param {string} [script='DFLT']
             * @param {string} [language='dlft']
             * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
             * @return {Object}
             */
            getLangSysTable: function (
              script,
              language,
              create
            ) {
              var scriptTable =
                this.getScriptTable(
                  script,
                  create
                );
              if (scriptTable) {
                if (
                  !language ||
                  language === "dflt" ||
                  language === "DFLT"
                ) {
                  return scriptTable.defaultLangSys;
                }
                var pos = searchTag(
                  scriptTable.langSysRecords,
                  language
                );
                if (pos >= 0) {
                  return scriptTable
                    .langSysRecords[pos].langSys;
                } else if (create) {
                  var langSysRecord = {
                    tag: language,
                    langSys: {
                      reserved: 0,
                      reqFeatureIndex: 0xffff,
                      featureIndexes: [],
                    },
                  };
                  scriptTable.langSysRecords.splice(
                    -1 - pos,
                    0,
                    langSysRecord
                  );
                  return langSysRecord.langSys;
                }
              }
            },

            /**
             * Get a specific feature table.
             * @instance
             * @param {string} [script='DFLT']
             * @param {string} [language='dlft']
             * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
             * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
             * @return {Object}
             */
            getFeatureTable: function (
              script,
              language,
              feature,
              create
            ) {
              var langSysTable =
                this.getLangSysTable(
                  script,
                  language,
                  create
                );
              if (langSysTable) {
                var featureRecord;
                var featIndexes =
                  langSysTable.featureIndexes;
                var allFeatures =
                  this.font.tables[this.tableName]
                    .features;
                // The FeatureIndex array of indices is in arbitrary order,
                // even if allFeatures is sorted alphabetically by feature tag.
                for (
                  var i = 0;
                  i < featIndexes.length;
                  i++
                ) {
                  featureRecord =
                    allFeatures[featIndexes[i]];
                  if (
                    featureRecord.tag === feature
                  ) {
                    return featureRecord.feature;
                  }
                }
                if (create) {
                  var index = allFeatures.length;
                  // Automatic ordering of features would require to shift feature indexes in the script list.
                  check.assert(
                    index === 0 ||
                      feature >=
                        allFeatures[index - 1]
                          .tag,
                    "Features must be added in alphabetical order."
                  );
                  featureRecord = {
                    tag: feature,
                    feature: {
                      params: 0,
                      lookupListIndexes: [],
                    },
                  };
                  allFeatures.push(featureRecord);
                  featIndexes.push(index);
                  return featureRecord.feature;
                }
              }
            },

            /**
             * Get the lookup tables of a given type for a script/language/feature.
             * @instance
             * @param {string} [script='DFLT']
             * @param {string} [language='dlft']
             * @param {string} feature - 4-letter feature code
             * @param {number} lookupType - 1 to 9
             * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
             * @return {Object[]}
             */
            getLookupTables: function (
              script,
              language,
              feature,
              lookupType,
              create
            ) {
              var featureTable =
                this.getFeatureTable(
                  script,
                  language,
                  feature,
                  create
                );
              var tables = [];
              if (featureTable) {
                var lookupTable;
                var lookupListIndexes =
                  featureTable.lookupListIndexes;
                var allLookups =
                  this.font.tables[this.tableName]
                    .lookups;
                // lookupListIndexes are in no particular order, so use naive search.
                for (
                  var i = 0;
                  i < lookupListIndexes.length;
                  i++
                ) {
                  lookupTable =
                    allLookups[
                      lookupListIndexes[i]
                    ];
                  if (
                    lookupTable.lookupType ===
                    lookupType
                  ) {
                    tables.push(lookupTable);
                  }
                }
                if (
                  tables.length === 0 &&
                  create
                ) {
                  lookupTable = {
                    lookupType: lookupType,
                    lookupFlag: 0,
                    subtables: [],
                    markFilteringSet: undefined,
                  };
                  var index = allLookups.length;
                  allLookups.push(lookupTable);
                  lookupListIndexes.push(index);
                  return [lookupTable];
                }
              }
              return tables;
            },

            /**
             * Find a glyph in a class definition table
             * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
             * @param {object} classDefTable - an OpenType Layout class definition table
             * @param {number} glyphIndex - the index of the glyph to find
             * @returns {number} -1 if not found
             */
            getGlyphClass: function (
              classDefTable,
              glyphIndex
            ) {
              switch (classDefTable.format) {
                case 1:
                  if (
                    classDefTable.startGlyph <=
                      glyphIndex &&
                    glyphIndex <
                      classDefTable.startGlyph +
                        classDefTable.classes
                          .length
                  ) {
                    return classDefTable.classes[
                      glyphIndex -
                        classDefTable.startGlyph
                    ];
                  }
                  return 0;
                case 2:
                  var range = searchRange(
                    classDefTable.ranges,
                    glyphIndex
                  );
                  return range
                    ? range.classId
                    : 0;
              }
            },

            /**
             * Find a glyph in a coverage table
             * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
             * @param {object} coverageTable - an OpenType Layout coverage table
             * @param {number} glyphIndex - the index of the glyph to find
             * @returns {number} -1 if not found
             */
            getCoverageIndex: function (
              coverageTable,
              glyphIndex
            ) {
              switch (coverageTable.format) {
                case 1:
                  var index = binSearch(
                    coverageTable.glyphs,
                    glyphIndex
                  );
                  return index >= 0 ? index : -1;
                case 2:
                  var range = searchRange(
                    coverageTable.ranges,
                    glyphIndex
                  );
                  return range
                    ? range.index +
                        glyphIndex -
                        range.start
                    : -1;
              }
            },

            /**
             * Returns the list of glyph indexes of a coverage table.
             * Format 1: the list is stored raw
             * Format 2: compact list as range records.
             * @instance
             * @param  {Object} coverageTable
             * @return {Array}
             */
            expandCoverage: function (
              coverageTable
            ) {
              if (coverageTable.format === 1) {
                return coverageTable.glyphs;
              } else {
                var glyphs = [];
                var ranges = coverageTable.ranges;
                for (
                  var i = 0;
                  i < ranges.length;
                  i++
                ) {
                  var range = ranges[i];
                  var start = range.start;
                  var end = range.end;
                  for (
                    var j = start;
                    j <= end;
                    j++
                  ) {
                    glyphs.push(j);
                  }
                }
                return glyphs;
              }
            },
          };

          // The Position object provides utility methods to manipulate

          /**
           * @exports opentype.Position
           * @class
           * @extends opentype.Layout
           * @param {opentype.Font}
           * @constructor
           */
          function Position(font) {
            Layout.call(this, font, "gpos");
          }

          Position.prototype = Layout.prototype;

          /**
           * Init some data for faster and easier access later.
           */
          Position.prototype.init = function () {
            var script =
              this.getDefaultScriptName();
            this.defaultKerningTables =
              this.getKerningTables(script);
          };

          /**
           * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
           *
           * @param {integer} leftIndex - left glyph index
           * @param {integer} rightIndex - right glyph index
           * @returns {integer}
           */
          Position.prototype.getKerningValue =
            function (
              kerningLookups,
              leftIndex,
              rightIndex
            ) {
              var this$1 = this;

              for (
                var i = 0;
                i < kerningLookups.length;
                i++
              ) {
                var subtables =
                  kerningLookups[i].subtables;
                for (
                  var j = 0;
                  j < subtables.length;
                  j++
                ) {
                  var subtable = subtables[j];
                  var covIndex =
                    this$1.getCoverageIndex(
                      subtable.coverage,
                      leftIndex
                    );
                  if (covIndex < 0) {
                    continue;
                  }
                  switch (subtable.posFormat) {
                    case 1:
                      // Search Pair Adjustment Positioning Format 1
                      var pairSet =
                        subtable.pairSets[
                          covIndex
                        ];
                      for (
                        var k = 0;
                        k < pairSet.length;
                        k++
                      ) {
                        var pair = pairSet[k];
                        if (
                          pair.secondGlyph ===
                          rightIndex
                        ) {
                          return (
                            (pair.value1 &&
                              pair.value1
                                .xAdvance) ||
                            0
                          );
                        }
                      }
                      break; // left glyph found, not right glyph - try next subtable
                    case 2:
                      // Search Pair Adjustment Positioning Format 2
                      var class1 =
                        this$1.getGlyphClass(
                          subtable.classDef1,
                          leftIndex
                        );
                      var class2 =
                        this$1.getGlyphClass(
                          subtable.classDef2,
                          rightIndex
                        );
                      var pair$1 =
                        subtable.classRecords[
                          class1
                        ][class2];
                      return (
                        (pair$1.value1 &&
                          pair$1.value1
                            .xAdvance) ||
                        0
                      );
                  }
                }
              }
              return 0;
            };

          /**
           * List all kerning lookup tables.
           *
           * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
           * @param {string} [language='dflt']
           * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
           */
          Position.prototype.getKerningTables =
            function (script, language) {
              if (this.font.tables.gpos) {
                return this.getLookupTables(
                  script,
                  language,
                  "kern",
                  2
                );
              }
            };

          // The Substitution object provides utility methods to manipulate

          /**
           * @exports opentype.Substitution
           * @class
           * @extends opentype.Layout
           * @param {opentype.Font}
           * @constructor
           */
          function Substitution(font) {
            Layout.call(this, font, "gsub");
          }

          // Check if 2 arrays of primitives are equal.
          function arraysEqual(ar1, ar2) {
            var n = ar1.length;
            if (n !== ar2.length) {
              return false;
            }
            for (var i = 0; i < n; i++) {
              if (ar1[i] !== ar2[i]) {
                return false;
              }
            }
            return true;
          }

          // Find the first subtable of a lookup table in a particular format.
          function getSubstFormat(
            lookupTable,
            format,
            defaultSubtable
          ) {
            var subtables = lookupTable.subtables;
            for (
              var i = 0;
              i < subtables.length;
              i++
            ) {
              var subtable = subtables[i];
              if (
                subtable.substFormat === format
              ) {
                return subtable;
              }
            }
            if (defaultSubtable) {
              subtables.push(defaultSubtable);
              return defaultSubtable;
            }
            return undefined;
          }

          Substitution.prototype =
            Layout.prototype;

          /**
           * Create a default GSUB table.
           * @return {Object} gsub - The GSUB table.
           */
          Substitution.prototype.createDefaultTable =
            function () {
              // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
              return {
                version: 1,
                scripts: [
                  {
                    tag: "DFLT",
                    script: {
                      defaultLangSys: {
                        reserved: 0,
                        reqFeatureIndex: 0xffff,
                        featureIndexes: [],
                      },
                      langSysRecords: [],
                    },
                  },
                ],
                features: [],
                lookups: [],
              };
            };

          /**
           * List all single substitutions (lookup type 1) for a given script, language, and feature.
           * @param {string} [script='DFLT']
           * @param {string} [language='dflt']
           * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
           * @return {Array} substitutions - The list of substitutions.
           */
          Substitution.prototype.getSingle =
            function (feature, script, language) {
              var this$1 = this;

              var substitutions = [];
              var lookupTables =
                this.getLookupTables(
                  script,
                  language,
                  feature,
                  1
                );
              for (
                var idx = 0;
                idx < lookupTables.length;
                idx++
              ) {
                var subtables =
                  lookupTables[idx].subtables;
                for (
                  var i = 0;
                  i < subtables.length;
                  i++
                ) {
                  var subtable = subtables[i];
                  var glyphs =
                    this$1.expandCoverage(
                      subtable.coverage
                    );
                  var j = void 0;
                  if (
                    subtable.substFormat === 1
                  ) {
                    var delta =
                      subtable.deltaGlyphId;
                    for (
                      j = 0;
                      j < glyphs.length;
                      j++
                    ) {
                      var glyph = glyphs[j];
                      substitutions.push({
                        sub: glyph,
                        by: glyph + delta,
                      });
                    }
                  } else {
                    var substitute =
                      subtable.substitute;
                    for (
                      j = 0;
                      j < glyphs.length;
                      j++
                    ) {
                      substitutions.push({
                        sub: glyphs[j],
                        by: substitute[j],
                      });
                    }
                  }
                }
              }
              return substitutions;
            };

          /**
           * List all alternates (lookup type 3) for a given script, language, and feature.
           * @param {string} [script='DFLT']
           * @param {string} [language='dflt']
           * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
           * @return {Array} alternates - The list of alternates
           */
          Substitution.prototype.getAlternates =
            function (feature, script, language) {
              var this$1 = this;

              var alternates = [];
              var lookupTables =
                this.getLookupTables(
                  script,
                  language,
                  feature,
                  3
                );
              for (
                var idx = 0;
                idx < lookupTables.length;
                idx++
              ) {
                var subtables =
                  lookupTables[idx].subtables;
                for (
                  var i = 0;
                  i < subtables.length;
                  i++
                ) {
                  var subtable = subtables[i];
                  var glyphs =
                    this$1.expandCoverage(
                      subtable.coverage
                    );
                  var alternateSets =
                    subtable.alternateSets;
                  for (
                    var j = 0;
                    j < glyphs.length;
                    j++
                  ) {
                    alternates.push({
                      sub: glyphs[j],
                      by: alternateSets[j],
                    });
                  }
                }
              }
              return alternates;
            };

          /**
           * List all ligatures (lookup type 4) for a given script, language, and feature.
           * The result is an array of ligature objects like { sub: [ids], by: id }
           * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
           * @param {string} [script='DFLT']
           * @param {string} [language='dflt']
           * @return {Array} ligatures - The list of ligatures.
           */
          Substitution.prototype.getLigatures =
            function (feature, script, language) {
              var this$1 = this;

              var ligatures = [];
              var lookupTables =
                this.getLookupTables(
                  script,
                  language,
                  feature,
                  4
                );
              for (
                var idx = 0;
                idx < lookupTables.length;
                idx++
              ) {
                var subtables =
                  lookupTables[idx].subtables;
                for (
                  var i = 0;
                  i < subtables.length;
                  i++
                ) {
                  var subtable = subtables[i];
                  var glyphs =
                    this$1.expandCoverage(
                      subtable.coverage
                    );
                  var ligatureSets =
                    subtable.ligatureSets;
                  for (
                    var j = 0;
                    j < glyphs.length;
                    j++
                  ) {
                    var startGlyph = glyphs[j];
                    var ligSet = ligatureSets[j];
                    for (
                      var k = 0;
                      k < ligSet.length;
                      k++
                    ) {
                      var lig = ligSet[k];
                      ligatures.push({
                        sub: [startGlyph].concat(
                          lig.components
                        ),
                        by: lig.ligGlyph,
                      });
                    }
                  }
                }
              }
              return ligatures;
            };

          /**
           * Add or modify a single substitution (lookup type 1)
           * Format 2, more flexible, is always used.
           * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
           * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
           * @param {string} [script='DFLT']
           * @param {string} [language='dflt']
           */
          Substitution.prototype.addSingle =
            function (
              feature,
              substitution,
              script,
              language
            ) {
              var lookupTable =
                this.getLookupTables(
                  script,
                  language,
                  feature,
                  1,
                  true
                )[0];
              var subtable = getSubstFormat(
                lookupTable,
                2,
                {
                  // lookup type 1 subtable, format 2, coverage format 1
                  substFormat: 2,
                  coverage: {
                    format: 1,
                    glyphs: [],
                  },
                  substitute: [],
                }
              );
              check.assert(
                subtable.coverage.format === 1,
                "Ligature: unable to modify coverage table format " +
                  subtable.coverage.format
              );
              var coverageGlyph =
                substitution.sub;
              var pos = this.binSearch(
                subtable.coverage.glyphs,
                coverageGlyph
              );
              if (pos < 0) {
                pos = -1 - pos;
                subtable.coverage.glyphs.splice(
                  pos,
                  0,
                  coverageGlyph
                );
                subtable.substitute.splice(
                  pos,
                  0,
                  0
                );
              }
              subtable.substitute[pos] =
                substitution.by;
            };

          /**
           * Add or modify an alternate substitution (lookup type 1)
           * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
           * @param {Object} substitution - { sub: id, by: [ids] }
           * @param {string} [script='DFLT']
           * @param {string} [language='dflt']
           */
          Substitution.prototype.addAlternate =
            function (
              feature,
              substitution,
              script,
              language
            ) {
              var lookupTable =
                this.getLookupTables(
                  script,
                  language,
                  feature,
                  3,
                  true
                )[0];
              var subtable = getSubstFormat(
                lookupTable,
                1,
                {
                  // lookup type 3 subtable, format 1, coverage format 1
                  substFormat: 1,
                  coverage: {
                    format: 1,
                    glyphs: [],
                  },
                  alternateSets: [],
                }
              );
              check.assert(
                subtable.coverage.format === 1,
                "Ligature: unable to modify coverage table format " +
                  subtable.coverage.format
              );
              var coverageGlyph =
                substitution.sub;
              var pos = this.binSearch(
                subtable.coverage.glyphs,
                coverageGlyph
              );
              if (pos < 0) {
                pos = -1 - pos;
                subtable.coverage.glyphs.splice(
                  pos,
                  0,
                  coverageGlyph
                );
                subtable.alternateSets.splice(
                  pos,
                  0,
                  0
                );
              }
              subtable.alternateSets[pos] =
                substitution.by;
            };

          /**
           * Add a ligature (lookup type 4)
           * Ligatures with more components must be stored ahead of those with fewer components in order to be found
           * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
           * @param {Object} ligature - { sub: [ids], by: id }
           * @param {string} [script='DFLT']
           * @param {string} [language='dflt']
           */
          Substitution.prototype.addLigature =
            function (
              feature,
              ligature,
              script,
              language
            ) {
              var lookupTable =
                this.getLookupTables(
                  script,
                  language,
                  feature,
                  4,
                  true
                )[0];
              var subtable =
                lookupTable.subtables[0];
              if (!subtable) {
                subtable = {
                  // lookup type 4 subtable, format 1, coverage format 1
                  substFormat: 1,
                  coverage: {
                    format: 1,
                    glyphs: [],
                  },
                  ligatureSets: [],
                };
                lookupTable.subtables[0] =
                  subtable;
              }
              check.assert(
                subtable.coverage.format === 1,
                "Ligature: unable to modify coverage table format " +
                  subtable.coverage.format
              );
              var coverageGlyph = ligature.sub[0];
              var ligComponents =
                ligature.sub.slice(1);
              var ligatureTable = {
                ligGlyph: ligature.by,
                components: ligComponents,
              };
              var pos = this.binSearch(
                subtable.coverage.glyphs,
                coverageGlyph
              );
              if (pos >= 0) {
                // ligatureSet already exists
                var ligatureSet =
                  subtable.ligatureSets[pos];
                for (
                  var i = 0;
                  i < ligatureSet.length;
                  i++
                ) {
                  // If ligature already exists, return.
                  if (
                    arraysEqual(
                      ligatureSet[i].components,
                      ligComponents
                    )
                  ) {
                    return;
                  }
                }
                // ligature does not exist: add it.
                ligatureSet.push(ligatureTable);
              } else {
                // Create a new ligatureSet and add coverage for the first glyph.
                pos = -1 - pos;
                subtable.coverage.glyphs.splice(
                  pos,
                  0,
                  coverageGlyph
                );
                subtable.ligatureSets.splice(
                  pos,
                  0,
                  [ligatureTable]
                );
              }
            };

          /**
           * List all feature data for a given script and language.
           * @param {string} feature - 4-letter feature name
           * @param {string} [script='DFLT']
           * @param {string} [language='dflt']
           * @return {Array} substitutions - The list of substitutions.
           */
          Substitution.prototype.getFeature =
            function (feature, script, language) {
              if (/ss\d\d/.test(feature)) {
                // ss01 - ss20
                return this.getSingle(
                  feature,
                  script,
                  language
                );
              }
              switch (feature) {
                case "aalt":
                case "salt":
                  return this.getSingle(
                    feature,
                    script,
                    language
                  ).concat(
                    this.getAlternates(
                      feature,
                      script,
                      language
                    )
                  );
                case "dlig":
                case "liga":
                case "rlig":
                  return this.getLigatures(
                    feature,
                    script,
                    language
                  );
              }
              return undefined;
            };

          /**
           * Add a substitution to a feature for a given script and language.
           * @param {string} feature - 4-letter feature name
           * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
           * @param {string} [script='DFLT']
           * @param {string} [language='dflt']
           */
          Substitution.prototype.add = function (
            feature,
            sub,
            script,
            language
          ) {
            if (/ss\d\d/.test(feature)) {
              // ss01 - ss20
              return this.addSingle(
                feature,
                sub,
                script,
                language
              );
            }
            switch (feature) {
              case "aalt":
              case "salt":
                if (typeof sub.by === "number") {
                  return this.addSingle(
                    feature,
                    sub,
                    script,
                    language
                  );
                }
                return this.addAlternate(
                  feature,
                  sub,
                  script,
                  language
                );
              case "dlig":
              case "liga":
              case "rlig":
                return this.addLigature(
                  feature,
                  sub,
                  script,
                  language
                );
            }
            return undefined;
          };

          function isBrowser() {
            return typeof window !== "undefined";
          }

          function nodeBufferToArrayBuffer(
            buffer
          ) {
            var ab = new ArrayBuffer(
              buffer.length
            );
            var view = new Uint8Array(ab);
            for (
              var i = 0;
              i < buffer.length;
              ++i
            ) {
              view[i] = buffer[i];
            }

            return ab;
          }

          function arrayBufferToNodeBuffer(ab) {
            var buffer = new Buffer(
              ab.byteLength
            );
            var view = new Uint8Array(ab);
            for (
              var i = 0;
              i < buffer.length;
              ++i
            ) {
              buffer[i] = view[i];
            }

            return buffer;
          }

          function checkArgument(
            expression,
            message
          ) {
            if (!expression) {
              throw message;
            }
          }

          // The `glyf` table describes the glyphs in TrueType outline format.

          // Parse the coordinate data for a glyph.
          function parseGlyphCoordinate(
            p,
            flag,
            previousValue,
            shortVectorBitMask,
            sameBitMask
          ) {
            var v;
            if ((flag & shortVectorBitMask) > 0) {
              // The coordinate is 1 byte long.
              v = p.parseByte();
              // The `same` bit is re-used for short values to signify the sign of the value.
              if ((flag & sameBitMask) === 0) {
                v = -v;
              }

              v = previousValue + v;
            } else {
              //  The coordinate is 2 bytes long.
              // If the `same` bit is set, the coordinate is the same as the previous coordinate.
              if ((flag & sameBitMask) > 0) {
                v = previousValue;
              } else {
                // Parse the coordinate as a signed 16-bit delta value.
                v =
                  previousValue + p.parseShort();
              }
            }

            return v;
          }

          // Parse a TrueType glyph.
          function parseGlyph(
            glyph,
            data,
            start
          ) {
            var p = new parse.Parser(data, start);
            glyph.numberOfContours =
              p.parseShort();
            glyph._xMin = p.parseShort();
            glyph._yMin = p.parseShort();
            glyph._xMax = p.parseShort();
            glyph._yMax = p.parseShort();
            var flags;
            var flag;

            if (glyph.numberOfContours > 0) {
              // This glyph is not a composite.
              var endPointIndices =
                (glyph.endPointIndices = []);
              for (
                var i = 0;
                i < glyph.numberOfContours;
                i += 1
              ) {
                endPointIndices.push(
                  p.parseUShort()
                );
              }

              glyph.instructionLength =
                p.parseUShort();
              glyph.instructions = [];
              for (
                var i$1 = 0;
                i$1 < glyph.instructionLength;
                i$1 += 1
              ) {
                glyph.instructions.push(
                  p.parseByte()
                );
              }

              var numberOfCoordinates =
                endPointIndices[
                  endPointIndices.length - 1
                ] + 1;
              flags = [];
              for (
                var i$2 = 0;
                i$2 < numberOfCoordinates;
                i$2 += 1
              ) {
                flag = p.parseByte();
                flags.push(flag);
                // If bit 3 is set, we repeat this flag n times, where n is the next byte.
                if ((flag & 8) > 0) {
                  var repeatCount = p.parseByte();
                  for (
                    var j = 0;
                    j < repeatCount;
                    j += 1
                  ) {
                    flags.push(flag);
                    i$2 += 1;
                  }
                }
              }

              check.argument(
                flags.length ===
                  numberOfCoordinates,
                "Bad flags."
              );

              if (endPointIndices.length > 0) {
                var points = [];
                var point;
                // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
                if (numberOfCoordinates > 0) {
                  for (
                    var i$3 = 0;
                    i$3 < numberOfCoordinates;
                    i$3 += 1
                  ) {
                    flag = flags[i$3];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour =
                      endPointIndices.indexOf(
                        i$3
                      ) >= 0;
                    points.push(point);
                  }

                  var px = 0;
                  for (
                    var i$4 = 0;
                    i$4 < numberOfCoordinates;
                    i$4 += 1
                  ) {
                    flag = flags[i$4];
                    point = points[i$4];
                    point.x =
                      parseGlyphCoordinate(
                        p,
                        flag,
                        px,
                        2,
                        16
                      );
                    px = point.x;
                  }

                  var py = 0;
                  for (
                    var i$5 = 0;
                    i$5 < numberOfCoordinates;
                    i$5 += 1
                  ) {
                    flag = flags[i$5];
                    point = points[i$5];
                    point.y =
                      parseGlyphCoordinate(
                        p,
                        flag,
                        py,
                        4,
                        32
                      );
                    py = point.y;
                  }
                }

                glyph.points = points;
              } else {
                glyph.points = [];
              }
            } else if (
              glyph.numberOfContours === 0
            ) {
              glyph.points = [];
            } else {
              glyph.isComposite = true;
              glyph.points = [];
              glyph.components = [];
              var moreComponents = true;
              while (moreComponents) {
                flags = p.parseUShort();
                var component = {
                  glyphIndex: p.parseUShort(),
                  xScale: 1,
                  scale01: 0,
                  scale10: 0,
                  yScale: 1,
                  dx: 0,
                  dy: 0,
                };
                if ((flags & 1) > 0) {
                  // The arguments are words
                  if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseShort();
                    component.dy = p.parseShort();
                  } else {
                    // values are matched points
                    component.matchedPoints = [
                      p.parseUShort(),
                      p.parseUShort(),
                    ];
                  }
                } else {
                  // The arguments are bytes
                  if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseChar();
                    component.dy = p.parseChar();
                  } else {
                    // values are matched points
                    component.matchedPoints = [
                      p.parseByte(),
                      p.parseByte(),
                    ];
                  }
                }

                if ((flags & 8) > 0) {
                  // We have a scale
                  component.xScale =
                    component.yScale =
                      p.parseF2Dot14();
                } else if ((flags & 64) > 0) {
                  // We have an X / Y scale
                  component.xScale =
                    p.parseF2Dot14();
                  component.yScale =
                    p.parseF2Dot14();
                } else if ((flags & 128) > 0) {
                  // We have a 2x2 transformation
                  component.xScale =
                    p.parseF2Dot14();
                  component.scale01 =
                    p.parseF2Dot14();
                  component.scale10 =
                    p.parseF2Dot14();
                  component.yScale =
                    p.parseF2Dot14();
                }

                glyph.components.push(component);
                moreComponents = !!(flags & 32);
              }
              if (flags & 0x100) {
                // We have instructions
                glyph.instructionLength =
                  p.parseUShort();
                glyph.instructions = [];
                for (
                  var i$6 = 0;
                  i$6 < glyph.instructionLength;
                  i$6 += 1
                ) {
                  glyph.instructions.push(
                    p.parseByte()
                  );
                }
              }
            }
          }

          // Transform an array of points and return a new array.
          function transformPoints(
            points,
            transform
          ) {
            var newPoints = [];
            for (
              var i = 0;
              i < points.length;
              i += 1
            ) {
              var pt = points[i];
              var newPt = {
                x:
                  transform.xScale * pt.x +
                  transform.scale01 * pt.y +
                  transform.dx,
                y:
                  transform.scale10 * pt.x +
                  transform.yScale * pt.y +
                  transform.dy,
                onCurve: pt.onCurve,
                lastPointOfContour:
                  pt.lastPointOfContour,
              };
              newPoints.push(newPt);
            }

            return newPoints;
          }

          function getContours(points) {
            var contours = [];
            var currentContour = [];
            for (
              var i = 0;
              i < points.length;
              i += 1
            ) {
              var pt = points[i];
              currentContour.push(pt);
              if (pt.lastPointOfContour) {
                contours.push(currentContour);
                currentContour = [];
              }
            }

            check.argument(
              currentContour.length === 0,
              "There are still points left in the current contour."
            );
            return contours;
          }

          // Convert the TrueType glyph outline to a Path.
          function getPath(points) {
            var p = new Path();
            if (!points) {
              return p;
            }

            var contours = getContours(points);

            for (
              var contourIndex = 0;
              contourIndex < contours.length;
              ++contourIndex
            ) {
              var contour =
                contours[contourIndex];

              var prev = null;
              var curr =
                contour[contour.length - 1];
              var next = contour[0];

              if (curr.onCurve) {
                p.moveTo(curr.x, curr.y);
              } else {
                if (next.onCurve) {
                  p.moveTo(next.x, next.y);
                } else {
                  // If both first and last points are off-curve, start at their middle.
                  var start = {
                    x: (curr.x + next.x) * 0.5,
                    y: (curr.y + next.y) * 0.5,
                  };
                  p.moveTo(start.x, start.y);
                }
              }

              for (
                var i = 0;
                i < contour.length;
                ++i
              ) {
                prev = curr;
                curr = next;
                next =
                  contour[
                    (i + 1) % contour.length
                  ];

                if (curr.onCurve) {
                  // This is a straight line.
                  p.lineTo(curr.x, curr.y);
                } else {
                  var prev2 = prev;
                  var next2 = next;

                  if (!prev.onCurve) {
                    prev2 = {
                      x: (curr.x + prev.x) * 0.5,
                      y: (curr.y + prev.y) * 0.5,
                    };
                  }

                  if (!next.onCurve) {
                    next2 = {
                      x: (curr.x + next.x) * 0.5,
                      y: (curr.y + next.y) * 0.5,
                    };
                  }

                  p.quadraticCurveTo(
                    curr.x,
                    curr.y,
                    next2.x,
                    next2.y
                  );
                }
              }

              p.closePath();
            }
            return p;
          }

          function buildPath(glyphs, glyph) {
            if (glyph.isComposite) {
              for (
                var j = 0;
                j < glyph.components.length;
                j += 1
              ) {
                var component =
                  glyph.components[j];
                var componentGlyph = glyphs.get(
                  component.glyphIndex
                );
                // Force the ttfGlyphLoader to parse the glyph.
                componentGlyph.getPath();
                if (componentGlyph.points) {
                  var transformedPoints = void 0;
                  if (
                    component.matchedPoints ===
                    undefined
                  ) {
                    // component positioned by offset
                    transformedPoints =
                      transformPoints(
                        componentGlyph.points,
                        component
                      );
                  } else {
                    // component positioned by matched points
                    if (
                      component.matchedPoints[0] >
                        glyph.points.length - 1 ||
                      component.matchedPoints[1] >
                        componentGlyph.points
                          .length -
                          1
                    ) {
                      throw Error(
                        "Matched points out of range in " +
                          glyph.name
                      );
                    }
                    var firstPt =
                      glyph.points[
                        component.matchedPoints[0]
                      ];
                    var secondPt =
                      componentGlyph.points[
                        component.matchedPoints[1]
                      ];
                    var transform = {
                      xScale: component.xScale,
                      scale01: component.scale01,
                      scale10: component.scale10,
                      yScale: component.yScale,
                      dx: 0,
                      dy: 0,
                    };
                    secondPt = transformPoints(
                      [secondPt],
                      transform
                    )[0];
                    transform.dx =
                      firstPt.x - secondPt.x;
                    transform.dy =
                      firstPt.y - secondPt.y;
                    transformedPoints =
                      transformPoints(
                        componentGlyph.points,
                        transform
                      );
                  }
                  glyph.points =
                    glyph.points.concat(
                      transformedPoints
                    );
                }
              }
            }

            return getPath(glyph.points);
          }

          // Parse all the glyphs according to the offsets from the `loca` table.
          function parseGlyfTable(
            data,
            start,
            loca,
            font
          ) {
            var glyphs = new glyphset.GlyphSet(
              font
            );

            // The last element of the loca table is invalid.
            for (
              var i = 0;
              i < loca.length - 1;
              i += 1
            ) {
              var offset = loca[i];
              var nextOffset = loca[i + 1];
              if (offset !== nextOffset) {
                glyphs.push(
                  i,
                  glyphset.ttfGlyphLoader(
                    font,
                    i,
                    parseGlyph,
                    data,
                    start + offset,
                    buildPath
                  )
                );
              } else {
                glyphs.push(
                  i,
                  glyphset.glyphLoader(font, i)
                );
              }
            }

            return glyphs;
          }

          var glyf = {
            getPath: getPath,
            parse: parseGlyfTable,
          };

          /* A TrueType font hinting interpreter.
           *
           * (c) 2017 Axel Kittenberger
           *
           * This interpreter has been implemented according to this documentation:
           * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
           *
           * According to the documentation F24DOT6 values are used for pixels.
           * That means calculation is 1/64 pixel accurate and uses integer operations.
           * However, Javascript has floating point operations by default and only
           * those are available. One could make a case to simulate the 1/64 accuracy
           * exactly by truncating after every division operation
           * (for example with << 0) to get pixel exactly results as other TrueType
           * implementations. It may make sense since some fonts are pixel optimized
           * by hand using DELTAP instructions. The current implementation doesn't
           * and rather uses full floating point precision.
           *
           * xScale, yScale and rotation is currently ignored.
           *
           * A few non-trivial instructions are missing as I didn't encounter yet
           * a font that used them to test a possible implementation.
           *
           * Some fonts seem to use undocumented features regarding the twilight zone.
           * Only some of them are implemented as they were encountered.
           *
           * The exports.DEBUG statements are removed on the minified distribution file.
           */

          var instructionTable;
          var exec;
          var execGlyph;
          var execComponent;

          /*
           * Creates a hinting object.
           *
           * There ought to be exactly one
           * for each truetype font that is used for hinting.
           */
          function Hinting(font) {
            // the font this hinting object is for
            this.font = font;

            this.getCommands = function (
              hPoints
            ) {
              return glyf.getPath(hPoints)
                .commands;
            };

            // cached states
            this._fpgmState = this._prepState =
              undefined;

            // errorState
            // 0 ... all okay
            // 1 ... had an error in a glyf,
            //       continue working but stop spamming
            //       the console
            // 2 ... error at prep, stop hinting at this ppem
            // 3 ... error at fpeg, stop hinting for this font at all
            this._errorState = 0;
          }

          /*
           * Not rounding.
           */
          function roundOff(v) {
            return v;
          }

          /*
           * Rounding to grid.
           */
          function roundToGrid(v) {
            //Rounding in TT is supposed to "symmetrical around zero"
            return (
              Math.sign(v) *
              Math.round(Math.abs(v))
            );
          }

          /*
           * Rounding to double grid.
           */
          function roundToDoubleGrid(v) {
            return (
              (Math.sign(v) *
                Math.round(Math.abs(v * 2))) /
              2
            );
          }

          /*
           * Rounding to half grid.
           */
          function roundToHalfGrid(v) {
            return (
              Math.sign(v) *
              (Math.round(Math.abs(v) + 0.5) -
                0.5)
            );
          }

          /*
           * Rounding to up to grid.
           */
          function roundUpToGrid(v) {
            return (
              Math.sign(v) *
              Math.ceil(Math.abs(v))
            );
          }

          /*
           * Rounding to down to grid.
           */
          function roundDownToGrid(v) {
            return (
              Math.sign(v) *
              Math.floor(Math.abs(v))
            );
          }

          /*
           * Super rounding.
           */
          var roundSuper = function (v) {
            var period = this.srPeriod;
            var phase = this.srPhase;
            var threshold = this.srThreshold;
            var sign = 1;

            if (v < 0) {
              v = -v;
              sign = -1;
            }

            v += threshold - phase;

            v = Math.trunc(v / period) * period;

            v += phase;

            // according to http://xgridfit.sourceforge.net/round.html
            if (v < 0) {
              return phase * sign;
            }

            return v * sign;
          };

          /*
           * Unit vector of x-axis.
           */
          var xUnitVector = {
            x: 1,

            y: 0,

            axis: "x",

            // Gets the projected distance between two points.
            // o1/o2 ... if true, respective original position is used.
            distance: function (p1, p2, o1, o2) {
              return (
                (o1 ? p1.xo : p1.x) -
                (o2 ? p2.xo : p2.x)
              );
            },

            // Moves point p so the moved position has the same relative
            // position to the moved positions of rp1 and rp2 than the
            // original positions had.
            //
            // See APPENDIX on INTERPOLATE at the bottom of this file.
            interpolate: function (
              p,
              rp1,
              rp2,
              pv
            ) {
              var do1;
              var do2;
              var doa1;
              var doa2;
              var dm1;
              var dm2;
              var dt;

              if (!pv || pv === this) {
                do1 = p.xo - rp1.xo;
                do2 = p.xo - rp2.xo;
                dm1 = rp1.x - rp1.xo;
                dm2 = rp2.x - rp2.xo;
                doa1 = Math.abs(do1);
                doa2 = Math.abs(do2);
                dt = doa1 + doa2;

                if (dt === 0) {
                  p.x = p.xo + (dm1 + dm2) / 2;
                  return;
                }

                p.x =
                  p.xo +
                  (dm1 * doa2 + dm2 * doa1) / dt;
                return;
              }

              do1 = pv.distance(
                p,
                rp1,
                true,
                true
              );
              do2 = pv.distance(
                p,
                rp2,
                true,
                true
              );
              dm1 = pv.distance(
                rp1,
                rp1,
                false,
                true
              );
              dm2 = pv.distance(
                rp2,
                rp2,
                false,
                true
              );
              doa1 = Math.abs(do1);
              doa2 = Math.abs(do2);
              dt = doa1 + doa2;

              if (dt === 0) {
                xUnitVector.setRelative(
                  p,
                  p,
                  (dm1 + dm2) / 2,
                  pv,
                  true
                );
                return;
              }

              xUnitVector.setRelative(
                p,
                p,
                (dm1 * doa2 + dm2 * doa1) / dt,
                pv,
                true
              );
            },

            // Slope of line normal to this
            normalSlope: Number.NEGATIVE_INFINITY,

            // Sets the point 'p' relative to point 'rp'
            // by the distance 'd'.
            //
            // See APPENDIX on SETRELATIVE at the bottom of this file.
            //
            // p   ... point to set
            // rp  ... reference point
            // d   ... distance on projection vector
            // pv  ... projection vector (undefined = this)
            // org ... if true, uses the original position of rp as reference.
            setRelative: function (
              p,
              rp,
              d,
              pv,
              org
            ) {
              if (!pv || pv === this) {
                p.x = (org ? rp.xo : rp.x) + d;
                return;
              }

              var rpx = org ? rp.xo : rp.x;
              var rpy = org ? rp.yo : rp.y;
              var rpdx = rpx + d * pv.x;
              var rpdy = rpy + d * pv.y;

              p.x =
                rpdx +
                (p.y - rpdy) / pv.normalSlope;
            },

            // Slope of vector line.
            slope: 0,

            // Touches the point p.
            touch: function (p) {
              p.xTouched = true;
            },

            // Tests if a point p is touched.
            touched: function (p) {
              return p.xTouched;
            },

            // Untouches the point p.
            untouch: function (p) {
              p.xTouched = false;
            },
          };

          /*
           * Unit vector of y-axis.
           */
          var yUnitVector = {
            x: 0,

            y: 1,

            axis: "y",

            // Gets the projected distance between two points.
            // o1/o2 ... if true, respective original position is used.
            distance: function (p1, p2, o1, o2) {
              return (
                (o1 ? p1.yo : p1.y) -
                (o2 ? p2.yo : p2.y)
              );
            },

            // Moves point p so the moved position has the same relative
            // position to the moved positions of rp1 and rp2 than the
            // original positions had.
            //
            // See APPENDIX on INTERPOLATE at the bottom of this file.
            interpolate: function (
              p,
              rp1,
              rp2,
              pv
            ) {
              var do1;
              var do2;
              var doa1;
              var doa2;
              var dm1;
              var dm2;
              var dt;

              if (!pv || pv === this) {
                do1 = p.yo - rp1.yo;
                do2 = p.yo - rp2.yo;
                dm1 = rp1.y - rp1.yo;
                dm2 = rp2.y - rp2.yo;
                doa1 = Math.abs(do1);
                doa2 = Math.abs(do2);
                dt = doa1 + doa2;

                if (dt === 0) {
                  p.y = p.yo + (dm1 + dm2) / 2;
                  return;
                }

                p.y =
                  p.yo +
                  (dm1 * doa2 + dm2 * doa1) / dt;
                return;
              }

              do1 = pv.distance(
                p,
                rp1,
                true,
                true
              );
              do2 = pv.distance(
                p,
                rp2,
                true,
                true
              );
              dm1 = pv.distance(
                rp1,
                rp1,
                false,
                true
              );
              dm2 = pv.distance(
                rp2,
                rp2,
                false,
                true
              );
              doa1 = Math.abs(do1);
              doa2 = Math.abs(do2);
              dt = doa1 + doa2;

              if (dt === 0) {
                yUnitVector.setRelative(
                  p,
                  p,
                  (dm1 + dm2) / 2,
                  pv,
                  true
                );
                return;
              }

              yUnitVector.setRelative(
                p,
                p,
                (dm1 * doa2 + dm2 * doa1) / dt,
                pv,
                true
              );
            },

            // Slope of line normal to this.
            normalSlope: 0,

            // Sets the point 'p' relative to point 'rp'
            // by the distance 'd'
            //
            // See APPENDIX on SETRELATIVE at the bottom of this file.
            //
            // p   ... point to set
            // rp  ... reference point
            // d   ... distance on projection vector
            // pv  ... projection vector (undefined = this)
            // org ... if true, uses the original position of rp as reference.
            setRelative: function (
              p,
              rp,
              d,
              pv,
              org
            ) {
              if (!pv || pv === this) {
                p.y = (org ? rp.yo : rp.y) + d;
                return;
              }

              var rpx = org ? rp.xo : rp.x;
              var rpy = org ? rp.yo : rp.y;
              var rpdx = rpx + d * pv.x;
              var rpdy = rpy + d * pv.y;

              p.y =
                rpdy +
                pv.normalSlope * (p.x - rpdx);
            },

            // Slope of vector line.
            slope: Number.POSITIVE_INFINITY,

            // Touches the point p.
            touch: function (p) {
              p.yTouched = true;
            },

            // Tests if a point p is touched.
            touched: function (p) {
              return p.yTouched;
            },

            // Untouches the point p.
            untouch: function (p) {
              p.yTouched = false;
            },
          };

          Object.freeze(xUnitVector);
          Object.freeze(yUnitVector);

          /*
           * Creates a unit vector that is not x- or y-axis.
           */
          function UnitVector(x, y) {
            this.x = x;
            this.y = y;
            this.axis = undefined;
            this.slope = y / x;
            this.normalSlope = -x / y;
            Object.freeze(this);
          }

          /*
           * Gets the projected distance between two points.
           * o1/o2 ... if true, respective original position is used.
           */
          UnitVector.prototype.distance =
            function (p1, p2, o1, o2) {
              return (
                this.x *
                  xUnitVector.distance(
                    p1,
                    p2,
                    o1,
                    o2
                  ) +
                this.y *
                  yUnitVector.distance(
                    p1,
                    p2,
                    o1,
                    o2
                  )
              );
            };

          /*
           * Moves point p so the moved position has the same relative
           * position to the moved positions of rp1 and rp2 than the
           * original positions had.
           *
           * See APPENDIX on INTERPOLATE at the bottom of this file.
           */
          UnitVector.prototype.interpolate =
            function (p, rp1, rp2, pv) {
              var dm1;
              var dm2;
              var do1;
              var do2;
              var doa1;
              var doa2;
              var dt;

              do1 = pv.distance(
                p,
                rp1,
                true,
                true
              );
              do2 = pv.distance(
                p,
                rp2,
                true,
                true
              );
              dm1 = pv.distance(
                rp1,
                rp1,
                false,
                true
              );
              dm2 = pv.distance(
                rp2,
                rp2,
                false,
                true
              );
              doa1 = Math.abs(do1);
              doa2 = Math.abs(do2);
              dt = doa1 + doa2;

              if (dt === 0) {
                this.setRelative(
                  p,
                  p,
                  (dm1 + dm2) / 2,
                  pv,
                  true
                );
                return;
              }

              this.setRelative(
                p,
                p,
                (dm1 * doa2 + dm2 * doa1) / dt,
                pv,
                true
              );
            };

          /*
           * Sets the point 'p' relative to point 'rp'
           * by the distance 'd'
           *
           * See APPENDIX on SETRELATIVE at the bottom of this file.
           *
           * p   ...  point to set
           * rp  ... reference point
           * d   ... distance on projection vector
           * pv  ... projection vector (undefined = this)
           * org ... if true, uses the original position of rp as reference.
           */
          UnitVector.prototype.setRelative =
            function (p, rp, d, pv, org) {
              pv = pv || this;

              var rpx = org ? rp.xo : rp.x;
              var rpy = org ? rp.yo : rp.y;
              var rpdx = rpx + d * pv.x;
              var rpdy = rpy + d * pv.y;

              var pvns = pv.normalSlope;
              var fvs = this.slope;

              var px = p.x;
              var py = p.y;

              p.x =
                (fvs * px -
                  pvns * rpdx +
                  rpdy -
                  py) /
                (fvs - pvns);
              p.y = fvs * (p.x - px) + py;
            };

          /*
           * Touches the point p.
           */
          UnitVector.prototype.touch = function (
            p
          ) {
            p.xTouched = true;
            p.yTouched = true;
          };

          /*
           * Returns a unit vector with x/y coordinates.
           */
          function getUnitVector(x, y) {
            var d = Math.sqrt(x * x + y * y);

            x /= d;
            y /= d;

            if (x === 1 && y === 0) {
              return xUnitVector;
            } else if (x === 0 && y === 1) {
              return yUnitVector;
            } else {
              return new UnitVector(x, y);
            }
          }

          /*
           * Creates a point in the hinting engine.
           */
          function HPoint(
            x,
            y,
            lastPointOfContour,
            onCurve
          ) {
            this.x = this.xo =
              Math.round(x * 64) / 64; // hinted x value and original x-value
            this.y = this.yo =
              Math.round(y * 64) / 64; // hinted y value and original y-value

            this.lastPointOfContour =
              lastPointOfContour;
            this.onCurve = onCurve;
            this.prevPointOnContour = undefined;
            this.nextPointOnContour = undefined;
            this.xTouched = false;
            this.yTouched = false;

            Object.preventExtensions(this);
          }

          /*
           * Returns the next touched point on the contour.
           *
           * v  ... unit vector to test touch axis.
           */
          HPoint.prototype.nextTouched =
            function (v) {
              var p = this.nextPointOnContour;

              while (
                !v.touched(p) &&
                p !== this
              ) {
                p = p.nextPointOnContour;
              }

              return p;
            };

          /*
           * Returns the previous touched point on the contour
           *
           * v  ... unit vector to test touch axis.
           */
          HPoint.prototype.prevTouched =
            function (v) {
              var p = this.prevPointOnContour;

              while (
                !v.touched(p) &&
                p !== this
              ) {
                p = p.prevPointOnContour;
              }

              return p;
            };

          /*
           * The zero point.
           */
          var HPZero = Object.freeze(
            new HPoint(0, 0)
          );

          /*
           * The default state of the interpreter.
           *
           * Note: Freezing the defaultState and then deriving from it
           * makes the V8 Javascript engine going awkward,
           * so this is avoided, albeit the defaultState shouldn't
           * ever change.
           */
          var defaultState = {
            cvCutIn: 17 / 16, // control value cut in
            deltaBase: 9,
            deltaShift: 0.125,
            loop: 1, // loops some instructions
            minDis: 1, // minimum distance
            autoFlip: true,
          };

          /*
           * The current state of the interpreter.
           *
           * env  ... 'fpgm' or 'prep' or 'glyf'
           * prog ... the program
           */
          function State(env, prog) {
            this.env = env;
            this.stack = [];
            this.prog = prog;

            switch (env) {
              case "glyf":
                this.zp0 =
                  this.zp1 =
                  this.zp2 =
                    1;
                this.rp0 =
                  this.rp1 =
                  this.rp2 =
                    0;
              /* fall through */
              case "prep":
                this.fv =
                  this.pv =
                  this.dpv =
                    xUnitVector;
                this.round = roundToGrid;
            }
          }

          /*
           * Executes a glyph program.
           *
           * This does the hinting for each glyph.
           *
           * Returns an array of moved points.
           *
           * glyph: the glyph to hint
           * ppem: the size the glyph is rendered for
           */
          Hinting.prototype.exec = function (
            glyph,
            ppem
          ) {
            if (typeof ppem !== "number") {
              throw new Error(
                "Point size is not a number!"
              );
            }

            // Received a fatal error, don't do any hinting anymore.
            if (this._errorState > 2) {
              return;
            }

            var font = this.font;
            var prepState = this._prepState;

            if (
              !prepState ||
              prepState.ppem !== ppem
            ) {
              var fpgmState = this._fpgmState;

              if (!fpgmState) {
                // Executes the fpgm state.
                // This is used by fonts to define functions.
                State.prototype = defaultState;

                fpgmState = this._fpgmState =
                  new State(
                    "fpgm",
                    font.tables.fpgm
                  );

                fpgmState.funcs = [];
                fpgmState.font = font;

                if (exports.DEBUG) {
                  console.log("---EXEC FPGM---");
                  fpgmState.step = -1;
                }

                try {
                  exec(fpgmState);
                } catch (e) {
                  console.log(
                    "Hinting error in FPGM:" + e
                  );
                  this._errorState = 3;
                  return;
                }
              }

              // Executes the prep program for this ppem setting.
              // This is used by fonts to set cvt values
              // depending on to be rendered font size.

              State.prototype = fpgmState;
              prepState = this._prepState =
                new State(
                  "prep",
                  font.tables.prep
                );

              prepState.ppem = ppem;

              // Creates a copy of the cvt table
              // and scales it to the current ppem setting.
              var oCvt = font.tables.cvt;
              if (oCvt) {
                var cvt = (prepState.cvt =
                  new Array(oCvt.length));
                var scale =
                  ppem / font.unitsPerEm;
                for (
                  var c = 0;
                  c < oCvt.length;
                  c++
                ) {
                  cvt[c] = oCvt[c] * scale;
                }
              } else {
                prepState.cvt = [];
              }

              if (exports.DEBUG) {
                console.log("---EXEC PREP---");
                prepState.step = -1;
              }

              try {
                exec(prepState);
              } catch (e) {
                if (this._errorState < 2) {
                  console.log(
                    "Hinting error in PREP:" + e
                  );
                }
                this._errorState = 2;
              }
            }

            if (this._errorState > 1) {
              return;
            }

            try {
              return execGlyph(glyph, prepState);
            } catch (e) {
              if (this._errorState < 1) {
                console.log("Hinting error:" + e);
                console.log(
                  "Note: further hinting errors are silenced"
                );
              }
              this._errorState = 1;
              return undefined;
            }
          };

          /*
           * Executes the hinting program for a glyph.
           */
          execGlyph = function (
            glyph,
            prepState
          ) {
            // original point positions
            var xScale =
              prepState.ppem /
              prepState.font.unitsPerEm;
            var yScale = xScale;
            var components = glyph.components;
            var contours;
            var gZone;
            var state;

            State.prototype = prepState;
            if (!components) {
              state = new State(
                "glyf",
                glyph.instructions
              );
              if (exports.DEBUG) {
                console.log("---EXEC GLYPH---");
                state.step = -1;
              }
              execComponent(
                glyph,
                state,
                xScale,
                yScale
              );
              gZone = state.gZone;
            } else {
              var font = prepState.font;
              gZone = [];
              contours = [];
              for (
                var i = 0;
                i < components.length;
                i++
              ) {
                var c = components[i];
                var cg = font.glyphs.get(
                  c.glyphIndex
                );

                state = new State(
                  "glyf",
                  cg.instructions
                );

                if (exports.DEBUG) {
                  console.log(
                    "---EXEC COMP " + i + "---"
                  );
                  state.step = -1;
                }

                execComponent(
                  cg,
                  state,
                  xScale,
                  yScale
                );
                // appends the computed points to the result array
                // post processes the component points
                var dx = Math.round(
                  c.dx * xScale
                );
                var dy = Math.round(
                  c.dy * yScale
                );
                var gz = state.gZone;
                var cc = state.contours;
                for (
                  var pi = 0;
                  pi < gz.length;
                  pi++
                ) {
                  var p = gz[pi];
                  p.xTouched = p.yTouched = false;
                  p.xo = p.x = p.x + dx;
                  p.yo = p.y = p.y + dy;
                }

                var gLen = gZone.length;
                gZone.push.apply(gZone, gz);
                for (
                  var j = 0;
                  j < cc.length;
                  j++
                ) {
                  contours.push(cc[j] + gLen);
                }
              }

              if (
                glyph.instructions &&
                !state.inhibitGridFit
              ) {
                // the composite has instructions on its own
                state = new State(
                  "glyf",
                  glyph.instructions
                );

                state.gZone =
                  state.z0 =
                  state.z1 =
                  state.z2 =
                    gZone;

                state.contours = contours;

                // note: HPZero cannot be used here, since
                //       the point might be modified
                gZone.push(
                  new HPoint(0, 0),
                  new HPoint(
                    Math.round(
                      glyph.advanceWidth * xScale
                    ),
                    0
                  )
                );

                if (exports.DEBUG) {
                  console.log(
                    "---EXEC COMPOSITE---"
                  );
                  state.step = -1;
                }

                exec(state);

                gZone.length -= 2;
              }
            }

            return gZone;
          };

          /*
           * Executes the hinting program for a component of a multi-component glyph
           * or of the glyph itself for a non-component glyph.
           */
          execComponent = function (
            glyph,
            state,
            xScale,
            yScale
          ) {
            var points = glyph.points || [];
            var pLen = points.length;
            var gZone =
              (state.gZone =
              state.z0 =
              state.z1 =
              state.z2 =
                []);
            var contours = (state.contours = []);

            // Scales the original points and
            // makes copies for the hinted points.
            var cp; // current point
            for (var i = 0; i < pLen; i++) {
              cp = points[i];

              gZone[i] = new HPoint(
                cp.x * xScale,
                cp.y * yScale,
                cp.lastPointOfContour,
                cp.onCurve
              );
            }

            // Chain links the contours.
            var sp; // start point
            var np; // next point

            for (var i$1 = 0; i$1 < pLen; i$1++) {
              cp = gZone[i$1];

              if (!sp) {
                sp = cp;
                contours.push(i$1);
              }

              if (cp.lastPointOfContour) {
                cp.nextPointOnContour = sp;
                sp.prevPointOnContour = cp;
                sp = undefined;
              } else {
                np = gZone[i$1 + 1];
                cp.nextPointOnContour = np;
                np.prevPointOnContour = cp;
              }
            }

            if (state.inhibitGridFit) {
              return;
            }

            if (exports.DEBUG) {
              console.log(
                "PROCESSING GLYPH",
                state.stack
              );
              for (
                var i$2 = 0;
                i$2 < pLen;
                i$2++
              ) {
                console.log(
                  i$2,
                  gZone[i$2].x,
                  gZone[i$2].y
                );
              }
            }

            gZone.push(
              new HPoint(0, 0),
              new HPoint(
                Math.round(
                  glyph.advanceWidth * xScale
                ),
                0
              )
            );

            exec(state);

            // Removes the extra points.
            gZone.length -= 2;

            if (exports.DEBUG) {
              console.log(
                "FINISHED GLYPH",
                state.stack
              );
              for (
                var i$3 = 0;
                i$3 < pLen;
                i$3++
              ) {
                console.log(
                  i$3,
                  gZone[i$3].x,
                  gZone[i$3].y
                );
              }
            }
          };

          /*
           * Executes the program loaded in state.
           */
          exec = function (state) {
            var prog = state.prog;

            if (!prog) {
              return;
            }

            var pLen = prog.length;
            var ins;

            for (
              state.ip = 0;
              state.ip < pLen;
              state.ip++
            ) {
              if (exports.DEBUG) {
                state.step++;
              }
              ins =
                instructionTable[prog[state.ip]];

              if (!ins) {
                throw new Error(
                  "unknown instruction: 0x" +
                    Number(
                      prog[state.ip]
                    ).toString(16)
                );
              }

              ins(state);

              // very extensive debugging for each step
              /*
	        if (exports.DEBUG) {
	            var da;
	            if (state.gZone) {
	                da = [];
	                for (let i = 0; i < state.gZone.length; i++)
	                {
	                    da.push(i + ' ' +
	                        state.gZone[i].x * 64 + ' ' +
	                        state.gZone[i].y * 64 + ' ' +
	                        (state.gZone[i].xTouched ? 'x' : '') +
	                        (state.gZone[i].yTouched ? 'y' : '')
	                    );
	                }
	                console.log('GZ', da);
	            }

	            if (state.tZone) {
	                da = [];
	                for (let i = 0; i < state.tZone.length; i++) {
	                    da.push(i + ' ' +
	                        state.tZone[i].x * 64 + ' ' +
	                        state.tZone[i].y * 64 + ' ' +
	                        (state.tZone[i].xTouched ? 'x' : '') +
	                        (state.tZone[i].yTouched ? 'y' : '')
	                    );
	                }
	                console.log('TZ', da);
	            }

	            if (state.stack.length > 10) {
	                console.log(
	                    state.stack.length,
	                    '...', state.stack.slice(state.stack.length - 10)
	                );
	            } else {
	                console.log(state.stack.length, state.stack);
	            }
	        }
	        */
            }
          };

          /*
           * Initializes the twilight zone.
           *
           * This is only done if a SZPx instruction
           * refers to the twilight zone.
           */
          function initTZone(state) {
            var tZone = (state.tZone = new Array(
              state.gZone.length
            ));

            // no idea if this is actually correct...
            for (
              var i = 0;
              i < tZone.length;
              i++
            ) {
              tZone[i] = new HPoint(0, 0);
            }
          }

          /*
           * Skips the instruction pointer ahead over an IF/ELSE block.
           * handleElse .. if true breaks on matching ELSE
           */
          function skip(state, handleElse) {
            var prog = state.prog;
            var ip = state.ip;
            var nesting = 1;
            var ins;

            do {
              ins = prog[++ip];
              if (ins === 0x58) {
                // IF
                nesting++;
              } else if (ins === 0x59) {
                // EIF
                nesting--;
              } else if (ins === 0x40) {
                // NPUSHB
                ip += prog[ip + 1] + 1;
              } else if (ins === 0x41) {
                // NPUSHW
                ip += 2 * prog[ip + 1] + 1;
              } else if (
                ins >= 0xb0 &&
                ins <= 0xb7
              ) {
                // PUSHB
                ip += ins - 0xb0 + 1;
              } else if (
                ins >= 0xb8 &&
                ins <= 0xbf
              ) {
                // PUSHW
                ip += (ins - 0xb8 + 1) * 2;
              } else if (
                handleElse &&
                nesting === 1 &&
                ins === 0x1b
              ) {
                // ELSE
                break;
              }
            } while (nesting > 0);

            state.ip = ip;
          }

          /*----------------------------------------------------------*
           *          And then a lot of instructions...                *
           *----------------------------------------------------------*/

          // SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
          // 0x00-0x01
          function SVTCA(v, state) {
            if (exports.DEBUG) {
              console.log(
                state.step,
                "SVTCA[" + v.axis + "]"
              );
            }

            state.fv = state.pv = state.dpv = v;
          }

          // SPVTCA[a] Set Projection Vector to Coordinate Axis
          // 0x02-0x03
          function SPVTCA(v, state) {
            if (exports.DEBUG) {
              console.log(
                state.step,
                "SPVTCA[" + v.axis + "]"
              );
            }

            state.pv = state.dpv = v;
          }

          // SFVTCA[a] Set Freedom Vector to Coordinate Axis
          // 0x04-0x05
          function SFVTCA(v, state) {
            if (exports.DEBUG) {
              console.log(
                state.step,
                "SFVTCA[" + v.axis + "]"
              );
            }

            state.fv = v;
          }

          // SPVTL[a] Set Projection Vector To Line
          // 0x06-0x07
          function SPVTL(a, state) {
            var stack = state.stack;
            var p2i = stack.pop();
            var p1i = stack.pop();
            var p2 = state.z2[p2i];
            var p1 = state.z1[p1i];

            if (exports.DEBUG) {
              console.log(
                "SPVTL[" + a + "]",
                p2i,
                p1i
              );
            }

            var dx;
            var dy;

            if (!a) {
              dx = p1.x - p2.x;
              dy = p1.y - p2.y;
            } else {
              dx = p2.y - p1.y;
              dy = p1.x - p2.x;
            }

            state.pv = state.dpv = getUnitVector(
              dx,
              dy
            );
          }

          // SFVTL[a] Set Freedom Vector To Line
          // 0x08-0x09
          function SFVTL(a, state) {
            var stack = state.stack;
            var p2i = stack.pop();
            var p1i = stack.pop();
            var p2 = state.z2[p2i];
            var p1 = state.z1[p1i];

            if (exports.DEBUG) {
              console.log(
                "SFVTL[" + a + "]",
                p2i,
                p1i
              );
            }

            var dx;
            var dy;

            if (!a) {
              dx = p1.x - p2.x;
              dy = p1.y - p2.y;
            } else {
              dx = p2.y - p1.y;
              dy = p1.x - p2.x;
            }

            state.fv = getUnitVector(dx, dy);
          }

          // SPVFS[] Set Projection Vector From Stack
          // 0x0A
          function SPVFS(state) {
            var stack = state.stack;
            var y = stack.pop();
            var x = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SPVFS[]",
                y,
                x
              );
            }

            state.pv = state.dpv = getUnitVector(
              x,
              y
            );
          }

          // SFVFS[] Set Freedom Vector From Stack
          // 0x0B
          function SFVFS(state) {
            var stack = state.stack;
            var y = stack.pop();
            var x = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SPVFS[]",
                y,
                x
              );
            }

            state.fv = getUnitVector(x, y);
          }

          // GPV[] Get Projection Vector
          // 0x0C
          function GPV(state) {
            var stack = state.stack;
            var pv = state.pv;

            if (exports.DEBUG) {
              console.log(state.step, "GPV[]");
            }

            stack.push(pv.x * 0x4000);
            stack.push(pv.y * 0x4000);
          }

          // GFV[] Get Freedom Vector
          // 0x0C
          function GFV(state) {
            var stack = state.stack;
            var fv = state.fv;

            if (exports.DEBUG) {
              console.log(state.step, "GFV[]");
            }

            stack.push(fv.x * 0x4000);
            stack.push(fv.y * 0x4000);
          }

          // SFVTPV[] Set Freedom Vector To Projection Vector
          // 0x0E
          function SFVTPV(state) {
            state.fv = state.pv;

            if (exports.DEBUG) {
              console.log(state.step, "SFVTPV[]");
            }
          }

          // ISECT[] moves point p to the InterSECTion of two lines
          // 0x0F
          function ISECT(state) {
            var stack = state.stack;
            var pa0i = stack.pop();
            var pa1i = stack.pop();
            var pb0i = stack.pop();
            var pb1i = stack.pop();
            var pi = stack.pop();
            var z0 = state.z0;
            var z1 = state.z1;
            var pa0 = z0[pa0i];
            var pa1 = z0[pa1i];
            var pb0 = z1[pb0i];
            var pb1 = z1[pb1i];
            var p = state.z2[pi];

            if (exports.DEBUG) {
              console.log(
                "ISECT[], ",
                pa0i,
                pa1i,
                pb0i,
                pb1i,
                pi
              );
            }

            // math from
            // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

            var x1 = pa0.x;
            var y1 = pa0.y;
            var x2 = pa1.x;
            var y2 = pa1.y;
            var x3 = pb0.x;
            var y3 = pb0.y;
            var x4 = pb1.x;
            var y4 = pb1.y;

            var div =
              (x1 - x2) * (y3 - y4) -
              (y1 - y2) * (x3 - x4);
            var f1 = x1 * y2 - y1 * x2;
            var f2 = x3 * y4 - y3 * x4;

            p.x =
              (f1 * (x3 - x4) - f2 * (x1 - x2)) /
              div;
            p.y =
              (f1 * (y3 - y4) - f2 * (y1 - y2)) /
              div;
          }

          // SRP0[] Set Reference Point 0
          // 0x10
          function SRP0(state) {
            state.rp0 = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SRP0[]",
                state.rp0
              );
            }
          }

          // SRP1[] Set Reference Point 1
          // 0x11
          function SRP1(state) {
            state.rp1 = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SRP1[]",
                state.rp1
              );
            }
          }

          // SRP1[] Set Reference Point 2
          // 0x12
          function SRP2(state) {
            state.rp2 = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SRP2[]",
                state.rp2
              );
            }
          }

          // SZP0[] Set Zone Pointer 0
          // 0x13
          function SZP0(state) {
            var n = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SZP0[]",
                n
              );
            }

            state.zp0 = n;

            switch (n) {
              case 0:
                if (!state.tZone) {
                  initTZone(state);
                }
                state.z0 = state.tZone;
                break;
              case 1:
                state.z0 = state.gZone;
                break;
              default:
                throw new Error(
                  "Invalid zone pointer"
                );
            }
          }

          // SZP1[] Set Zone Pointer 1
          // 0x14
          function SZP1(state) {
            var n = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SZP1[]",
                n
              );
            }

            state.zp1 = n;

            switch (n) {
              case 0:
                if (!state.tZone) {
                  initTZone(state);
                }
                state.z1 = state.tZone;
                break;
              case 1:
                state.z1 = state.gZone;
                break;
              default:
                throw new Error(
                  "Invalid zone pointer"
                );
            }
          }

          // SZP2[] Set Zone Pointer 2
          // 0x15
          function SZP2(state) {
            var n = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SZP2[]",
                n
              );
            }

            state.zp2 = n;

            switch (n) {
              case 0:
                if (!state.tZone) {
                  initTZone(state);
                }
                state.z2 = state.tZone;
                break;
              case 1:
                state.z2 = state.gZone;
                break;
              default:
                throw new Error(
                  "Invalid zone pointer"
                );
            }
          }

          // SZPS[] Set Zone PointerS
          // 0x16
          function SZPS(state) {
            var n = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SZPS[]",
                n
              );
            }

            state.zp0 = state.zp1 = state.zp2 = n;

            switch (n) {
              case 0:
                if (!state.tZone) {
                  initTZone(state);
                }
                state.z0 =
                  state.z1 =
                  state.z2 =
                    state.tZone;
                break;
              case 1:
                state.z0 =
                  state.z1 =
                  state.z2 =
                    state.gZone;
                break;
              default:
                throw new Error(
                  "Invalid zone pointer"
                );
            }
          }

          // SLOOP[] Set LOOP variable
          // 0x17
          function SLOOP(state) {
            state.loop = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SLOOP[]",
                state.loop
              );
            }
          }

          // RTG[] Round To Grid
          // 0x18
          function RTG(state) {
            if (exports.DEBUG) {
              console.log(state.step, "RTG[]");
            }

            state.round = roundToGrid;
          }

          // RTHG[] Round To Half Grid
          // 0x19
          function RTHG(state) {
            if (exports.DEBUG) {
              console.log(state.step, "RTHG[]");
            }

            state.round = roundToHalfGrid;
          }

          // SMD[] Set Minimum Distance
          // 0x1A
          function SMD(state) {
            var d = state.stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "SMD[]", d);
            }

            state.minDis = d / 0x40;
          }

          // ELSE[] ELSE clause
          // 0x1B
          function ELSE(state) {
            // This instruction has been reached by executing a then branch
            // so it just skips ahead until matching EIF.
            //
            // In case the IF was negative the IF[] instruction already
            // skipped forward over the ELSE[]

            if (exports.DEBUG) {
              console.log(state.step, "ELSE[]");
            }

            skip(state, false);
          }

          // JMPR[] JuMP Relative
          // 0x1C
          function JMPR(state) {
            var o = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "JMPR[]",
                o
              );
            }

            // A jump by 1 would do nothing.
            state.ip += o - 1;
          }

          // SCVTCI[] Set Control Value Table Cut-In
          // 0x1D
          function SCVTCI(state) {
            var n = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SCVTCI[]",
                n
              );
            }

            state.cvCutIn = n / 0x40;
          }

          // DUP[] DUPlicate top stack element
          // 0x20
          function DUP(state) {
            var stack = state.stack;

            if (exports.DEBUG) {
              console.log(state.step, "DUP[]");
            }

            stack.push(stack[stack.length - 1]);
          }

          // POP[] POP top stack element
          // 0x21
          function POP(state) {
            if (exports.DEBUG) {
              console.log(state.step, "POP[]");
            }

            state.stack.pop();
          }

          // CLEAR[] CLEAR the stack
          // 0x22
          function CLEAR(state) {
            if (exports.DEBUG) {
              console.log(state.step, "CLEAR[]");
            }

            state.stack.length = 0;
          }

          // SWAP[] SWAP the top two elements on the stack
          // 0x23
          function SWAP(state) {
            var stack = state.stack;

            var a = stack.pop();
            var b = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "SWAP[]");
            }

            stack.push(a);
            stack.push(b);
          }

          // DEPTH[] DEPTH of the stack
          // 0x24
          function DEPTH(state) {
            var stack = state.stack;

            if (exports.DEBUG) {
              console.log(state.step, "DEPTH[]");
            }

            stack.push(stack.length);
          }

          // LOOPCALL[] LOOPCALL function
          // 0x2A
          function LOOPCALL(state) {
            var stack = state.stack;
            var fn = stack.pop();
            var c = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "LOOPCALL[]",
                fn,
                c
              );
            }

            // saves callers program
            var cip = state.ip;
            var cprog = state.prog;

            state.prog = state.funcs[fn];

            // executes the function
            for (var i = 0; i < c; i++) {
              exec(state);

              if (exports.DEBUG) {
                console.log(
                  ++state.step,
                  i + 1 < c
                    ? "next loopcall"
                    : "done loopcall",
                  i
                );
              }
            }

            // restores the callers program
            state.ip = cip;
            state.prog = cprog;
          }

          // CALL[] CALL function
          // 0x2B
          function CALL(state) {
            var fn = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "CALL[]",
                fn
              );
            }

            // saves callers program
            var cip = state.ip;
            var cprog = state.prog;

            state.prog = state.funcs[fn];

            // executes the function
            exec(state);

            // restores the callers program
            state.ip = cip;
            state.prog = cprog;

            if (exports.DEBUG) {
              console.log(
                ++state.step,
                "returning from",
                fn
              );
            }
          }

          // CINDEX[] Copy the INDEXed element to the top of the stack
          // 0x25
          function CINDEX(state) {
            var stack = state.stack;
            var k = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "CINDEX[]",
                k
              );
            }

            // In case of k == 1, it copies the last element after popping
            // thus stack.length - k.
            stack.push(stack[stack.length - k]);
          }

          // MINDEX[] Move the INDEXed element to the top of the stack
          // 0x26
          function MINDEX(state) {
            var stack = state.stack;
            var k = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "MINDEX[]",
                k
              );
            }

            stack.push(
              stack.splice(stack.length - k, 1)[0]
            );
          }

          // FDEF[] Function DEFinition
          // 0x2C
          function FDEF(state) {
            if (state.env !== "fpgm") {
              throw new Error(
                "FDEF not allowed here"
              );
            }
            var stack = state.stack;
            var prog = state.prog;
            var ip = state.ip;

            var fn = stack.pop();
            var ipBegin = ip;

            if (exports.DEBUG) {
              console.log(
                state.step,
                "FDEF[]",
                fn
              );
            }

            while (prog[++ip] !== 0x2d) {}

            state.ip = ip;
            state.funcs[fn] = prog.slice(
              ipBegin + 1,
              ip
            );
          }

          // MDAP[a] Move Direct Absolute Point
          // 0x2E-0x2F
          function MDAP(round, state) {
            var pi = state.stack.pop();
            var p = state.z0[pi];
            var fv = state.fv;
            var pv = state.pv;

            if (exports.DEBUG) {
              console.log(
                state.step,
                "MDAP[" + round + "]",
                pi
              );
            }

            var d = pv.distance(p, HPZero);

            if (round) {
              d = state.round(d);
            }

            fv.setRelative(p, HPZero, d, pv);
            fv.touch(p);

            state.rp0 = state.rp1 = pi;
          }

          // IUP[a] Interpolate Untouched Points through the outline
          // 0x30
          function IUP(v, state) {
            var z2 = state.z2;
            var pLen = z2.length - 2;
            var cp;
            var pp;
            var np;

            if (exports.DEBUG) {
              console.log(
                state.step,
                "IUP[" + v.axis + "]"
              );
            }

            for (var i = 0; i < pLen; i++) {
              cp = z2[i]; // current point

              // if this point has been touched go on
              if (v.touched(cp)) {
                continue;
              }

              pp = cp.prevTouched(v);

              // no point on the contour has been touched?
              if (pp === cp) {
                continue;
              }

              np = cp.nextTouched(v);

              if (pp === np) {
                // only one point on the contour has been touched
                // so simply moves the point like that

                v.setRelative(
                  cp,
                  cp,
                  v.distance(pp, pp, false, true),
                  v,
                  true
                );
              }

              v.interpolate(cp, pp, np, v);
            }
          }

          // SHP[] SHift Point using reference point
          // 0x32-0x33
          function SHP(a, state) {
            var stack = state.stack;
            var rpi = a ? state.rp1 : state.rp2;
            var rp = (a ? state.z0 : state.z1)[
              rpi
            ];
            var fv = state.fv;
            var pv = state.pv;
            var loop = state.loop;
            var z2 = state.z2;

            while (loop--) {
              var pi = stack.pop();
              var p = z2[pi];

              var d = pv.distance(
                rp,
                rp,
                false,
                true
              );
              fv.setRelative(p, p, d, pv);
              fv.touch(p);

              if (exports.DEBUG) {
                console.log(
                  state.step,
                  (state.loop > 1
                    ? "loop " +
                      (state.loop - loop) +
                      ": "
                    : "") +
                    "SHP[" +
                    (a ? "rp1" : "rp2") +
                    "]",
                  pi
                );
              }
            }

            state.loop = 1;
          }

          // SHC[] SHift Contour using reference point
          // 0x36-0x37
          function SHC(a, state) {
            var stack = state.stack;
            var rpi = a ? state.rp1 : state.rp2;
            var rp = (a ? state.z0 : state.z1)[
              rpi
            ];
            var fv = state.fv;
            var pv = state.pv;
            var ci = stack.pop();
            var sp = state.z2[state.contours[ci]];
            var p = sp;

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SHC[" + a + "]",
                ci
              );
            }

            var d = pv.distance(
              rp,
              rp,
              false,
              true
            );

            do {
              if (p !== rp) {
                fv.setRelative(p, p, d, pv);
              }
              p = p.nextPointOnContour;
            } while (p !== sp);
          }

          // SHZ[] SHift Zone using reference point
          // 0x36-0x37
          function SHZ(a, state) {
            var stack = state.stack;
            var rpi = a ? state.rp1 : state.rp2;
            var rp = (a ? state.z0 : state.z1)[
              rpi
            ];
            var fv = state.fv;
            var pv = state.pv;

            var e = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SHZ[" + a + "]",
                e
              );
            }

            var z;
            switch (e) {
              case 0:
                z = state.tZone;
                break;
              case 1:
                z = state.gZone;
                break;
              default:
                throw new Error("Invalid zone");
            }

            var p;
            var d = pv.distance(
              rp,
              rp,
              false,
              true
            );
            var pLen = z.length - 2;
            for (var i = 0; i < pLen; i++) {
              p = z[i];
              fv.setRelative(p, p, d, pv);
              //if (p !== rp) fv.setRelative(p, p, d, pv);
            }
          }

          // SHPIX[] SHift point by a PIXel amount
          // 0x38
          function SHPIX(state) {
            var stack = state.stack;
            var loop = state.loop;
            var fv = state.fv;
            var d = stack.pop() / 0x40;
            var z2 = state.z2;

            while (loop--) {
              var pi = stack.pop();
              var p = z2[pi];

              if (exports.DEBUG) {
                console.log(
                  state.step,
                  (state.loop > 1
                    ? "loop " +
                      (state.loop - loop) +
                      ": "
                    : "") + "SHPIX[]",
                  pi,
                  d
                );
              }

              fv.setRelative(p, p, d);
              fv.touch(p);
            }

            state.loop = 1;
          }

          // IP[] Interpolate Point
          // 0x39
          function IP(state) {
            var stack = state.stack;
            var rp1i = state.rp1;
            var rp2i = state.rp2;
            var loop = state.loop;
            var rp1 = state.z0[rp1i];
            var rp2 = state.z1[rp2i];
            var fv = state.fv;
            var pv = state.dpv;
            var z2 = state.z2;

            while (loop--) {
              var pi = stack.pop();
              var p = z2[pi];

              if (exports.DEBUG) {
                console.log(
                  state.step,
                  (state.loop > 1
                    ? "loop " +
                      (state.loop - loop) +
                      ": "
                    : "") + "IP[]",
                  pi,
                  rp1i,
                  "<->",
                  rp2i
                );
              }

              fv.interpolate(p, rp1, rp2, pv);

              fv.touch(p);
            }

            state.loop = 1;
          }

          // MSIRP[a] Move Stack Indirect Relative Point
          // 0x3A-0x3B
          function MSIRP(a, state) {
            var stack = state.stack;
            var d = stack.pop() / 64;
            var pi = stack.pop();
            var p = state.z1[pi];
            var rp0 = state.z0[state.rp0];
            var fv = state.fv;
            var pv = state.pv;

            fv.setRelative(p, rp0, d, pv);
            fv.touch(p);

            if (exports.DEBUG) {
              console.log(
                state.step,
                "MSIRP[" + a + "]",
                d,
                pi
              );
            }

            state.rp1 = state.rp0;
            state.rp2 = pi;
            if (a) {
              state.rp0 = pi;
            }
          }

          // ALIGNRP[] Align to reference point.
          // 0x3C
          function ALIGNRP(state) {
            var stack = state.stack;
            var rp0i = state.rp0;
            var rp0 = state.z0[rp0i];
            var loop = state.loop;
            var fv = state.fv;
            var pv = state.pv;
            var z1 = state.z1;

            while (loop--) {
              var pi = stack.pop();
              var p = z1[pi];

              if (exports.DEBUG) {
                console.log(
                  state.step,
                  (state.loop > 1
                    ? "loop " +
                      (state.loop - loop) +
                      ": "
                    : "") + "ALIGNRP[]",
                  pi
                );
              }

              fv.setRelative(p, rp0, 0, pv);
              fv.touch(p);
            }

            state.loop = 1;
          }

          // RTG[] Round To Double Grid
          // 0x3D
          function RTDG(state) {
            if (exports.DEBUG) {
              console.log(state.step, "RTDG[]");
            }

            state.round = roundToDoubleGrid;
          }

          // MIAP[a] Move Indirect Absolute Point
          // 0x3E-0x3F
          function MIAP(round, state) {
            var stack = state.stack;
            var n = stack.pop();
            var pi = stack.pop();
            var p = state.z0[pi];
            var fv = state.fv;
            var pv = state.pv;
            var cv = state.cvt[n];

            if (exports.DEBUG) {
              console.log(
                state.step,
                "MIAP[" + round + "]",
                n,
                "(",
                cv,
                ")",
                pi
              );
            }

            var d = pv.distance(p, HPZero);

            if (round) {
              if (
                Math.abs(d - cv) < state.cvCutIn
              ) {
                d = cv;
              }

              d = state.round(d);
            }

            fv.setRelative(p, HPZero, d, pv);

            if (state.zp0 === 0) {
              p.xo = p.x;
              p.yo = p.y;
            }

            fv.touch(p);

            state.rp0 = state.rp1 = pi;
          }

          // NPUSB[] PUSH N Bytes
          // 0x40
          function NPUSHB(state) {
            var prog = state.prog;
            var ip = state.ip;
            var stack = state.stack;

            var n = prog[++ip];

            if (exports.DEBUG) {
              console.log(
                state.step,
                "NPUSHB[]",
                n
              );
            }

            for (var i = 0; i < n; i++) {
              stack.push(prog[++ip]);
            }

            state.ip = ip;
          }

          // NPUSHW[] PUSH N Words
          // 0x41
          function NPUSHW(state) {
            var ip = state.ip;
            var prog = state.prog;
            var stack = state.stack;
            var n = prog[++ip];

            if (exports.DEBUG) {
              console.log(
                state.step,
                "NPUSHW[]",
                n
              );
            }

            for (var i = 0; i < n; i++) {
              var w =
                (prog[++ip] << 8) | prog[++ip];
              if (w & 0x8000) {
                w = -((w ^ 0xffff) + 1);
              }
              stack.push(w);
            }

            state.ip = ip;
          }

          // WS[] Write Store
          // 0x42
          function WS(state) {
            var stack = state.stack;
            var store = state.store;

            if (!store) {
              store = state.store = [];
            }

            var v = stack.pop();
            var l = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "WS", v, l);
            }

            store[l] = v;
          }

          // RS[] Read Store
          // 0x43
          function RS(state) {
            var stack = state.stack;
            var store = state.store;

            var l = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "RS", l);
            }

            var v = (store && store[l]) || 0;

            stack.push(v);
          }

          // WCVTP[] Write Control Value Table in Pixel units
          // 0x44
          function WCVTP(state) {
            var stack = state.stack;

            var v = stack.pop();
            var l = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "WCVTP",
                v,
                l
              );
            }

            state.cvt[l] = v / 0x40;
          }

          // RCVT[] Read Control Value Table entry
          // 0x45
          function RCVT(state) {
            var stack = state.stack;
            var cvte = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "RCVT",
                cvte
              );
            }

            stack.push(state.cvt[cvte] * 0x40);
          }

          // GC[] Get Coordinate projected onto the projection vector
          // 0x46-0x47
          function GC(a, state) {
            var stack = state.stack;
            var pi = stack.pop();
            var p = state.z2[pi];

            if (exports.DEBUG) {
              console.log(
                state.step,
                "GC[" + a + "]",
                pi
              );
            }

            stack.push(
              state.dpv.distance(
                p,
                HPZero,
                a,
                false
              ) * 0x40
            );
          }

          // MD[a] Measure Distance
          // 0x49-0x4A
          function MD(a, state) {
            var stack = state.stack;
            var pi2 = stack.pop();
            var pi1 = stack.pop();
            var p2 = state.z1[pi2];
            var p1 = state.z0[pi1];
            var d = state.dpv.distance(
              p1,
              p2,
              a,
              a
            );

            if (exports.DEBUG) {
              console.log(
                state.step,
                "MD[" + a + "]",
                pi2,
                pi1,
                "->",
                d
              );
            }

            state.stack.push(Math.round(d * 64));
          }

          // MPPEM[] Measure Pixels Per EM
          // 0x4B
          function MPPEM(state) {
            if (exports.DEBUG) {
              console.log(state.step, "MPPEM[]");
            }
            state.stack.push(state.ppem);
          }

          // FLIPON[] set the auto FLIP Boolean to ON
          // 0x4D
          function FLIPON(state) {
            if (exports.DEBUG) {
              console.log(state.step, "FLIPON[]");
            }
            state.autoFlip = true;
          }

          // LT[] Less Than
          // 0x50
          function LT(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "LT[]",
                e2,
                e1
              );
            }

            stack.push(e1 < e2 ? 1 : 0);
          }

          // LTEQ[] Less Than or EQual
          // 0x53
          function LTEQ(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "LTEQ[]",
                e2,
                e1
              );
            }

            stack.push(e1 <= e2 ? 1 : 0);
          }

          // GTEQ[] Greater Than
          // 0x52
          function GT(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "GT[]",
                e2,
                e1
              );
            }

            stack.push(e1 > e2 ? 1 : 0);
          }

          // GTEQ[] Greater Than or EQual
          // 0x53
          function GTEQ(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "GTEQ[]",
                e2,
                e1
              );
            }

            stack.push(e1 >= e2 ? 1 : 0);
          }

          // EQ[] EQual
          // 0x54
          function EQ(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "EQ[]",
                e2,
                e1
              );
            }

            stack.push(e2 === e1 ? 1 : 0);
          }

          // NEQ[] Not EQual
          // 0x55
          function NEQ(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "NEQ[]",
                e2,
                e1
              );
            }

            stack.push(e2 !== e1 ? 1 : 0);
          }

          // ODD[] ODD
          // 0x56
          function ODD(state) {
            var stack = state.stack;
            var n = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "ODD[]", n);
            }

            stack.push(Math.trunc(n) % 2 ? 1 : 0);
          }

          // EVEN[] EVEN
          // 0x57
          function EVEN(state) {
            var stack = state.stack;
            var n = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "EVEN[]",
                n
              );
            }

            stack.push(Math.trunc(n) % 2 ? 0 : 1);
          }

          // IF[] IF test
          // 0x58
          function IF(state) {
            var test = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "IF[]",
                test
              );
            }

            // if test is true it just continues
            // if not the ip is skipped until matching ELSE or EIF
            if (!test) {
              skip(state, true);

              if (exports.DEBUG) {
                console.log(state.step, "EIF[]");
              }
            }
          }

          // EIF[] End IF
          // 0x59
          function EIF(state) {
            // this can be reached normally when
            // executing an else branch.
            // -> just ignore it

            if (exports.DEBUG) {
              console.log(state.step, "EIF[]");
            }
          }

          // AND[] logical AND
          // 0x5A
          function AND(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "AND[]",
                e2,
                e1
              );
            }

            stack.push(e2 && e1 ? 1 : 0);
          }

          // OR[] logical OR
          // 0x5B
          function OR(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "OR[]",
                e2,
                e1
              );
            }

            stack.push(e2 || e1 ? 1 : 0);
          }

          // NOT[] logical NOT
          // 0x5C
          function NOT(state) {
            var stack = state.stack;
            var e = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "NOT[]", e);
            }

            stack.push(e ? 0 : 1);
          }

          // DELTAP1[] DELTA exception P1
          // DELTAP2[] DELTA exception P2
          // DELTAP3[] DELTA exception P3
          // 0x5D, 0x71, 0x72
          function DELTAP123(b, state) {
            var stack = state.stack;
            var n = stack.pop();
            var fv = state.fv;
            var pv = state.pv;
            var ppem = state.ppem;
            var base =
              state.deltaBase + (b - 1) * 16;
            var ds = state.deltaShift;
            var z0 = state.z0;

            if (exports.DEBUG) {
              console.log(
                state.step,
                "DELTAP[" + b + "]",
                n,
                stack
              );
            }

            for (var i = 0; i < n; i++) {
              var pi = stack.pop();
              var arg = stack.pop();
              var appem =
                base + ((arg & 0xf0) >> 4);
              if (appem !== ppem) {
                continue;
              }

              var mag = (arg & 0x0f) - 8;
              if (mag >= 0) {
                mag++;
              }
              if (exports.DEBUG) {
                console.log(
                  state.step,
                  "DELTAPFIX",
                  pi,
                  "by",
                  mag * ds
                );
              }

              var p = z0[pi];
              fv.setRelative(p, p, mag * ds, pv);
            }
          }

          // SDB[] Set Delta Base in the graphics state
          // 0x5E
          function SDB(state) {
            var stack = state.stack;
            var n = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "SDB[]", n);
            }

            state.deltaBase = n;
          }

          // SDS[] Set Delta Shift in the graphics state
          // 0x5F
          function SDS(state) {
            var stack = state.stack;
            var n = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "SDS[]", n);
            }

            state.deltaShift = Math.pow(0.5, n);
          }

          // ADD[] ADD
          // 0x60
          function ADD(state) {
            var stack = state.stack;
            var n2 = stack.pop();
            var n1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "ADD[]",
                n2,
                n1
              );
            }

            stack.push(n1 + n2);
          }

          // SUB[] SUB
          // 0x61
          function SUB(state) {
            var stack = state.stack;
            var n2 = stack.pop();
            var n1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SUB[]",
                n2,
                n1
              );
            }

            stack.push(n1 - n2);
          }

          // DIV[] DIV
          // 0x62
          function DIV(state) {
            var stack = state.stack;
            var n2 = stack.pop();
            var n1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "DIV[]",
                n2,
                n1
              );
            }

            stack.push((n1 * 64) / n2);
          }

          // MUL[] MUL
          // 0x63
          function MUL(state) {
            var stack = state.stack;
            var n2 = stack.pop();
            var n1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "MUL[]",
                n2,
                n1
              );
            }

            stack.push((n1 * n2) / 64);
          }

          // ABS[] ABSolute value
          // 0x64
          function ABS(state) {
            var stack = state.stack;
            var n = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "ABS[]", n);
            }

            stack.push(Math.abs(n));
          }

          // NEG[] NEGate
          // 0x65
          function NEG(state) {
            var stack = state.stack;
            var n = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "NEG[]", n);
            }

            stack.push(-n);
          }

          // FLOOR[] FLOOR
          // 0x66
          function FLOOR(state) {
            var stack = state.stack;
            var n = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "FLOOR[]",
                n
              );
            }

            stack.push(
              Math.floor(n / 0x40) * 0x40
            );
          }

          // CEILING[] CEILING
          // 0x67
          function CEILING(state) {
            var stack = state.stack;
            var n = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "CEILING[]",
                n
              );
            }

            stack.push(
              Math.ceil(n / 0x40) * 0x40
            );
          }

          // ROUND[ab] ROUND value
          // 0x68-0x6B
          function ROUND(dt, state) {
            var stack = state.stack;
            var n = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "ROUND[]");
            }

            stack.push(
              state.round(n / 0x40) * 0x40
            );
          }

          // WCVTF[] Write Control Value Table in Funits
          // 0x70
          function WCVTF(state) {
            var stack = state.stack;
            var v = stack.pop();
            var l = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "WCVTF[]",
                v,
                l
              );
            }

            state.cvt[l] =
              (v * state.ppem) /
              state.font.unitsPerEm;
          }

          // DELTAC1[] DELTA exception C1
          // DELTAC2[] DELTA exception C2
          // DELTAC3[] DELTA exception C3
          // 0x73, 0x74, 0x75
          function DELTAC123(b, state) {
            var stack = state.stack;
            var n = stack.pop();
            var ppem = state.ppem;
            var base =
              state.deltaBase + (b - 1) * 16;
            var ds = state.deltaShift;

            if (exports.DEBUG) {
              console.log(
                state.step,
                "DELTAC[" + b + "]",
                n,
                stack
              );
            }

            for (var i = 0; i < n; i++) {
              var c = stack.pop();
              var arg = stack.pop();
              var appem =
                base + ((arg & 0xf0) >> 4);
              if (appem !== ppem) {
                continue;
              }

              var mag = (arg & 0x0f) - 8;
              if (mag >= 0) {
                mag++;
              }

              var delta = mag * ds;

              if (exports.DEBUG) {
                console.log(
                  state.step,
                  "DELTACFIX",
                  c,
                  "by",
                  delta
                );
              }

              state.cvt[c] += delta;
            }
          }

          // SROUND[] Super ROUND
          // 0x76
          function SROUND(state) {
            var n = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SROUND[]",
                n
              );
            }

            state.round = roundSuper;

            var period;

            switch (n & 0xc0) {
              case 0x00:
                period = 0.5;
                break;
              case 0x40:
                period = 1;
                break;
              case 0x80:
                period = 2;
                break;
              default:
                throw new Error(
                  "invalid SROUND value"
                );
            }

            state.srPeriod = period;

            switch (n & 0x30) {
              case 0x00:
                state.srPhase = 0;
                break;
              case 0x10:
                state.srPhase = 0.25 * period;
                break;
              case 0x20:
                state.srPhase = 0.5 * period;
                break;
              case 0x30:
                state.srPhase = 0.75 * period;
                break;
              default:
                throw new Error(
                  "invalid SROUND value"
                );
            }

            n &= 0x0f;

            if (n === 0) {
              state.srThreshold = 0;
            } else {
              state.srThreshold =
                (n / 8 - 0.5) * period;
            }
          }

          // S45ROUND[] Super ROUND 45 degrees
          // 0x77
          function S45ROUND(state) {
            var n = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "S45ROUND[]",
                n
              );
            }

            state.round = roundSuper;

            var period;

            switch (n & 0xc0) {
              case 0x00:
                period = Math.sqrt(2) / 2;
                break;
              case 0x40:
                period = Math.sqrt(2);
                break;
              case 0x80:
                period = 2 * Math.sqrt(2);
                break;
              default:
                throw new Error(
                  "invalid S45ROUND value"
                );
            }

            state.srPeriod = period;

            switch (n & 0x30) {
              case 0x00:
                state.srPhase = 0;
                break;
              case 0x10:
                state.srPhase = 0.25 * period;
                break;
              case 0x20:
                state.srPhase = 0.5 * period;
                break;
              case 0x30:
                state.srPhase = 0.75 * period;
                break;
              default:
                throw new Error(
                  "invalid S45ROUND value"
                );
            }

            n &= 0x0f;

            if (n === 0) {
              state.srThreshold = 0;
            } else {
              state.srThreshold =
                (n / 8 - 0.5) * period;
            }
          }

          // ROFF[] Round Off
          // 0x7A
          function ROFF(state) {
            if (exports.DEBUG) {
              console.log(state.step, "ROFF[]");
            }

            state.round = roundOff;
          }

          // RUTG[] Round Up To Grid
          // 0x7C
          function RUTG(state) {
            if (exports.DEBUG) {
              console.log(state.step, "RUTG[]");
            }

            state.round = roundUpToGrid;
          }

          // RDTG[] Round Down To Grid
          // 0x7D
          function RDTG(state) {
            if (exports.DEBUG) {
              console.log(state.step, "RDTG[]");
            }

            state.round = roundDownToGrid;
          }

          // SCANCTRL[] SCAN conversion ConTRoL
          // 0x85
          function SCANCTRL(state) {
            var n = state.stack.pop();

            // ignored by opentype.js

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SCANCTRL[]",
                n
              );
            }
          }

          // SDPVTL[a] Set Dual Projection Vector To Line
          // 0x86-0x87
          function SDPVTL(a, state) {
            var stack = state.stack;
            var p2i = stack.pop();
            var p1i = stack.pop();
            var p2 = state.z2[p2i];
            var p1 = state.z1[p1i];

            if (exports.DEBUG) {
              console.log(
                state.step,
                "SDPVTL[" + a + "]",
                p2i,
                p1i
              );
            }

            var dx;
            var dy;

            if (!a) {
              dx = p1.x - p2.x;
              dy = p1.y - p2.y;
            } else {
              dx = p2.y - p1.y;
              dy = p1.x - p2.x;
            }

            state.dpv = getUnitVector(dx, dy);
          }

          // GETINFO[] GET INFOrmation
          // 0x88
          function GETINFO(state) {
            var stack = state.stack;
            var sel = stack.pop();
            var r = 0;

            if (exports.DEBUG) {
              console.log(
                state.step,
                "GETINFO[]",
                sel
              );
            }

            // v35 as in no subpixel hinting
            if (sel & 0x01) {
              r = 35;
            }

            // TODO rotation and stretch currently not supported
            // and thus those GETINFO are always 0.

            // opentype.js is always gray scaling
            if (sel & 0x20) {
              r |= 0x1000;
            }

            stack.push(r);
          }

          // ROLL[] ROLL the top three stack elements
          // 0x8A
          function ROLL(state) {
            var stack = state.stack;
            var a = stack.pop();
            var b = stack.pop();
            var c = stack.pop();

            if (exports.DEBUG) {
              console.log(state.step, "ROLL[]");
            }

            stack.push(b);
            stack.push(a);
            stack.push(c);
          }

          // MAX[] MAXimum of top two stack elements
          // 0x8B
          function MAX(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "MAX[]",
                e2,
                e1
              );
            }

            stack.push(Math.max(e1, e2));
          }

          // MIN[] MINimum of top two stack elements
          // 0x8C
          function MIN(state) {
            var stack = state.stack;
            var e2 = stack.pop();
            var e1 = stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "MIN[]",
                e2,
                e1
              );
            }

            stack.push(Math.min(e1, e2));
          }

          // SCANTYPE[] SCANTYPE
          // 0x8D
          function SCANTYPE(state) {
            var n = state.stack.pop();
            // ignored by opentype.js
            if (exports.DEBUG) {
              console.log(
                state.step,
                "SCANTYPE[]",
                n
              );
            }
          }

          // INSTCTRL[] INSTCTRL
          // 0x8D
          function INSTCTRL(state) {
            var s = state.stack.pop();
            var v = state.stack.pop();

            if (exports.DEBUG) {
              console.log(
                state.step,
                "INSTCTRL[]",
                s,
                v
              );
            }

            switch (s) {
              case 1:
                state.inhibitGridFit = !!v;
                return;
              case 2:
                state.ignoreCvt = !!v;
                return;
              default:
                throw new Error(
                  "invalid INSTCTRL[] selector"
                );
            }
          }

          // PUSHB[abc] PUSH Bytes
          // 0xB0-0xB7
          function PUSHB(n, state) {
            var stack = state.stack;
            var prog = state.prog;
            var ip = state.ip;

            if (exports.DEBUG) {
              console.log(
                state.step,
                "PUSHB[" + n + "]"
              );
            }

            for (var i = 0; i < n; i++) {
              stack.push(prog[++ip]);
            }

            state.ip = ip;
          }

          // PUSHW[abc] PUSH Words
          // 0xB8-0xBF
          function PUSHW(n, state) {
            var ip = state.ip;
            var prog = state.prog;
            var stack = state.stack;

            if (exports.DEBUG) {
              console.log(
                state.ip,
                "PUSHW[" + n + "]"
              );
            }

            for (var i = 0; i < n; i++) {
              var w =
                (prog[++ip] << 8) | prog[++ip];
              if (w & 0x8000) {
                w = -((w ^ 0xffff) + 1);
              }
              stack.push(w);
            }

            state.ip = ip;
          }

          // MDRP[abcde] Move Direct Relative Point
          // 0xD0-0xEF
          // (if indirect is 0)
          //
          // and
          //
          // MIRP[abcde] Move Indirect Relative Point
          // 0xE0-0xFF
          // (if indirect is 1)

          function MDRP_MIRP(
            indirect,
            setRp0,
            keepD,
            ro,
            dt,
            state
          ) {
            var stack = state.stack;
            var cvte = indirect && stack.pop();
            var pi = stack.pop();
            var rp0i = state.rp0;
            var rp = state.z0[rp0i];
            var p = state.z1[pi];

            var md = state.minDis;
            var fv = state.fv;
            var pv = state.dpv;
            var od; // original distance
            var d; // moving distance
            var sign; // sign of distance
            var cv;

            d = od = pv.distance(
              p,
              rp,
              true,
              true
            );
            sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

            // TODO consider autoFlip
            d = Math.abs(d);

            if (indirect) {
              cv = state.cvt[cvte];

              if (
                ro &&
                Math.abs(d - cv) < state.cvCutIn
              ) {
                d = cv;
              }
            }

            if (keepD && d < md) {
              d = md;
            }

            if (ro) {
              d = state.round(d);
            }

            fv.setRelative(p, rp, sign * d, pv);
            fv.touch(p);

            if (exports.DEBUG) {
              console.log(
                state.step,
                (indirect ? "MIRP[" : "MDRP[") +
                  (setRp0 ? "M" : "m") +
                  (keepD ? ">" : "_") +
                  (ro ? "R" : "_") +
                  (dt === 0
                    ? "Gr"
                    : dt === 1
                    ? "Bl"
                    : dt === 2
                    ? "Wh"
                    : "") +
                  "]",
                indirect
                  ? cvte +
                      "(" +
                      state.cvt[cvte] +
                      "," +
                      cv +
                      ")"
                  : "",
                pi,
                "(d =",
                od,
                "->",
                sign * d,
                ")"
              );
            }

            state.rp1 = state.rp0;
            state.rp2 = pi;
            if (setRp0) {
              state.rp0 = pi;
            }
          }

          /*
           * The instruction table.
           */
          instructionTable = [
            /* 0x00 */ SVTCA.bind(
              undefined,
              yUnitVector
            ),
            /* 0x01 */ SVTCA.bind(
              undefined,
              xUnitVector
            ),
            /* 0x02 */ SPVTCA.bind(
              undefined,
              yUnitVector
            ),
            /* 0x03 */ SPVTCA.bind(
              undefined,
              xUnitVector
            ),
            /* 0x04 */ SFVTCA.bind(
              undefined,
              yUnitVector
            ),
            /* 0x05 */ SFVTCA.bind(
              undefined,
              xUnitVector
            ),
            /* 0x06 */ SPVTL.bind(undefined, 0),
            /* 0x07 */ SPVTL.bind(undefined, 1),
            /* 0x08 */ SFVTL.bind(undefined, 0),
            /* 0x09 */ SFVTL.bind(undefined, 1),
            /* 0x0A */ SPVFS,
            /* 0x0B */ SFVFS,
            /* 0x0C */ GPV,
            /* 0x0D */ GFV,
            /* 0x0E */ SFVTPV,
            /* 0x0F */ ISECT,
            /* 0x10 */ SRP0,
            /* 0x11 */ SRP1,
            /* 0x12 */ SRP2,
            /* 0x13 */ SZP0,
            /* 0x14 */ SZP1,
            /* 0x15 */ SZP2,
            /* 0x16 */ SZPS,
            /* 0x17 */ SLOOP,
            /* 0x18 */ RTG,
            /* 0x19 */ RTHG,
            /* 0x1A */ SMD,
            /* 0x1B */ ELSE,
            /* 0x1C */ JMPR,
            /* 0x1D */ SCVTCI,
            /* 0x1E */ undefined, // TODO SSWCI
            /* 0x1F */ undefined, // TODO SSW
            /* 0x20 */ DUP,
            /* 0x21 */ POP,
            /* 0x22 */ CLEAR,
            /* 0x23 */ SWAP,
            /* 0x24 */ DEPTH,
            /* 0x25 */ CINDEX,
            /* 0x26 */ MINDEX,
            /* 0x27 */ undefined, // TODO ALIGNPTS
            /* 0x28 */ undefined,
            /* 0x29 */ undefined, // TODO UTP
            /* 0x2A */ LOOPCALL,
            /* 0x2B */ CALL,
            /* 0x2C */ FDEF,
            /* 0x2D */ undefined, // ENDF (eaten by FDEF)
            /* 0x2E */ MDAP.bind(undefined, 0),
            /* 0x2F */ MDAP.bind(undefined, 1),
            /* 0x30 */ IUP.bind(
              undefined,
              yUnitVector
            ),
            /* 0x31 */ IUP.bind(
              undefined,
              xUnitVector
            ),
            /* 0x32 */ SHP.bind(undefined, 0),
            /* 0x33 */ SHP.bind(undefined, 1),
            /* 0x34 */ SHC.bind(undefined, 0),
            /* 0x35 */ SHC.bind(undefined, 1),
            /* 0x36 */ SHZ.bind(undefined, 0),
            /* 0x37 */ SHZ.bind(undefined, 1),
            /* 0x38 */ SHPIX,
            /* 0x39 */ IP,
            /* 0x3A */ MSIRP.bind(undefined, 0),
            /* 0x3B */ MSIRP.bind(undefined, 1),
            /* 0x3C */ ALIGNRP,
            /* 0x3D */ RTDG,
            /* 0x3E */ MIAP.bind(undefined, 0),
            /* 0x3F */ MIAP.bind(undefined, 1),
            /* 0x40 */ NPUSHB,
            /* 0x41 */ NPUSHW,
            /* 0x42 */ WS,
            /* 0x43 */ RS,
            /* 0x44 */ WCVTP,
            /* 0x45 */ RCVT,
            /* 0x46 */ GC.bind(undefined, 0),
            /* 0x47 */ GC.bind(undefined, 1),
            /* 0x48 */ undefined, // TODO SCFS
            /* 0x49 */ MD.bind(undefined, 0),
            /* 0x4A */ MD.bind(undefined, 1),
            /* 0x4B */ MPPEM,
            /* 0x4C */ undefined, // TODO MPS
            /* 0x4D */ FLIPON,
            /* 0x4E */ undefined, // TODO FLIPOFF
            /* 0x4F */ undefined, // TODO DEBUG
            /* 0x50 */ LT,
            /* 0x51 */ LTEQ,
            /* 0x52 */ GT,
            /* 0x53 */ GTEQ,
            /* 0x54 */ EQ,
            /* 0x55 */ NEQ,
            /* 0x56 */ ODD,
            /* 0x57 */ EVEN,
            /* 0x58 */ IF,
            /* 0x59 */ EIF,
            /* 0x5A */ AND,
            /* 0x5B */ OR,
            /* 0x5C */ NOT,
            /* 0x5D */ DELTAP123.bind(
              undefined,
              1
            ),
            /* 0x5E */ SDB,
            /* 0x5F */ SDS,
            /* 0x60 */ ADD,
            /* 0x61 */ SUB,
            /* 0x62 */ DIV,
            /* 0x63 */ MUL,
            /* 0x64 */ ABS,
            /* 0x65 */ NEG,
            /* 0x66 */ FLOOR,
            /* 0x67 */ CEILING,
            /* 0x68 */ ROUND.bind(undefined, 0),
            /* 0x69 */ ROUND.bind(undefined, 1),
            /* 0x6A */ ROUND.bind(undefined, 2),
            /* 0x6B */ ROUND.bind(undefined, 3),
            /* 0x6C */ undefined, // TODO NROUND[ab]
            /* 0x6D */ undefined, // TODO NROUND[ab]
            /* 0x6E */ undefined, // TODO NROUND[ab]
            /* 0x6F */ undefined, // TODO NROUND[ab]
            /* 0x70 */ WCVTF,
            /* 0x71 */ DELTAP123.bind(
              undefined,
              2
            ),
            /* 0x72 */ DELTAP123.bind(
              undefined,
              3
            ),
            /* 0x73 */ DELTAC123.bind(
              undefined,
              1
            ),
            /* 0x74 */ DELTAC123.bind(
              undefined,
              2
            ),
            /* 0x75 */ DELTAC123.bind(
              undefined,
              3
            ),
            /* 0x76 */ SROUND,
            /* 0x77 */ S45ROUND,
            /* 0x78 */ undefined, // TODO JROT[]
            /* 0x79 */ undefined, // TODO JROF[]
            /* 0x7A */ ROFF,
            /* 0x7B */ undefined,
            /* 0x7C */ RUTG,
            /* 0x7D */ RDTG,
            /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
            /* 0x7F */ POP, // actually AA, supposed to do only a pop though
            /* 0x80 */ undefined, // TODO FLIPPT
            /* 0x81 */ undefined, // TODO FLIPRGON
            /* 0x82 */ undefined, // TODO FLIPRGOFF
            /* 0x83 */ undefined,
            /* 0x84 */ undefined,
            /* 0x85 */ SCANCTRL,
            /* 0x86 */ SDPVTL.bind(undefined, 0),
            /* 0x87 */ SDPVTL.bind(undefined, 1),
            /* 0x88 */ GETINFO,
            /* 0x89 */ undefined, // TODO IDEF
            /* 0x8A */ ROLL,
            /* 0x8B */ MAX,
            /* 0x8C */ MIN,
            /* 0x8D */ SCANTYPE,
            /* 0x8E */ INSTCTRL,
            /* 0x8F */ undefined,
            /* 0x90 */ undefined,
            /* 0x91 */ undefined,
            /* 0x92 */ undefined,
            /* 0x93 */ undefined,
            /* 0x94 */ undefined,
            /* 0x95 */ undefined,
            /* 0x96 */ undefined,
            /* 0x97 */ undefined,
            /* 0x98 */ undefined,
            /* 0x99 */ undefined,
            /* 0x9A */ undefined,
            /* 0x9B */ undefined,
            /* 0x9C */ undefined,
            /* 0x9D */ undefined,
            /* 0x9E */ undefined,
            /* 0x9F */ undefined,
            /* 0xA0 */ undefined,
            /* 0xA1 */ undefined,
            /* 0xA2 */ undefined,
            /* 0xA3 */ undefined,
            /* 0xA4 */ undefined,
            /* 0xA5 */ undefined,
            /* 0xA6 */ undefined,
            /* 0xA7 */ undefined,
            /* 0xA8 */ undefined,
            /* 0xA9 */ undefined,
            /* 0xAA */ undefined,
            /* 0xAB */ undefined,
            /* 0xAC */ undefined,
            /* 0xAD */ undefined,
            /* 0xAE */ undefined,
            /* 0xAF */ undefined,
            /* 0xB0 */ PUSHB.bind(undefined, 1),
            /* 0xB1 */ PUSHB.bind(undefined, 2),
            /* 0xB2 */ PUSHB.bind(undefined, 3),
            /* 0xB3 */ PUSHB.bind(undefined, 4),
            /* 0xB4 */ PUSHB.bind(undefined, 5),
            /* 0xB5 */ PUSHB.bind(undefined, 6),
            /* 0xB6 */ PUSHB.bind(undefined, 7),
            /* 0xB7 */ PUSHB.bind(undefined, 8),
            /* 0xB8 */ PUSHW.bind(undefined, 1),
            /* 0xB9 */ PUSHW.bind(undefined, 2),
            /* 0xBA */ PUSHW.bind(undefined, 3),
            /* 0xBB */ PUSHW.bind(undefined, 4),
            /* 0xBC */ PUSHW.bind(undefined, 5),
            /* 0xBD */ PUSHW.bind(undefined, 6),
            /* 0xBE */ PUSHW.bind(undefined, 7),
            /* 0xBF */ PUSHW.bind(undefined, 8),
            /* 0xC0 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              0,
              0,
              0
            ),
            /* 0xC1 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              0,
              0,
              1
            ),
            /* 0xC2 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              0,
              0,
              2
            ),
            /* 0xC3 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              0,
              0,
              3
            ),
            /* 0xC4 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              0,
              1,
              0
            ),
            /* 0xC5 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              0,
              1,
              1
            ),
            /* 0xC6 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              0,
              1,
              2
            ),
            /* 0xC7 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              0,
              1,
              3
            ),
            /* 0xC8 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              1,
              0,
              0
            ),
            /* 0xC9 */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              1,
              0,
              1
            ),
            /* 0xCA */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              1,
              0,
              2
            ),
            /* 0xCB */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              1,
              0,
              3
            ),
            /* 0xCC */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              1,
              1,
              0
            ),
            /* 0xCD */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              1,
              1,
              1
            ),
            /* 0xCE */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              1,
              1,
              2
            ),
            /* 0xCF */ MDRP_MIRP.bind(
              undefined,
              0,
              0,
              1,
              1,
              3
            ),
            /* 0xD0 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              0,
              0,
              0
            ),
            /* 0xD1 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              0,
              0,
              1
            ),
            /* 0xD2 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              0,
              0,
              2
            ),
            /* 0xD3 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              0,
              0,
              3
            ),
            /* 0xD4 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              0,
              1,
              0
            ),
            /* 0xD5 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              0,
              1,
              1
            ),
            /* 0xD6 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              0,
              1,
              2
            ),
            /* 0xD7 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              0,
              1,
              3
            ),
            /* 0xD8 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              1,
              0,
              0
            ),
            /* 0xD9 */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              1,
              0,
              1
            ),
            /* 0xDA */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              1,
              0,
              2
            ),
            /* 0xDB */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              1,
              0,
              3
            ),
            /* 0xDC */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              1,
              1,
              0
            ),
            /* 0xDD */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              1,
              1,
              1
            ),
            /* 0xDE */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              1,
              1,
              2
            ),
            /* 0xDF */ MDRP_MIRP.bind(
              undefined,
              0,
              1,
              1,
              1,
              3
            ),
            /* 0xE0 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              0,
              0,
              0
            ),
            /* 0xE1 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              0,
              0,
              1
            ),
            /* 0xE2 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              0,
              0,
              2
            ),
            /* 0xE3 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              0,
              0,
              3
            ),
            /* 0xE4 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              0,
              1,
              0
            ),
            /* 0xE5 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              0,
              1,
              1
            ),
            /* 0xE6 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              0,
              1,
              2
            ),
            /* 0xE7 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              0,
              1,
              3
            ),
            /* 0xE8 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              1,
              0,
              0
            ),
            /* 0xE9 */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              1,
              0,
              1
            ),
            /* 0xEA */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              1,
              0,
              2
            ),
            /* 0xEB */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              1,
              0,
              3
            ),
            /* 0xEC */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              1,
              1,
              0
            ),
            /* 0xED */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              1,
              1,
              1
            ),
            /* 0xEE */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              1,
              1,
              2
            ),
            /* 0xEF */ MDRP_MIRP.bind(
              undefined,
              1,
              0,
              1,
              1,
              3
            ),
            /* 0xF0 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              0,
              0,
              0
            ),
            /* 0xF1 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              0,
              0,
              1
            ),
            /* 0xF2 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              0,
              0,
              2
            ),
            /* 0xF3 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              0,
              0,
              3
            ),
            /* 0xF4 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              0,
              1,
              0
            ),
            /* 0xF5 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              0,
              1,
              1
            ),
            /* 0xF6 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              0,
              1,
              2
            ),
            /* 0xF7 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              0,
              1,
              3
            ),
            /* 0xF8 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              1,
              0,
              0
            ),
            /* 0xF9 */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              1,
              0,
              1
            ),
            /* 0xFA */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              1,
              0,
              2
            ),
            /* 0xFB */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              1,
              0,
              3
            ),
            /* 0xFC */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              1,
              1,
              0
            ),
            /* 0xFD */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              1,
              1,
              1
            ),
            /* 0xFE */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              1,
              1,
              2
            ),
            /* 0xFF */ MDRP_MIRP.bind(
              undefined,
              1,
              1,
              1,
              1,
              3
            ),
          ];

          /*****************************
	  Mathematical Considerations
	******************************

	fv ... refers to freedom vector
	pv ... refers to projection vector
	rp ... refers to reference point
	p  ... refers to to point being operated on
	d  ... refers to distance

	SETRELATIVE:
	============

	case freedom vector == x-axis:
	------------------------------

	                        (pv)
	                     .-'
	              rpd .-'
	               .-*
	          d .-'90°'
	         .-'       '
	      .-'           '
	   *-'               ' b
	  rp                  '
	                       '
	                        '
	            p *----------*-------------- (fv)
	                          pm

	  rpdx = rpx + d * pv.x
	  rpdy = rpy + d * pv.y

	  equation of line b

	   y - rpdy = pvns * (x- rpdx)

	   y = p.y

	   x = rpdx + ( p.y - rpdy ) / pvns


	case freedom vector == y-axis:
	------------------------------

	    * pm
	    |\
	    | \
	    |  \
	    |   \
	    |    \
	    |     \
	    |      \
	    |       \
	    |        \
	    |         \ b
	    |          \
	    |           \
	    |            \    .-' (pv)
	    |         90° \.-'
	    |           .-'* rpd
	    |        .-'
	    *     *-'  d
	    p     rp

	  rpdx = rpx + d * pv.x
	  rpdy = rpy + d * pv.y

	  equation of line b:
	           pvns ... normal slope to pv

	   y - rpdy = pvns * (x - rpdx)

	   x = p.x

	   y = rpdy +  pvns * (p.x - rpdx)



	generic case:
	-------------


	                              .'(fv)
	                            .'
	                          .* pm
	                        .' !
	                      .'    .
	                    .'      !
	                  .'         . b
	                .'           !
	               *              .
	              p               !
	                         90°   .    ... (pv)
	                           ...-*-'''
	                  ...---'''    rpd
	         ...---'''   d
	   *--'''
	  rp

	    rpdx = rpx + d * pv.x
	    rpdy = rpy + d * pv.y

	 equation of line b:
	    pvns... normal slope to pv

	    y - rpdy = pvns * (x - rpdx)

	 equation of freedom vector line:
	    fvs ... slope of freedom vector (=fy/fx)

	    y - py = fvs * (x - px)


	  on pm both equations are true for same x/y

	    y - rpdy = pvns * (x - rpdx)

	    y - py = fvs * (x - px)

	  form to y and set equal:

	    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

	  expand:

	    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

	  switch:

	    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

	  solve for x:

	    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



	          fvs * px - pvns * rpdx + rpdy - py
	    x =  -----------------------------------
	                 fvs - pvns

	  and:

	    y = fvs * (x - px) + py



	INTERPOLATE:
	============

	Examples of point interpolation.

	The weight of the movement of the reference point gets bigger
	the further the other reference point is away, thus the safest
	option (that is avoiding 0/0 divisions) is to weight the
	original distance of the other point by the sum of both distances.

	If the sum of both distances is 0, then move the point by the
	arithmetic average of the movement of both reference points.




	           (+6)
	    rp1o *---->*rp1
	         .     .                          (+12)
	         .     .                  rp2o *---------->* rp2
	         .     .                       .           .
	         .     .                       .           .
	         .    10          20           .           .
	         |.........|...................|           .
	               .   .                               .
	               .   . (+8)                          .
	                po *------>*p                      .
	               .           .                       .
	               .    12     .          24           .
	               |...........|.......................|
	                                  36


	-------



	           (+10)
	    rp1o *-------->*rp1
	         .         .                      (-10)
	         .         .              rp2 *<---------* rpo2
	         .         .                   .         .
	         .         .                   .         .
	         .    10   .          30       .         .
	         |.........|.............................|
	                   .                   .
	                   . (+5)              .
	                po *--->* p            .
	                   .    .              .
	                   .    .   20         .
	                   |....|..............|
	                     5        15


	-------


	           (+10)
	    rp1o *-------->*rp1
	         .         .
	         .         .
	    rp2o *-------->*rp2


	                               (+10)
	                          po *-------->* p

	-------


	           (+10)
	    rp1o *-------->*rp1
	         .         .
	         .         .(+30)
	    rp2o *---------------------------->*rp2


	                                        (+25)
	                          po *----------------------->* p



	vim: set ts=4 sw=4 expandtab:
	*****/

          // The Font object

          // This code is based on Array.from implementation for strings in https://github.com/mathiasbynens/Array.from
          var arrayFromString =
            Array.from ||
            function (s) {
              return (
                s.match(
                  /[\uD800-\uDBFF][\uDC00-\uDFFF]?|[^\uD800-\uDFFF]|./g
                ) || []
              );
            };

          /**
           * @typedef FontOptions
           * @type Object
           * @property {Boolean} empty - whether to create a new empty font
           * @property {string} familyName
           * @property {string} styleName
           * @property {string=} fullName
           * @property {string=} postScriptName
           * @property {string=} designer
           * @property {string=} designerURL
           * @property {string=} manufacturer
           * @property {string=} manufacturerURL
           * @property {string=} license
           * @property {string=} licenseURL
           * @property {string=} version
           * @property {string=} description
           * @property {string=} copyright
           * @property {string=} trademark
           * @property {Number} unitsPerEm
           * @property {Number} ascender
           * @property {Number} descender
           * @property {Number} createdTimestamp
           * @property {string=} weightClass
           * @property {string=} widthClass
           * @property {string=} fsSelection
           */

          /**
           * A Font represents a loaded OpenType font file.
           * It contains a set of glyphs and methods to draw text on a drawing context,
           * or to get a path representing the text.
           * @exports opentype.Font
           * @class
           * @param {FontOptions}
           * @constructor
           */
          function Font(options) {
            options = options || {};

            if (!options.empty) {
              // Check that we've provided the minimum set of names.
              checkArgument(
                options.familyName,
                "When creating a new Font object, familyName is required."
              );
              checkArgument(
                options.styleName,
                "When creating a new Font object, styleName is required."
              );
              checkArgument(
                options.unitsPerEm,
                "When creating a new Font object, unitsPerEm is required."
              );
              checkArgument(
                options.ascender,
                "When creating a new Font object, ascender is required."
              );
              checkArgument(
                options.descender,
                "When creating a new Font object, descender is required."
              );
              checkArgument(
                options.descender < 0,
                "Descender should be negative (e.g. -512)."
              );

              // OS X will complain if the names are empty, so we put a single space everywhere by default.
              this.names = {
                fontFamily: {
                  en: options.familyName || " ",
                },
                fontSubfamily: {
                  en: options.styleName || " ",
                },
                fullName: {
                  en:
                    options.fullName ||
                    options.familyName +
                      " " +
                      options.styleName,
                },
                // postScriptName may not contain any whitespace
                postScriptName: {
                  en:
                    options.postScriptName ||
                    (
                      options.familyName +
                      options.styleName
                    ).replace(/\s/g, ""),
                },
                designer: {
                  en: options.designer || " ",
                },
                designerURL: {
                  en: options.designerURL || " ",
                },
                manufacturer: {
                  en: options.manufacturer || " ",
                },
                manufacturerURL: {
                  en:
                    options.manufacturerURL ||
                    " ",
                },
                license: {
                  en: options.license || " ",
                },
                licenseURL: {
                  en: options.licenseURL || " ",
                },
                version: {
                  en:
                    options.version ||
                    "Version 0.1",
                },
                description: {
                  en: options.description || " ",
                },
                copyright: {
                  en: options.copyright || " ",
                },
                trademark: {
                  en: options.trademark || " ",
                },
              };
              this.unitsPerEm =
                options.unitsPerEm || 1000;
              this.ascender = options.ascender;
              this.descender = options.descender;
              this.createdTimestamp =
                options.createdTimestamp;
              this.tables = {
                os2: {
                  usWeightClass:
                    options.weightClass ||
                    this.usWeightClasses.MEDIUM,
                  usWidthClass:
                    options.widthClass ||
                    this.usWidthClasses.MEDIUM,
                  fsSelection:
                    options.fsSelection ||
                    this.fsSelectionValues
                      .REGULAR,
                },
              };
            }

            this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
            this.glyphs = new glyphset.GlyphSet(
              this,
              options.glyphs || []
            );
            this.encoding = new DefaultEncoding(
              this
            );
            this.position = new Position(this);
            this.substitution = new Substitution(
              this
            );
            this.tables = this.tables || {};

            Object.defineProperty(
              this,
              "hinting",
              {
                get: function () {
                  if (this._hinting) {
                    return this._hinting;
                  }
                  if (
                    this.outlinesFormat ===
                    "truetype"
                  ) {
                    return (this._hinting =
                      new Hinting(this));
                  }
                },
              }
            );
          }

          /**
           * Check if the font has a glyph for the given character.
           * @param  {string}
           * @return {Boolean}
           */
          Font.prototype.hasChar = function (c) {
            return (
              this.encoding.charToGlyphIndex(
                c
              ) !== null
            );
          };

          /**
           * Convert the given character to a single glyph index.
           * Note that this function assumes that there is a one-to-one mapping between
           * the given character and a glyph; for complex scripts this might not be the case.
           * @param  {string}
           * @return {Number}
           */
          Font.prototype.charToGlyphIndex =
            function (s) {
              return this.encoding.charToGlyphIndex(
                s
              );
            };

          /**
           * Convert the given character to a single Glyph object.
           * Note that this function assumes that there is a one-to-one mapping between
           * the given character and a glyph; for complex scripts this might not be the case.
           * @param  {string}
           * @return {opentype.Glyph}
           */
          Font.prototype.charToGlyph = function (
            c
          ) {
            var glyphIndex =
              this.charToGlyphIndex(c);
            var glyph =
              this.glyphs.get(glyphIndex);
            if (!glyph) {
              // .notdef
              glyph = this.glyphs.get(0);
            }

            return glyph;
          };

          /**
           * Convert the given text to a list of Glyph objects.
           * Note that there is no strict one-to-one mapping between characters and
           * glyphs, so the list of returned glyphs can be larger or smaller than the
           * length of the given string.
           * @param  {string}
           * @param  {GlyphRenderOptions} [options]
           * @return {opentype.Glyph[]}
           */
          Font.prototype.stringToGlyphs =
            function (s, options) {
              var this$1 = this;

              options =
                options ||
                this.defaultRenderOptions;
              // Get glyph indexes
              var chars = arrayFromString(s);
              var indexes = [];
              for (
                var i = 0;
                i < chars.length;
                i += 1
              ) {
                var c = chars[i];
                indexes.push(
                  this$1.charToGlyphIndex(c)
                );
              }
              var length = indexes.length;

              // Apply substitutions on glyph indexes
              if (options.features) {
                var script =
                  options.script ||
                  this.substitution.getDefaultScriptName();
                var manyToOne = [];
                if (options.features.liga) {
                  manyToOne = manyToOne.concat(
                    this.substitution.getFeature(
                      "liga",
                      script,
                      options.language
                    )
                  );
                }
                if (options.features.rlig) {
                  manyToOne = manyToOne.concat(
                    this.substitution.getFeature(
                      "rlig",
                      script,
                      options.language
                    )
                  );
                }
                for (
                  var i$1 = 0;
                  i$1 < length;
                  i$1 += 1
                ) {
                  for (
                    var j = 0;
                    j < manyToOne.length;
                    j++
                  ) {
                    var ligature = manyToOne[j];
                    var components = ligature.sub;
                    var compCount =
                      components.length;
                    var k = 0;
                    while (
                      k < compCount &&
                      components[k] ===
                        indexes[i$1 + k]
                    ) {
                      k++;
                    }
                    if (k === compCount) {
                      indexes.splice(
                        i$1,
                        compCount,
                        ligature.by
                      );
                      length =
                        length - compCount + 1;
                    }
                  }
                }
              }

              // convert glyph indexes to glyph objects
              var glyphs = new Array(length);
              var notdef = this.glyphs.get(0);
              for (
                var i$2 = 0;
                i$2 < length;
                i$2 += 1
              ) {
                glyphs[i$2] =
                  this$1.glyphs.get(
                    indexes[i$2]
                  ) || notdef;
              }
              return glyphs;
            };

          /**
           * @param  {string}
           * @return {Number}
           */
          Font.prototype.nameToGlyphIndex =
            function (name) {
              return this.glyphNames.nameToGlyphIndex(
                name
              );
            };

          /**
           * @param  {string}
           * @return {opentype.Glyph}
           */
          Font.prototype.nameToGlyph = function (
            name
          ) {
            var glyphIndex =
              this.nameToGlyphIndex(name);
            var glyph =
              this.glyphs.get(glyphIndex);
            if (!glyph) {
              // .notdef
              glyph = this.glyphs.get(0);
            }

            return glyph;
          };

          /**
           * @param  {Number}
           * @return {String}
           */
          Font.prototype.glyphIndexToName =
            function (gid) {
              if (
                !this.glyphNames.glyphIndexToName
              ) {
                return "";
              }

              return this.glyphNames.glyphIndexToName(
                gid
              );
            };

          /**
           * Retrieve the value of the kerning pair between the left glyph (or its index)
           * and the right glyph (or its index). If no kerning pair is found, return 0.
           * The kerning value gets added to the advance width when calculating the spacing
           * between glyphs.
           * For GPOS kerning, this method uses the default script and language, which covers
           * most use cases. To have greater control, use font.position.getKerningValue .
           * @param  {opentype.Glyph} leftGlyph
           * @param  {opentype.Glyph} rightGlyph
           * @return {Number}
           */
          Font.prototype.getKerningValue =
            function (leftGlyph, rightGlyph) {
              leftGlyph =
                leftGlyph.index || leftGlyph;
              rightGlyph =
                rightGlyph.index || rightGlyph;
              var gposKerning =
                this.position
                  .defaultKerningTables;
              if (gposKerning) {
                return this.position.getKerningValue(
                  gposKerning,
                  leftGlyph,
                  rightGlyph
                );
              }
              // "kern" table
              return (
                this.kerningPairs[
                  leftGlyph + "," + rightGlyph
                ] || 0
              );
            };

          /**
           * @typedef GlyphRenderOptions
           * @type Object
           * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
           *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
           * @property {string} [language='dflt'] - language system used to determine which features to apply.
           *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
           * @property {boolean} [kerning=true] - whether to include kerning values
           * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
           *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
           */
          Font.prototype.defaultRenderOptions = {
            kerning: true,
            features: {
              liga: true,
              rlig: true,
            },
          };

          /**
           * Helper function that invokes the given callback for each glyph in the given text.
           * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
           * @param {string} text - The text to apply.
           * @param  {number} [x=0] - Horizontal position of the beginning of the text.
           * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           * @param  {GlyphRenderOptions=} options
           * @param  {Function} callback
           */
          Font.prototype.forEachGlyph = function (
            text,
            x,
            y,
            fontSize,
            options,
            callback
          ) {
            var this$1 = this;

            x = x !== undefined ? x : 0;
            y = y !== undefined ? y : 0;
            fontSize =
              fontSize !== undefined
                ? fontSize
                : 72;
            options =
              options ||
              this.defaultRenderOptions;
            var fontScale =
              (1 / this.unitsPerEm) * fontSize;
            var glyphs = this.stringToGlyphs(
              text,
              options
            );
            var kerningLookups;
            if (options.kerning) {
              var script =
                options.script ||
                this.position.getDefaultScriptName();
              kerningLookups =
                this.position.getKerningTables(
                  script,
                  options.language
                );
            }
            for (
              var i = 0;
              i < glyphs.length;
              i += 1
            ) {
              var glyph = glyphs[i];
              callback.call(
                this$1,
                glyph,
                x,
                y,
                fontSize,
                options
              );
              if (glyph.advanceWidth) {
                x +=
                  glyph.advanceWidth * fontScale;
              }

              if (
                options.kerning &&
                i < glyphs.length - 1
              ) {
                // We should apply position adjustment lookups in a more generic way.
                // Here we only use the xAdvance value.
                var kerningValue = kerningLookups
                  ? this$1.position.getKerningValue(
                      kerningLookups,
                      glyph.index,
                      glyphs[i + 1].index
                    )
                  : this$1.getKerningValue(
                      glyph,
                      glyphs[i + 1]
                    );
                x += kerningValue * fontScale;
              }

              if (options.letterSpacing) {
                x +=
                  options.letterSpacing *
                  fontSize;
              } else if (options.tracking) {
                x +=
                  (options.tracking / 1000) *
                  fontSize;
              }
            }
            return x;
          };

          /**
           * Create a Path object that represents the given text.
           * @param  {string} text - The text to create.
           * @param  {number} [x=0] - Horizontal position of the beginning of the text.
           * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           * @param  {GlyphRenderOptions=} options
           * @return {opentype.Path}
           */
          Font.prototype.getPath = function (
            text,
            x,
            y,
            fontSize,
            options
          ) {
            var fullPath = new Path();
            this.forEachGlyph(
              text,
              x,
              y,
              fontSize,
              options,
              function (
                glyph,
                gX,
                gY,
                gFontSize
              ) {
                var glyphPath = glyph.getPath(
                  gX,
                  gY,
                  gFontSize,
                  options,
                  this
                );
                fullPath.extend(glyphPath);
              }
            );
            return fullPath;
          };

          /**
           * Create an array of Path objects that represent the glyphs of a given text.
           * @param  {string} text - The text to create.
           * @param  {number} [x=0] - Horizontal position of the beginning of the text.
           * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           * @param  {GlyphRenderOptions=} options
           * @return {opentype.Path[]}
           */
          Font.prototype.getPaths = function (
            text,
            x,
            y,
            fontSize,
            options
          ) {
            var glyphPaths = [];
            this.forEachGlyph(
              text,
              x,
              y,
              fontSize,
              options,
              function (
                glyph,
                gX,
                gY,
                gFontSize
              ) {
                var glyphPath = glyph.getPath(
                  gX,
                  gY,
                  gFontSize,
                  options,
                  this
                );
                glyphPaths.push(glyphPath);
              }
            );

            return glyphPaths;
          };

          /**
           * Returns the advance width of a text.
           *
           * This is something different than Path.getBoundingBox() as for example a
           * suffixed whitespace increases the advanceWidth but not the bounding box
           * or an overhanging letter like a calligraphic 'f' might have a quite larger
           * bounding box than its advance width.
           *
           * This corresponds to canvas2dContext.measureText(text).width
           *
           * @param  {string} text - The text to create.
           * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           * @param  {GlyphRenderOptions=} options
           * @return advance width
           */
          Font.prototype.getAdvanceWidth =
            function (text, fontSize, options) {
              return this.forEachGlyph(
                text,
                0,
                0,
                fontSize,
                options,
                function () {}
              );
            };

          /**
           * Draw the text on the given drawing context.
           * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
           * @param  {string} text - The text to create.
           * @param  {number} [x=0] - Horizontal position of the beginning of the text.
           * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           * @param  {GlyphRenderOptions=} options
           */
          Font.prototype.draw = function (
            ctx,
            text,
            x,
            y,
            fontSize,
            options
          ) {
            this.getPath(
              text,
              x,
              y,
              fontSize,
              options
            ).draw(ctx);
          };

          /**
           * Draw the points of all glyphs in the text.
           * On-curve points will be drawn in blue, off-curve points will be drawn in red.
           * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
           * @param {string} text - The text to create.
           * @param {number} [x=0] - Horizontal position of the beginning of the text.
           * @param {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           * @param {GlyphRenderOptions=} options
           */
          Font.prototype.drawPoints = function (
            ctx,
            text,
            x,
            y,
            fontSize,
            options
          ) {
            this.forEachGlyph(
              text,
              x,
              y,
              fontSize,
              options,
              function (
                glyph,
                gX,
                gY,
                gFontSize
              ) {
                glyph.drawPoints(
                  ctx,
                  gX,
                  gY,
                  gFontSize
                );
              }
            );
          };

          /**
           * Draw lines indicating important font measurements for all glyphs in the text.
           * Black lines indicate the origin of the coordinate system (point 0,0).
           * Blue lines indicate the glyph bounding box.
           * Green line indicates the advance width of the glyph.
           * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
           * @param {string} text - The text to create.
           * @param {number} [x=0] - Horizontal position of the beginning of the text.
           * @param {number} [y=0] - Vertical position of the *baseline* of the text.
           * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
           * @param {GlyphRenderOptions=} options
           */
          Font.prototype.drawMetrics = function (
            ctx,
            text,
            x,
            y,
            fontSize,
            options
          ) {
            this.forEachGlyph(
              text,
              x,
              y,
              fontSize,
              options,
              function (
                glyph,
                gX,
                gY,
                gFontSize
              ) {
                glyph.drawMetrics(
                  ctx,
                  gX,
                  gY,
                  gFontSize
                );
              }
            );
          };

          /**
           * @param  {string}
           * @return {string}
           */
          Font.prototype.getEnglishName =
            function (name) {
              var translations = this.names[name];
              if (translations) {
                return translations.en;
              }
            };

          /**
           * Validate
           */
          Font.prototype.validate = function () {
            var _this = this;

            function assert(predicate, message) {}

            function assertNamePresent(name) {
              var englishName =
                _this.getEnglishName(name);
              assert(
                englishName &&
                  englishName.trim().length > 0,
                "No English " +
                  name +
                  " specified."
              );
            }

            // Identification information
            assertNamePresent("fontFamily");
            assertNamePresent("weightName");
            assertNamePresent("manufacturer");
            assertNamePresent("copyright");
            assertNamePresent("version");

            // Dimension information
            assert(
              this.unitsPerEm > 0,
              "No unitsPerEm specified."
            );
          };

          /**
           * Convert the font object to a SFNT data structure.
           * This structure contains all the necessary tables and metadata to create a binary OTF file.
           * @return {opentype.Table}
           */
          Font.prototype.toTables = function () {
            return sfnt.fontToTable(this);
          };
          /**
           * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
           */
          Font.prototype.toBuffer = function () {
            console.warn(
              "Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."
            );
            return this.toArrayBuffer();
          };
          /**
           * Converts a `opentype.Font` into an `ArrayBuffer`
           * @return {ArrayBuffer}
           */
          Font.prototype.toArrayBuffer =
            function () {
              var sfntTable = this.toTables();
              var bytes = sfntTable.encode();
              var buffer = new ArrayBuffer(
                bytes.length
              );
              var intArray = new Uint8Array(
                buffer
              );
              for (
                var i = 0;
                i < bytes.length;
                i++
              ) {
                intArray[i] = bytes[i];
              }

              return buffer;
            };

          /**
           * Initiate a download of the OpenType font.
           */
          Font.prototype.download = function (
            fileName
          ) {
            var familyName =
              this.getEnglishName("fontFamily");
            var styleName = this.getEnglishName(
              "fontSubfamily"
            );
            fileName =
              fileName ||
              familyName.replace(/\s/g, "") +
                "-" +
                styleName +
                ".otf";
            var arrayBuffer =
              this.toArrayBuffer();

            if (isBrowser()) {
              window.URL =
                window.URL || window.webkitURL;

              if (window.URL) {
                var dataView = new DataView(
                  arrayBuffer
                );
                var blob = new Blob([dataView], {
                  type: "font/opentype",
                });

                var link =
                  document.createElement("a");
                link.href =
                  window.URL.createObjectURL(
                    blob
                  );
                link.download = fileName;

                var event = document.createEvent(
                  "MouseEvents"
                );
                event.initEvent(
                  "click",
                  true,
                  false
                );
                link.dispatchEvent(event);
              } else {
                console.warn(
                  "Font file could not be downloaded. Try using a different browser."
                );
              }
            } else {
              var fs = __webpack_require__(
                /*! fs */ "?4db5"
              );
              var buffer =
                arrayBufferToNodeBuffer(
                  arrayBuffer
                );
              fs.writeFileSync(fileName, buffer);
            }
          };
          /**
           * @private
           */
          Font.prototype.fsSelectionValues = {
            ITALIC: 0x001, //1
            UNDERSCORE: 0x002, //2
            NEGATIVE: 0x004, //4
            OUTLINED: 0x008, //8
            STRIKEOUT: 0x010, //16
            BOLD: 0x020, //32
            REGULAR: 0x040, //64
            USER_TYPO_METRICS: 0x080, //128
            WWS: 0x100, //256
            OBLIQUE: 0x200, //512
          };

          /**
           * @private
           */
          Font.prototype.usWidthClasses = {
            ULTRA_CONDENSED: 1,
            EXTRA_CONDENSED: 2,
            CONDENSED: 3,
            SEMI_CONDENSED: 4,
            MEDIUM: 5,
            SEMI_EXPANDED: 6,
            EXPANDED: 7,
            EXTRA_EXPANDED: 8,
            ULTRA_EXPANDED: 9,
          };

          /**
           * @private
           */
          Font.prototype.usWeightClasses = {
            THIN: 100,
            EXTRA_LIGHT: 200,
            LIGHT: 300,
            NORMAL: 400,
            MEDIUM: 500,
            SEMI_BOLD: 600,
            BOLD: 700,
            EXTRA_BOLD: 800,
            BLACK: 900,
          };

          // The `fvar` table stores font variation axes and instances.

          function addName(name, names) {
            var nameString = JSON.stringify(name);
            var nameID = 256;
            for (var nameKey in names) {
              var n = parseInt(nameKey);
              if (!n || n < 256) {
                continue;
              }

              if (
                JSON.stringify(names[nameKey]) ===
                nameString
              ) {
                return n;
              }

              if (nameID <= n) {
                nameID = n + 1;
              }
            }

            names[nameID] = name;
            return nameID;
          }

          function makeFvarAxis(n, axis, names) {
            var nameID = addName(
              axis.name,
              names
            );
            return [
              {
                name: "tag_" + n,
                type: "TAG",
                value: axis.tag,
              },
              {
                name: "minValue_" + n,
                type: "FIXED",
                value: axis.minValue << 16,
              },
              {
                name: "defaultValue_" + n,
                type: "FIXED",
                value: axis.defaultValue << 16,
              },
              {
                name: "maxValue_" + n,
                type: "FIXED",
                value: axis.maxValue << 16,
              },
              {
                name: "flags_" + n,
                type: "USHORT",
                value: 0,
              },
              {
                name: "nameID_" + n,
                type: "USHORT",
                value: nameID,
              },
            ];
          }

          function parseFvarAxis(
            data,
            start,
            names
          ) {
            var axis = {};
            var p = new parse.Parser(data, start);
            axis.tag = p.parseTag();
            axis.minValue = p.parseFixed();
            axis.defaultValue = p.parseFixed();
            axis.maxValue = p.parseFixed();
            p.skip("uShort", 1); // reserved for flags; no values defined
            axis.name =
              names[p.parseUShort()] || {};
            return axis;
          }

          function makeFvarInstance(
            n,
            inst,
            axes,
            names
          ) {
            var nameID = addName(
              inst.name,
              names
            );
            var fields = [
              {
                name: "nameID_" + n,
                type: "USHORT",
                value: nameID,
              },
              {
                name: "flags_" + n,
                type: "USHORT",
                value: 0,
              },
            ];

            for (
              var i = 0;
              i < axes.length;
              ++i
            ) {
              var axisTag = axes[i].tag;
              fields.push({
                name: "axis_" + n + " " + axisTag,
                type: "FIXED",
                value:
                  inst.coordinates[axisTag] << 16,
              });
            }

            return fields;
          }

          function parseFvarInstance(
            data,
            start,
            axes,
            names
          ) {
            var inst = {};
            var p = new parse.Parser(data, start);
            inst.name =
              names[p.parseUShort()] || {};
            p.skip("uShort", 1); // reserved for flags; no values defined

            inst.coordinates = {};
            for (
              var i = 0;
              i < axes.length;
              ++i
            ) {
              inst.coordinates[axes[i].tag] =
                p.parseFixed();
            }

            return inst;
          }

          function makeFvarTable(fvar, names) {
            var result = new table.Table("fvar", [
              {
                name: "version",
                type: "ULONG",
                value: 0x10000,
              },
              {
                name: "offsetToData",
                type: "USHORT",
                value: 0,
              },
              {
                name: "countSizePairs",
                type: "USHORT",
                value: 2,
              },
              {
                name: "axisCount",
                type: "USHORT",
                value: fvar.axes.length,
              },
              {
                name: "axisSize",
                type: "USHORT",
                value: 20,
              },
              {
                name: "instanceCount",
                type: "USHORT",
                value: fvar.instances.length,
              },
              {
                name: "instanceSize",
                type: "USHORT",
                value: 4 + fvar.axes.length * 4,
              },
            ]);
            result.offsetToData = result.sizeOf();

            for (
              var i = 0;
              i < fvar.axes.length;
              i++
            ) {
              result.fields =
                result.fields.concat(
                  makeFvarAxis(
                    i,
                    fvar.axes[i],
                    names
                  )
                );
            }

            for (
              var j = 0;
              j < fvar.instances.length;
              j++
            ) {
              result.fields =
                result.fields.concat(
                  makeFvarInstance(
                    j,
                    fvar.instances[j],
                    fvar.axes,
                    names
                  )
                );
            }

            return result;
          }

          function parseFvarTable(
            data,
            start,
            names
          ) {
            var p = new parse.Parser(data, start);
            var tableVersion = p.parseULong();
            check.argument(
              tableVersion === 0x00010000,
              "Unsupported fvar table version."
            );
            var offsetToData = p.parseOffset16();
            // Skip countSizePairs.
            p.skip("uShort", 1);
            var axisCount = p.parseUShort();
            var axisSize = p.parseUShort();
            var instanceCount = p.parseUShort();
            var instanceSize = p.parseUShort();

            var axes = [];
            for (var i = 0; i < axisCount; i++) {
              axes.push(
                parseFvarAxis(
                  data,
                  start +
                    offsetToData +
                    i * axisSize,
                  names
                )
              );
            }

            var instances = [];
            var instanceStart =
              start +
              offsetToData +
              axisCount * axisSize;
            for (
              var j = 0;
              j < instanceCount;
              j++
            ) {
              instances.push(
                parseFvarInstance(
                  data,
                  instanceStart +
                    j * instanceSize,
                  axes,
                  names
                )
              );
            }

            return {
              axes: axes,
              instances: instances,
            };
          }

          var fvar = {
            make: makeFvarTable,
            parse: parseFvarTable,
          };

          // The `GPOS` table contains kerning pairs, among other things.

          var subtableParsers$1 = new Array(10); // subtableParsers[0] is unused

          // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
          // this = Parser instance
          subtableParsers$1[1] =
            function parseLookup1() {
              var start =
                this.offset + this.relativeOffset;
              var posformat = this.parseUShort();
              if (posformat === 1) {
                return {
                  posFormat: 1,
                  coverage: this.parsePointer(
                    Parser.coverage
                  ),
                  value: this.parseValueRecord(),
                };
              } else if (posformat === 2) {
                return {
                  posFormat: 2,
                  coverage: this.parsePointer(
                    Parser.coverage
                  ),
                  values:
                    this.parseValueRecordList(),
                };
              }
              check.assert(
                false,
                "0x" +
                  start.toString(16) +
                  ": GPOS lookup type 1 format must be 1 or 2."
              );
            };

          // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
          subtableParsers$1[2] =
            function parseLookup2() {
              var start =
                this.offset + this.relativeOffset;
              var posFormat = this.parseUShort();
              check.assert(
                posFormat === 1 ||
                  posFormat === 2,
                "0x" +
                  start.toString(16) +
                  ": GPOS lookup type 2 format must be 1 or 2."
              );
              var coverage = this.parsePointer(
                Parser.coverage
              );
              var valueFormat1 =
                this.parseUShort();
              var valueFormat2 =
                this.parseUShort();
              if (posFormat === 1) {
                // Adjustments for Glyph Pairs
                return {
                  posFormat: posFormat,
                  coverage: coverage,
                  valueFormat1: valueFormat1,
                  valueFormat2: valueFormat2,
                  pairSets: this.parseList(
                    Parser.pointer(
                      Parser.list(function () {
                        return {
                          // pairValueRecord
                          secondGlyph:
                            this.parseUShort(),
                          value1:
                            this.parseValueRecord(
                              valueFormat1
                            ),
                          value2:
                            this.parseValueRecord(
                              valueFormat2
                            ),
                        };
                      })
                    )
                  ),
                };
              } else if (posFormat === 2) {
                var classDef1 = this.parsePointer(
                  Parser.classDef
                );
                var classDef2 = this.parsePointer(
                  Parser.classDef
                );
                var class1Count =
                  this.parseUShort();
                var class2Count =
                  this.parseUShort();
                return {
                  // Class Pair Adjustment
                  posFormat: posFormat,
                  coverage: coverage,
                  valueFormat1: valueFormat1,
                  valueFormat2: valueFormat2,
                  classDef1: classDef1,
                  classDef2: classDef2,
                  class1Count: class1Count,
                  class2Count: class2Count,
                  classRecords: this.parseList(
                    class1Count,
                    Parser.list(
                      class2Count,
                      function () {
                        return {
                          value1:
                            this.parseValueRecord(
                              valueFormat1
                            ),
                          value2:
                            this.parseValueRecord(
                              valueFormat2
                            ),
                        };
                      }
                    )
                  ),
                };
              }
            };

          subtableParsers$1[3] =
            function parseLookup3() {
              return {
                error:
                  "GPOS Lookup 3 not supported",
              };
            };
          subtableParsers$1[4] =
            function parseLookup4() {
              return {
                error:
                  "GPOS Lookup 4 not supported",
              };
            };
          subtableParsers$1[5] =
            function parseLookup5() {
              return {
                error:
                  "GPOS Lookup 5 not supported",
              };
            };
          subtableParsers$1[6] =
            function parseLookup6() {
              return {
                error:
                  "GPOS Lookup 6 not supported",
              };
            };
          subtableParsers$1[7] =
            function parseLookup7() {
              return {
                error:
                  "GPOS Lookup 7 not supported",
              };
            };
          subtableParsers$1[8] =
            function parseLookup8() {
              return {
                error:
                  "GPOS Lookup 8 not supported",
              };
            };
          subtableParsers$1[9] =
            function parseLookup9() {
              return {
                error:
                  "GPOS Lookup 9 not supported",
              };
            };

          // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
          function parseGposTable(data, start) {
            start = start || 0;
            var p = new Parser(data, start);
            var tableVersion = p.parseVersion(1);
            check.argument(
              tableVersion === 1 ||
                tableVersion === 1.1,
              "Unsupported GPOS table version " +
                tableVersion
            );

            if (tableVersion === 1) {
              return {
                version: tableVersion,
                scripts: p.parseScriptList(),
                features: p.parseFeatureList(),
                lookups: p.parseLookupList(
                  subtableParsers$1
                ),
              };
            } else {
              return {
                version: tableVersion,
                scripts: p.parseScriptList(),
                features: p.parseFeatureList(),
                lookups: p.parseLookupList(
                  subtableParsers$1
                ),
                variations:
                  p.parseFeatureVariationsList(),
              };
            }
          }

          // GPOS Writing //////////////////////////////////////////////
          // NOT SUPPORTED
          var subtableMakers$1 = new Array(10);

          function makeGposTable(gpos) {
            return new table.Table("GPOS", [
              {
                name: "version",
                type: "ULONG",
                value: 0x10000,
              },
              {
                name: "scripts",
                type: "TABLE",
                value: new table.ScriptList(
                  gpos.scripts
                ),
              },
              {
                name: "features",
                type: "TABLE",
                value: new table.FeatureList(
                  gpos.features
                ),
              },
              {
                name: "lookups",
                type: "TABLE",
                value: new table.LookupList(
                  gpos.lookups,
                  subtableMakers$1
                ),
              },
            ]);
          }

          var gpos = {
            parse: parseGposTable,
            make: makeGposTable,
          };

          // The `kern` table contains kerning pairs.

          function parseWindowsKernTable(p) {
            var pairs = {};
            // Skip nTables.
            p.skip("uShort");
            var subtableVersion = p.parseUShort();
            check.argument(
              subtableVersion === 0,
              "Unsupported kern sub-table version."
            );
            // Skip subtableLength, subtableCoverage
            p.skip("uShort", 2);
            var nPairs = p.parseUShort();
            // Skip searchRange, entrySelector, rangeShift.
            p.skip("uShort", 3);
            for (var i = 0; i < nPairs; i += 1) {
              var leftIndex = p.parseUShort();
              var rightIndex = p.parseUShort();
              var value = p.parseShort();
              pairs[
                leftIndex + "," + rightIndex
              ] = value;
            }
            return pairs;
          }

          function parseMacKernTable(p) {
            var pairs = {};
            // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
            // Skip the rest.
            p.skip("uShort");
            var nTables = p.parseULong();
            //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
            if (nTables > 1) {
              console.warn(
                "Only the first kern subtable is supported."
              );
            }
            p.skip("uLong");
            var coverage = p.parseUShort();
            var subtableVersion = coverage & 0xff;
            p.skip("uShort");
            if (subtableVersion === 0) {
              var nPairs = p.parseUShort();
              // Skip searchRange, entrySelector, rangeShift.
              p.skip("uShort", 3);
              for (
                var i = 0;
                i < nPairs;
                i += 1
              ) {
                var leftIndex = p.parseUShort();
                var rightIndex = p.parseUShort();
                var value = p.parseShort();
                pairs[
                  leftIndex + "," + rightIndex
                ] = value;
              }
            }
            return pairs;
          }

          // Parse the `kern` table which contains kerning pairs.
          function parseKernTable(data, start) {
            var p = new parse.Parser(data, start);
            var tableVersion = p.parseUShort();
            if (tableVersion === 0) {
              return parseWindowsKernTable(p);
            } else if (tableVersion === 1) {
              return parseMacKernTable(p);
            } else {
              throw new Error(
                "Unsupported kern table version (" +
                  tableVersion +
                  ")."
              );
            }
          }

          var kern = { parse: parseKernTable };

          // The `loca` table stores the offsets to the locations of the glyphs in the font.

          // Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
          // relative to the beginning of the glyphData table.
          // The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
          // The loca table has two versions: a short version where offsets are stored as uShorts, and a long
          // version where offsets are stored as uLongs. The `head` table specifies which version to use
          // (under indexToLocFormat).
          function parseLocaTable(
            data,
            start,
            numGlyphs,
            shortVersion
          ) {
            var p = new parse.Parser(data, start);
            var parseFn = shortVersion
              ? p.parseUShort
              : p.parseULong;
            // There is an extra entry after the last index element to compute the length of the last glyph.
            // That's why we use numGlyphs + 1.
            var glyphOffsets = [];
            for (
              var i = 0;
              i < numGlyphs + 1;
              i += 1
            ) {
              var glyphOffset = parseFn.call(p);
              if (shortVersion) {
                // The short table version stores the actual offset divided by 2.
                glyphOffset *= 2;
              }

              glyphOffsets.push(glyphOffset);
            }

            return glyphOffsets;
          }

          var loca = { parse: parseLocaTable };

          // opentype.js

          /**
           * The opentype library.
           * @namespace opentype
           */

          // File loaders /////////////////////////////////////////////////////////
          /**
           * Loads a font from a file. The callback throws an error message as the first parameter if it fails
           * and the font as an ArrayBuffer in the second parameter if it succeeds.
           * @param  {string} path - The path of the file
           * @param  {Function} callback - The function to call when the font load completes
           */
          function loadFromFile(path, callback) {
            var fs = __webpack_require__(
              /*! fs */ "?4db5"
            );
            fs.readFile(
              path,
              function (err, buffer) {
                if (err) {
                  return callback(err.message);
                }

                callback(
                  null,
                  nodeBufferToArrayBuffer(buffer)
                );
              }
            );
          }
          /**
           * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
           * and the font as an ArrayBuffer in the second parameter if it succeeds.
           * @param  {string} url - The URL of the font file.
           * @param  {Function} callback - The function to call when the font load completes
           */
          function loadFromUrl(url, callback) {
            var request = new XMLHttpRequest();
            request.open("get", url, true);
            request.responseType = "arraybuffer";
            request.onload = function () {
              if (request.response) {
                return callback(
                  null,
                  request.response
                );
              } else {
                return callback(
                  "Font could not be loaded: " +
                    request.statusText
                );
              }
            };

            request.onerror = function () {
              callback(
                "Font could not be loaded"
              );
            };

            request.send();
          }

          // Table Directory Entries //////////////////////////////////////////////
          /**
           * Parses OpenType table entries.
           * @param  {DataView}
           * @param  {Number}
           * @return {Object[]}
           */
          function parseOpenTypeTableEntries(
            data,
            numTables
          ) {
            var tableEntries = [];
            var p = 12;
            for (
              var i = 0;
              i < numTables;
              i += 1
            ) {
              var tag = parse.getTag(data, p);
              var checksum = parse.getULong(
                data,
                p + 4
              );
              var offset = parse.getULong(
                data,
                p + 8
              );
              var length = parse.getULong(
                data,
                p + 12
              );
              tableEntries.push({
                tag: tag,
                checksum: checksum,
                offset: offset,
                length: length,
                compression: false,
              });
              p += 16;
            }

            return tableEntries;
          }

          /**
           * Parses WOFF table entries.
           * @param  {DataView}
           * @param  {Number}
           * @return {Object[]}
           */
          function parseWOFFTableEntries(
            data,
            numTables
          ) {
            var tableEntries = [];
            var p = 44; // offset to the first table directory entry.
            for (
              var i = 0;
              i < numTables;
              i += 1
            ) {
              var tag = parse.getTag(data, p);
              var offset = parse.getULong(
                data,
                p + 4
              );
              var compLength = parse.getULong(
                data,
                p + 8
              );
              var origLength = parse.getULong(
                data,
                p + 12
              );
              var compression = void 0;
              if (compLength < origLength) {
                compression = "WOFF";
              } else {
                compression = false;
              }

              tableEntries.push({
                tag: tag,
                offset: offset,
                compression: compression,
                compressedLength: compLength,
                length: origLength,
              });
              p += 20;
            }

            return tableEntries;
          }

          /**
           * @typedef TableData
           * @type Object
           * @property {DataView} data - The DataView
           * @property {number} offset - The data offset.
           */

          /**
           * @param  {DataView}
           * @param  {Object}
           * @return {TableData}
           */
          function uncompressTable(
            data,
            tableEntry
          ) {
            if (
              tableEntry.compression === "WOFF"
            ) {
              var inBuffer = new Uint8Array(
                data.buffer,
                tableEntry.offset + 2,
                tableEntry.compressedLength - 2
              );
              var outBuffer = new Uint8Array(
                tableEntry.length
              );
              tinyInflate(inBuffer, outBuffer);
              if (
                outBuffer.byteLength !==
                tableEntry.length
              ) {
                throw new Error(
                  "Decompression error: " +
                    tableEntry.tag +
                    " decompressed length doesn't match recorded length"
                );
              }

              var view = new DataView(
                outBuffer.buffer,
                0
              );
              return { data: view, offset: 0 };
            } else {
              return {
                data: data,
                offset: tableEntry.offset,
              };
            }
          }

          // Public API ///////////////////////////////////////////////////////////

          /**
           * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
           * Throws an error if the font could not be parsed.
           * @param  {ArrayBuffer}
           * @return {opentype.Font}
           */
          function parseBuffer(buffer) {
            var indexToLocFormat;
            var ltagTable;

            // Since the constructor can also be called to create new fonts from scratch, we indicate this
            // should be an empty font that we'll fill with our own data.
            var font = new Font({ empty: true });

            // OpenType fonts use big endian byte ordering.
            // We can't rely on typed array view types, because they operate with the endianness of the host computer.
            // Instead we use DataViews where we can specify endianness.
            var data = new DataView(buffer, 0);
            var numTables;
            var tableEntries = [];
            var signature = parse.getTag(data, 0);
            if (
              signature ===
                String.fromCharCode(0, 1, 0, 0) ||
              signature === "true" ||
              signature === "typ1"
            ) {
              font.outlinesFormat = "truetype";
              numTables = parse.getUShort(
                data,
                4
              );
              tableEntries =
                parseOpenTypeTableEntries(
                  data,
                  numTables
                );
            } else if (signature === "OTTO") {
              font.outlinesFormat = "cff";
              numTables = parse.getUShort(
                data,
                4
              );
              tableEntries =
                parseOpenTypeTableEntries(
                  data,
                  numTables
                );
            } else if (signature === "wOFF") {
              var flavor = parse.getTag(data, 4);
              if (
                flavor ===
                String.fromCharCode(0, 1, 0, 0)
              ) {
                font.outlinesFormat = "truetype";
              } else if (flavor === "OTTO") {
                font.outlinesFormat = "cff";
              } else {
                throw new Error(
                  "Unsupported OpenType flavor " +
                    signature
                );
              }

              numTables = parse.getUShort(
                data,
                12
              );
              tableEntries =
                parseWOFFTableEntries(
                  data,
                  numTables
                );
            } else {
              throw new Error(
                "Unsupported OpenType signature " +
                  signature
              );
            }

            var cffTableEntry;
            var fvarTableEntry;
            var glyfTableEntry;
            var gposTableEntry;
            var gsubTableEntry;
            var hmtxTableEntry;
            var kernTableEntry;
            var locaTableEntry;
            var nameTableEntry;
            var metaTableEntry;
            var p;

            for (
              var i = 0;
              i < numTables;
              i += 1
            ) {
              var tableEntry = tableEntries[i];
              var table = void 0;
              switch (tableEntry.tag) {
                case "cmap":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  font.tables.cmap = cmap.parse(
                    table.data,
                    table.offset
                  );
                  font.encoding =
                    new CmapEncoding(
                      font.tables.cmap
                    );
                  break;
                case "cvt ":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  p = new parse.Parser(
                    table.data,
                    table.offset
                  );
                  font.tables.cvt =
                    p.parseShortList(
                      tableEntry.length / 2
                    );
                  break;
                case "fvar":
                  fvarTableEntry = tableEntry;
                  break;
                case "fpgm":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  p = new parse.Parser(
                    table.data,
                    table.offset
                  );
                  font.tables.fpgm =
                    p.parseByteList(
                      tableEntry.length
                    );
                  break;
                case "head":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  font.tables.head = head.parse(
                    table.data,
                    table.offset
                  );
                  font.unitsPerEm =
                    font.tables.head.unitsPerEm;
                  indexToLocFormat =
                    font.tables.head
                      .indexToLocFormat;
                  break;
                case "hhea":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  font.tables.hhea = hhea.parse(
                    table.data,
                    table.offset
                  );
                  font.ascender =
                    font.tables.hhea.ascender;
                  font.descender =
                    font.tables.hhea.descender;
                  font.numberOfHMetrics =
                    font.tables.hhea.numberOfHMetrics;
                  break;
                case "hmtx":
                  hmtxTableEntry = tableEntry;
                  break;
                case "ltag":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  ltagTable = ltag.parse(
                    table.data,
                    table.offset
                  );
                  break;
                case "maxp":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  font.tables.maxp = maxp.parse(
                    table.data,
                    table.offset
                  );
                  font.numGlyphs =
                    font.tables.maxp.numGlyphs;
                  break;
                case "name":
                  nameTableEntry = tableEntry;
                  break;
                case "OS/2":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  font.tables.os2 = os2.parse(
                    table.data,
                    table.offset
                  );
                  break;
                case "post":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  font.tables.post = post.parse(
                    table.data,
                    table.offset
                  );
                  font.glyphNames =
                    new GlyphNames(
                      font.tables.post
                    );
                  break;
                case "prep":
                  table = uncompressTable(
                    data,
                    tableEntry
                  );
                  p = new parse.Parser(
                    table.data,
                    table.offset
                  );
                  font.tables.prep =
                    p.parseByteList(
                      tableEntry.length
                    );
                  break;
                case "glyf":
                  glyfTableEntry = tableEntry;
                  break;
                case "loca":
                  locaTableEntry = tableEntry;
                  break;
                case "CFF ":
                  cffTableEntry = tableEntry;
                  break;
                case "kern":
                  kernTableEntry = tableEntry;
                  break;
                case "GPOS":
                  gposTableEntry = tableEntry;
                  break;
                case "GSUB":
                  gsubTableEntry = tableEntry;
                  break;
                case "meta":
                  metaTableEntry = tableEntry;
                  break;
              }
            }

            var nameTable = uncompressTable(
              data,
              nameTableEntry
            );
            font.tables.name = _name.parse(
              nameTable.data,
              nameTable.offset,
              ltagTable
            );
            font.names = font.tables.name;

            if (
              glyfTableEntry &&
              locaTableEntry
            ) {
              var shortVersion =
                indexToLocFormat === 0;
              var locaTable = uncompressTable(
                data,
                locaTableEntry
              );
              var locaOffsets = loca.parse(
                locaTable.data,
                locaTable.offset,
                font.numGlyphs,
                shortVersion
              );
              var glyfTable = uncompressTable(
                data,
                glyfTableEntry
              );
              font.glyphs = glyf.parse(
                glyfTable.data,
                glyfTable.offset,
                locaOffsets,
                font
              );
            } else if (cffTableEntry) {
              var cffTable = uncompressTable(
                data,
                cffTableEntry
              );
              cff.parse(
                cffTable.data,
                cffTable.offset,
                font
              );
            } else {
              throw new Error(
                "Font doesn't contain TrueType or CFF outlines."
              );
            }

            var hmtxTable = uncompressTable(
              data,
              hmtxTableEntry
            );
            hmtx.parse(
              hmtxTable.data,
              hmtxTable.offset,
              font.numberOfHMetrics,
              font.numGlyphs,
              font.glyphs
            );
            addGlyphNames(font);

            if (kernTableEntry) {
              var kernTable = uncompressTable(
                data,
                kernTableEntry
              );
              font.kerningPairs = kern.parse(
                kernTable.data,
                kernTable.offset
              );
            } else {
              font.kerningPairs = {};
            }

            if (gposTableEntry) {
              var gposTable = uncompressTable(
                data,
                gposTableEntry
              );
              font.tables.gpos = gpos.parse(
                gposTable.data,
                gposTable.offset
              );
              font.position.init();
            }

            if (gsubTableEntry) {
              var gsubTable = uncompressTable(
                data,
                gsubTableEntry
              );
              font.tables.gsub = gsub.parse(
                gsubTable.data,
                gsubTable.offset
              );
            }

            if (fvarTableEntry) {
              var fvarTable = uncompressTable(
                data,
                fvarTableEntry
              );
              font.tables.fvar = fvar.parse(
                fvarTable.data,
                fvarTable.offset,
                font.names
              );
            }

            if (metaTableEntry) {
              var metaTable = uncompressTable(
                data,
                metaTableEntry
              );
              font.tables.meta = meta.parse(
                metaTable.data,
                metaTable.offset
              );
              font.metas = font.tables.meta;
            }

            return font;
          }

          /**
           * Asynchronously load the font from a URL or a filesystem. When done, call the callback
           * with two arguments `(err, font)`. The `err` will be null on success,
           * the `font` is a Font object.
           * We use the node.js callback convention so that
           * opentype.js can integrate with frameworks like async.js.
           * @alias opentype.load
           * @param  {string} url - The URL of the font to load.
           * @param  {Function} callback - The callback.
           */
          function load(url, callback) {
            var isNode$$1 =
              typeof window === "undefined";
            var loadFn = isNode$$1
              ? loadFromFile
              : loadFromUrl;
            loadFn(
              url,
              function (err, arrayBuffer) {
                if (err) {
                  return callback(err);
                }
                var font;
                try {
                  font = parseBuffer(arrayBuffer);
                } catch (e) {
                  return callback(e, null);
                }
                return callback(null, font);
              }
            );
          }

          /**
           * Synchronously load the font from a URL or file.
           * When done, returns the font object or throws an error.
           * @alias opentype.loadSync
           * @param  {string} url - The URL of the font to load.
           * @return {opentype.Font}
           */
          function loadSync(url) {
            var fs = __webpack_require__(
              /*! fs */ "?4db5"
            );
            var buffer = fs.readFileSync(url);
            return parseBuffer(
              nodeBufferToArrayBuffer(buffer)
            );
          }

          exports.Font = Font;
          exports.Glyph = Glyph;
          exports.Path = Path;
          exports.BoundingBox = BoundingBox;
          exports._parse = parse;
          exports.parse = parseBuffer;
          exports.load = load;
          exports.loadSync = loadSync;

          Object.defineProperty(
            exports,
            "__esModule",
            { value: true }
          );
        });
        //# sourceMappingURL=opentype.js.map

        /***/
      },

    /***/ "./extensions/PDF/textlayer.css":
      /*!**************************************!*\
  !*** ./extensions/PDF/textlayer.css ***!
  \**************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        "use strict";
        __webpack_require__.r(
          __webpack_exports__
        );
        /* harmony export */ __webpack_require__.d(
          __webpack_exports__,
          {
            /* harmony export */ default: () =>
              __WEBPACK_DEFAULT_EXPORT__,
            /* harmony export */
          }
        );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js"
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js"
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js"
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js"
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__
          );
        /* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            /*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!../../node_modules/css-unicode-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./textlayer.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./node_modules/css-unicode-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/PDF/textlayer.css"
          );

        var options = {};

        options.styleTagTransform =
          _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default();
        options.setAttributes =
          _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default();

        options.insert =
          _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(
            null,
            "head"
          );

        options.domAPI =
          _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default();
        options.insertStyleElement =
          _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default();

        var update =
          _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(
            _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__[
              "default"
            ],
            options
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__[
            "default"
          ] &&
          _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__[
            "default"
          ].locals
            ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__[
                "default"
              ].locals
            : undefined;

        /***/
      },

    /***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
      /*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
      /***/ (module) => {
        "use strict";

        var stylesInDOM = [];
        function getIndexByIdentifier(
          identifier
        ) {
          var result = -1;
          for (
            var i = 0;
            i < stylesInDOM.length;
            i++
          ) {
            if (
              stylesInDOM[i].identifier ===
              identifier
            ) {
              result = i;
              break;
            }
          }
          return result;
        }
        function modulesToDom(list, options) {
          var idCountMap = {};
          var identifiers = [];
          for (var i = 0; i < list.length; i++) {
            var item = list[i];
            var id = options.base
              ? item[0] + options.base
              : item[0];
            var count = idCountMap[id] || 0;
            var identifier = ""
              .concat(id, " ")
              .concat(count);
            idCountMap[id] = count + 1;
            var indexByIdentifier =
              getIndexByIdentifier(identifier);
            var obj = {
              css: item[1],
              media: item[2],
              sourceMap: item[3],
              supports: item[4],
              layer: item[5],
            };
            if (indexByIdentifier !== -1) {
              stylesInDOM[indexByIdentifier]
                .references++;
              stylesInDOM[
                indexByIdentifier
              ].updater(obj);
            } else {
              var updater = addElementStyle(
                obj,
                options
              );
              options.byIndex = i;
              stylesInDOM.splice(i, 0, {
                identifier: identifier,
                updater: updater,
                references: 1,
              });
            }
            identifiers.push(identifier);
          }
          return identifiers;
        }
        function addElementStyle(obj, options) {
          var api = options.domAPI(options);
          api.update(obj);
          var updater = function updater(newObj) {
            if (newObj) {
              if (
                newObj.css === obj.css &&
                newObj.media === obj.media &&
                newObj.sourceMap ===
                  obj.sourceMap &&
                newObj.supports ===
                  obj.supports &&
                newObj.layer === obj.layer
              ) {
                return;
              }
              api.update((obj = newObj));
            } else {
              api.remove();
            }
          };
          return updater;
        }
        module.exports = function (
          list,
          options
        ) {
          options = options || {};
          list = list || [];
          var lastIdentifiers = modulesToDom(
            list,
            options
          );
          return function update(newList) {
            newList = newList || [];
            for (
              var i = 0;
              i < lastIdentifiers.length;
              i++
            ) {
              var identifier = lastIdentifiers[i];
              var index =
                getIndexByIdentifier(identifier);
              stylesInDOM[index].references--;
            }
            var newLastIdentifiers = modulesToDom(
              newList,
              options
            );
            for (
              var _i = 0;
              _i < lastIdentifiers.length;
              _i++
            ) {
              var _identifier =
                lastIdentifiers[_i];
              var _index =
                getIndexByIdentifier(_identifier);
              if (
                stylesInDOM[_index].references ===
                0
              ) {
                stylesInDOM[_index].updater();
                stylesInDOM.splice(_index, 1);
              }
            }
            lastIdentifiers = newLastIdentifiers;
          };
        };

        /***/
      },

    /***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
      /*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
      /***/ (module) => {
        "use strict";

        var memo = {};

        /* istanbul ignore next  */
        function getTarget(target) {
          if (
            typeof memo[target] === "undefined"
          ) {
            var styleTarget =
              document.querySelector(target);

            // Special case to return head of iframe instead of iframe itself
            if (
              window.HTMLIFrameElement &&
              styleTarget instanceof
                window.HTMLIFrameElement
            ) {
              try {
                // This will throw an exception if access to iframe is blocked
                // due to cross-origin restrictions
                styleTarget =
                  styleTarget.contentDocument
                    .head;
              } catch (e) {
                // istanbul ignore next
                styleTarget = null;
              }
            }
            memo[target] = styleTarget;
          }
          return memo[target];
        }

        /* istanbul ignore next  */
        function insertBySelector(insert, style) {
          var target = getTarget(insert);
          if (!target) {
            throw new Error(
              "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
            );
          }
          target.appendChild(style);
        }
        module.exports = insertBySelector;

        /***/
      },

    /***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
      /*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
      /***/ (module) => {
        "use strict";

        /* istanbul ignore next  */
        function insertStyleElement(options) {
          var element =
            document.createElement("style");
          options.setAttributes(
            element,
            options.attributes
          );
          options.insert(
            element,
            options.options
          );
          return element;
        }
        module.exports = insertStyleElement;

        /***/
      },

    /***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
      /*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
      /***/ (
        module,
        __unused_webpack_exports,
        __webpack_require__
      ) => {
        "use strict";

        /* istanbul ignore next  */
        function setAttributesWithoutAttributes(
          styleElement
        ) {
          var nonce = true
            ? __webpack_require__.nc
            : 0;
          if (nonce) {
            styleElement.setAttribute(
              "nonce",
              nonce
            );
          }
        }
        module.exports =
          setAttributesWithoutAttributes;

        /***/
      },

    /***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
      /*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
      /***/ (module) => {
        "use strict";

        /* istanbul ignore next  */
        function apply(
          styleElement,
          options,
          obj
        ) {
          var css = "";
          if (obj.supports) {
            css += "@supports (".concat(
              obj.supports,
              ") {"
            );
          }
          if (obj.media) {
            css += "@media ".concat(
              obj.media,
              " {"
            );
          }
          var needLayer =
            typeof obj.layer !== "undefined";
          if (needLayer) {
            css += "@layer".concat(
              obj.layer.length > 0
                ? " ".concat(obj.layer)
                : "",
              " {"
            );
          }
          css += obj.css;
          if (needLayer) {
            css += "}";
          }
          if (obj.media) {
            css += "}";
          }
          if (obj.supports) {
            css += "}";
          }
          var sourceMap = obj.sourceMap;
          if (
            sourceMap &&
            typeof btoa !== "undefined"
          ) {
            css +=
              "\n/*# sourceMappingURL=data:application/json;base64,".concat(
                btoa(
                  unescape(
                    encodeURIComponent(
                      JSON.stringify(sourceMap)
                    )
                  )
                ),
                " */"
              );
          }

          // For old IE
          /* istanbul ignore if  */
          options.styleTagTransform(
            css,
            styleElement,
            options.options
          );
        }
        function removeStyleElement(
          styleElement
        ) {
          // istanbul ignore if
          if (styleElement.parentNode === null) {
            return false;
          }
          styleElement.parentNode.removeChild(
            styleElement
          );
        }

        /* istanbul ignore next  */
        function domAPI(options) {
          if (typeof document === "undefined") {
            return {
              update: function update() {},
              remove: function remove() {},
            };
          }
          var styleElement =
            options.insertStyleElement(options);
          return {
            update: function update(obj) {
              apply(styleElement, options, obj);
            },
            remove: function remove() {
              removeStyleElement(styleElement);
            },
          };
        }
        module.exports = domAPI;

        /***/
      },

    /***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
      /*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
      /***/ (module) => {
        "use strict";

        /* istanbul ignore next  */
        function styleTagTransform(
          css,
          styleElement
        ) {
          if (styleElement.styleSheet) {
            styleElement.styleSheet.cssText = css;
          } else {
            while (styleElement.firstChild) {
              styleElement.removeChild(
                styleElement.firstChild
              );
            }
            styleElement.appendChild(
              document.createTextNode(css)
            );
          }
        }
        module.exports = styleTagTransform;

        /***/
      },

    /***/ "./res/fonts/font-list.js":
      /*!********************************!*\
  !*** ./res/fonts/font-list.js ***!
  \********************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        "use strict";
        __webpack_require__.r(
          __webpack_exports__
        );
        /* harmony export */ __webpack_require__.d(
          __webpack_exports__,
          {
            /* harmony export */ FONT_LIST: () =>
              /* binding */ FONT_LIST,
            /* harmony export */ ONDEMAND_FONT_LIST:
              () =>
                /* binding */ ONDEMAND_FONT_LIST,
            /* harmony export */
          }
        );
        let FONT_LIST = [
          //Metrically compatible to Arial
          //https://fonts.google.com/specimen/Arimo
          {
            name: "Arimo",
            url: "res/fonts/arimo-v29-latin_latin-ext-regular.woff",
            subs: [
              "arial",
              "arialmt",
              "helvetica",
              "sans serif",
              "sans-serif",
            ],
          },

          //Metrically compatible to Times
          //https://fonts.google.com/specimen/Tinos
          {
            name: "Tinos",
            url: "res/fonts/tinos-v24-latin_latin-ext-regular.woff",
            subs: ["times", "serif"],
          },

          //Metrically compatible to Courier
          //https://fonts.google.com/specimen/Cousine
          {
            name: "Cousine",
            url: "res/fonts/cousine-v27-latin_latin-ext-regular.woff",
            subs: ["courier", "monospace"],
          },

          // taken from pdf.js, which in turn got it from PDFium, and then converted from raw CFF to WOFF. I also fixed the missing cmap.
          // https://github.com/mozilla/pdf.js/blob/4c1dd47e65ae66135c6d9a55774a99a8066fbf37/external/standard_fonts/FoxitDingbats.pfb
          // The original licence file is "res/fonts/LICENSE_FOXIT"
          {
            name: "FoxitDingbats",
            url: "res/fonts/FoxitDingbats.woff",
            subs: ["zapfdingbats", "dingbats"],
          },
          // taken from pdf.js, which in turn got it from PDFium, and then converted from raw CFF to WOFF. I also fixed the missing cmap.
          // https://github.com/mozilla/pdf.js/blob/4c1dd47e65ae66135c6d9a55774a99a8066fbf37/external/standard_fonts/FoxitSymbol.pfb
          // The original licence file is "res/fonts/LICENSE_FOXIT"
          {
            name: "FoxitSymbol",
            url: "res/fonts/FoxitSymbol.woff",
            subs: ["symbol"],
          },
        ];

        // These are large font files that we do not want to load by default.
        // These will get loaded only if the font is required.
        let ONDEMAND_FONT_LIST = [
          // https://fonts.google.com/specimen/Noto+Sans+SC
          // https://fonts.google.com/specimen/Noto+Sans+TC
          // https://fonts.google.com/specimen/Noto+Sans+JP
          // License: SIL Open Font License (OFL) https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=OFL
          // The licenses for NotoSansSC, NotoSansTC, and NotoSansJP exist in the res/fonts folder in OFL.txt.
          {
            name: "NotoSansSC",
            url: "res/fonts/NotoSansSC-Regular.otf",
            subs: ["microsoftyahei", "simsun"],
          },
          {
            name: "NotoSansTC",
            url: "res/fonts/NotoSansTC-Regular.otf",
            subs: [
              "microsoftmingliu",
              "mingliu",
              "bcdeee+dfkaishu-sb-estd-bf",
              "bcdeee+dfkaishu-sb-estd",
            ],
          },
          // Japanese font replacements
          // 'hirakakupron-w3', 'kozminpr6n-regular' have been seen in actual documents (BLMV-7717, BLMV-7846)
          // 'kozgopr6n-medium', 'adobegothicstd-bold' are two Adobe standard fonts that are apparently used by default when using Japanese characters in text comments
          // 'arialunicodems' is used by FoxIt Reader (simsun as well, but that is covered already)
          // 'ms-gothic', 'ms-mincho', 'meiryo', 'yugo-bold' are popular fonts or have been seen otherwise and added here for completeness
          {
            name: "NotoSansJP",
            url: "res/fonts/NotoSansJP-Regular.otf",
            subs: [
              "hirakakupron-w3",
              "kozminpr6n-regular",
              "kozgopr6n-medium",
              "adobegothicstd-bold",
              "arialunicodems",
              "ms-gothic",
              "msgothic",
              "ms-mincho",
              "msmincho",
              "meiryo",
              "yugo-bold",
            ],
          },
        ];

        /***/
      },

    /***/ "?97a1":
      /*!************************!*\
  !*** canvas (ignored) ***!
  \************************/
      /***/ () => {
        /* (ignored) */
        /***/
      },

    /***/ "?6e49":
      /*!********************!*\
  !*** fs (ignored) ***!
  \********************/
      /***/ () => {
        /* (ignored) */
        /***/
      },

    /***/ "?0b3b":
      /*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
      /***/ () => {
        /* (ignored) */
        /***/
      },

    /***/ "?bfb0":
      /*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
      /***/ () => {
        /* (ignored) */
        /***/
      },

    /***/ "?a42f":
      /*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
      /***/ () => {
        /* (ignored) */
        /***/
      },

    /***/ "?331b":
      /*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
      /***/ () => {
        /* (ignored) */
        /***/
      },

    /***/ "?4db5":
      /*!********************!*\
  !*** fs (ignored) ***!
  \********************/
      /***/ () => {
        /* (ignored) */
        /***/
      },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(
    moduleId
  ) {
    /******/ // Check if module is in cache
    /******/ var cachedModule =
      __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module =
      (__webpack_module_cache__[moduleId] = {
        /******/ id: moduleId,
        /******/ // no module.loaded needed
        /******/ exports: {},
        /******/
      });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    );
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/compat get default export */
  /******/ (() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter =
        module && module.__esModule
          ? /******/ () => module["default"]
          : /******/ () => module;
      /******/ __webpack_require__.d(getter, {
        a: getter,
      });
      /******/ return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (
      exports,
      definition
    ) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(
            definition,
            key
          ) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(
            exports,
            key,
            {
              enumerable: true,
              get: definition[key],
            }
          );
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/global */
  /******/ (() => {
    /******/ __webpack_require__.g =
      (function () {
        /******/ if (
          typeof globalThis === "object"
        )
          return globalThis;
        /******/ try {
          /******/ return (
            this || new Function("return this")()
          );
          /******/
        } catch (e) {
          /******/ if (typeof window === "object")
            return window;
          /******/
        }
        /******/
      })();
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (
      obj,
      prop
    ) =>
      Object.prototype.hasOwnProperty.call(
        obj,
        prop
      );
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (
      exports
    ) => {
      /******/ if (
        typeof Symbol !== "undefined" &&
        Symbol.toStringTag
      ) {
        /******/ Object.defineProperty(
          exports,
          Symbol.toStringTag,
          { value: "Module" }
        );
        /******/
      }
      /******/ Object.defineProperty(
        exports,
        "__esModule",
        { value: true }
      );
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/nonce */
  /******/ (() => {
    /******/ __webpack_require__.nc = undefined;
    /******/
  })();
  /******/
  /************************************************************************/
  var __webpack_exports__ = {};
  // This entry need to be wrapped in an IIFE because it need to be in strict mode.
  (() => {
    "use strict";
    /*!*********************************!*\
  !*** ./extensions/PDF/index.js ***!
  \*********************************/
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(
      __webpack_exports__,
      {
        /* harmony export */ PDFExtension: () =>
          /* binding */ PDFExtension,
        /* harmony export */ PDFLoader: () =>
          /* reexport safe */ _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader,
        /* harmony export */
      }
    );
    /* harmony import */ var _PDFLoader__WEBPACK_IMPORTED_MODULE_0__ =
      __webpack_require__(
        /*! ./PDFLoader */ "./extensions/PDF/PDFLoader.js"
      );
    /* harmony import */ var _PDFTextLayer__WEBPACK_IMPORTED_MODULE_1__ =
      __webpack_require__(
        /*! ./PDFTextLayer */ "./extensions/PDF/PDFTextLayer.js"
      );

    var av = Autodesk.Viewing;
    var aveh = AutodeskNamespace(
      "Autodesk.Viewing.Extensions.PDF"
    );

    /**
     * Registers a FileLoader to enhance `viewer.loadModel()` to allow loading of PDF files.
     * The viewer will render a single page at a time.
     *
     * The extension id is: `Autodesk.PDF`
     *
     * @example
     * // Create Viewer instance and load PDF file on page 1
     * Autodesk.Viewing.Initializer(options, function() {
     *     var viewer = new Autodesk.Viewing.Viewer3D(div,config3d);
     *     viewer.start();
     *     viewer.loadExtension('Autodesk.PDF').then(function() {
     *         // URL parameter `page` will override value passed to loadModel
     *         viewer.loadModel('path/to/file.pdf', { page: 1 });
     *     });
     * });
     *
     *
     * @memberof Autodesk.Viewing.Extensions
     * @alias Autodesk.Viewing.Extensions.PDFExtension
     * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
     * @class
     */
    class PDFExtension extends av.Extension {
      constructor(viewer, options) {
        super(viewer, options);
        this.onModelLoaded =
          this.onModelLoaded.bind(this);
        this.onPopState =
          this.onPopState.bind(this);
        // each time pdf change a page, tear down will happen, we need to use PDFLoader.useTextLayer to save the options
        this.showTextLayer = options
          ? options.useTextLayer
          : _PDFLoader__WEBPACK_IMPORTED_MODULE_0__
              .PDFLoader.useTextLayer;
        _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.useTextLayer =
          this.showTextLayer || false;
        _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableHyperlinks =
          options &&
          options.enableHyperlinks != undefined
            ? options.enableHyperlinks
            : _PDFLoader__WEBPACK_IMPORTED_MODULE_0__
                .PDFLoader.enableHyperlinks !=
              null
            ? _PDFLoader__WEBPACK_IMPORTED_MODULE_0__
                .PDFLoader.enableHyperlinks
            : true;
        _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableTextSearch =
          options &&
          options.enableTextSearch != undefined
            ? options.enableTextSearch
            : _PDFLoader__WEBPACK_IMPORTED_MODULE_0__
                .PDFLoader.enableTextSearch !=
              null
            ? _PDFLoader__WEBPACK_IMPORTED_MODULE_0__
                .PDFLoader.enableTextSearch
            : true;

        PDFExtension.enableBrowserNavigation =
          options &&
          options.enableBrowserNavigation !=
            undefined
            ? options.enableBrowserNavigation
            : PDFExtension.enableBrowserNavigation !=
              null
            ? PDFExtension.enableBrowserNavigation
            : true;
        this.enableTextSearch =
          _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableTextSearch;
        _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableMSDFText =
          options &&
          options.enableMSDFText != undefined
            ? options.enableMSDFText
            : _PDFLoader__WEBPACK_IMPORTED_MODULE_0__
                .PDFLoader.enableMSDFText != null
            ? _PDFLoader__WEBPACK_IMPORTED_MODULE_0__
                .PDFLoader.enableMSDFText
            : false;

        // Turn on SSAA if it is not an weak device and using MSDFText
        if (
          _PDFLoader__WEBPACK_IMPORTED_MODULE_0__
            .PDFLoader.enableMSDFText &&
          !viewer.impl
            .renderer()
            .isWeakDevice() &&
          viewer.impl
            .glrenderer()
            .getPixelRatio() <= 1
        ) {
          viewer.impl.renderer().settings.useSSAA = true;
        }
      }

      async load() {
        await this.viewer.loadExtension(
          "Autodesk.CompGeom"
        );

        av.FileLoaderManager.registerFileLoader(
          "pdf",
          ["pdf"],
          _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader
        );
        if (!av.isNodeJS()) {
          if (
            PDFExtension.enableBrowserNavigation
          ) {
            this.viewer.addEventListener(
              av.GEOMETRY_LOADED_EVENT,
              this.onModelLoaded
            );
            this.addWindowEventListener(
              "popstate",
              this.onPopState
            );
          }

          if (this.enableTextSearch) {
            this.textLayer =
              new _PDFTextLayer__WEBPACK_IMPORTED_MODULE_1__.PDFTextLayer(
                this.viewer,
                this.showTextLayer
              );
            this.textLayer.onModelLoaded();
          }
        }
        return true;
      }

      unload() {
        av.FileLoaderManager.unregisterFileLoader(
          "pdf"
        );
        if (!av.isNodeJS()) {
          this.viewer.removeEventListener(
            av.GEOMETRY_LOADED_EVENT,
            this.onModelLoaded
          );
          this.removeWindowEventListener(
            "popstate",
            this.onPopState
          );

          if (this.textLayer) {
            this.textLayer.destroy();
            this.textLayer = null;
          }
        }
        return true;
      }

      onModelLoaded(event) {
        if (
          event &&
          event.model &&
          event.model.getDocumentNode() &&
          event.model.isPdf(true)
        ) {
          var url = new URL(window.location.href);
          var bubbleNode =
            event.model.getDocumentNode();
          var pageIndex = bubbleNode.data.page;
          if (
            url.searchParams.get("page") !=
            pageIndex
          ) {
            url.searchParams.set(
              "page",
              pageIndex
            );
            const _window = this.getWindow();
            _window.history.pushState(
              undefined,
              "Page:" + pageIndex,
              url.href
            );
          }
        }
      }

      onPopState(event) {
        var model = this.viewer.model;
        if (
          event &&
          model &&
          model.getDocumentNode() &&
          model.isPdf(true)
        ) {
          const _window = this.getWindow();
          var url = new URL(
            _window.location.href
          );
          var pageIndex =
            parseInt(
              url.searchParams.get("page")
            ) || 1;
          var rootNode = model
            .getDocumentNode()
            .getRootNode();

          var bubbleNode =
            rootNode.children[pageIndex - 1];
          this.viewer.dispatchEvent({
            type: av.HYPERLINK_EVENT,
            data: { bubbleNode: bubbleNode },
          });
          this.viewer.loadDocumentNode(
            rootNode.getDocument(),
            bubbleNode
          );
        }
      }

      activate() {
        return true;
      }
      deactivate() {
        return false;
      }
    }

    aveh.PDFExtension = PDFExtension;
    aveh.PDFLoader =
      _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader;

    av.theExtensionManager.registerExtension(
      "Autodesk.PDF",
      PDFExtension
    );
  })();

  Autodesk.Extensions.PDF = __webpack_exports__;
  /******/
})();
//# sourceMappingURL=PDF.js.map
